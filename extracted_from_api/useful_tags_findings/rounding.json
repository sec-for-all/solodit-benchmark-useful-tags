{
  "tag": "Rounding",
  "count": 32,
  "metadata": {
    "totalResults": 32,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 8,
    "reset": 1771761120
  },
  "findings": [
    {
      "id": "34253",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "1342",
      "title": "H-5: Adding liquidity can be `DoS`ed due to calculation mismatches",
      "content": "Source: https://github.com/sherlock-audit/2024-03-arrakis-judging/issues/54 \n\n## Found by \nKupiaSec, cu5t0mPe0, juaan, whitehair0330\n## Summary\n\nWhen users add liquidity, they send tokens to the `ArrakisPublicVaultRouter` contract. The `ValantisHOTModulePublic` contract then takes the required tokens from the `ArrakisPublicVaultRouter` contract. However, due to a calculation mismatch, the required amount is often greater than the user-sent amount, causing the transaction to be reverted.\n\n## Vulnerability Detail\n\nLet's consider following scenario:\n1. The current state:\n    - pool: `reserve0 = 1e18 + 1, reserve1 = 1e18 + 1`\n    - vault: `totalSupply = 1e18 + 1`\n2. Bob calls the `ArrakisPublicVaultRouter.addLiquidity()` function with the following parameters:\n    - `amount0Max = 1e18, amount1Max = 1e18`\n3. At [L139](https://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/ArrakisPublicVaultRouter.sol#L139), the `_getMintAmounts()` function returns:\n    - `(sharesReceived, amount0, amount1) = (1e18 - 1, 1e18 - 1, 1e18 - 1)`\n4. The router contract takes `token0` and `token1` from Bob in amounts of `1e18 - 1` each and calls the `_addLiquidity()` function with above parameters.\n5. In the `_addLiquidity()` function, `ArrakisMetaVaultPublic.mint(1e18 - 1, Bob)` is invoked at [L898](https://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/ArrakisPublicVaultRouter.sol#L898).\n6. In the `ArrakisMetaVaultPublic.mint()` function:\n    - at [L58](https://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/ArrakisMetaVaultPublic.sol#L58), the `proportion` is recalculated as `1e18 - 1`\n    - `_deposit(1e18 - 1)` is called at [L71](https://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/ArrakisMetaVaultPublic.sol#L71)\n    - in the `_deposit()` function, `ValantisHOTModulePublic.deposit(router, 1e18 - 1)` is invoked at [L150](https://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/ArrakisMetaVaultPublic.sol#L150-L151)\n7. In the `ValantisHOTModulePublic.deposit()` function:\n    - `amount0 = 1e18, amount1 = 1e18`(at [L71, L73](https://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/modules/ValantisHOTModulePublic.sol#L71-L74))\n    - at [L79, L80](https://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/modules/ValantisHOTModulePublic.sol#L79-L80), it takes `token0` and `token1` from the router in amounts of `1e18` each\n\nFinally, the process fails because there is only `1e18 - 1` in the router, as mentioned in step `4`.\n\nThis problem occurs because the calculations in the `ArrakisPublicVaultRouter._getMintAmounts()` function rely on rounding down. In contrast, the proportion calculation in the `ArrakisMetaVaultPublic.mint()` function and the amount calculations in the `ValantisHOTModulePublic.deposit()` function are based on rounding up.\n\n## Impact\n\nAdding liquidity can be `DoS`ed due to the calculation mismatches.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/ArrakisPublicVaultRouter.sol#L122-L191\n\nhttps://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/ArrakisPublicVaultRouter.sol#L869-L901\n\nhttps://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/ArrakisPublicVaultRouter.sol#L1194-L1231\n\nhttps://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/ArrakisMetaVaultPublic.sol#L51-L74\n\nhttps://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/ArrakisMetaVaultPublic.sol#L137-L154\n\nhttps://github.com/sherlock-audit/2024-03-arrakis/blob/main/arrakis-modular/src/modules/ValantisHOTModulePublic.sol#L35-L96\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe `ArrakisPublicVaultRouter._getMintAmounts()` function should be updated to return the accurate required amounts.\n\n\n\n## Discussion\n\n**KupiaSecAdmin**\n\nEscalate\n\nThe severity of this issue should be high, as the probability of the calculation mismatch occurring is quite high.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> The severity of this issue should be high, as the probability of the calculation mismatch occurring is quite high.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**WangSecurity**\n\nIn Sherlock, we don't judge issues based on the probabilities. As I understand there's no material loss, but the issue has serious non-material losses, cause as I understand, it's possible that there will always be users who cannot deposit due to this issue. Hence, I agree that high severity is appropriate here, planning to accept the escalation and upgrade severity to high.\n\n**Gevarist**\n\nValid finding, for us it's a low level finding.\n\n**CergyK**\n\n> In Sherlock, we don't judge issues based on the probabilities. As I understand there's no material loss, but the issue has serious non-material losses, cause as I understand, it's possible that there will always be users who cannot deposit due to this issue. Hence, I agree that high severity is appropriate here, planning to accept the escalation and upgrade severity to high.\n\nThis should remain medium, as there is no loss of funds.\n\nIn the hypothetical case some deposit absolutely has to be carried on, the simple work-around of sending some DUST of tokens to the contract would unlock the situation.\n\n> It seems that Sherlock has a new rule to identify high issues which is cited here:\n> `2. Inflicts serious non-material losses (doesn't include contract simply not working).` \n> Which seems inconsistent with how to identify a medium issue:\n> `2. Breaks core contract functionality, rendering the contract useless or leading to loss of funds.`\n> As the rule to identify the medium issue uses a higher impact?\n\n**KupiaSecAdmin**\n\n@CergyK\n\n> In the hypothetical case some deposit absolutely has to be carried on, the simple work-around of sending some DUST of tokens to the contract would unlock the situation.\n> \n\nSending DUST of tokens cann't resolve the problem.\n\nIn the `_addLiquidity()` function of the router contract, the contract approves tokens to the module. Subsequently, in the `deposit()` function of the module, the module brings those tokens from the router contract. For the transaction to succeed, the router contract must approve enough tokens to the module. Therefore, only sending tokens cannot resolve the problem.\n\n```solidity\nIERC20(token0_).safeIncreaseAllowance(module, amount0_);\n```\n\n```solidity\ntoken0.safeTransferFrom(depositor_, address(this), amount0);\n```\n\nImpossibility of deposit should be considered as a HIGH severity issue.\n\n**CergyK**\n\n> @CergyK\n> \n> > In the hypothetical case some deposit absolutely has to be carried on, the simple work-around of sending some DUST of tokens to the contract would unlock the situation.\n> \n> Sending DUST of tokens cann't resolve the problem.\n> \n> In the `_addLiquidity()` function of the router contract, the contract approves tokens to the module. Subsequently, in the `deposit()` function of the module, the module brings those tokens from the router contract. For the transaction to succeed, the router contract must approve enough tokens to the module. Therefore, only sending tokens cannot resolve the problem.\n> \n> ```solidity\n> IERC20(token0_).safeIncreaseAllowance(module, amount0_);\n> ```\n> \n> ```solidity\n> token0.safeTransferFrom(depositor_, address(this), amount0);\n> ```\n> \n> Impossibility of deposit should be considered as a HIGH severity issue.\n\nOk I see. Indeed depositing would be impossible in that case.\nStill this is a medium severity issue since it is a DOS of a core functionality, but no loss demonstrated\n\n**KupiaSecAdmin**\n\n> IV. How to identify a high issue:\n> 2. Inflicts serious non-material losses (doesn't include contract simply not working).\n\nBased on the judging rule, I think the issue deserves high severity, because it inflicts serious non-material losses, which is not contract simply not working.\n\n**0xjuaan**\n\n@KupiaSecAdmin that rule actually says that there must be a non material loss other than the contract simply not working. \n\nSince this bug simply causes a function to not work, I agree with @CergyK that this should be medium.\n\n**WangSecurity**\n\n@0xjuaan could you please elaborate? The rule says non-material losses, excluding the contract simply not working. Here, the contract is working, but the deposits are DOSed?\n\nAlso, another question, are the contracts upgradable and in reality could this issue be solved by updating the contract?\n\n**0xjuaan**\n\nIt seems similar to [this issue](https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/40) which is medium severity.\n\nFrom what I understand, the rules say that the non-material loss must not be that a contract/function simply is not functional. However in this bug, that is the impact. \n\nNote I did submit this so am not incentivised to disagree with the escalation, but it based on the rules I don't see any way this can be high severity.\n\n**WangSecurity**\n\n@0xjuaan could you please elaborate on what do you think includes \"serious non-material losses\"? So I can better understand how I can explain my decision better.\n\n**WangSecurity**\n\nThe decision remains the same. I believe in that case it's not just a function simply doesn't work, but deposits into protocol are DOSed, hence, it's serious non-material losses. Planning to accept the escalation and upgrade severity to high.\n\n**0xjuaan**\n\nHonestly I still think @CergyK's stance is correct since deposits are technically not DoS'd, they can occur via the vault directly. \n\nI do benefit from it being converted to H though so I don't mind either way.\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/ArrakisFinance/arrakis-modular/pull/88\n\n\n**CergyK**\n\n> @0xjuaan could you please elaborate on what do you think includes \"serious non-material losses\"? So I can better understand how I can explain my decision better.\n\nOne possible interpretation is that the line in the Sherlock rules:\n> 2. Inflicts serious non-material losses (doesn't include contract simply not working).\n\nwas added to enable high severity issues in protocols which are not handling financial assets (SocialFi, data-availability). Otherwise it is too vague, and can be applicable to any valid issue (low, medium, high).\n\n**WangSecurity**\n\n> Honestly I still think @CergyK's stance is correct since deposits are technically not DoS'd, they can occur via the vault directly.\n\nHm, I may have misunderstood that point. As I understand @CergyK talks about sending dust amounts to the contract, to mitigate the DoS. But this was answered [here](https://github.com/sherlock-audit/2024-03-arrakis-judging/issues/54#issuecomment-2176230181), which @CergyK agreed with. If I’m missing something please correct.\n \n > was added to enable high severity issues in protocols which are not handling financial assets (SocialFi, data-availability)\n\nFair point, but I still believe DOS of depositing into the protocol is indeed serious non-material loss.\n\nBut correct me on the first if I’m wrong.\n\n**WangSecurity**\n\nThe decision remains the same. Planning to accept the escalation and upgrade severity to high.\n\n**WangSecurity**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [KupiaSecAdmin](https://github.com/sherlock-audit/2024-03-arrakis-judging/issues/54/#issuecomment-2167570652): accepted",
      "summary": "\nThe issue reported is that adding liquidity to the Arrakis protocol can cause a \"Denial of Service\" (DoS) due to incorrect calculations. This means that users who try to add liquidity may have their transactions fail due to the system not being able to accurately calculate the required amounts. This bug was found by a group of security researchers and has been identified as a high severity issue. The vulnerability occurs when the system tries to calculate the required amount of tokens from the user and ends up requesting more than what was sent, causing the transaction to fail. This is due to a mismatch in rounding calculations in different parts of the code. The impact of this bug is that users may not be able to add liquidity to the protocol, causing a loss of functionality. The code snippets where the bug occurs have been identified and the recommendation is to update the code to fix the calculations. There was some discussion among the security researchers about the severity of the issue, but ultimately it was agreed that it should be considered a high severity issue. The protocol team has fixed the bug and it has been resolved.",
      "report_date": {},
      "contest_prize_txt": "55500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/195",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-03-arrakis-judging/issues/54",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "195",
      "slug": "h-5-adding-liquidity-can-be-dosed-due-to-calculation-mismatches-sherlock-arrakis-valantis-sot-audit-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Arrakis Valantis SOT Audit",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Arrakis Valantis SOT Audit",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        },
        {
          "tags_tag": {
            "title": "Denial-Of-Service"
          }
        },
        {
          "tags_tag": {
            "title": "Allowance"
          }
        }
      ]
    },
    {
      "id": "32054",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "235",
      "title": "[H-02] Attacker can amplify a rounding error in MagicLP to break the I invariant and cause malicious pricing",
      "content": "\nOne of the two key parameters in MagicLP pools is `I`, which is defined to be the ideal ratio between the two reserves. It is set during MagicLP initialization:\n`_I_ = i;`\n\nIt is used when performing the initial LP deposit, in `buyShares()`:\n\n    if (totalSupply() == 0) {\n        // case 1. initial supply\n        if (quoteBalance == 0) {\n            revert ErrZeroQuoteAmount();\n        }\n        shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;\n        _BASE_TARGET_ = shares.toUint112();\n        _QUOTE_TARGET_ = DecimalMath.mulFloor(shares, _I_).toUint112();\n        if (_QUOTE_TARGET_ == 0) {\n            revert ErrZeroQuoteTarget();\n        }\n        if (shares <= 2001) {\n            revert ErrMintAmountNotEnough();\n        }\n        _mint(address(0), 1001);\n        shares -= 1001;\n\nThe `QUOTE_TARGET` is determined by multiplying the `BASE_TARGET` with `I`.\n\nThe flaw is in the check below:\n`shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;`\nEssentially there needs to be enough `quoteBalance` at the `I` ratio to mint `baseBalance` shares, if there's not enough then shares are instead determined by dividing the `quoteBalance` with `I`.\nAn attacker can abuse the `mulFloor()` to create a major inconsistency.\nSuppose `quoteBalance = 1`, `baseBalance = 19999`, `I = 1e14`. Then we have:\n`1 < 19999 * 1e14 / 1e18 => 1 < 1 => False`\nTherefore `shares = 19999` .\nIt sets the targets:\n\n    _BASE_TARGET_ = 19999\n    _QUOTE_TARGET_ = 19999 * 1e14 / 1e18 = 1\n\nThe result is the ratio 1:19999, when the intended ratio from `I` is 1:1000.\n\nEssentially a small rounding error is magnified. The rounding direction should instead be:\n`quoteBalance < DecimalMath.mulCeil(baseBalance, _I_)`\nThis would ensure that `DecimalMath.divFloor(quoteBalance, _I_)` is executed. At this point, when calculating `QUOTE_TARGET` there will not be a precision error as above (it performs the opposing actions to the divFloor).\n\nAn attacker can abuse it by making users perform trades under the assumption `I` is the effective ratio, however the ratio is actually `2I`. The pool's pricing mechanics will be wrong. Note that users will legitimately trust any MagicLP pool created by the Factory as it is supposed to enforce that ratio.\n\nThe attack can be performed on another entity's pool right after the `init()` call, or on a self-created pool. The initial cost for the attack is very small due to the small numbers involved.\n\n### Impact\n\nAttacker can initialize a Pool with malicious pricing mechanics that break the assumed invariants of the pool, leading to incorrect pool interactions.\n\n### POC\n\nStep by step of the initial `buyShares()` was provided above.  `_QUOTE_TARGET_` is used by the pricer:\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n    ...\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount) internal pure returns (uint256 receiveQuoteAmount, RState newR) {\n        if (state.R == RState.ONE) {\n            // case 1: R=1\n            // R falls below one\n            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            uint256 backToOnePayBase = state.B0 - state.B;\n            uint256 backToOneReceiveQuote = state.Q - \n    \t\t// @@@@@@@@@@   USED HERE \n    \t\tstate.Q0;\n\nNote that deposits/withdrawals will continue to apply the bad ratio:\n\n    } else if (baseReserve > 0 && quoteReserve > 0) {\n        // case 2. normal case\n        uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n        uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n        uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n        shares = DecimalMath.mulFloor(totalSupply(), mintRatio);\n        _BASE_TARGET_ = (uint256(_BASE_TARGET_) + DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)).toUint112();\n        _QUOTE_TARGET_ = (uint256(_QUOTE_TARGET_) + DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)).toUint112();\n\n### Recommended Mitigation Steps\n\nUse `DecimalMaths.mulCeil()` to protect against the rounding error.\n\n**[0xCalibur (Abracadabra) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/221#issuecomment-1997566094):**\n > Based on our previous audit, it was discussed that using mulCeil here would not be the right answer since that would just create imprecision in the ratio in the other direction.\n> \n> It would be good if the submitter could provide a PoC showing a veritable exploit case for this one.\n>\n > Acknowledged, but will not fix it on contract level but filtering pool quality and legitimacy on our main frontend.\n\n**[trust1995 commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/221#issuecomment-2031868891):**\n > Hi,\n> \n> The impact demonstrated is doubling the ratio of the pool, which is a core invariant of the MIMswap platform. It means pricing will be incorrect, which is the core functionality of an AMM. A user who will make a trade assuming they will follow the price set out by the I parameter will make _incorrect trades_, losing their funds inappropriately.\n> I believe the direct risk of loss of funds by innocent traders who are not making a mistake, warrants the severity of High.\n\n**[cccz (Judge) commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/221#issuecomment-2040273466):**\n > 1. The attacker can compromise _QUOTE_TARGET_ in buyShares() after the pool is created.\n> ```solidity\n>     function createPool(\n>         address baseToken,\n>         address quoteToken,\n>         uint256 lpFeeRate,\n>         uint256 i,\n>         uint256 k,\n>         address to,\n>         uint256 baseInAmount,\n>         uint256 quoteInAmount\n>     ) external returns (address clone, uint256 shares) {\n>         _validateDecimals(IERC20Metadata(baseToken).decimals(), IERC20Metadata(quoteToken).decimals());\n> \n>         clone = IFactory(factory).create(baseToken, quoteToken, lpFeeRate, i, k);\n> \n>         baseToken.safeTransferFrom(msg.sender, clone, baseInAmount);\n>         quoteToken.safeTransferFrom(msg.sender, clone, quoteInAmount);\n>         (shares, , ) = IMagicLP(clone).buyShares(to);  <========\n>     }\n> ```\n> 2. The victim calls sellBase, and the call chain is as follows. In adjustedTarget, state.Q0 will not be adjusted since state.R == RState.ONE.\n> ```solidity\n>     function sellBase(address to) external nonReentrant returns (uint256 receiveQuoteAmount) {\n>         uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n>         uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n>         uint256 mtFee;\n>         uint256 newBaseTarget;\n>         PMMPricing.RState newRState;\n>         (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput); <==============\n> ...\n>     function querySellBase(\n>         address trader,\n>         uint256 payBaseAmount\n>     ) public view returns (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) {\n>         PMMPricing.PMMState memory state = getPMMState(); <========\n>         (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount); <======\n> ...\n>     function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n>         state.i = _I_;\n>         state.K = _K_;\n>         state.B = _BASE_RESERVE_;\n>         state.Q = _QUOTE_RESERVE_;\n>         state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget\n>         state.Q0 = _QUOTE_TARGET_;\n>         state.R = PMMPricing.RState(_RState_);\n>         PMMPricing.adjustedTarget(state); <======\n>     }\n> ...\n>     function adjustedTarget(PMMState memory state) internal pure {\n>         if (state.R == RState.BELOW_ONE) {\n>             state.Q0 = Math._SolveQuadraticFunctionForTarget(state.Q, state.B - state.B0, state.i, state.K);\n>         } else if (state.R == RState.ABOVE_ONE) {\n>             state.B0 = Math._SolveQuadraticFunctionForTarget(\n>                 state.B,\n>                 state.Q - state.Q0,\n>                 DecimalMath.reciprocalFloor(state.i),\n>                 state.K\n>             );\n>         }\n>     }\n> ```\n> 3. sellBaseToken calls _ROneSellBaseToken, and _ROneSellBaseToken calls _SolveQuadraticFunctionForTrade to use compromised _QUOTE_TARGET_ for calculation. It'll compromise the victim.\n> ```solidity\n>     function sellBaseToken(PMMState memory state, uint256 payBaseAmount) internal pure returns (uint256 receiveQuoteAmount, RState newR) {\n>         if (state.R == RState.ONE) {\n>             // case 1: R=1\n>             // R falls below one\n>             receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount); <======\n>             newR = RState.BELOW_ONE;\n> ...\n>     function _ROneSellBaseToken(\n>         PMMState memory state,\n>         uint256 payBaseAmount\n>     )\n>         internal\n>         pure\n>         returns (\n>             uint256 // receiveQuoteToken\n>         )\n>     {\n>         // in theory Q2 <= targetQuoteTokenAmount\n>         // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\n>         return Math._SolveQuadraticFunctionForTrade(state.Q0, state.Q0, payBaseAmount, state.i, state.K); <======\n>     }\n> ```\n>\n>Therefore, High Severity is warranted.\n\n_Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/221)._\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the MagicLP pools where the `I` parameter, which is used to determine the ideal ratio between two reserves, can be manipulated by an attacker. This can lead to incorrect pricing and trading on the platform, potentially causing users to lose their funds. The report recommends using a different function to protect against this manipulation and suggests steps to mitigate the issue. The severity of the bug is debated by the team, but it is ultimately deemed to be a high severity issue.",
      "report_date": {},
      "contest_prize_txt": "63000",
      "contest_link": "https://code4rena.com/reports/2024-03-abracadabra-money",
      "sponsor_name": "Abracadabra Money",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 2,
      "source_link": "https://code4rena.com/reports/2024-03-abracadabra-money",
      "github_link": "https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/221",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "349",
      "slug": "h-02-attacker-can-amplify-a-rounding-error-in-magiclp-to-break-the-i-invariant-and-cause-malicious-pricing-code4rena-abracadabra-money-abracadabra-money-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Abracadabra Money",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Abracadabra Money",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Oracle"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "30073",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "931",
      "title": "[M-01] secRewardsPerShare Insufficient precision",
      "content": "\n> We also introduced the field secRewardDebt. The idea of this field is to enable any lending platforms that are integrated with Neofinance Coordinator to send their own rewards based on this value (or rather the difference of this value since the last time secondary rewards were sent) and their own emission schedule for the tokens.\n\nThe current calculation formula for `secRewardsPerShare` is as follows:\n\n```solidity\nmarket.secRewardsPerShare += uint128((blockDelta * 1e18) / marketSupply);\n```\n\n`marketSupply` is `cNOTE`, with a precision of `1e18`\nSo as long as the supply is greater than `1` cNote, `secRewardsPerShare` is easily `rounded down` to `0`\nExample:\nmarketSupply = 10e18\nblockDelta = 1\nsecRewardsPerShare=1 &ast;  1e18 / 10e18 = 0\n\n### Impact\n\nDue to insufficient precision, `secRewardsPerShare` will basically be 0.\n\n### Recommended Mitigation\n\nIt is recommended to use 1e27 for `secRewardsPerShare`:\n\n```solidity\n    market.secRewardsPerShare += uint128((blockDelta * 1e27) / marketSupply);\n```\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2024-01-canto-findings/issues/12#issuecomment-1920977276):**\n > The Warden has shown how, due to incorrect precision, it is possible to create a loss due to rounding down.\n> \n> Because the loss is limited to yield, Medium Severity seems most appropriate.\n\n**[OpenCoreCH (sponsor) confirmed](https://github.com/code-423n4/2024-01-canto-findings/issues/12#issuecomment-1923534235)**\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the calculation formula for `secRewardsPerShare` in the Neofinance Coordinator platform. This field is used to distribute rewards to lending platforms integrated with the Coordinator. However, due to a lack of precision in the formula, the value of `secRewardsPerShare` is often rounded down to 0, resulting in a loss of yield for users. The recommended mitigation is to use a precision of 1e27 instead of 1e18. The severity of this bug is considered medium and has been confirmed by the sponsor of the project.",
      "report_date": {},
      "contest_prize_txt": "16425",
      "contest_link": "https://code4rena.com/reports/2024-01-canto",
      "sponsor_name": "Canto",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-01-canto",
      "github_link": "https://github.com/code-423n4/2024-01-canto-findings/issues/12",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "326",
      "slug": "m-01-secrewardspershare-insufficient-precision-code4rena-canto-canto-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Canto",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Canto",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        },
        {
          "tags_tag": {
            "title": "Precision Loss"
          }
        }
      ]
    },
    {
      "id": "30140",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "1240",
      "title": "H-2: FundingRateArbitrage contract can be drained due to rounding error",
      "content": "Source: https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/57 \n\n## Found by \ndetectiveking\n## Summary\n\nIn the `requestWithdraw`, rounding in the wrong direction is done which can lead to contract being drained. \n\n## Vulnerability Detail\n\nIn the `requestWithdraw` function in `FundingRateArbitrage`, we find the following lines of code:\n\n```solidity\njusdOutside[msg.sender] -= repayJUSDAmount;\nuint256 index = getIndex();\nuint256 lockedEarnUSDCAmount = jusdOutside[msg.sender].decimalDiv(index);\nrequire(\n     earnUSDCBalance[msg.sender] >= lockedEarnUSDCAmount, \"lockedEarnUSDCAmount is bigger than earnUSDCBalance\"\n);\nwithdrawEarnUSDCAmount = earnUSDCBalance[msg.sender] - lockedEarnUSDCAmount;\n```\n\nBecause we round down when calculating `lockedEarnUSDCAmount`, `withdrawEarnUSDCAmount` is higher than it should be, which leads to us allowing the user to withdraw more than we should allow them to given the amount of JUSD they repaid. \n\nThe execution of this is a bit more complicated, let's go through an example. We will assume there's a bunch of JUSD existing in the contract and the attacker is the first to deposit. \n\nSteps:\n\n1. The attacker deposits 1 unit of USDC and then manually sends in another 100 * 10^6 - 1 (not through deposit, just a transfer). The share price / price per earnUSDC will now be $100. Exactly one earnUSDC is in existence at the moment. \n2. Next the attacker creates a new EOA and deposits a little over $101 worth of USDC (so that after fees we can get to the $100), giving one earnUSDC to the EOA. The attacker will receive around $100 worth of JUSD from doing this. \n3. Attacker calls `requestWithdraw` with `repayJUSDAmount = 1` with the second newly created EOA\n4. `lockedEarnUSDCAmount` is rounded down to 0 (since `repayJUSDAmount` is subtracted from jusdOutside[msg.sender]\n5. `withdrawEarnUSDCAmount` will be `1`\n6. After `permitWithdrawRequests` is called, attacker will be able to withdraw the $100 they deposited through the second EOA (granted, they lost the deposit and withdrawal fees) while only having sent `1` unit of `JUSD` back. This leads to massive profit for the attacker. \n\nAttacker can repeat steps 2-6 constantly until the contract is drained of JUSD. \n \n## Impact\n\nAll JUSD in the contract can be drained\n\n## Code Snippet\n\nhttps://github.com/JOJOexchange/smart-contract-EVM/blob/main/src/FundingRateArbitrage.sol#L283-L300\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRound up instead of down \n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { This is valid and also a dupp of 054 due to the same underlying cause of first deposit attack; but in this the watson explained the exploit scenario of the inflation attack}\n\n\n\n**nevillehuang**\n\nrequest poc\n\n**sherlock-admin**\n\nPoC requested from @detectiveking123\n\nRequests remaining: **4**\n\n**JoscelynFarr**\n\nI think this issue is similar to https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/54\n\n**nevillehuang**\n\n@JoscelynFarr Seems right, @detectiveking123 do you agree that this seems to be related to a typical first depositor inflation attack.\n\n**detectiveking123**\n\n@nevillehuang I am not exactly sure how this should be judged. \n\nThe attack that I describe here chains two separate vulnerabilities together (one of which is the rounding error and the other which is the same root cause as the share inflation attack) to drain all the funds existing in the contract, which is clearly a high. **It also doesn't rely on any front-running on Arbitrum assumptions, while the other issue does. In fact, no interaction from any other users is necessary for the attacker to drain all the funds.** The exploit that is described in the other issue cannot actually drain all the funds in the contract like this one can, but simply drain user deposits if they can frontrun them. \n\nTo clarify, the rounding error that I describe here is different from the rounding error described in the ERC4626 inflation style exploit (so I guess there are two separate rounding errors that optimally should be chained together for this exploit). \n\nDo you still want me to provide a code POC here? I already have an example in the issue description of how the attack can be performed. \n\n**nevillehuang**\n\n@detectiveking123 Yes, please provide me a coded PoC in 1-2 days so that I can verify the draining impact, because it does share similar root causes of direct donation of funds as the first inflation attack.\n\n**detectiveking123**\n\n@nevillehuang let me get it to you by tomorrow\n\n**detectiveking123**\n\n@nevillehuang \n\n```\n    function testExploit() public {\n        jusd.mint(address(fundingRateArbitrage), 5000e6);\n        // net value starts out at 0 :)\n        console.log(fundingRateArbitrage.getNetValue());\n\n        vm.startPrank(Owner); \n        fundingRateArbitrage.setMaxNetValue(10000000e6); \n        fundingRateArbitrage.setDefaultQuota(10000000e6); \n        vm.stopPrank(); \n                 \n        initAlice();\n        // Alice deposits twice\n        fundingRateArbitrage.deposit(1);\n        USDC.transfer(address(fundingRateArbitrage), 100e6);\n        fundingRateArbitrage.deposit(100e6);\n        vm.stopPrank();\n\n        vm.startPrank(alice);\n        fundingRateArbitrage.requestWithdraw(1);\n        fundingRateArbitrage.requestWithdraw(1);\n        vm.stopPrank();\n\n        vm.startPrank(Owner); \n        uint256[] memory requestIds = new uint256[](2);\n        requestIds[0] = 0; \n        requestIds[1] = 1;\n        fundingRateArbitrage.permitWithdrawRequests(requestIds); \n        vm.stopPrank(); \n\n        // Alice is back to her initial balance, but now has a bunch of extra JUSD deposited for her into jojodealer!\n        console.log(USDC.balanceOf(alice));\n        (,uint secondaryCredit,,,) = jojoDealer.getCreditOf(alice);\n        console.log(secondaryCredit);\n    }\n```\n\nAdd this to `FundingRateArbitrageTest.t.sol`\n\nYou will also need to add:\n\n```\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n```\n\nto TestERC20\n\nAnd change initAlice to:\n\n```\n    function initAlice() public {\n        USDC.mint(alice, 300e6 + 1);\n        jusd.mint(alice, 300e6 + 1);\n        vm.startPrank(alice);\n        USDC.approve(address(fundingRateArbitrage), 300e6 + 1);\n        jusd.approve(address(fundingRateArbitrage), 300e6 + 1); \n    }\n```\n**FYI for this exploit the share inflation is helpful but not necessary**. The main issue is the rounding down of `lockedEarnUSDCAmount` in `requestWithdraw`. Even if the share price is 1 cent for example, we will slowly be able to drain JUSD from the contract. An assumption for profitability is that the share price is nontrivial though (so if it's really small it won't be profitable for the attacker b/c of gas fees and deposit fees, though you can still technically drain). \n\n\n\n**nevillehuang**\n\nThis issue is exactly the same as #21 and the **original** submission shares the same root cause of depositor inflation to make the attack feasible, given share price realistically won't be of such a low price. I will be duplicating accordingly. Given and subsequent deposits can be drained, I will be upgrading to high severity\n\n@detectiveking123 If you want to escalate feel free,I will maintain my stance here.\n\n**IAm0x52**\n\nSame fix as #54",
      "summary": "\nThis report discusses a bug in the FundingRateArbitrage contract that can lead to all JUSD funds being drained. This is due to a rounding error in the `requestWithdraw` function, which can be exploited by an attacker to withdraw more funds than they are entitled to. The vulnerability was found by detectiveking and confirmed by sherlock-admin2. The impact of this bug is significant as it can result in the loss of all JUSD funds in the contract. A code snippet is provided for reference and a manual review was conducted to identify the issue. The recommended solution is to round up instead of down in the `requestWithdraw` function. This issue is similar to a previous bug report and has been marked as a duplicate. The severity of this bug has been upgraded to high due to the potential for all funds to be drained.",
      "report_date": {},
      "contest_prize_txt": "16500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/136",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/57",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "136",
      "slug": "h-2-fundingratearbitrage-contract-can-be-drained-due-to-rounding-error-sherlock-jojo-exchange-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "JOJO Exchange Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "JOJO Exchange Update",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "27149",
      "kind": "MARKDOWN",
      "auditfirm_id": "11",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "1151",
      "title": "`VoteKickPolicy._endVote()` might revert forever due to underflow",
      "content": "**Severity:** High\n\n**Description:** In `onFlag()`, `targetStakeAtRiskWei[target]` might be less than the total rewards for the flagger/reviewers due to rounding.\n\n```solidity\nFile: contracts\\OperatorTokenomics\\StreamrConfig.sol\n22:     /**\n23:      * Minimum amount to pay reviewers+flagger\n24:      * That is: minimumStakeWei >= (flaggerRewardWei + flagReviewerCount * flagReviewerRewardWei) / slashingFraction\n25:      */\n26:     function minimumStakeWei() public view returns (uint) {\n27:         return (flaggerRewardWei + flagReviewerCount * flagReviewerRewardWei) * 1 ether / slashingFraction;\n28:     }\n```\n\n- Let's assume `flaggerRewardWei + flagReviewerCount * flagReviewerRewardWei = 100, StreamrConfig.slashingFraction = 0.03e18(3%), minimumStakeWei() = 1000 * 1e18 / 0.03e18 = 10000 / 3 = 3333.`\n- If we suppose `stakedWei[target] = streamrConfig.minimumStakeWei()`, then `targetStakeAtRiskWei[target] = 3333 * 0.03e18 / 1e18 = 99.99 = 99.`\n- As a result, `targetStakeAtRiskWei[target]` is less than total rewards(=100), and `_endVote()` will revert during the reward distribution due to underflow.\n\nThe above scenario is possible only when there is a rounding during `minimumStakeWei` calculation. So it works properly with the default `slashingFraction = 10%`.\n\n**Impact:** The `VoteKickPolicy` wouldn't work as expected and malicious operators won't be kicked forever.\n\n**Recommended Mitigation:** Always round the `minimumStakeWei()` up.\n\n**Client:** Fixed in commit [615b531](https://github.com/streamr-dev/network-contracts/commit/615b5311963082c79d05ec4072b1abeba4d1f9b4).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report describes an issue with the `VoteKickPolicy` in the `StreamrConfig.sol` contract. In the `onFlag()` function, `targetStakeAtRiskWei[target]` might be less than the total rewards for the flagger/reviewers due to rounding. This is possible when the `slashingFraction` is set to a value other than 10%. If this happens, during reward distribution the `_endVote()` will revert due to underflow.\n\nThe impact of this bug is that the `VoteKickPolicy` won't work as expected and malicious operators won't be kicked forever. The recommended mitigation is to always round the `minimumStakeWei()` up. The client has fixed the issue in commit 615b531 and it has been verified by Cyfrin.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-03-cyfrin-streamr.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "votekickpolicy_endvote-might-revert-forever-due-to-underflow-cyfrin-none-cyfrin-streamr-markdown",
      "firm_name": "Cyfrin",
      "firm_logo_square": "Cyfrin_square.jpg",
      "protocol_name": "Streamr",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
      },
      "protocols_protocol": {
        "name": "Streamr",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Overflow/Underflow"
          }
        },
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "20726",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "976",
      "title": "M-2: `optionTokens` can be expired even though the epoch is not over",
      "content": "Source: https://github.com/sherlock-audit/2023-06-bond-judging/issues/63 \n\n## Found by \nBenRai, qandisa\n## Summary\n\nWhen deploying an `optionToken` the parameter `expiry` is rounded down to the “nearest day at 0000 UTC” but since the end of an epoch is calculated by the `epochDuration` and the exact time the epoch has stared and the `optionToken` was created this can lead to an epoch still being active but the corresponding `optionToken` to be already expired. \n\n## Vulnerability Detail\n\nWhen starting a new epoch, the variable `epochStart` is set to the current time (`block.timestamp`) and the end of the epoch is calculated by adding the `epochDuration` to the `epochStart` variable. \n\nThe `optionToken` of the new epoch is deployed with the parameter `expire` calculated based on the current time stamp, the `timeUntilEligible` and the `eligibleDuration`. (`uint48(block.timestamp) + timeUntilEligible + eligibleDuration`). The final expiration date of the optionToken is rounded down to the “nearest day at 0000 UTC” before the token is deployed.\n\nSince the `epochDuration` can be as close as 1 second to the sum of `timeUntilEligible + eligibleDuration` this can lead to an epoch still being active but its `optionToken` to be already expired.\n\nExample:\n\nepochDuration = 7 days\ntimeUntilEligible = 0\neligibleDuration = 7 days + 12 hours\n\n\nNew epoch is launched on the 01.01.2024 at 11:45 am.\n\n=>\nepochStart = block.timestamp  = 01.01.2024 at 11:45 am\nepochEnd = epochStart + epochDuration = 08.01.2024 at 11:45 am\n\n`initial expire` = block.timestamp + timeUntilEligible + eligibleDuration = 08.01.2024 at 11:45 pm\n\n`final expire` after rounding down = uint48(`initial expire`/ 1day) * 1 day = 08.01.2024 at 00:00 am\n\nThe epoch is still active between `final expire` and `epochEnd` even though the option has already expired.\n\n## Impact\n\nUsers that wait until the epoch has ended to claim their rewards expecting the options to be exercisable for 12 hours after the epoch end cannot claim their options since they are expired already and lose out on all the value the options would have had which can be significant depending on the current price of the `payoutToken`\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/liquidity-mining/OTLM.sol#L514-L534\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L122\n\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/liquidity-mining/OTLM.sol#L605-L611\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/liquidity-mining/OTLM.sol#L629-L643\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe expiration of the `optionTokens` should be rounded up instead of down. This would increase the time an option can be redeemed long enough to prevent the scenario described above.\n\n\n\n\n## Discussion\n\n**Oighty**\n\nAgree with this issue, but would prefer to fix by requiring the expiry to be atleast 1 day longer than the epoch duration. Having expiries all round-down is simpler and consistent with some of our other contracts.\n\n**ctf-sec**\n\nBased on impact, agree with the finding\n\n> Users that wait until the epoch has ended to claim their rewards expecting the options to be exercisable for 12 hours after the epoch end cannot claim their options since they are expired already and lose out on all the value the options would have had which can be significant depending on the current price of the payoutToken\n\n**Oighty**\n\nFix implemented at https://github.com/Bond-Protocol/options/pull/10\n\n**ctf-sec**\n\nLooks likes ok, may also want to round up as well O(∩_∩)O\n\n> The expiration of the optionTokens should be rounded up instead of down. This would increase the time an option can be redeemed long enough to prevent the scenario described above.\n\n**Oighty**\n\nSee comment above. Our other contracts use expiry values that are rounded down. We want to maintain consistency.\n\n**ctf-sec**\n\nOk Then the fix looks good!",
      "summary": "\nThis bug report is about an issue (M-2) with the `optionTokens` in the Bond Protocol. It was found by BenRai and qandisa and the source of the report is from the github page https://github.com/sherlock-audit/2023-06-bond-judging/issues/63. \n\nThe issue is that when deploying an `optionToken` the parameter `expiry` is rounded down to the “nearest day at 0000 UTC” which can lead to an epoch still being active but the corresponding `optionToken` to be already expired. This is because the `epochDuration` can be as close as 1 second to the sum of `timeUntilEligible + eligibleDuration` when the `optionToken` is deployed.\n\nThe impact of this issue is that users that wait until the epoch has ended to claim their rewards expecting the options to be exercisable for 12 hours after the epoch end cannot claim their options since they are expired already and lose out on all the value the options would have had which can be significant depending on the current price of the `payoutToken`.\n\nThe recommendation for fixing this bug is for the expiration of the `optionTokens` to be rounded up instead of down. This would increase the time an option can be redeemed long enough to prevent the scenario described above. The fix was implemented at https://github.com/Bond-Protocol/options/pull/10 and looks good.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/99",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-bond-judging/issues/63",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "99",
      "slug": "m-2-optiontokens-can-be-expired-even-though-the-epoch-is-not-over-sherlock-none-bond-options-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Bond Options",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Bond Options",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Time Rounding"
          }
        },
        {
          "tags_tag": {
            "title": "Rounding"
          }
        },
        {
          "tags_tag": {
            "title": "Block Period"
          }
        }
      ]
    },
    {
      "id": "20725",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "976",
      "title": "M-1: Funds can be stolen from the `FixedStrikeOptionTeller` contract by creating put option tokens without providing collateral",
      "content": "Source: https://github.com/sherlock-audit/2023-06-bond-judging/issues/61 \n\n## Found by \nberndartmueller, pks\\_, techOptimizor\n## Summary\n\nDue to a rounding error when calculating the `quoteAmount` in the `create` function of the `FixedStrikeOptionTeller` contract, it is possible to create (issue) option tokens without providing the necessary collateral. A malicious receiver can exploit this to steal funds from the `FixedStrikeOptionTeller` contract.\n\n## Vulnerability Detail\n\nAnyone can create (issue) put option tokens with the `create` function in the `FixedStrikeOptionTeller` contract. However, by specifying a very small `amount_`, the `quoteAmount` calculation in line 283 can potentially round down to zero. This is the case if the result of the multiplication in line 283, $amount * strikePrice$ is smaller than $10^{decimals}$, where `decimals` is the number of decimals of the payout token.\n\nFor example, assume the following scenario:\n\n| Parameter                | Description                                                                                      |\n| ------------------------ | ------------------------------------------------------------------------------------------------ |\n| Quote token              | $USDC. 6 decimals                                                                                |\n| Payout token             | $GMX. 18 decimals                                                                                |\n| $payoutToken_{decimals}$ | 18 decimals                                                                                      |\n| $amount$                 | `1e10`. Amount (`amount_`) supplied to the `create` function, in payout token decimal precision. |\n| $strikePrice$            | `50e6` ~ 50 USD. The strike price of the option token, in quote tokens.                              |\n\n_[Please note that the option token has the same amount of decimals as the payout token.](https://github.com/sherlock-audit/2023-06-bond/blob/main/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L221)_\n\nCalculating `quoteAmount` leads to the following result:\n\n$$\n\\begin{align}\nquoteAmount &= \\dfrac{amount * strikePrice}{10^{payoutToken_{decimals}}} \\\\\n&= \\dfrac{1e10 * 50e6}{10^{18}} \\\\\n&= \\dfrac{5e17}{10^{18}} \\\\\n&= \\dfrac{5 * 10^{17}}{10^{18}} \\\\\n&= 0\n\\end{align}\n$$\n\nAs observed, the result is rounded down to zero due to the numerator being smaller than the denominator.\n\nThis results in **0** quote tokens to be transferred from the caller to the contract, and in return, the caller receives `1e10` ($amount$) option tokens. This process can be repeated to mint an arbitrary amount of option tokens for free.\n\n## Impact\n\nPut options can be minted for free without providing the required `quoteToken` collateral.\n\nThis is intensified by the fact that a malicious receiver, which anyone can be, can exploit this issue by deploying a new option token (optionally with a very short expiry), repeatedly minting free put options to accumulate option tokens, and then, once the option expires, call `reclaim` to receive quote token collateral.\n\nThis collateral, however, was supplied by other users who issued (created) option tokens with the same quote token. Thus, the malicious receiver can drain funds from other users and cause undercollateralization of those affected option tokens.\n\n## Code Snippet\n\n[src/fixed-strike/FixedStrikeOptionTeller.sol#L283](https://github.com/sherlock-audit/2023-06-bond/blob/main/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L283)\n\n```solidity\n236: function create(\n237:     FixedStrikeOptionToken optionToken_,\n238:     uint256 amount_\n239: ) external override nonReentrant {\n...      // [...]\n268:\n269:     // Transfer in collateral\n270:     // If call option, transfer in payout tokens equivalent to the amount of option tokens being issued\n271:     // If put option, transfer in quote tokens equivalent to the amount of option tokens being issued * strike price\n272:     if (call) {\n...          // [...]\n281:     } else {\n282:         // Calculate amount of quote tokens required to mint\n283: @>      uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals()); // @audit-issue Rounds down\n284:\n285:         // Transfer quote tokens from user\n286:         // Check that amount received is not less than amount expected\n287:         // Handles edge cases like fee-on-transfer tokens (which are not supported)\n288:         uint256 startBalance = quoteToken.balanceOf(address(this));\n289:         quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n290:         uint256 endBalance = quoteToken.balanceOf(address(this));\n291:         if (endBalance < startBalance + quoteAmount)\n292:             revert Teller_UnsupportedToken(address(quoteToken));\n293:     }\n294:\n295:     // Mint new option tokens to sender\n296:     optionToken.mint(msg.sender, amount_);\n297: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a check after line 283 to ensure `quoteAmount` is not zero.\n\n\n\n\n## Discussion\n\n**Oighty**\n\nAgree with this issue. Checking for a zero quote amount is a potential solution, but it would be better to fix the precision issue. I'm going to explore other ways to do this (including something like the price scale system used in the other bond protocol contracts).\n\n**ctf-sec**\n\nI agree, if only checking the amount > 0, the precision loss can still be large and round down to 1 wei\n\nscaling amount with decimals seems the way to go!\n\n**ctf-sec**\n\nIn report #62 \n\nthe auditor is correct the user can game the code to not pay the quote amount and receive the payout token just like the receiver\n\nbut there is no loss of fund, because when minting option, the payout token collateral has to be supplied.\n\nIn this report\n\nit is true the user can game the code to not supply the collateral and get the option token and then call reclaim the drain the fund.\n\nthe impact is clearly more severe\n\nbut the reclaim issue has been extensively covered in report:\n\nhttps://github.com/sherlock-audit/2023-06-bond-judging/issues/79\n\nthe report takes the advantage of the rounding\n\nin fact in my report:\n\nhttps://github.com/sherlock-audit/2023-06-bond-judging/issues/90\n\nI highlight the decimals is large and collateral is round down to 0 then call reclaim to drain the fund as well\n\nAfter internal discussion, Agree with the de-duplication and leave as a separate medium\n\n**0x3b33**\n\nI mean the issue is valid in a way that there needs to be a check for quote of 0, but how is anyone gonna profit from it? The attacker's profit is only 1e10, compared to GMX's decimals 18, he is making nothing! If my calculations are not wrong, the attacker will make 0.00000055$ per call...\nWhen I press the button to turn my PC on I spend more money, let alone to run a TX on any network. \n\n**ctf-sec**\n\n> I mean the issue is valid in a way that there needs to be a check for quote of 0, but how is anyone gonna profit from it? The attacker's profit is only 1e10, compared to GMX's decimals 18, he is making nothing! If my calculations are not wrong, the attacker will make 0.00000055$ per call... When I press the button to turn my PC on I spend more money, let alone to run a TX on any network.\n\nTo profits, the attacker would need to repeated call reclaim (which is another issue)\n\nThe decimal rounding plays a role as well (which is another issue)\n\nEven the fact that can mint token without providing collateral make it a valid issue.\n\n**Oighty**\n\nFix implemented at https://github.com/Bond-Protocol/options/pull/11\n\n**ctf-sec**\n\nFix looks good",
      "summary": "\nThis bug report is about a vulnerability found in the `FixedStrikeOptionTeller` contract of the Bond Protocol. It was discovered by three developers: berndartmueller, pks\\_, and techOptimizor. \n\nThe vulnerability allows anyone to create (issue) put option tokens with the `create` function in the `FixedStrikeOptionTeller` contract without providing the necessary collateral. This is due to a rounding error when calculating the `quoteAmount` in line 283 of the contract. If the result of the multiplication in line 283, $amount * strikePrice$, is smaller than $10^{decimals}$, where `decimals` is the number of decimals of the payout token, the result is rounded down to zero. \n\nAs a result, the caller receives `1e10` ($amount$) option tokens without transferring any quote tokens to the contract. This process can be repeated to mint an arbitrary amount of option tokens for free.\n\nThe impact of this vulnerability is that put options can be minted for free without providing the required `quoteToken` collateral. It is further intensified by the fact that a malicious receiver can exploit this issue by deploying a new option token (optionally with a very short expiry), repeatedly minting free put options to accumulate option tokens, and then, once the option expires, calling `reclaim` to receive quote token collateral. This collateral, however, was supplied by other users who issued (created) option tokens with the same quote token, so the malicious receiver can drain funds from other users and cause undercollateralization of those affected option tokens. \n\nThe issue was discovered by manual review. The recommended solution is to consider adding a check after line 283 to ensure `quoteAmount` is not zero. This fix has been implemented at https://github.com/Bond-Protocol/options/pull/11.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/99",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-bond-judging/issues/61",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "99",
      "slug": "m-1-funds-can-be-stolen-from-the-fixedstrikeoptionteller-contract-by-creating-put-option-tokens-without-providing-collateral-sherlock-none-bond-options-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Bond Options",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Bond Options",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        },
        {
          "tags_tag": {
            "title": "Missing Check"
          }
        }
      ]
    },
    {
      "id": "21220",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "995",
      "title": "M-19: Rounding error when closing quote",
      "content": "Source: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/251 \n\n## Found by \nmstpr-brainbot, xiaoming90\n## Summary\n\nRounding errors could occur if the provided `filledAmount` is too small, resulting in the locked balance of an account remains the same even though a certain amount of the position has been closed.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L155\n\n```solidity\nFile: LibQuote.sol\n149:     function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n150:         QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n151:         AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n152: \n153:         quote.modifyTimestamp = block.timestamp;\n154: \n155:         LockedValues memory lockedValues = LockedValues(\n156:             quote.lockedValues.cva -\n157:                 ((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n158:             quote.lockedValues.mm -\n159:                 ((quote.lockedValues.mm * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n160:             quote.lockedValues.lf -\n161:                 ((quote.lockedValues.lf * filledAmount) / (LibQuote.quoteOpenAmount(quote)))\n162:         );\n163:         accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n164:         accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(\n165:             lockedValues\n166:         );\n167:         quote.lockedValues = lockedValues;\n168: \n169:         (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(\n170:             closedPrice,\n171:             filledAmount,\n172:             quote\n173:         );\n174:         if (hasMadeProfit) {\n175:             accountLayout.allocatedBalances[quote.partyA] += pnl;\n176:             accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n177:         } else {\n178:             accountLayout.allocatedBalances[quote.partyA] -= pnl;\n179:             accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n180:         }\n\n```\n\nIn Lines 157, 159, and 161 above, a malicious user could make the numerator smaller than the denominator (`LibQuote.quoteOpenAmount(quote)`), and the result will be zero due to a rounding error in Solidity.\n\nIn this case, the `quote.lockedValues` will not decrease and will remain the same. As a result, the locked balance of the account will remain the same even though a certain amount of the position has been closed. This could cause the account's locked balance to be higher than expected, and the errors will accumulate if it happens many times.\n\n## Impact\n\nWhen an account's locked balances are higher than expected, their available balance will be lower than expected. The available balance affects the amount that users can withdraw from their accounts. The \"silent\" increase in their locked values means that the amount that users can withdraw becomes lesser over time, and these amounts are lost due to the errors.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L155\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen the `((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote)))` rounds down to zero, this means that a rounding error has occurred as the numerator is smaller than the denominator. The CVA, `filledAmount` or both might be too small.\n\nConsider performing input validation against the `filledAmount` within the `fillCloseRequest` function to ensure that the provided values are sufficiently large and will not result in a rounding error.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Given that:\n> - All amounts are of precision 18 decimals and multiplication before division rule is implemented\n> - Multiple checks on locked amounts wrt quantity opened:\n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L50-L65\n> \n> The amounts remaining locked are very small (magnitude of few wei per call), this issue should be of low severity per sherlock standards\n\n    You've deleted an escalation for this issue.\n\n**xiaoming9090**\n\nEscalate\n\n> Escalate\n>\n> Given that:\n>\n> * All amounts are of precision 18 decimals and multiplication before division rule is implemented\n> * Multiple checks on locked amounts wrt quantity opened:\n>   https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L50-L65\n>\n> The amounts remaining locked are very small (magnitude of few wei per call), this issue should be of low severity per sherlock standards\n\nRegarding the second bullet point, the checks will only be relevant if the position is fully closed via the `forceClosePosition` or `emergencyClosePosition` function, as they are forced to close the entire quantity of the position. However, if the position is partially filled via the `fillCloseRequest`, the error might still occur since the caller can specify an arbitrary `filledAmount`.\n\nIf an account has only traded a few times and the error only happens a few times, it might be fine. However, this is a trading protocol, and it is expected that there will be users who are active traders or entities that perform high-frequency or algorithmic trading. \n\nThus, the error will eventually accumulate into a significant value for these types of traders, and they will suffer the consequences as mentioned in my impact section of the report. In addition, it breaks an important protocol invariant where the locked balance does not decrease when a position is closed, which is unacceptable.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> > Escalate\n> >\n> > Given that:\n> >\n> > * All amounts are of precision 18 decimals and multiplication before division rule is implemented\n> > * Multiple checks on locked amounts wrt quantity opened:\n> >   https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L50-L65\n> >\n> > The amounts remaining locked are very small (magnitude of few wei per call), this issue should be of low severity per sherlock standards\n> \n> Regarding the second bullet point, the checks will only be relevant if the position is fully closed via the `forceClosePosition` or `emergencyClosePosition` function, as they are forced to close the entire quantity of the position. However, if the position is partially filled via the `fillCloseRequest`, the error might still occur since the caller can specify an arbitrary `filledAmount`.\n> \n> If an account has only traded a few times and the error only happens a few times, it might be fine. However, this is a trading protocol, and it is expected that there will be users who are active traders or entities that perform high-frequency or algorithmic trading. \n> \n> Thus, the error will eventually accumulate into a significant value for these types of traders, and they will suffer the consequences as mentioned in my impact section of the report. In addition, it breaks an important protocol invariant where the locked balance does not decrease when a position is closed, which is unacceptable.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**SergeKireev**\n\nEscalate\n\nThis issue is invalid because `LibQuote.quoteOpenAmount(quote))` is defined as:\n```\nfunction quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n    return quote.quantity - quote.closedAmount;\n}\n```\n\nin the `closeQuote` function, `quote.closedAmount` is also updated as follows:\n```\nquote.closedAmount += filledAmount;\n```\n\nWhich means that when the user closes the position completely `filledAmount == LibQuote.quoteOpenAmount(quote))` (which also means `filledAmount/LibQuote.quoteOpenAmount(quote)) == 1` and without  rounding error) and the whole amount is unlocked in any case\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This issue is invalid because `LibQuote.quoteOpenAmount(quote))` is defined as:\n> ```\n> function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n>     return quote.quantity - quote.closedAmount;\n> }\n> ```\n> \n> in the `closeQuote` function, `quote.closedAmount` is also updated as follows:\n> ```\n> quote.closedAmount += filledAmount;\n> ```\n> \n> Which means that when the user closes the position completely `filledAmount == LibQuote.quoteOpenAmount(quote))` (which also means `filledAmount/LibQuote.quoteOpenAmount(quote)) == 1` and without  rounding error) and the whole amount is unlocked in any case\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\n@xiaoming9090 any comment on the escalation by @SergeKireev ?\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/24\n\n**xiaoming9090**\n\n> Escalate\n> \n> This issue is invalid because `LibQuote.quoteOpenAmount(quote))` is defined as:\n> \n> ```\n> function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n>     return quote.quantity - quote.closedAmount;\n> }\n> ```\n> \n> in the `closeQuote` function, `quote.closedAmount` is also updated as follows:\n> \n> ```\n> quote.closedAmount += filledAmount;\n> ```\n> \n> Which means that when the user closes the position completely `filledAmount == LibQuote.quoteOpenAmount(quote))` (which also means `filledAmount/LibQuote.quoteOpenAmount(quote)) == 1` and without rounding error) and the whole amount is unlocked in any case\n\nDisagree. This does not make the issue invalid. If the trader executes many small partial closes without completely closing the position, the accumulated error in the locked values will exist. It is unacceptable for the protocol to have inaccurate locked values at any single point in time. The locked values are used to determine many crucial decisions throughout the protocol, such as in assessing the solvency of an account.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAgree with the fix and the comment here:\nhttps://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/251#issuecomment-1685574052\nmaintaining severity as is\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/251/#issuecomment-1652872462): accepted\n- [SergeKireev](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/251/#issuecomment-1653204545): rejected",
      "summary": "\nThis bug report is about a rounding error that could occur when closing a quote in the Sherlock Audit 2023-06-symmetrical-judging protocol. The issue was discovered by mstpr-brainbot and xiaoming90. The issue occurs when the provided filledAmount is too small, resulting in the locked balance of an account remaining the same even though a certain amount of the position has been closed. This is caused by a rounding error in Solidity in Lines 157, 159, and 161 of LibQuote.sol.\n\nThe impact of this issue is that when an account's locked balances are higher than expected, their available balance will be lower than expected. This affects the amount that users can withdraw from their accounts, and the \"silent\" increase in their locked values means that the amount that users can withdraw becomes lesser over time, and these amounts are lost due to the errors.\n\nThe recommended solution is to perform input validation against the filledAmount within the fillCloseRequest function to ensure that the provided values are sufficiently large and will not result in a rounding error. This issue was escalated by sherlock-admin2, xiaoming9090, and SergeKireev. The issue was resolved by hrishibhat who maintained the severity as is and agreed with the fix and comment in the issue. MoonKnightDev provided a Fixed code PR link.",
      "report_date": {},
      "contest_prize_txt": "61000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/85",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/251",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "85",
      "slug": "m-19-rounding-error-when-closing-quote-sherlock-none-symmetrical-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Symmetrical",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Symmetrical",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "21143",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 7,
      "protocol_id": "933",
      "title": "[H-06] `EUSD.mint` function wrong assumption of cases when calculated sharesAmount = 0",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L299-#L306> <br><https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L414-#L418>\n\n### Impact\n\n*   `Mint` function might calculate the `sharesAmount` incorrectly.\n*   User can profit by manipulating the protocol to enjoy 1-1 share-eUSD ratio even when share prices is super high.\n\n### Proof of Concept\n\nCurrently, the function `EUSD.mint` calls function `EUSD.getSharesByMintedEUSD` to calculate the shares corresponding to the input eUSD amount:\n\n```solidity\nfunction mint(address _recipient, uint256 _mintAmount) external onlyMintVault MintPaused returns (uint256 newTotalShares) {\n        require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n        uint256 sharesAmount = getSharesByMintedEUSD(_mintAmount);\n        if (sharesAmount == 0) {\n            //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n            sharesAmount = _mintAmount;\n        }\n        ...\n}\nfunction getSharesByMintedEUSD(uint256 _EUSDAmount) public view returns (uint256) {\n        uint256 totalMintedEUSD = _totalSupply;\n        if (totalMintedEUSD == 0) {\n            return 0;\n        } else {\n            return _EUSDAmount.mul(_totalShares).div(totalMintedEUSD);\n        }\n}\n```\n\nAs you can see in the comment after `sharesAmount` is checked, `//EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1`. The code assumes that if `sharesAmount = 0`, then `totalSupply` must be 0 and the minted share should equal to input eUSD. However, that's not always the case.\n\nVariable `sharesAmount` could be 0 if `totalShares *_EUSDAmount` < `totalMintedEUSD` because this is integer division. If that happens, the user will profit by calling mint with a small EUSD amount and enjoys 1-1 minting proportion (1 share for each eUSD). The reason this can happen is because `EUSD` support `burnShares` feature, which remove the share of a users but keep the `totalSupply` value.\n\nFor example:\n1.  At the start, Bob is minted 1e18 eUSD, they receive 1e18 shares.\n2.  Bob call `burnShares` by `1e18-1`. After this, contract contains 1e18 eUSD and 1 share, which mean 1 share now worth 1e18 eUSD.\n3.  If Alice calls `mint` with 1e18 eUSD, then they receive 1 share (since 1 share worth 1e18 eUSD).\n4.  However, if they then call `mint` with 1e17 eUSD, they will receive 1e17 shares although 1 share is now worth 1e18 eUSD. This happens because `1e17 * (totalShares = 2) / (totalMintedEUSD = 2e18)` = 0.\n\nBelow is POC for the above example. I use foundry to run tests; create a folder named `test` and save this to a file named `eUSD.t.sol`, then run it using command:\n\n`forge test --match-path test/eUSD.t.sol -vvvv`\n\n```solidity\npragma solidity ^0.8.17;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {Iconfigurator} from \"contracts/lybra/interfaces/Iconfigurator.sol\";\nimport {Configurator} from \"contracts/lybra/configuration/LybraConfigurator.sol\";\nimport {GovernanceTimelock} from \"contracts/lybra/governance/GovernanceTimeLock.sol\";\nimport {mockCurve} from \"contracts/mocks/mockCurve.sol\";\nimport {EUSD} from \"contracts/lybra/token/EUSD.sol\";\n\ncontract TestEUSD is Test {\n    address admin = address(0x1111);\n    address user1 = address(0x1);\n    address user2 = address(0x2);\n    address pool = address(0x3);\n\n    Configurator configurator;\n    GovernanceTimelock governanceTimeLock;\n    mockCurve curve;\n    EUSD eUSD;\n\n\n\n    function setUp() public{\n        // deploy curve\n        curve = new mockCurve();\n        // deploy governance time lock\n        address[] memory proposers = new address[](1);\n        proposers[0] = admin;\n\n        address[] memory executors = new address[](1);\n        executors[0] = admin;\n\n        governanceTimeLock = new GovernanceTimelock(1, proposers, executors, admin);\n        configurator = new Configurator(address(governanceTimeLock), address(curve));\n\n        eUSD = new EUSD(address(configurator));\n        // set mintVault to this address\n        vm.prank(admin);\n        configurator.setMintVault(address(this), true);\n    }\n\n    function testRoundingNotCheck() public {\n        // Mint some tokens for user1\n        eUSD.mint(user1, 1e18);\n\n        assertEq(eUSD.balanceOf(user1), 1e18);\n        assertEq(eUSD.totalSupply(), 1e18);\n\n        //\n        eUSD.burnShares(user1, 1e18-1);\n\n        assertEq(eUSD.getTotalShares(),1);\n        assertEq(eUSD.sharesOf(user1), 1);\n        assertEq(eUSD.totalSupply(), 1e18);\n\n        // After this, 1 shares worth 1e18 eUSDs\n        // If mintAmount = 1e18 -> receive  1 shares\n\n        eUSD.mint(user2, 1e18);\n        assertEq(eUSD.getTotalShares(), 2);\n        assertEq(eUSD.sharesOf(user2), 1);\n        assertEq(eUSD.totalSupply(), 2e18);\n\n        // However, if mintAmount = 1e17 -> receive 1e17 shares\n\n        eUSD.mint(user2, 1e17);\n\n        assertEq(eUSD.sharesOf(user2), 1 + 1e17);\n\n\n    }\n\n}\n```\n\n### Tools Used\n\nManual Review\n\n### Recommended Mitigation Steps\n\nI recommend checking again in `EUSD.mint` function if `sharesAmount` is 0 and `totalSupply` is not 0, then exit the function without minting anything.\n\n**[LybraFinance confirmed](https://github.com/code-423n4/2023-06-lybra-findings/issues/106#issuecomment-1635617210)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the LybraFinance protocol. The vulnerability is in the function `EUSD.mint`, which calls the function `EUSD.getSharesByMintedEUSD` to calculate the shares corresponding to the input eUSD amount. The code assumes that if `sharesAmount = 0`, then `totalSupply` must be 0 and the minted share should equal to input eUSD. However, this is not always the case. \n\nThe bug occurs when `totalShares *_EUSDAmount` is less than `totalMintedEUSD` because this is integer division. If that happens, the user will profit by calling mint with a small EUSD amount and enjoys 1-1 minting proportion (1 share for each eUSD). This can happen because `EUSD` support `burnShares` feature, which remove the share of a users but keep the `totalSupply` value. \n\nThe Proof of Concept (POC) provided in the bug report shows how this can happen. As an example, it shows how a user can call `mint` with 1e17 eUSD and receive 1e17 shares, even though 1 share is now worth 1e18 eUSD. The POC was tested using foundry, by creating a folder named `test` and saving the code to a file named `eUSD.t.sol`, then running it using the command `forge test --match-path test/eUSD.t.sol -vvvv`.\n\nThe recommended mitigation step for this bug is to check again in the `EUSD.mint` function if `sharesAmount` is 0 and `totalSupply` is not 0, then exit the function without minting anything. LybraFinance has confirmed this bug and is working on a fix.",
      "report_date": {},
      "contest_prize_txt": "$60,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-06-lybra",
      "sponsor_name": "Lybra Finance",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-06-lybra",
      "github_link": "https://github.com/code-423n4/2023-06-lybra-findings/issues/106",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "254",
      "slug": "h-06-eusdmint-function-wrong-assumption-of-cases-when-calculated-sharesamount-0-code4rena-lybra-finance-lybra-finance-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Lybra Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Lybra Finance",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Precision Loss"
          }
        },
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "18415",
      "kind": "MARKDOWN",
      "auditfirm_id": "11",
      "impact": "MEDIUM",
      "finders_count": 4,
      "protocol_id": "298",
      "title": "Different rounding directions are recommended for getting buy/sell info",
      "content": "**Description:**\nThis issue pertains to the need for more implementation of different rounding directions for buy and sell operations in the AMM pools.\nIn several `ICurve` implementations (`XykCurve`, `GDACurve`), the `ICurve::getBuyInfo` and `ICurve::getSellInfo` functions are implemented using the same rounding direction.\nThis does not align with the best practices for AMM pools, which dictate that different rounding directions should be applied for buy and sell operations to prevent potential issues. The problem becomes more significant for tokens with fewer decimals, resulting in larger pricing discrepancies.\n\nNote that `ExponentialCurve` explicitly uses different rounding directions for buy and sell operations, which aligns with the best practices.\n\nAdditionally, across all curves, calculations of the protocol and trade fees currently do not round in favor of the protocol and fee recipients, which means that value may leak from the system in favor of the traders.\n\n**Impact:**\nThe issue may result in financial loss for pair creators and negatively impact the platform's overall stability, especially for tokens with fewer decimals. We, therefore, rate the severity as MEDIUM.\n\n**Recommended Mitigation:**\nEnsure that the buy price and protocol/trade fees are rounded up to prevent selling items at a lower price than desired and leaking value from the system.\n\n**Sudoswap:**\nFixed in [commit 902eee](https://github.com/sudoswap/lssvm2/commit/902eee37890af3953a55472d885bf6265b329434).\n\n**Cyfrin:**\nVerified.",
      "summary": "\nThis bug report is about the need for more implementation of different rounding directions for buy and sell operations in the AMM pools. In several `ICurve` implementations, the same rounding direction was applied for buy and sell operations, which does not align with the best practices for AMM pools. This may lead to financial loss for pair creators and negatively impact the platform's overall stability, especially for tokens with fewer decimals.\n\nThe recommended mitigation for this issue is to ensure that the buy price and protocol/trade fees are rounded up to prevent selling items at a lower price than desired and leaking value from the system. This issue has been fixed in the commit 902eee on the Sudoswap GitHub repository and has been verified by Cyfrin.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "different-rounding-directions-are-recommended-for-getting-buysell-info-cyfrin-sudoswap-markdown_",
      "firm_name": "Cyfrin",
      "firm_logo_square": "Cyfrin_square.jpg",
      "protocol_name": "Sudoswap",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
      },
      "protocols_protocol": {
        "name": "Sudoswap",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "7258",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 5,
      "protocol_id": "39",
      "title": "Rounding up of taker fees of constituent orders may exceed collected fee",
      "content": "## Severity: High Risk\n\n## Context\n- OrderBook.sol#L463 \n- OrderBook.sol#L478-L482 \n- OrderBook.sol#L604 \n\n## Description\nIf multiple orders are taken, the taker fee calculated is rounded up once, but that of each taken maker order could be rounded up as well, leading to more fees accounted for than actually taken.\n\n### Example:\n- takerFee = 100011 (10.0011%)\n- 2 maker orders of amounts 400000 and 377000\n- total amount = 400000 + 377000 = 777000\n- Taker fee taken = 777000 * 100011 / 1000000 = 77708.547 ≈ 77709 \n\nMaker fees would be:\n- 377000 * 100011 / 1000000 = 37704.147 ≈ 37705\n- 400000 * 100011 / 1000000 = 40004.4 ≈ 40005\n\nThis results in 1 wei more than actually taken.\n\nBelow is a foundry test to reproduce the problem, which can be inserted into `Claim.t.sol`:\n\n```solidity\nfunction testClaimFeesFailFromRounding() public {\n    _createOrderBook(0, 100011); // 10.0011% taker fee\n    // create 2 orders\n    uint256 orderIndex1 = _createPostOnlyOrder(Constants.BID, Constants.RAW_AMOUNT);\n    uint256 orderIndex2 = _createPostOnlyOrder(Constants.BID, Constants.RAW_AMOUNT);\n    // take both orders\n    _createTakeOrder(Constants.BID, 2 * Constants.RAW_AMOUNT);\n    CloberOrderBook.OrderKey[] memory ids = new CloberOrderBook.OrderKey[](2);\n    ids[0] = CloberOrderBook.OrderKey({\n        isBid: Constants.BID,\n        priceIndex: Constants.PRICE_INDEX,\n        orderIndex: orderIndex1\n    });\n    ids[1] = CloberOrderBook.OrderKey({\n        isBid: Constants.BID,\n        priceIndex: Constants.PRICE_INDEX,\n        orderIndex: orderIndex2\n    });\n    // perform claim\n    orderBook.claim(\n        address(this),\n        ids\n    );\n    // (uint128 quoteFeeBal, uint128 baseFeeBal) = orderBook.getFeeBalance();\n    // console.log(quoteFeeBal); // fee accounted = 20004\n    // console.log(baseFeeBal); // fee accounted = 0\n    // console.log(quoteToken.balanceOf(address(orderBook))); // actual fee collected = 20003\n    // try to claim fees, will revert\n    vm.expectRevert(\"ERC20: transfer amount exceeds balance\");\n    orderBook.collectFees();\n}\n```\n\n## Recommendation\nConsider rounding down the taker fee instead of rounding up.\n\n## Clober\nFixed in PR 325.\n\nWhile checking this issue, I found that we should use rounding up in the following parts (pretty informative) to avoid loss for the protocol:\n1. Flash loan fee calculation: OrderBook.sol#L330-L331\n2. DAO fee calculation: OrderBook.sol#L839\n3. Maker fee (when makerFee > 0) calculation: OrderBook.sol#L476 \n\n## Spearbit\nFixed.",
      "summary": "\nThis bug report discusses a high-risk issue in the OrderBook.sol file in the context of multiple orders being taken. If multiple orders are taken, the taker fee is rounded up once, but the maker fee for each taken order could also be rounded up, leading to more fees being accounted for than actually taken. To illustrate this issue, an example is given of a taker fee of 100011 (10.0011%), two maker orders of amounts 400000 and 377000, and a total amount of 777000. The taker fee taken is 777000 * 100011 / 1000000 = 77708.547 = 777709, while the maker fees would be calculated as 377000 * 100011 / 1000000 = 37704.147 = 37705 and 400000 * 100011 / 1000000 = 40004.4 = 40005, which is 1 wei more than actually taken. A foundry test to reproduce the problem is provided, as well as a recommendation to consider rounding down the taker fee instead of rounding up. Clober and Spearbit have both fixed the issue. Additionally, while checking the issue, it was found that rounding up should be used at three parts in the code (OrderBook.sol#L330-L331, OrderBook.sol#L839, and OrderBook.sol#L476) to avoid loss of the protocol.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Clober-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Clober-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Clober-Spearbit-Security-Review.pdf",
      "pdf_page_from": 14,
      "contest_id": "",
      "slug": "rounding-up-of-taker-fees-of-constituent-orders-may-exceed-collected-fee-spearbit-clober-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "CLOBER",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "CLOBER",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "22014",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 10,
      "protocol_id": "900",
      "title": "[M-17] Malicious Users Can Drain The Assets Of Vault. (Due to not being ERC4626 Complaint)",
      "content": "\nMalicious users can drain the assets of the vault.\n\n### Proof of Concept\n\nThe `withdraw` function users `convertToShares` to convert the assets to the amount of shares. These shares are burned from the users account and the assets are returned to the user.\n\nThe function `withdraw` is shown below:\n\n```solidity\nfunction withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public nonReentrant syncFeeCheckpoint returns (uint256 shares) {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        shares = convertToShares(assets);\n/// .... [skipped the code]\n```\n\nThe function `convertToShares` is shown below:\n\n```solidity\nfunction convertToShares(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return\n            supply == 0\n                ? assets\n                : assets.mulDiv(supply, totalAssets(), Math.Rounding.Down);\n    }\n```\n\nIt uses `Math.Rounding.Down` , but it should use `Math.Rounding.Up`\n\nAssume that the vault with the following state:\n\n*   Total Asset = 1000 WETH\n*   Total Supply = 10 shares\n\nAssume that Alice wants to withdraw 99 WETH from the vault. Thus, she calls the **`Vault.withdraw(99 WETH)`** function.\n\nThe calculation would go like this:\n\n```solidity\nassets = 99\nreturn value = assets * supply / totalAssets()\nreturn value = 99 * 10 / 1000\nreturn value = 0\n```\n\nThe value would be rounded round to zero. This will be the amount of shares burned from users account, which is zero.\n\nHence user can drain the assets from the vault without burning their shares.\n\n> Note : A similar issue also exists in `mint` functionality where `Math.Rounding.Down` is used and `Math.Rounding.Up` should be used.\n\n### Recommended Mitigation Steps\n\nUse `Math.Rounding.Up` instead of `Math.Rounding.Down`.\n\nAs per OZ implementation here is the rounding method that should be used:\n\n`deposit` : `convertToShares` → `Math.Rounding.Down`\n\n`mint` : `converttoAssets` → `Math.Rounding.Up`\n\n`withdraw` : `convertToShares` → `Math.Rounding.Up`\n\n`redeem` : `convertToAssets` →  `Math.Rounding.Down`\n\n**[RedVeil (Popcorn) confirmed, but disagreed with severity](https://github.com/code-423n4/2023-01-popcorn-findings/issues/471)** \n\n**[LSDan (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-popcorn-findings/issues/471)** \n\n\n***\n\n",
      "summary": "\nA bug has been found in the `withdraw` function of a vault, which allows malicious users to drain the assets of the vault without burning their shares. The bug is caused by the use of `Math.Rounding.Down` instead of `Math.Rounding.Up` in the `convertToShares` function. \n\nTo illustrate the issue, assume the vault has 1000 WETH in total assets and 10 shares in total supply. If Alice wants to withdraw 99 WETH from the vault by calling the `Vault.withdraw(99 WETH)` function, the calculation would be: `99 * 10 / 1000 = 0`, and the value would be rounded down to zero. This means that the amount of shares burned from Alice's account would be zero, allowing her to drain the assets from the vault without burning her shares.\n\nA similar issue also exists in the `mint` functionality, where `Math.Rounding.Down` is used and `Math.Rounding.Up` should be used. To fix this issue, the following rounding methods should be used: `deposit` → `convertToShares` → `Math.Rounding.Down`; `mint` → `converttoAssets` → `Math.Rounding.Up`; `withdraw` → `convertToShares` → `Math.Rounding.Up`; `redeem` → `convertToAssets` →  `Math.Rounding.Down`. The bug has been confirmed by RedVeil (Popcorn) and the severity has been decreased to Medium by LSDan (judge).",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-01-popcorn",
      "sponsor_name": "Popcorn",
      "sponsor_link": "",
      "quality_score": 2,
      "general_score": 2,
      "source_link": "https://code4rena.com/reports/2023-01-popcorn",
      "github_link": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/471",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "211",
      "slug": "m-17-malicious-users-can-drain-the-assets-of-vault-due-to-not-being-erc4626-complaint-code4rena-popcorn-popcorn-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Popcorn",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Popcorn",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-4626"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "21995",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 24,
      "protocol_id": "900",
      "title": "[H-10] First vault depositor can steal other's assets",
      "content": "\nThe first depositor can be front run by an attacker and as a result will lose a considerable part of the assets provided.\n\nThe vault calculates the amount of shares to be minted upon deposit to every user via the `convertToShares()` function:\n\n```solidity\nfunction deposit(uint256 assets, address receiver)\n    public\n    nonReentrant\n    whenNotPaused\n    syncFeeCheckpoint\n    returns (uint256 shares)\n{\n    if (receiver == address(0)) revert InvalidReceiver();\n\n    uint256 feeShares = convertToShares(\n        assets.mulDiv(uint256(fees.deposit), 1e18, Math.Rounding.Down)\n    );\n\n    shares = convertToShares(assets) - feeShares;\n\n    if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n    _mint(receiver, shares);\n\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    adapter.deposit(assets, address(this));\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n\nfunction convertToShares(uint256 assets) public view returns (uint256) {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return\n        supply == 0\n            ? assets\n            : assets.mulDiv(supply, totalAssets(), Math.Rounding.Down);\n}\n\n```\n\nWhen the pool has no share supply, the amount of shares to be minted is equal to the assets provided. An attacker can abuse this situation and profit off the rounding down operation when calculating the amount of shares if the supply is non-zero. This attack is enabled by the following components: frontrunning, rounding down the amount of shares calculated and regular ERC20 transfers.\n\n### Proof of Concept\n\nThe Vault charges zero fees to conduct any action.\n\n*   Alice wants to deposit 2MM USDT to a vault.\n*   Bob frontruns Alice deposit() call with the following transactions:\n    *   `vault.deposit(1, bob)`: This gives Bob 1 share backed by 1 USDT.\n    *   `usdt.transfer(address(vault.adapter()), 1MM)`: Sends 1MM USDT to the underlying vault's adapter (from were the `totalAssets` are calculated)\n    *   After those two transactions, `totalAssets = 1MM + 1` and `totalSupply = 1`.\n*   Alice deposit transaction is mined: `deposit(2MM, alice)`, she receives only **one** share because:\n    *   2MM / (1MM + 1) &ast; totalSupply = 2MM / (1MM + 1) &ast; 1 = 2MM / (1MM+) ≈ 1.999998 = 1 (as Solidity floors down).\n*   After Alice tx, the pool now has 3MM assets and distributed 2 shares.\n*   Bob backruns Alice's transaction and redeems his share getting 3MM &ast; (1 Share Owned by Bob) / (2 total shares) = 1.5MM\n\nThis process gives Bob a ≈500k asset profit and Alice incurs a ≈500k loss:\n\n```solidity\n  function test__FirstDepositorFrontRun() public {\n    uint256 amount = 2_000_000 ether;\n\n    uint256 aliceassetAmount = amount;\n\n    asset.mint(bob, aliceassetAmount);\n    asset.mint(alice, aliceassetAmount);\n\n    vm.prank(alice);\n    asset.approve(address(vault), aliceassetAmount);\n    assertEq(asset.allowance(alice, address(vault)), aliceassetAmount);\n\n    vm.prank(bob);\n    asset.approve(address(vault), aliceassetAmount);\n    assertEq(asset.allowance(bob, address(vault)), aliceassetAmount);\n\n    uint256 alicePreDepositBal = asset.balanceOf(alice);\n\n    console.log(\"\\n=== INITIAL STATES ===\");\n    console.log(\"Bob assets: %s\", asset.balanceOf(bob));\n    console.log(\"Alice assets: %s\", alicePreDepositBal);\n\n    // Bob frontruns Alice deposit.\n    vm.startPrank(bob);\n    uint256 bobShareAmount = vault.deposit(1, bob);\n    console.log(\"\\n=== BOB DEPOSITS ===\");\n    console.log(\"Bob Shares Amount: %s\", bobShareAmount);\n    console.log(\"Vault Assets : %s\", vault.totalAssets());\n\n    assertTrue(bobShareAmount == 1);\n    assertTrue(vault.totalAssets() == 1);\n    assertEq(adapter.afterDepositHookCalledCounter(), 1);\n\n    // Bob transfers 1MM of tokens to the adapter\n    asset.transfer(address(vault.adapter()), 1_000_000 ether);\n    console.log(\"\\n=== AFTER BOB's TRANSFER ===\");\n    console.log(\"Bob Shares Amount: %s\", bobShareAmount);\n    console.log(\"Vault Assets : %s\", vault.totalAssets());\n    assertTrue(vault.totalAssets() == 1_000_000 ether + 1);\n    vm.stopPrank();\n\n    \n    // Alice Txn is mined\n    vm.prank(alice);\n    uint256 aliceShareAmount = vault.deposit(aliceassetAmount, alice);\n    console.log(\"\\n=== AFTER ALICE TX ===\");\n    console.log(\"Alice Shares Amount: %s\", aliceShareAmount);\n    console.log(\"Vault Assets : %s\", vault.totalAssets());\n    assertTrue(aliceShareAmount == 1);\n\n    console.log(\"Convertable assets that Bob receives: %s\", vault.convertToAssets(vault.balanceOf(bob)));\n    console.log(\"Convertable assets that Alice receives: %s\", vault.convertToAssets(vault.balanceOf(bob)));\n\n    // Bob backruns the call and gets a 500k profit\n    vm.prank(bob);\n    vault.redeem(bobShareAmount, bob, bob);\n    console.log(\"\\n=== BOB WITHDRAWS ===\");\n\n    console.log(\"\\n=== ALICE WITHDRAWS ===\");\n    vm.prank(alice);\n    vault.redeem(aliceShareAmount, alice, alice);\n\n    console.log(\"\\n=== FINAL STATES ===\");\n    console.log(\"Bob assets: %s\", asset.balanceOf(bob));\n    console.log(\"Alice assets: %s\", asset.balanceOf(alice));\n  }\n```\n\nOutput:\n\n    === INITIAL STATES ===\n      Bob assets: 2000000000000000000000000\n      Alice assets: 2000000000000000000000000\n      \n    === BOB DEPOSITS ===\n      Bob Shares Amount: 1\n      Vault Assets : 1\n\n    === AFTER BOB's TRANSFER ===\n      Bob Shares Amount: 1\n      Vault Assets : 1000000000000000000000001\n      \n    === AFTER ALICE TX ===\n      Alice Shares Amount: 1\n      Vault Assets : 3000000000000000000000001\n      Convertable assets that Bob receives: 1500000000000000000000000\n      Convertable assets that Alice receives: 1500000000000000000000000\n      \n    === BOB WITHDRAWS ===\n      \n    === ALICE WITHDRAWS ===\n      \n    === FINAL STATES ===\n      Bob assets: 2499999999999999999999999\n      Alice assets: 1500000000000000000000001\n\nThis same issue is commonly found in vaults. [Spearbit](https://spearbit.com/) also [reported this](https://github.com/spearbit/portfolio/blob/master/pdfs/MapleV2.pdf) on their Maple V2 audit as the primary high risk issue.\n\n### Recommended Mitigation Steps\n\n*   Require a minimum amount of initial shares (when its supply is zero) to be minted taking into account that:\n    *   The deposit mints an effective (INITIAL_MINT - INITIAL_BURN) amount of shares to the first depositor\n    *   Burns the INITIAL_BURN amount to a dead address.\n\nBoth initial amounts should be set carefully as they partially harm the first depositor. Those amounts should be high enough to reduce the profitability of this attack to the first depositor but not excessively high which could reduce the incentive of being the first depositor.\n\n**[RedVeil (Popcorn) confirmed](https://github.com/code-423n4/2023-01-popcorn-findings/issues/243)** \n\n***\n\n",
      "summary": "\nA bug has been discovered in the vault system where an attacker can abuse the situation and profit off the rounding down operation when calculating the amount of shares if the supply is non-zero. This attack is enabled by the following components: frontrunning, rounding down the amount of shares calculated and regular ERC20 transfers. To prove this concept, the vault charges zero fees to conduct any action. An example is given where Alice wants to deposit 2MM USDT to a vault. Bob frontruns Alice deposit() call with two transactions, one to get 1 share backed by 1 USDT and the other to send 1MM USDT to the underlying vault's adapter. After Alice's deposit transaction is mined, Bob backruns it and redeems his share, getting 1.5MM assets, resulting in a 500k asset profit for Bob and a 500k loss for Alice. This same issue is commonly found in vaults and has been reported on the Maple V2 audit as the primary high risk issue. To mitigate this issue, a minimum amount of initial shares should be minted taking into account that the deposit mints an effective (INITIAL_MINT - INITIAL_BURN) amount of shares to the first depositor and burns the INITIAL_BURN amount to a dead address. The initial amounts should be high enough to reduce the profitability of this attack to the first depositor but not excessively high which could reduce the incentive of being the first depositor.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-01-popcorn",
      "sponsor_name": "Popcorn",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-01-popcorn",
      "github_link": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/243",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "211",
      "slug": "h-10-first-vault-depositor-can-steal-others-assets-code4rena-popcorn-popcorn-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Popcorn",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Popcorn",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        },
        {
          "tags_tag": {
            "title": "Front-Running"
          }
        },
        {
          "tags_tag": {
            "title": "First Depositor Issue"
          }
        }
      ]
    },
    {
      "id": "6296",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "46",
      "title": "H-10: ERC721Pool's take will proceed with truncated collateral amount and full debt when borrower's collateral is fractional",
      "content": "Source: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/68 \n\n## Found by \nhyh\n\n## Summary\n\nCaller of take() can end up paying the debt corresponding to the fractional ERC721 collateral of a borrower, but receiving only truncated part of the this collateral in return (paying the debt for `1.9`, receiving `1.0`), with the borrower keeping the remainder.\n\n## Vulnerability Detail\n\nFractional part of ERC721 collateral is gifted to the borrower in Auctions's _take() (L889-898) when `params_.collateral` doesn't allow an increase. Say when `vars.collateralAmount = params_.collateral = 1.9e18`, while taker specified collateral is `2`, it will proceed with paying the debt corresponding to `1.9e18`, which was calculated before in _calculateTakeFlowsAndBondChange(), but will pay the caller only `1e18` of collateral, leaving `0.9e18` with the borrower at caller's expense.\n\nIt happens only when `params_.collateral = borrower.collateral` isn't whole 18dp integer, the state that can periodically occur after ERC721Pool's bucketTake(), which applies _calculateTakeFlowsAndBondChange() result to the borrower's balance without rounding, so a partial bucketTake() will leave it as a 18dp fraction.\n\n## Impact\n\nCaller's funds will be lost as they pay borrower's debt according to the untruncated `params_.collateral` value, but receive only truncated amount of collateral.\n\nAs both take() and bucketTake() are routine operations and there are no low probability prerequisites, and given the loss of funds for the taker, setting the severity to be high.\n\n## Code Snippet\n\nDebt is calculated off `min(params_.collateral, params_.takeCollateral)`, but if `params_.collateral` is a fraction, say `1.9e18`, the `0.9e18` of collateral is gifted back to the borrower:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L854-L909\n\n```solidity\n    function _take(\n        AuctionsState storage auctions_,\n        TakeParams memory params_\n    ) internal returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n        ...\n\n        vars = _calculateTakeFlowsAndBondChange(\n            Maths.min(params_.collateral, params_.takeCollateral),\n            params_.inflator,\n            params_.collateralScale,\n            vars\n        );\n\n        ...\n\n        if (params_.poolType == uint8(PoolType.ERC721)) {\n            // slither-disable-next-line divide-before-multiply\n            uint256 collateralTaken = (vars.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2\n\n            if (collateralTaken != vars.collateralAmount && params_.collateral >= collateralTaken + 1e18) { // collateral taken not a round number\n                collateralTaken += 1e18; // round up collateral to take\n                // taker should send additional quote tokens to cover difference between collateral needed to be taken and rounded collateral, at auction price\n                // borrower will get quote tokens for the difference between rounded collateral and collateral taken to cover debt\n                vars.excessQuoteToken = Maths.wmul(collateralTaken - vars.collateralAmount, vars.auctionPrice);\n            }\n\n            vars.collateralAmount = collateralTaken;\n        }\n\n        return ...;\n    }\n```\n\n`params_.takeCollateral` is caller specified collateral value, while `params_.collateral` is `borrower.collateral`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L538-L571\n\n```solidity\n    function take(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        uint256 collateral_,\n        uint256 collateralScale_\n    ) external returns (TakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        // revert if borrower's collateral is 0 or if maxCollateral to be taken is 0\n        if (borrower.collateral == 0 || collateral_ == 0) revert InsufficientCollateral();\n\n        (\n            result_.collateralAmount,\n            result_.quoteTokenAmount,\n            result_.t0RepayAmount,\n            borrower.t0Debt,\n            result_.t0DebtPenalty,\n            result_.excessQuoteToken\n        ) = _take(\n            auctions_,\n            TakeParams({\n                borrower:        borrowerAddress_,\n                collateral:      borrower.collateral,\n                t0Debt:          borrower.t0Debt,\n                takeCollateral:  collateral_,\n                inflator:        poolState_.inflator,\n                poolType:        poolState_.poolType,\n                collateralScale: collateralScale_\n            })\n        );\n```\n\nCaller specified `params_.takeCollateral = collateral_` of ERC721Pool's take() is always whole 1e18 integer via `Maths.wad(collateral_)`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L405-L422\n\n```solidity\n    function take(\n        address        borrowerAddress_,\n        uint256        collateral_,\n        address        callee_,\n        bytes calldata data_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        TakeResult memory result = Auctions.take(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            Maths.wad(collateral_),\n            1\n        );\n```\n\nBut `params_.collateral = borrower.collateral` can be fractional as bucketTake() do not round collateral result in the ERC721 case and subtract this result from `borrower.collateral`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L472-L507\n\n```solidity\n    function bucketTake(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_,\n        uint256 collateralScale_\n    ) external returns (BucketTakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0\n\n        (\n            result_.collateralAmount,\n            result_.t0RepayAmount,\n            borrower.t0Debt,\n            result_.t0DebtPenalty \n        ) = _takeBucket(\n            auctions_,\n            buckets_,\n            deposits_,\n            BucketTakeParams({\n                borrower:        borrowerAddress_,\n                collateral:      borrower.collateral,\n                t0Debt:          borrower.t0Debt,\n                inflator:        poolState_.inflator,\n                depositTake:     depositTake_,\n                index:           index_,\n                collateralScale: collateralScale_\n            })\n        );\n\n        borrower.collateral -= result_.collateralAmount;\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOne way is to revert such take attempts:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L887-L899\n\n```solidity\n        if (params_.poolType == uint8(PoolType.ERC721)) {\n            // slither-disable-next-line divide-before-multiply\n            uint256 collateralTaken = (vars.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2\n\n-           if (collateralTaken != vars.collateralAmount && params_.collateral >= collateralTaken + 1e18) { // collateral taken not a round number\n+           if (collateralTaken != vars.collateralAmount) { // collateral taken not a round number\n+               if (params_.collateral >= collateralTaken + 1e18) {\n                    collateralTaken += 1e18; // round up collateral to take\n                    // taker should send additional quote tokens to cover difference between collateral needed to be taken and rounded collateral, at auction price\n                    // borrower will get quote tokens for the difference between rounded collateral and collateral taken to cover debt\n                    vars.excessQuoteToken = Maths.wmul(collateralTaken - vars.collateralAmount, vars.auctionPrice);\n+                   vars.collateralAmount = collateralTaken;\n+               } else {\n+                   revert collateralRoundingIsNeededButNotPossible();        \n+               }\n            }\n\n-           vars.collateralAmount = collateralTaken;\n        }\n```\n\nA drawback is that, while the taker can repeat the call with `1` collateral and succeed with it, the `0.9` part will be untakeable. It looks to be a natural limitation of using ERC721 collaterals. From this point some borrower collateral pooling mechanics can be accessed similar to the existing bucket's fractional collateral pooling logic.\n\nEarly revert when borrower's collateral is less than `1` can be advised if the pool is ERC721:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L538-L552\n\n```solidity\n    function take(\n        ...\n    ) external returns (TakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        // revert if borrower's collateral is 0 or if maxCollateral to be taken is 0\n        if (borrower.collateral == 0 || collateral_ == 0) revert InsufficientCollateral();\n\n```",
      "summary": "\nThis bug report is about an issue in the ERC721Pool's take() function of the Auctions library. The issue is that when the borrower's collateral is fractional, the caller of take() can end up paying the debt corresponding to the fractional ERC721 collateral of the borrower, but receiving only the truncated part of the collateral in return. The remainder of the collateral is kept by the borrower, resulting in the caller losing funds.\n\nThe issue occurs when the `params_.takeCollateral` is a whole 1e18 integer, while the `params_.collateral` is a fraction. This can happen periodically after the ERC721Pool's bucketTake() function, which applies the _calculateTakeFlowsAndBondChange() result to the borrower's balance without rounding.\n\nThe impact of this issue is that the caller's funds will be lost as they pay the borrower's debt according to the untruncated `params_.collateral` value, but receive only the truncated amount of collateral.\n\nA recommendation to fix this issue is to revert such take attempts. Another recommendation is to add an early revert when the borrower's collateral is less than `1` if the pool is ERC721. A drawback is that, while the taker can repeat the call with `1` collateral and succeed with it, the `0.9` part will be untakeable.",
      "report_date": {},
      "contest_prize_txt": "75000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/32",
      "sponsor_name": "Ajna",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-ajna-judging/issues/68",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "32",
      "slug": "h-10-erc721pools-take-will-proceed-with-truncated-collateral-amount-and-full-debt-when-borrowers-collateral-is-fractional-sherlock-ajna-ajna-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Ajna",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Ajna",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "6510",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "50",
      "title": "[H-01] Precision loss in the invariant function can lead to loss of funds",
      "content": "\n[src/core/Pair.sol#L56](https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L56)<br>\n\nAn attacker can steal the funds without affecting the invariant.\n\n### Proof of Concept\n\nWe can say the function `Pair.invariant()` is the heart of the protocol.<br>\nAll the malicious trades should be prevented by this function.\n\n```solidity\nPair.sol\n52:   /// @inheritdoc IPair\n53:   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n54:     if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n55:\n56:     uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;//@audit-info precison loss\n57:     uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;//@audit-info precison loss\n58:\n59:     if (scale1 > 2 * upperBound) revert InvariantError();\n60:\n61:     uint256 a = scale0 * 1e18;\n62:     uint256 b = scale1 * upperBound;\n63:     uint256 c = (scale1 * scale1) / 4;\n64:     uint256 d = upperBound * upperBound;\n65:\n66:     return a + b >= c + d;\n67:   }\n\n```\n\nThe problem is there is a precision loss in the L56 and L57.<br>\nThe precision loss can result in the wrong invariant check result.<br>\nLet's say the `token0` has 6 decimals and liquidity has more than 24 decimals.<br>\nThen the first `FullMath.mulDiv` will cause significant rounding before it's converted to D18.<br>\nTo clarify the difference I wrote a custom function `invariant()` to see the actual value of `a+b-c-d`.\n\n      function invariant(uint256 amount0, uint256 amount1, uint256 liquidity, uint256 token0Scale, uint256 token1Scale) public view returns (uint256 res) {\n        if (liquidity == 0) {\n            require (amount0 == 0 && amount1 == 0);\n            return 0;\n        }\n\n        // uint256 scale0 = FullMath.mulDiv(amount0* token0Scale, 1e18, liquidity) ;\n        // uint256 scale1 = FullMath.mulDiv(amount1* token1Scale, 1e18, liquidity) ;\n        uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n        uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n        if (scale1 > 2 * upperBound) revert();\n\n        uint256 a = scale0 * 1e18;\n        uint256 b = scale1 * upperBound;\n        uint256 c = (scale1 * scale1) / 4;\n        uint256 d = upperBound * upperBound;\n\n        res = a + b - c - d;\n      }\n\n      function testAudit1() external\n      {\n        uint256 x = 1*10**6;\n        uint256 y = 2 * (5 * 10**24 - 10**21);\n        uint256 liquidity = 10**24;\n        uint256 token0Scale=10**12;\n        uint256 token1Scale=1;\n        emit log_named_decimal_uint(\"invariant\", invariant(x, y, liquidity, token0Scale, token1Scale), 36);\n\n        x = 1.5*10**6;\n        emit log_named_decimal_uint(\"invariant\", invariant(x, y, liquidity, token0Scale, token1Scale), 36);\n      }\n\nPut these two functions in the `LiquidityManagerTest.t.sol` and run the case.<br>\nThe result is as below and it shows that while the reserve0 amount changes to 150%, the actual value `a+b-c-d` does not change.\n\n    F:\\SOL\\Code\\Code4rena\\2023-01-numoen>forge test -vv --match-test testAudit1\n    [⠒] Compiling...\n    No files changed, compilation skipped\n\n    Running 1 test for test/LiquidityManagerTest.t.sol:LiquidityManagerTest\n    [PASS] testAudit1() (gas: 10361)\n    Logs:\n      invariant: 0.000000000000000000000000000000000000\n      invariant: 0.000000000000000000000000000000000000\n\n    Test result: ok. 1 passed; 0 failed; finished in 5.74ms\n\nSo what does this mean? We know that if `a+b-c-d` is positive, it means anyone can call `swap()` to withdraw the excess value.<br>\nThe above test shows that the significant change in the token0 reserve amount did not change the value `a+b-c-d`.<br>\nBased on this, I wrote an attack case where dennis pulls 0.5&ast;10&ast;&ast;6 token0 without cost while the invariant stays at zero.<br>\nAlthough the benefit is only 0.5 USDC for this test case, this shows a possibility drawing value without affecting the invariant for pools with low decimals.\n\n```solidity\n  function testAttack() external\n  {\n    // token0 is USDC\n    token0Scale = 6;\n    token1Scale = 18;\n\n    // cuh adds liquidity\n    lendgine = Lendgine(factory.createLendgine(address(token0), address(token1), token0Scale, token1Scale, upperBound));\n\n    uint256 amount0 = 1.5*10**6;\n    uint256 amount1 = 2 * (5 * 10**24 - 10**21);\n    uint256 liquidity = 10**24;\n\n    token0.mint(cuh, amount0);\n    token1.mint(cuh, amount1);\n\n    vm.startPrank(cuh);\n    token0.approve(address(liquidityManager), amount0);\n    token1.approve(address(liquidityManager), amount1);\n\n    liquidityManager.addLiquidity(\n      LiquidityManager.AddLiquidityParams({\n        token0: address(token0),\n        token1: address(token1),\n        token0Exp: token0Scale,\n        token1Exp: token1Scale,\n        upperBound: upperBound,\n        liquidity: liquidity,\n        amount0Min: amount0,\n        amount1Min: amount1,\n        sizeMin: 0,\n        recipient: cuh,\n        deadline: block.timestamp\n      })\n    );\n    vm.stopPrank();\n    showLendgineInfo();\n\n    // dennis starts with zero token\n    assertEq(token0.balanceOf(dennis), 0);\n\n    // dennis pulls 0.5 USDC free\n    lendgine.swap(\n      dennis,\n      5*10**5,\n      0,\n      abi.encode(\n        SwapCallbackData({token0: address(token0), token1: address(token1), amount0: 0, amount1: 0, payer: dennis})\n      )\n    );\n\n    showLendgineInfo();\n\n    // assert\n    assertEq(token0.balanceOf(dennis), 5*10**5);\n  }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nMake sure to multiply first before division to prevent precision loss.\n\n```solidity\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0 * token0Scale, 1e18, liquidity) ;//@audit-info change here\n    uint256 scale1 = FullMath.mulDiv(amount1 * token1Scale, 1e18, liquidity) ;//@audit-info change here\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n```\n\n**[kyscott18 (Numoen) confirmed and commented](https://github.com/code-423n4/2023-01-numoen-findings/issues/264#issuecomment-1423005106):**\n > We agree with the issue and implemented the same fix.\n\n\n\n***\n \n",
      "summary": "\nA bug report has been filed regarding a vulnerability in the code of the 'Pair.sol' file of the '2023-01-numoen' repository on GitHub. The vulnerability is related to the function 'Pair.invariant()', which is intended to prevent malicious trades. The bug is caused by a precision loss in lines 56 and 57, which can result in the wrong invariant check result.\n\nTo demonstrate the difference, a custom function 'invariant()' was written and tested. The test showed that while the reserve0 amount changed by 150%, the actual value 'a+b-c-d' did not change. This means that anyone can call 'swap()' to withdraw the excess value without affecting the invariant for pools with low decimals.\n\nTo mitigate the vulnerability, it is recommended to multiply first before division to prevent precision loss. This can be done by changing lines 56 and 57 of the 'Pair.sol' file.",
      "report_date": {},
      "contest_prize_txt": "$60,500 USDC",
      "contest_link": "https://code4rena.com/contests/2023-01-numoen-contest",
      "sponsor_name": "Numoen",
      "sponsor_link": "https://twitter.com/numoen",
      "quality_score": 4.333333333333333,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2023-01-numoen",
      "github_link": "https://github.com/code-423n4/2023-01-numoen-findings/issues/264",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "207",
      "slug": "h-01-precision-loss-in-the-invariant-function-can-lead-to-loss-of-funds-code4rena-numoen-numoen-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Numoen",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Numoen",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Precision Loss"
          }
        },
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "7021",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "53",
      "title": "Shares distributed to operators suffer from rounding error",
      "content": "## Severity: Medium Risk\n\n## Context: \nRiver.1.sol#L238\n\n## Description: \n*rewardOperators* distribute a portion of the overall shares distributed to operators based on the number of active and funded validators that each operator has.\n\nThe current number of shares distributed to a validator is calculated by the following code:\n\n```solidity\n_mintRawShares(operators[idx].feeRecipient, validatorCounts[idx] * rewardsPerActiveValidator);\n```\n\nwhere *rewardsPerActiveValidator* is calculated as:\n\n```solidity\nuint256 rewardsPerActiveValidator = _reward / totalActiveValidators;\n```\n\nThis means that in reality each operator receives:\n\n*validatorCounts[idx] * (_reward / totalActiveValidators)* shares. Such share calculation suffers from a rounding error caused by division before multiplication.\n\n## Recommendation: \nConsider re-writing the number of shares distributed to each operator:\n\n```solidity\n// removed --- > uint256 rewardsPerActiveValidator = _reward / totalActiveValidators;\nfor (uint256 idx = 0; idx < validatorCounts.length;) {\n    _mintRawShares(\n        operators[idx].feeRecipient,\n        (validatorCounts[idx] * _reward) / totalActiveValidators\n    );\n    ...\n}\n```\n\nNote that this will reduce the rounding error, but it adds 1 DIVgas cost (5 gas) per iteration. Also, the rounding errors favor the users/depositors.\n\n## Alluvial: \nThe whole operator rewarding system has been removed in SPEARBIT/8.\n\n## Spearbit: \nAcknowledged.",
      "summary": "\nA bug has been identified in the River.1.sol#L238 code, which is used to distribute a portion of the overall shares to operators based on the number of active and funded validators. The code calculates the number of shares distributed to a validator by dividing the reward by the total number of active validators, then multiplying it by the validator count. This calculation is subject to a rounding error, which can favor the users/depositors. \n\nThe recommendation is to rewrite the code to reduce the rounding error, but this would add an additional DIVgas cost of 5gas per iteration. Alternatively, the whole operator rewarding system has been removed in SPEARBIT/8. This has been acknowledged.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LiquidCollective-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LiquidCollective-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/LiquidCollective-Spearbit-Security-Review.pdf",
      "pdf_page_from": 24,
      "contest_id": "",
      "slug": "shares-distributed-to-operators-suffer-from-rounding-error-spearbit-liquid-collective-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Liquid Collective",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Liquid Collective",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 67.10914421941607
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "7020",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "53",
      "title": "Avoid multiple divisions when calculating operatorRewards",
      "content": "## Severity: Medium Risk\n\n## Context\nRiver.1.sol#L277\n\n## Description/Recommendation\nIn `_onEarnings`, we calculate the `sharesToMint` and `operatorRewards` by dividing two numbers. We can reduce the number of divisions to one and also delegate this division to `_rewardOperators`. This would further avoid the rounding errors that we get when we divide two numbers in EVM. \n\nHere is the original code:\n\n```solidity\nuint256 globalFee = GlobalFee.get();\nuint256 numerator = _amount * currentTotalSupply * globalFee;\nuint256 denominator = (_assetBalance() * BASE) - (_amount * globalFee);\nuint256 sharesToMint = denominator == 0 ? 0 : (numerator / denominator);\nuint256 operatorRewards = (sharesToMint * OperatorRewardsShare.get()) / BASE;\nuint256 mintedRewards = _rewardOperators(operatorRewards);\n```\n\nInstead of passing `operatorRewards`, we can pass two values: one for the numerator and one for the denominator. This way, we can avoid extra rounding errors introduced in `_rewardOperators`. `_rewardOperators` also needs to be changed slightly to account for these two new values.\n\nHere’s the updated code:\n\n```solidity\nuint256 globalFee = GlobalFee.get();\nuint256 numerator = _amount * currentTotalSupply * globalFee * OperatorRewardsShare.get();\nuint256 denominator = ((_assetBalance() * BASE) - (_amount * globalFee)) * BASE;\nuint256 mintedRewards;\n\nif (denominator != 0) { // note: this was added to avoid calling `_rewardOperators` if `denominator == 0`\n    mintedRewards = _rewardOperators(numerator, denominator);\n}\n```\n\nWithout this correction, the rounding errors are in favor of the general users/stakers and the treasury of the River protocol (not the operators).\n\n## Alluvial\nThe whole operator rewarding system has been removed in SPEARBIT/8.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a medium risk issue that has been identified in the River.1.sol#L277 code. The code has two divisions which can be reduced to one and delegated to the _rewardOperators function. This will help to avoid any rounding errors that may be caused by the division in the EVM. The code needs to be changed slightly to account for the two new values, numerator and denominator, which should be passed to the _rewardOperators function. This will ensure that any rounding errors are in favor of the general users/stakers and the treasury of the River protocol. It should also be noted that the whole operator rewarding system has been removed in SPEARBIT/8.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LiquidCollective-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LiquidCollective-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/LiquidCollective-Spearbit-Security-Review.pdf",
      "pdf_page_from": 24,
      "contest_id": "",
      "slug": "avoid-multiple-divisions-when-calculating-operatorrewards-spearbit-liquid-collective-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Liquid Collective",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Liquid Collective",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 67.10914421941607
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "10416",
      "kind": "MARKDOWN",
      "auditfirm_id": "7",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "73",
      "title": "Rounding up in minting shares",
      "content": "When processing the queued deposits, shares are minted to the receiver in the queue according to the amount of assets deposited. However, the amount of shares minted is always [rounded up](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L392). This means that one can always receive 1 vault share with a 1-wei deposit.\n\n\nAs the vault is expected to be increasing in value from yield rewards, 1 vault share will be worth more than 1 wei asset eventually. A malicious user can spam the deposit queue with 1-wei deposit from many accounts to get 1 share each and then redeem them for more assets when each share is worth more.\n\n\nConsider rounding down when minting vault shares.\n\n\n**Update:** *Fixed in [PR#46](https://github.com/pods-finance/yield-contracts/pull/46), with commit `5ac5e3c` being the last one added.*",
      "summary": "\nA bug report has been identified in the processing of queued deposits in the yield contracts. When processing the queued deposits, shares are minted to the receiver in the queue according to the amount of assets deposited. However, the amount of shares minted is always rounded up. This means that one can always receive 1 vault share with a 1-wei deposit.\n\nThis poses a security risk as a malicious user can spam the deposit queue with 1-wei deposit from many accounts to get 1 share each and then redeem them for more assets when each share is worth more. To address the issue, it has been suggested that the vault shares should be rounded down when minting.\n\nThe bug has been fixed in Pull Request #46, with the last commit being 5ac5e3c.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1/",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "rounding-up-in-minting-shares-openzeppelin-pods-finance-ethereum-volatility-vault-audit-1-markdown",
      "firm_name": "OpenZeppelin",
      "firm_logo_square": "openzeppelin_square.png",
      "protocol_name": "Pods Finance Ethereum Volatility Vault Audit #1",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "OpenZeppelin",
        "logo_square": "openzeppelin_square.png"
      },
      "protocols_protocol": {
        "name": "Pods Finance Ethereum Volatility Vault Audit #1",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "6101",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 19,
      "protocol_id": "76",
      "title": "[M-03] Rounding error in `buyQuote` might result in free tokens",
      "content": "\nIn order to guarantee the contract does not become insolvent, incoming assets should be rounded up, while outgoing assets should be rounded down.\n\nThe function `buyQuote()` calculates the amount of base tokens required to buy a given amount of fractional tokens. However, this function rounds down the required amount, which is in favor of the buyer (i.e. he/she has to provide less base tokens for the amount of receiving fractional tokens.\n\nDepending on the amount of current token reserves and the amount of fractional tokens the user wishes to buy, it might be possible to receive free fractional tokens.\n\nAssume the following reserve state:\n\n*   base token reserve: 0,1 WBTC (=`1e7`)\n*   fractional token reserve: 10.000.000 (=`1e25`)\n\nThe user wishes to buy 0,9 fractional tokens (=`9e17`). Then, the function `buyQuote()` will calculate the amount of base tokens as follows:\n\n`(9e17 * 1000 * 1e7) / ((1e25 - 9e17) * 997) = 0,903`\n\nAs division in Solidity will round down, the amount results in `0` amount of base tokens required (WBTC) to buy 0,9 fractional tokens.\n\n### Impact\n\nUsing the example above, 0,9 fractional tokens is a really small amount (`0,1 BTC / 1e7 = +- $0,00017`). Moreover, if the user keeps repeating this attack, the fractional token reserve becomes smaller, which will result in a buyQuote amount of >1, after which the tokens will not be free anymore.\n\nAdditionally, as the contract incorporates a fee of 30bps, it will likely not be insolvent. The downside would be the LP holder, which will receive a fee of less than 30bps. Hence, the impact is rated as medium.\n\n### Recommended Mitigation Steps\n\nFor incoming assets, it’s recommended to round up the required amount. We could use solmate’s `FixedPointMathLib` library to calculate the quote and round up. This way the required amount will always at least be 1 wei:\n\n```solidity\nfunction buyQuote(uint256 outputAmount) public view returns (uint256) {\n  return mulDivUp(outputAmount * 1000, baseTokenReserves(), (fractionalTokenReserves() - outputAmount) * 997);\n}\n```\n\n**[outdoteth (Caviar) confirmed and commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/243#issuecomment-1373918925):**\n > Fixed in: https://github.com/outdoteth/caviar/pull/4\n> \n> Uses muldivup from solmate to round up the calculation in buyQuote.\n\n\n\n***\n\n",
      "summary": "\nThis bug report details a vulnerability in the code of the contract Pair.sol, which is hosted on GitHub. The function `buyQuote()` calculates the amount of base tokens required to buy a given amount of fractional tokens, but it rounds down the required amount, which is in favor of the buyer. Depending on the amount of current token reserves and the amount of fractional tokens the user wishes to buy, it might be possible to receive free fractional tokens.\n\nThe impact of this vulnerability is rated as medium, as the fractional token reserve can become smaller, and the LP holder will receive a fee of less than 30bps. \n\nThe recommended mitigation step is to round up the required amount of incoming assets, and use the `FixedPointMathLib` library to calculate the quote and round up. This way, the required amount will always be at least 1 wei.",
      "report_date": {},
      "contest_prize_txt": "$36,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-12-caviar-contest",
      "sponsor_name": "Caviar",
      "sponsor_link": "https://twitter.com/caviarAMM",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/243",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "193",
      "slug": "m-03-rounding-error-in-buyquote-might-result-in-free-tokens-code4rena-caviar-caviar-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Caviar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Caviar",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "6035",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "97",
      "title": "[H-04] User's Accrued Rewards Will Be Lost",
      "content": "\nIf the user deposits too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Subsequently, their accrued rewards will be cleared out (set to zero), and they will lose their rewards.\n\nThe amount of reward tokens that are claimable by a user is computed in Line 403 of the `PirexRewards.claim` function.\n\nIf the balance of pxGMX of a user is too small compared to other users (or total supply of pxGMX), the code below will always return zero due to rounding issues within solidity.\n\n```solidity\nuint256 amount = (rewardState * userRewards) / globalRewards;\n```\n\nSince the user's accrued rewards is cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), the user's accrued rewards will be lost.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373>\n\n```solidity\nFile: PirexRewards.sol\n368:     /**\n369:         @notice Claim rewards\n370:         @param  producerToken  ERC20    Producer token contract\n371:         @param  user           address  User\n372:     */\n373:     function claim(ERC20 producerToken, address user) external {\n374:         if (address(producerToken) == address(0)) revert ZeroAddress();\n375:         if (user == address(0)) revert ZeroAddress();\n376: \n377:         harvest();\n378:         userAccrue(producerToken, user);\n379: \n380:         ProducerToken storage p = producerTokens[producerToken];\n381:         uint256 globalRewards = p.globalState.rewards;\n382:         uint256 userRewards = p.userStates[user].rewards;\n383: \n384:         // Claim should be skipped and not reverted on zero global/user reward\n385:         if (globalRewards != 0 && userRewards != 0) {\n386:             ERC20[] memory rewardTokens = p.rewardTokens;\n387:             uint256 rLen = rewardTokens.length;\n388: \n389:             // Update global and user reward states to reflect the claim\n390:             p.globalState.rewards = globalRewards - userRewards;\n391:             p.userStates[user].rewards = 0;\n392: \n393:             emit Claim(producerToken, user);\n394: \n395:             // Transfer the proportionate reward token amounts to the recipient\n396:             for (uint256 i; i < rLen; ++i) {\n397:                 ERC20 rewardToken = rewardTokens[i];\n398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken];\n399:                 address recipient = rewardRecipient != address(0)\n400:                     ? rewardRecipient\n401:                     : user;\n402:                 uint256 rewardState = p.rewardStates[rewardToken];\n403:                 uint256 amount = (rewardState * userRewards) / globalRewards;\n404: \n405:                 if (amount != 0) {\n406:                     // Update reward state (i.e. amount) to reflect reward tokens transferred out\n407:                     p.rewardStates[rewardToken] = rewardState - amount;\n408: \n409:                     producer.claimUserReward(\n410:                         address(rewardToken),\n411:                         amount,\n412:                         recipient\n413:                     );\n414:                 }\n415:             }\n416:         }\n417:     }\n```\n\nThe graph below represents the amount of GMX tokens Alice and Bob staked in `PirexGmx` for each second during the period. Note that the graph is not drawn proportionally.\n\nGreen = Number of GMX tokens staked by Alice\n\nBlue = Number of GMX tokens staked by Bob\n\n![](https://user-images.githubusercontent.com/102820284/204132852-f76c8959-5040-46bf-9529-edd0d4a98e41.png)\n\nBased on the above graph:\n\n*   Alice staked 1 GMX token for 4 seconds (From T80 to T85)\n*   Bob staked 99999 GMX tokens for 4 seconds (From T80 to T85)\n\nAssume that the emission rate is 0.1 esGMX per 1 GMX staked per second.\n\nIn this case, the state variable will be as follows at the end of T83, assuming both the global and all user states have been updated and rewards have been harvested.\n\n*   rewardState = 60,000 esGMX tokens (600,000 \\* 0.1)\n*   globalRewards = 600,000 (100,000 \\* 6)\n*   Accrued `userRewards` of Alice = 6\n*   Accrued `userRewards` of Bob = 599,994 (99,999 \\* 6)\n\nFollowing is the description of `rewardState` for reference:\n\n> The `rewardState` represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).\n>\n> The `rewardState` of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. `PirexRewards.harvest` is called). On the other hand, the `rewardState` will decrease if the users claim the rewards.\n\nAt the end of T85, Alice should be entitled to 1.2 esGMX tokens (0.2/sec \\* 6).\n\nFollowing is the formula used in the `PirexRewards` contract to compute the number of reward tokens a user is entitled to.\n\n```solidity\namount = (rewardState * userRewards) / globalRewards;\n```\n\nIf Alice claims the rewards at the end of T85, she will get zero esGMX tokens instead of 1.2 esGMX tokens.\n\n```solidity\namount = (rewardState * userRewards) / globalRewards;\n60,000 * 6 / 600,000\n360,000/600,000 = 0.6 = 0\n```\n\nSince Alice's accrued rewards are cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), Alice's accrued rewards will be lost. Alice will have to start accruing the rewards from zero after calling the `PirexRewards.claim` function.\n\nAnother side effect is that since the 1.2 esGMX tokens that belong to Alice are still in the contract, they will be claimed by other users.\n\n### Impact\n\nUsers who deposit too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Also, their accrued rewards will be cleared out (set to zero). Loss of reward tokens for the users.\n\nAdditionally, the `PirexRewards.claim` function is permissionless, and anyone can trigger the claim on behalf of any user. A malicious user could call the `PirexRewards.claim` function on behalf of a victim at the right time when the victim's accrued reward is small enough to cause a rounding error or precision loss, thus causing the victim accrued reward to be cleared out (set to zero).\n\n### Recommended Mitigation Steps\n\nFollowing are some of the possible remediation actions:\n\n#### 1. Use ` RewardPerToken  ` approach\n\nAvoid calculating the rewards that the users are entitled based on the ratio of `userRewards` and `globalRewards`.\n\nInstead, consider implementing the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which are not vulnerable to this issue:\n\n*   <https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226>\n*   <https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61>\n\n#### 2. Fallback logic if`amount ==  0`\n\nIf the `amount` is zero, revert the transaction. Alternatively, if the `amount` is zero, do not clear out the user's accrued reward state variable since the user did not receive anything yet.\n\n```diff\nfunction claim(ERC20 producerToken, address user) external {\n..SNIP..\n\t\t\tuint256 amount = (rewardState * userRewards) / globalRewards;\n\n\t\t\tif (amount != 0) {\n\t\t\t\t// Update reward state (i.e. amount) to reflect reward tokens transferred out\n\t\t\t\tp.rewardStates[rewardToken] = rewardState - amount;\n\n\t\t\t\tproducer.claimUserReward(\n\t\t\t\t\taddress(rewardToken),\n\t\t\t\t\tamount,\n\t\t\t\t\trecipient\n\t\t\t\t);\n-\t\t\t}\n+\t\t\t} else {\n+\t\t\t\trevert ZeroRewardTokens();\n+\t\t\t}\n..SNIP..\n}\n```\n\n**[kphed (Redacted Cartel) confirmed](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/184)** \n\n\n***\n\n",
      "summary": "\nA bug report has been made for the PirexRewards smart contract, which is used to distribute rewards to users. If the user deposits too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Subsequently, their accrued rewards will be cleared out (set to zero), and they will lose their rewards.\n\nThe amount of reward tokens that are claimable by a user is computed in Line 403 of the `PirexRewards.claim` function. If the balance of pxGMX of a user is too small compared to other users (or total supply of pxGMX), the code below will always return zero due to rounding issues within solidity.\n\n```solidity\nuint256 amount = (rewardState * userRewards) / globalRewards;\n```\n\nSince the user's accrued rewards is cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), the user's accrued rewards will be lost. The graph below represents the amount of GMX tokens Alice and Bob staked in `PirexGmx` for each second during the period. Note that the graph is not drawn proportionally.\n\nThe impact of this bug is that users who deposit too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Also, their accrued rewards will be cleared out (set to zero). Loss of reward tokens for the users. Additionally, the `PirexRewards.claim` function is permissionless, and anyone can trigger the claim on behalf of any user. A malicious user could call the `PirexRewards.claim` function on behalf of a victim at the right time when the victim's accrued reward is small enough to cause a rounding error or precision loss, thus causing the victim accrued reward to be cleared out (set to zero).\n\nRecommended mitigation steps include using the RewardPerToken approach, which avoids calculating the rewards that the users are entitled based on the ratio of `userRewards` and `globalRewards`, and implementing a fallback logic if `amount ==  0",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
      "sponsor_name": "Redacted Cartel",
      "sponsor_link": "https://twitter.com/redactedcartel",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-11-redactedcartel",
      "github_link": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/184",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "183",
      "slug": "h-04-users-accrued-rewards-will-be-lost-code4rena-redacted-cartel-redacted-cartel-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Redacted Cartel",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Redacted Cartel",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "6034",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 14,
      "protocol_id": "97",
      "title": "[H-03] Malicious Users Can Drain The Assets Of Auto Compound Vault",
      "content": "\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L156>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315>\n\n### Proof of Concept\n\n> Note: This issue affects both the AutoPxGmx and AutoPxGlp vaults. Since the root cause is the same, the PoC of AutoPxGlp vault is omitted for brevity.\n\nThe `PirexERC4626.convertToShares` function relies on the `mulDivDown` function in Line 164 when calculating the number of shares needed in exchange for a certain number of assets. Note that the computation is rounded down, therefore, if the result is less than 1 (e.g. 0.9), Solidity will round them down to zero. Thus, it is possible that this function will return zero.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L156>\n\n```solidity\nFile: PirexERC4626.sol\n156:     function convertToShares(uint256 assets)\n157:         public\n158:         view\n159:         virtual\n160:         returns (uint256)\n161:     {\n162:         uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n163: \n164:         return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n165:     }\n```\n\nThe `AutoPxGmx.previewWithdraw` function relies on the `PirexERC4626.convertToShares` function in Line 206. Thus, this function will also \"round down\".\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199>\n\n```solidity\nFile: AutoPxGmx.sol\n199:     function previewWithdraw(uint256 assets)\n200:         public\n201:         view\n202:         override\n203:         returns (uint256)\n204:     {\n205:         // Calculate shares based on the specified assets' proportion of the pool\n206:         uint256 shares = convertToShares(assets);\n207: \n208:         // Save 1 SLOAD\n209:         uint256 _totalSupply = totalSupply;\n210: \n211:         // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n212:         return\n213:             (_totalSupply == 0 || _totalSupply - shares == 0)\n214:                 ? shares\n215:                 : (shares * FEE_DENOMINATOR) /\n216:                     (FEE_DENOMINATOR - withdrawalPenalty);\n217:     }\n```\n\nThe `AutoPxGmx.withdraw` function relies on the `AutoPxGmx.previewWithdraw` function. In certain conditions, the `AutoPxGmx.previewWithdraw` function in Line 323 will return zero if the withdrawal amount causes the division within the `PirexERC4626.convertToShares` function to round down to zero (usually due to a small amount of withdrawal amount).\n\nIf the `AutoPxGmx.previewWithdraw` function in Line 323 returns zero, no shares will be burned at Line 332. Subsequently, in Line 336, the contract will transfer the assets to the users. As a result, the users receive the assets without burning any of their shares, effectively allowing them to receive assets for free.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315>\n\n```solidity\nFile: AutoPxGmx.sol\n315:     function withdraw(\n316:         uint256 assets,\n317:         address receiver,\n318:         address owner\n319:     ) public override returns (uint256 shares) {\n320:         // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n321:         compound(poolFee, 1, 0, true);\n322:         \n323:         shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n324: \n325:         if (msg.sender != owner) {\n326:             uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n327: \n328:             if (allowed != type(uint256).max)\n329:                 allowance[owner][msg.sender] = allowed - shares;\n330:         }\n331: \n332:         _burn(owner, shares);\n333: \n334:         emit Withdraw(msg.sender, receiver, owner, assets, shares);\n335: \n336:         asset.safeTransfer(receiver, assets);\n337:     }\n```\n\nAssume that the vault with the following state:\n\n*   Total Asset = 1000 WETH\n*   Total Supply = 10 shares\n\nAssume that Alice wants to withdraw 99 WETH from the vault. Thus, she calls the `AutoPxGmx.withdraw(99 WETH)` function.\n\nThe `PirexERC4626.convertToShares` function will compute the number of shares that Alice needs to burn in exchange for 99 WETH.\n\n```solidity\nassets.mulDivDown(supply, totalAssets())\n99WETH.mulDivDown(10 shares, 1000WETH)\n(99 * 10) / 1000\n990 / 1000 = 0.99 = 0\n```\n\nHowever, since Solidity rounds `0.99` down to `0`, Alice does not need to burn a single share. She will receive 99 WETH for free.\n\n### Impact\n\nMalicious users can withdraw the assets from the vault for free, effectively allowing them to drain the assets of the vault.\n\n### Recommended Mitigation Steps\n\nEnsure that at least 1 share is burned when the users withdraw their assets.\n\nThis can be mitigated by updating the `previewWithdraw` function to round up instead of round down when computing the number of shares to be burned.\n\n```diff\nfunction previewWithdraw(uint256 assets)\n\tpublic\n\tview\n\toverride\n\treturns (uint256)\n{\n\t// Calculate shares based on the specified assets' proportion of the pool\n-\tuint256 shares = convertToShares(assets);\n+\tuint256 shares = supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n\t\n\t// Save 1 SLOAD\n\tuint256 _totalSupply = totalSupply;\n\n\t// Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n\treturn\n\t\t(_totalSupply == 0 || _totalSupply - shares == 0)\n\t\t\t? shares\n\t\t\t: (shares * FEE_DENOMINATOR) /\n\t\t\t\t(FEE_DENOMINATOR - withdrawalPenalty);\n}\n```\n\n**[kphed (Redacted Cartel) confirmed](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/264)** \n\n***\n\n",
      "summary": "\nA bug has been discovered in the code of the AutoPxGmx and AutoPxGlp vaults. The bug allows malicious users to withdraw assets from the vault without burning any of their shares, effectively allowing them to receive assets for free. \n\nThe bug is caused by the `PirexERC4626.convertToShares` function in Line 164, which relies on the `mulDivDown` function. The computation is rounded down, so if the result is less than 1 (e.g. 0.9), Solidity will round them down to zero. \n\nThe `AutoPxGmx.previewWithdraw` function in Line 206 relies on the `PirexERC4626.convertToShares` function. Thus, this function will also \"round down\". \n\nThe `AutoPxGmx.withdraw` function relies on the `AutoPxGmx.previewWithdraw` function. In certain conditions, the `AutoPxGmx.previewWithdraw` function in Line 323 will return zero if the withdrawal amount causes the division within the `PirexERC4626.convertToShares` function to round down to zero. If the `AutoPxGmx.previewWithdraw` function in Line 323 returns zero, no shares will be burned at Line 332. Subsequently, in Line 336, the contract will transfer the assets to the users. As a result, the users receive the assets without burning any of their shares, effectively allowing them to receive assets for free. \n\nThe bug can be mitigated by updating the `previewWithdraw` function to round up instead of round down when computing the number of shares to be burned.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
      "sponsor_name": "Redacted Cartel",
      "sponsor_link": "https://twitter.com/redactedcartel",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-11-redactedcartel",
      "github_link": "https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/178",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "183",
      "slug": "h-03-malicious-users-can-drain-the-assets-of-auto-compound-vault-code4rena-redacted-cartel-redacted-cartel-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Redacted Cartel",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Redacted Cartel",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "3536",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "102",
      "title": "M-12: Debt Decay Faster Than Expected",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/12 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe debt decay at a rate faster than expected, causing market makers to sell bond tokens at a lower price than expected.  \n\n## Vulnerability Detail\n\nThe following definition of the debt decay reference time following any purchases at time `t` taken from the whitepaper. The second variable, which is the delay increment, is rounded up. Following is taken from Page 15 of the whitepaper - Definition 27\n\n![image-20221114170852736](https://user-images.githubusercontent.com/102820284/201844416-023c6d4f-893d-40ab-b6cb-6e33402d8e78.png)\n\nHowever, the actual implementation in the codebase differs from the specification. At Line 514, the delay increment is rounded down instead.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L514\n\n```solidity\nFile: BondBaseSDA.sol\n513:         // Set last decay timestamp based on size of purchase to linearize decay\n514:         uint256 lastDecayIncrement = debtDecayInterval.mulDiv(payout_, lastTuneDebt);\n515:         metadata[id_].lastDecay += uint48(lastDecayIncrement);\n```\n\n## Impact\n\nWhen the delay increment (TD) is rounded down, the debt decay reference time increment will be smaller than expected. The debt component will then decay at a faster rate. As a result, the market price will not be adjusted in an optimized manner, and the market price will fall faster than expected, causing market makers to sell bond tokens at a lower price than expected.\n\nFollowing is taken from Page 8 of the whitepaper - Definition 8\n\n![image-20221114173425259](https://user-images.githubusercontent.com/102820284/201844554-bdb7c975-ec4c-417f-a83e-56430300bd6e.png)\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L514\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen computing the `lastDecayIncrement`, the result should be rounded up.\n\n```diff\n// Set last decay timestamp based on size of purchase to linearize decay\n- uint256 lastDecayIncrement = debtDecayInterval.mulDiv(payout_, lastTuneDebt);\n+ uint256 lastDecayIncrement = debtDecayInterval.mulDivUp(payout_, lastTuneDebt);\nmetadata[id_].lastDecay += uint48(lastDecayIncrement);\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree that the rounding should be to match the specification. This was inadvertently changed when another change was implemented. Good catch.\n\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/071d2a450779dd3413224831934727dcb77e3045",
      "summary": "\nThis bug report is about an issue M-12, which was found by xiaoming90 and is related to debt decay. The debt decay is faster than expected, causing market makers to sell bond tokens at a lower price than expected. The issue was found in the whitepaper, which stated that the delay increment should be rounded up, but the actual implementation in the codebase rounds it down instead. This causes the debt component to decay at a faster rate, resulting in the market price falling faster than expected. The code snippet for this issue can be found at the BondBaseSDA.sol file at Line 514.\n\nThe bug was identified through manual review and the recommendation was to round up the delay increment when computing the lastDecayIncrement. This was fixed in the Bond-Protocol/bonds repository in the commit 071d2a450779dd3413224831934727dcb77e3045. The issue was acknowledged by the sponsor who agreed that the rounding should be to match the specification.",
      "report_date": {},
      "contest_prize_txt": "33333 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/20",
      "sponsor_name": "Bond",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 2,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/12",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "20",
      "slug": "m-12-debt-decay-faster-than-expected-sherlock-bond-bond-protocol-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Bond Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Bond Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA Lending"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "3531",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "102",
      "title": "M-7: Market Price Lower Than Expected",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/20 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe market price does not conform to the specification documented within the whitepaper. As a result, the computed market price is lower than expected.\n\n## Vulnerability Detail\n\nThe following definition of the market price is taken from the whitepaper. Taken from Page 13 of the whitepaper - Definition 25\n\n![image-20221114132609169](https://user-images.githubusercontent.com/102820284/201850739-496a5e30-bb92-40e3-acfc-6d46821a4eab.png)\n\nThe integer implementation of the market price must be rounded up per the whitepaper. This ensures that the integer implementation of the market price is greater than or equal to the real value of the market price so as to protect makers from selling tokens at a lower price than expected.\n\nWithin the `BondBaseSDA.marketPrice` function, the computation of the market price is rounded up in Line 688, which conforms to the specification.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L687\n\n```solidity\nFile: BondBaseSDA.sol\n687:     function marketPrice(uint256 id_) public view override returns (uint256) {\n688:         uint256 price = currentControlVariable(id_).mulDivUp(currentDebt(id_), markets[id_].scale);\n689: \n690:         return (price > markets[id_].minPrice) ? price : markets[id_].minPrice;\n691:     }\n```\n\nHowever, within the `BondBaseSDA._currentMarketPrice` function, the market price is rounded down, resulting in the makers selling tokens at a lower price than expected.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L631\n\n```solidity\nFile: BondBaseSDA.sol\n631:     function _currentMarketPrice(uint256 id_) internal view returns (uint256) {\n632:         BondMarket memory market = markets[id_];\n633:         return terms[id_].controlVariable.mulDiv(market.totalDebt, market.scale);\n634:     }\n```\n\n## Impact\n\nLoss for the makers as their tokens are sold at a lower price than expected.\n\nAdditionally, the affected `BondBaseSDA._currentMarketPrice` function is used within the `BondBaseSDA._decayAndGetPrice` function to derive the market price. Since a lower market price will be returned, this will lead to a higher amount of payout tokens. Subsequently, the `lastDecayIncrement` will be higher than expected, which will lead to a lower `totalDebt`. Lower debt means a lower market price will be computed later.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L687\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L631\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure the market price is rounded up so that the desired property can be achieved and the makers will not be selling tokens at a lower price than expected.\n\n```diff\nfunction _currentMarketPrice(uint256 id_) internal view returns (uint256) {\n    BondMarket memory market = markets[id_];\n-   return terms[id_].controlVariable.mulDiv(market.totalDebt, market.scale);\n+   return terms[id_].controlVariable.mulDivUp(market.totalDebt, market.scale);\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this issue. We have updated the price calculation in `_currentMarketPrice()` to round up to match the specification.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/a77f0150dd4bf401a1b30c16eca4865bb69c59d3",
      "summary": "\nThis bug report is about an issue where the market price of a bond does not conform to the specification documented in the whitepaper. The integer implementation of the market price must be rounded up to ensure that the makers are not selling tokens at a lower price than expected. The bug was found by xiaoming90 and the impact of the bug is a loss for the makers. The code snippet of the bug is provided and the recommendation is to ensure that the market price is rounded up. The issue was fixed by the sponsor and xiaoming9090.",
      "report_date": {},
      "contest_prize_txt": "33333 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/20",
      "sponsor_name": "Bond",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/20",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "20",
      "slug": "m-7-market-price-lower-than-expected-sherlock-bond-bond-protocol-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Bond Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Bond Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA Lending"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "3517",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 10,
      "protocol_id": "104",
      "title": "M-5: Early depositors to DnGmxSeniorVault can manipulate exchange rates to steal funds from later depositors",
      "content": "Source: https://github.com/sherlock-audit/2022-10-rage-trade-judging/issues/37 \n\n## Found by \nrvierdiiev, tives, peanuts, joestakey, cccz, ctf\\_sec, \\_\\_141345\\_\\_, 0x52, GimelSec, clems4ever\n\n## Summary\n\nTo calculate the exchange rate for shares in DnGmxSeniorVault it divides the total supply of shares by the totalAssets of the vault. The first deposit can mint a very small number of shares then donate aUSDC to the vault to grossly manipulate the share price. When later depositor deposit into the vault they will lose value due to precision loss and the adversary will profit.\n\n## Vulnerability Detail\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\nShare exchange rate is calculated using the total supply of shares and the totalAsset. This can lead to exchange rate manipulation. As an example, an adversary can mint a single share, then donate 1e8 aUSDC. Minting the first share established a 1:1 ratio but then donating 1e8 changed the ratio to 1:1e8. Now any deposit lower than 1e8 (100 aUSDC) will suffer from precision loss and the attackers share will benefit from it.\n\nThis same vector is present in DnGmxJuniorVault.\n\n## Impact\n\nAdversary can effectively steal funds from later users\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-rage-trade/blob/main/dn-gmx-vaults/contracts/vaults/DnGmxSeniorVault.sol#L211-L221\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInitialize should include a small deposit, such as 1e6 aUSDC that mints the share to a dead address to permanently lock the exchange rate:\n\n        aUsdc.approve(address(pool), type(uint256).max);\n        IERC20(asset).approve(address(pool), type(uint256).max);\n\n    +   deposit(1e6, DEAD_ADDRESS);\n\n## Discussion\n\n**0xDosa**\n\nWe will ensure a guarded launch process that safeguards the first deposit to avoid being manipulated.\n\n**Evert0x**\n\nWe are still considering it a valid issue as the guarded launch process is out of scope.",
      "summary": "\nA bug has been identified in the code for DnGmxSeniorVault that could allow an early depositor to manipulate exchange rates to steal funds from later depositors. This is because the exchange rate for shares is calculated using the total supply of shares and the totalAsset. If the first deposit is a very small number of shares then an adversary can donate aUSDC to the vault to grossly manipulate the share price, resulting in later depositors losing value due to precision loss while the adversary profits. The same issue is present in DnGmxJuniorVault. In order to protect against this, a guarded launch process should be implemented that safeguards the first deposit and prevents it from being manipulated. This will ensure that later depositors are not adversely affected.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/16",
      "sponsor_name": "Rage Trade",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-rage-trade-judging/issues/37",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "16",
      "slug": "m-5-early-depositors-to-dngmxseniorvault-can-manipulate-exchange-rates-to-steal-funds-from-later-depositors-sherlock-rage-trade-rage-trade-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Rage Trade",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Rage Trade",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        },
        {
          "tags_tag": {
            "title": "First Depositor Issue"
          }
        }
      ]
    },
    {
      "id": "3563",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "109",
      "title": "M-5: Math rounding in AutoRoller.sol is not ERC4626-complicant: previewWithdraw should round up.",
      "content": "Source: https://github.com/sherlock-audit/2022-11-sense-judging/issues/30 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nMath rounding in AutoRoller.sol is not ERC4626-complicant: previewWithdraw should round up.\n\n## Vulnerability Detail\n\nPer EIP 4626's Security Considerations (https://eips.ethereum.org/EIPS/eip-4626)\n\n> Finally, ERC-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users:\n\n> If (1) it’s calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) it’s determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round down.\nIf (1) it’s calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) it’s calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round up.\n\nThen previewWithdraw in AutoRoller.sol should round up.\n\nThe original implementation for previewWithdraw in Solmate ERC4626 is:\n\n```solidity\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n```\n\nIt is rounding up, however in the implementation of the AutoRoller.sol#previewWith is not round up.\n\n```solidity\nfor (uint256 i = 0; i < 20;) { // 20 chosen as a safe bound for convergence from practical trials.\n    if (guess > supply) {\n        guess = supply;\n    }\n\n    int256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n\n    if (answer >= 0 && answer <= assets.mulWadDown(0.001e18).safeCastToInt() || (prevAnswer == answer)) { // Err on the side of overestimating shares needed. Could reduce precision for gas efficiency.\n        break;\n    }\n\n    if (guess == supply && answer < 0) revert InsufficientLiquidity();\n\n    int256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n    prevGuess  = guess;\n    prevAnswer = answer;\n    guess      = nextGuess;\n\n    unchecked { ++i; }\n}\n\nreturn guess.safeCastToUint() + maxError; // Buffer for pow discrepancies.\n```\n\nnote the line:\n\n```solidity\n  int256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n```\n\npreviewRedeem is round down.\n\nand later we update guess and return guess\n\n```solidity\n    int256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n    prevGuess  = guess;\n    prevAnswer = answer;\n    guess      = nextGuess;\n```\n\nand\n\n```solidity\n return guess.safeCastToUint() + maxError; // Buffer for pow discrepancies.\n```\n\nwhen calculating the the nextGuess, the code does not round up.\n\n```solidity\nint256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n```\n\n## Impact\n\nOther protocols that integrate with Sense finance AutoRoller.sol might wrongly assume that the functions handle rounding as per ERC4626 expectation. Thus, it might cause some intergration problem in the future that can lead to wide range of issues for both parties.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/AutoRoller.sol#L528-L567\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRound up in previewWithdraw using mulDivUp and divWadUp\n\n## Discussion\n\n**jparklev**\n\nOur understanding is that `nextGuess` does not need to be rounded up since it's just a \"guess\" that is confirmed or denied in how close the \"answer\" is to what we're looking for. So the rounding needs to be in the answer assessment stage.\n\nIn addition, as our comment in the answer inequality says, we do overestimate the shares needed, which is equivalent to rounding up. Perhaps one could make the case that the inequality should be `> 0` rather than `>= 0` so that exact matches from the rounded down `previewRedeem` don't make it through\n\nGiven the above, we're ok accepting this issue, but disagree with the severity\n\n**jparklev**\n\nFix: https://github.com/sense-finance/auto-roller/pull/22\n\n**Evert0x**\n\n@jparklev What severity are you suggesting?\n\n**jparklev**\n\n> @jparklev What severity are you suggesting?\n\n`medium` would be our suggestion\n\n**aktech297**\n\nVerified the fix. As @jparklev mentioned, `rounding needs to be in the answer assessment stage`, the fix is not related to rounding up. It is related to inequality. so, the fix is to check for `> 0` rather than `>= 0` so that exact matches from the rounded down `previewRedeem` don't make it through.",
      "summary": "\nThis bug report is about an issue found in the AutoRoller.sol of the Sense Finance project. The issue is that the math rounding implemented in the previewWithdraw function is not compliant with ERC4626. According to the Ethereum Improvement Proposal (EIP) 4626, when calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide, or when determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round down. However, when calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens, or when calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round up.\n\nThe bug was found by ctf\\_sec and the code snippet can be found at https://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/AutoRoller.sol#L528-L567. The impact of this bug is that other protocols that integrate with Sense finance AutoRoller.sol might wrongly assume that the functions handle rounding as per ERC4626 expectation, which can lead to a wide range of issues for both parties.\n\nThe recommendation is to round up in previewWithdraw using mulDivUp and divWadUp. The fix was implemented and verified and can be found at https://github.com/sense-finance/auto-roller/pull/22. The severity of the issue was suggested to be medium.",
      "report_date": {},
      "contest_prize_txt": "25333 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/19",
      "sponsor_name": "Sense",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-sense-judging/issues/30",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "19",
      "slug": "m-5-math-rounding-in-autorollersol-is-not-erc4626-complicant-previewwithdraw-should-round-up-sherlock-sense-sense-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sense",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sense",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "5820",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "116",
      "title": "[H-01] Bidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance.",
      "content": "\nBidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance.\n\nThe main flaw is the seller might receive more quote tokens than the bidders offer after the auction was finalized.\n\nIf there is no other auctions to use the same quote token, the last bidder will fail to withdraw his funds because the contract doesn't have enough balance of quote token.\n\n### Proof of Concept\n\nAfter the auction was finalized, the seller receives the `filledQuote` amount of quote token using [data.filledBase](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L325).\n\n```solidity\n    // Calculate quote amount based on clearing price\n    uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);\n```\n\nBut when the bidders withdraw the funds using `withdraw()`, they offer the quote token [using this formula](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L375-L382).\n\n```solidity\n    // Refund unfilled quoteAmount on first withdraw\n    if (b.quoteAmount != 0) {\n        uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);\n        uint256 refundedQuote = b.quoteAmount - quoteBought;\n        b.quoteAmount = 0;\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);\n    }\n```\n\nEven if they use the same clearing price, the total amount of quote token that the bidders offer might be less than the amount that the seller charged during finalization because the round down would happen several times with the bidders.\n\nThis is the test to show the scenario.\n\n```solidity\n    function testAuditBidderMoneyLock() public {\n        // in this scenario, we show that bidder's money can be locked due to inaccurate calculation of claimed quote tokens for a seller\n        uint128 K = 1 ether;\n        baseToSell = 4*K;\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n\n        bidder1.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(3*K, 3*K+2, \"Honest bidder\");\n        bidder2.setAuctionId(aid);\n        bidder2.bidOnAuctionWithSalt(2*K, 2*K+1, \"Honest bidder\");\n\n        vm.warp(endTime);\n\n        uint256[] memory bidIndices = new uint[](2);\n        bidIndices[0] = 0;\n        bidIndices[1] = 1;\n\n        seller.finalize(bidIndices, 2*K, 2*K+1);\n        emit log_string(\"Seller claimed\");\n        // seller claimed 4*K+2\n        assertEq(quoteToken.balanceOf(address(seller)), 4*K+2);\n        // contract has K+1 quote token left\n        assertEq(quoteToken.balanceOf(address(auction)), K+1);\n\n        // bidder1 withdraws\n        bidder1.withdraw();\n        emit log_string(\"Bidder 1 withdrew\");\n        // contract has K quote token left\n        assertEq(quoteToken.balanceOf(address(auction)), K);\n        // bidder2 withdraws and he is supposed to be able to claim K+1 quote tokens\n        // but the protocol reverts because of insufficient quote tokens\n        bidder2.withdraw();\n        emit log_string(\"Bidder 2 withdrew\"); // will not happen\n    }\n```\n\nThe test result shows the seller charged more quote token than the bidders offer so the last bidder can't withdraw his unused quote token because the contract doesn't have enough balance.\n\n```solidity\n    Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest\n    [FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985)\n    Logs:\n    Seller claimed\n    Bidder 1 withdrew\n\n    Test result: FAILED. 0 passed; 1 failed; finished in 6.94ms\n\n    Failing tests:\n    Encountered 1 failing test in src/test/SizeSealed.t.sol:SizeSealedTest\n    [FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985)\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nCurrently, the `FinalizeData` struct contains the `filledBase` only and calculates the `filledQuote` using the clearing price.\n\n```solidity\n    struct FinalizeData {\n        uint256 reserveQuotePerBase;\n        uint128 totalBaseAmount;\n        uint128 filledBase;\n        uint256 previousQuotePerBase;\n        uint256 previousIndex;\n    }\n```\n\nI think we should add one more field `filledQuote` and update it during auction finalization.\n\nAnd the seller can recieve the sum of `filledQuote` of all bidders to avoid the rounding issue.\n\nAlso, each bidder can pay the `filledQuote` of quote token and receive the `filledBase` of base token without calculating again using the clearing price.\n\n**[RagePit (SIZE) confirmed](https://github.com/code-423n4/2022-11-size-findings/issues/94#issuecomment-1319190203)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the SizeSealed.sol contract, which is part of the code-423n4/2022-11-size repository. The vulnerability could cause bidders to fail to withdraw their unused funds after the auction is finalized. The main flaw is the seller might receive more quote tokens than the bidders offer after the auction is finalized. The proof of concept shows that the seller receives the amount of quote token based on the clearing price, while the bidders offer quote tokens based on a different formula. This could lead to the contract not having enough balance of quote token for the last bidder to withdraw their funds.\n\nFoundry was used to identify the vulnerability. To mitigate the issue, the FinalizeData struct should be updated to include a field for filledQuote, which should be updated during auction finalization. This way, the seller can receive the sum of filledQuote of all bidders, and each bidder can pay the filledQuote of quote token and receive the filledBase of base token without calculating again using the clearing price.",
      "report_date": {},
      "contest_prize_txt": "$42,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-size-contest",
      "sponsor_name": "SIZE",
      "sponsor_link": "https://twitter.com/sizemarkets",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-11-size",
      "github_link": "https://github.com/code-423n4/2022-11-size-findings/issues/94",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "180",
      "slug": "h-01-bidders-might-fail-to-withdraw-their-unused-funds-after-the-auction-was-finalized-because-the-contract-doesnt-have-enough-balance-code4rena-size-size-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "SIZE",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "SIZE",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "5736",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "126",
      "title": "[M-07] Oracle’s two-day feature can be gamed",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L124\n\n\n## Vulnerability details\n\n## Impact\nThe two-day feature of the oracle can be gamed where you only have to manipulate the oracle for ~2 blocks.\n\n## Proof of Concept\nThe oracle computes the day using:\n```sol\nuint day = block.timestamp / 1 days;\n```\n\nSince we're working with `uint` values here, the following is true:\n$1728799 / 86400 = 1$\n$172800 / 86400 = 2$\n\nMeaning, if you manipulate the oracle at the last block of day $X$, e.g. 23:59:50, and at the first block of day $X + 1$, e.g. 00:00:02, you bypass the two-day feature of the oracle. You only have to manipulate the oracle for two blocks.\n\nThis is quite hard to pull off. I'm also not sure whether there were any instances of Chainlink oracle manipulation before. But, since you designed this feature to prevent small timeframe oracle manipulation I think it's valid to point this out.\n\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nIf you increase it to a three-day interval you can fix this issue. Then, the oracle has to be manipulated for at least 24 hours.",
      "summary": "\nThis bug report is about how the two-day feature of the oracle can be gamed. The oracle computes the day using a mathematical formula. If the oracle is manipulated at the last block of day X and the first block of day X+1, it bypasses the two-day feature of the oracle. This makes it possible to manipulate the oracle for only two blocks. To fix this issue, the oracle can be increased to a three-day interval, so the oracle has to be manipulated for at least 24 hours.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
      "sponsor_name": "Inverse Finance",
      "sponsor_link": "https://twitter.com/InverseFinance",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-inverse",
      "github_link": "https://github.com/code-423n4/2022-10-inverse-findings/issues/278",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "175",
      "slug": "m-07-oracles-two-day-feature-can-be-gamed-code4rena-inverse-finance-inverse-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Inverse Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Inverse Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Bypass limit"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "5731",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "126",
      "title": "[M-02] Users can avoid paying fees if they manage to update their accrued fees periodically",
      "content": "\n[DBR.sol#L287](https://github.com/code-423n4/2022-10-inverse/blob/main/src/DBR.sol#L287)<br>\n\nWhile a user borrows DOLA, his debt position in the DBR contract accrues more debt over time. However, Solidity contracts cannot update their storage automatically over time; state updates must always be triggered by externally owned accounts. For this reason, the DBR contract cannot accurately represent a user's debt position in its storage at all times. Instead, the contract offers a method `accrueDueTokens` that, when called, updates the internal storage with the debts that accrued since the last update. This method is called before all critical financial operations that depend on an accurate value of the accumulated deficit in the contract's storage. On top, this method can also be invoked permissionless at any time. Suppose a borrower manages to call this function periodically and keep the time difference between updates short. In that case, a rounding error in the computation of the accrued debt can cause the expression to round down to zero. In this case, the user successfully avoided paying interest on his debt.\n\n### Proof of Concept\n\nFor reference, here is the affected code:\n\n```Solidity\n    function accrueDueTokens(address user) public {\n        uint debt = debts[user];\n        if(lastUpdated[user] == block.timestamp) return;\n        uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;\n        dueTokensAccrued[user] += accrued;\n        totalDueTokensAccrued += accrued;\n        lastUpdated[user] = block.timestamp;\n        emit Transfer(user, address(0), accrued);\n    }\n```\n\nThe problem is that the function updates the `lastUpdated[user]` storage variable even when `accrued` is `0`.\n\n#### Example\n\nLet's assume that the last update occurred at `t_0`.<br>\nFurther assume that the next update occurs at `t_1` with `t_1 - t_0 = 12s`. (`12s` is the current Ethereum block time)<br>\nSuppose that the user's recorded `debt` position at ` t_0` is `1,000,000 wei`.<br>\nThen the accrued debt formula gives us the following:<br>\n\n    accrued = (t_1 - t_0) * debt / 365 days\n            = 12          * 1,000,000 / 31,536,000\n            = 1,000,000 / 31,536,000\n            = 0 (because unsigned integer division rounds down)\n\n#### Maximizing profit\n\nThe accrued debt formula rounds towards zero if we have `(t_1 - t_0) * debt < 365 days`.<br>\nThis gives us a method to compute the maximal debt that we can deposit to make the attack more efficient:\n\n    debt_max = 365 days / 12s -1 = 2,627,999\n\nNotice that an attacker is not limited to these small loans. He can split a massive loan into multiple small loans, capped at 2,627,999.<br>\nTo borrow X tokens (where X is given in WEI), we can compute the number of needed loans as:\n\n    #loans = X / 2,627,999\n\nFor example, to borrow 1 DOLA:\n\n    #loans = 10^18 / 2,627,999 = 380517648599\n\nTo borrow 1,000,000 DOLA we would thus need 380,517,648,599,000,000 small loans.\n\n#### Economical feasibility\n\nThe attack would be economically feasible if the costs of the attack were lower than the interest that accrued throughout the successful attack.<br>\nThe dominating factor of the attack costs is the gas costs which the attacker needs to pay to update the accrued interest of the small loans every second. A clever attacker would batch as many updates into a single transaction as possible to minimize the gas overhead of the transaction. Still, at the current block time (12s), gas price (7 gwei), block gas limit (30,000,000), and current ETH price (`$1,550.80`), it's hardly imaginable that this attack is economically feasible at the moment.\n\n#### Risk parameters\n\nHowever, all these values could change in the future. And if we look at other networks, Layer2 or EVM compatible Layer1, the parameters might be different today.\n\nAlso, notice that if the contract were used to borrow a different asset than DOLA, the numbers would look drastically different. The risk increases with the asset's price and becomes bigger the fewer decimals the token uses. For example, to borrow 1 WBTC (8 decimals), we would only need 39 small loans:\n\n    #loans = 10^8 / 2,627,999 ~39\n\nAnd to borrow WBTC worth $1,000,000 at a price of 20,746$/BTC, we would need 1864 small loans.\n\n    #loans ~= 49*10^8 / 2,627,999 ~= 1864\n\n#### Foundry\n\nThe following test demonstrates how to avoid paying interest on a loan for 1h. A failing test means that the attack was successful.\n\n    $ git diff src/test/DBR.t.sol\n    diff --git a/src/test/DBR.t.sol b/src/test/DBR.t.sol\n    index 3988cf7..8779da7 100644\n    --- a/src/test/DBR.t.sol\n    +++ b/src/test/DBR.t.sol\n    @@ -25,6 +25,20 @@ contract DBRTest is FiRMTest {\n             vm.stopPrank();\n         }\n     \n    +    function testFail_free_borrow() public {\n    +        uint borrowAmount =  2_627_999;\n    +\n    +        vm.prank(address(market));\n    +        dbr.onBorrow(user, borrowAmount);\n    +\n    +        for (uint i = 12; i <= 3600; i += 12) {\n    +            vm.warp(block.timestamp + 12);\n    +            dbr.accrueDueTokens(user);\n    +        }\n    +        assertEq(dbr.deficitOf(user), 0);\n    +    }\n    +\n    +\n         function testOnBorrow_Reverts_When_AccrueDueTokensBringsUserDbrBelow0() public {\n             gibWeth(user, wethTestAmount);\n             gibDBR(user, wethTestAmount);\n\nOutput:\n\n    $ forge test --match-test testFail_free_borrow -vv\n    [⠆] Compiling...\n    [⠊] Compiling 1 files with 0.8.17\n    [⠢] Solc 0.8.17 finished in 2.62s\n    Compiler run successful\n\n    Running 1 test for src/test/DBR.t.sol:DBRTest\n    [FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543)\n    Test result: FAILED. 0 passed; 1 failed; finished in 8.03ms\n\n    Failing tests:\n    Encountered 1 failing test in src/test/DBR.t.sol:DBRTest\n    [FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543)\n\n    Encountered a total of 1 failing tests, 0 tests succeeded\n\nClassified as a high medium because the yields can get stolen/denied. It's not high risk because I don't see an economically feasible exploit.\n\n### Tools Used\n\nVSCode, Wolramapha, Foundry\n\n### Recommended Mitigation Steps\n\n*   Document the risks transparently and prominently.\n*   Re-evaluate the risks according to the specific network parameters of every network you want to deploy to.\n*   Do not update the `lastUpdated` timestamp of the user if the computed accrued amount was zero.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-10-inverse-findings/issues/83#issuecomment-1304324558):**\n > Debatable if this even qualifies as Medium. Leaning towards QA / LOW but will leave open for sponsor review.\n\n**[08xmt (Inverse) confirmed and commented](https://github.com/code-423n4/2022-10-inverse-findings/issues/83#issuecomment-1315741882):**\n > Fixed in https://github.com/InverseFinance/FrontierV2/pull/20.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the DBR contract of the 2022-10-inverse project on GitHub. The vulnerability allows a user to borrow DOLA and avoid paying interest on their debt. This is achieved by calling the `accrueDueTokens` method periodically and keeping the time difference between updates short. This causes a rounding error in the computation of the accrued debt, which can cause the expression to round down to zero. The bug is classified as a high medium risk because the yields can get stolen/denied.\n\nThe dominating factor of the attack costs is the gas costs which the attacker needs to pay to update the accrued interest of the small loans every second. At the current block time (12s), gas price (7 gwei), block gas limit (30,000,000), and current ETH price (\\$1,550.80), it's hardly imaginable that this attack is economically feasible at the moment.\n\nRecommended mitigation steps include document the risks transparently and prominently, re-evaluate the risks according to the specific network parameters of every network you want to deploy to, and not update the `lastUpdated` timestamp of the user if the computed accrued amount was zero. Tools used to identify this vulnerability include VSCode, Wolramapha, and Foundry.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
      "sponsor_name": "Inverse Finance",
      "sponsor_link": "https://twitter.com/InverseFinance",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-inverse",
      "github_link": "https://github.com/code-423n4/2022-10-inverse-findings/issues/83",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "175",
      "slug": "m-02-users-can-avoid-paying-fees-if-they-manage-to-update-their-accrued-fees-periodically-code4rena-inverse-finance-inverse-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Inverse Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Inverse Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "5806",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "189",
      "title": "[H-04] Reserved token rounding can be abused to honeypot and steal user's funds",
      "content": "\nWhen the project wishes to mint reserved tokens, they call mintReservesFor which allows minting up to the amount calculated by DelegateStore's \\_numberOfReservedTokensOutstandingFor. The function has this line:\n\n    // No token minted yet? Round up to 1.\n    if (_storedTier.initialQuantity == _storedTier.remainingQuantity) return 1;\n\nIn order to ease calculations, if reserve rate is not 0 and no token has been minted yet, the function allows a single reserve token to be printed. It turns out that this introduces a very significant risk for users. Projects can launch with several tierIDs of similar contribution size, and reserve rate as low as 1%. Once a victim contributes to the project, it can instantly mint a single reserve token of all the rest of the tiers. They can then redeem the reserve token and receive most of the user's contribution, without putting in any money of their own.\n\nSince this attack does not require setting \"dangerous\" flags like lockReservedTokenChanges or lockManualMintingChanges, it represents a very considerable threat to unsuspecting users. Note that the attack circumvents user voting or any funding cycle changes which leave time for victim to withdraw their funds. \n\n### Impact\n\nHoneypot project can instantly take most of first user's contribution.\n\n### Proof of Concept\n\nNew project launches, with 10 tiers, of contributions 1000, 1050, 1100, ...\n\nReserve rate is set to 1% and redemption rate = 100%\n\nUser contributes 1100 and gets a Tier 3 NFT reward. \n\nProject immediately mints Tier 1,  Tier 2, Tier 4,... Tier 10 reserve tokens, and redeems all the reserve tokens.\n\nProject's total weight = 12250\n\nReserve token weight = 11150\n\nMalicious project cashes 1100 (overflow) &ast; 11150 / 12250 = \\~1001 tokens.\n\n### Recommended Mitigation Steps\n\nDon't round up outstanding reserve tokens as it represents too much of a threat.\n\n**[mejango (Juicebox DAO) acknowledged](https://github.com/code-423n4/2022-10-juicebox-findings/issues/191)**  \n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/191#issuecomment-1305972852):**\n > The finding is valid and clearly demonstrates how project owners could bypass the flags and safeguards implemented to trick users into thinking that they'll be safe.\n> \n> However, it falls within the \"centralization risk\" category, and within reports showing \"a unique attack path which users were not told upfront about\" (see [this issue](https://github.com/code-423n4/org/issues/54)). So I believe Medium severity to be appropriate.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/191#issuecomment-1306080547):**\n > I would just like to state that the way I look at it, this is not a centralization risk, as the counterparty which can perform the exploit is some listed project on Juicebox, rather than Juicebox itself. It is very similar to a high severity [finding ](https://github.com/code-423n4/2022-05-enso-findings/issues/204) in Enso Finance, where a strategy creator can rug funds sent to their strategy. \n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/191#issuecomment-1321944954):**\n > Kept it high risk out of coherence with https://github.com/code-423n4/2022-05-enso-findings/issues/204, and because this attack would bypass all the safeguards implemented by Juicebox\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the JBTiered721DelegateStore.sol code. Specifically, when the project wishes to mint reserved tokens, they call mintReservesFor which allows minting up to the amount calculated by DelegateStore's _numberOfReservedTokensOutstandingFor. The function has a line which rounds up to 1 if no token has been minted yet. This introduces a significant risk for users, as projects can launch with several tiers of similar contribution size and a reserve rate as low as 1%. This allows a malicious project to instantly take most of the first user's contribution without putting in any money of their own. \n\nThe impact of this vulnerability is that honeypot projects can instantly take most of first user's contribution. A proof of concept is provided, in which a new project launches with 10 tiers of contributions, and a reserve rate of 1%. When a user contributes 1100, the project can instantly mint reserve tokens of all the other tiers and redeem them, allowing the malicious project to cash 1100 tokens.\n\nThe recommended mitigation step is to not round up outstanding reserve tokens, as it represents too much of a threat.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-juicebox-contest",
      "sponsor_name": "Juicebox",
      "sponsor_link": "https://twitter.com/juiceboxETH",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-juicebox",
      "github_link": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/191",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "172",
      "slug": "h-04-reserved-token-rounding-can-be-abused-to-honeypot-and-steal-users-funds-code4rena-juicebox-juicebox-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Juicebox",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Juicebox",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "3100",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 11,
      "protocol_id": "176",
      "title": "[H-02] Builder can halve the interest paid to a community owner due to arithmetic rounding",
      "content": "_Submitted by scaraven, also found by 0x52, auditor0517, Deivitto, hansfriese, Lambda, rbserver, simon135, smiling&#95;heretic, sseefried, and TrungOre_\n\n[Community.sol#L685-L686](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L685-L686)<br>\n\nDue to arithmetic rounding in `returnToLender()`, a builder can halve the APR paid to a community owner by paying every 1.9999 days. This allows a builder to drastically decrease the amount of interest paid to a community owner, which in turn allows them to advertise very high APR rates to secure funding, most of which they will not pay.\n\nThis issue occurs in the calculation of `noOfDays` in `returnToLender()` which calculates the number of days since interest has last been calculated. If a builder repays a very small amount of tokens every 1.9999 days, then the `noOfDays` will be rounded down to `1 days` however `lastTimestamp` is updated to the current timestamp anyway, so the builder essentially accumulates only 1 day of interest after 2 days.\n\nI believe this is high severity because a community owner can have a drastic decrease in interest gained from a loan which counts as lost rewards. Additionally, this problem does not require a malicious builder because if a builder pays at a wrong time, the loaner receives less interest anyway.\n\n### Proof of Concept\n\n1.  A community owner provides a loan of 500\\_000 tokens to a builder with an APR of 10% (ignoring treasury fees)\n2.  Therefore, the community owner will expect an interest of 136.9 tokens per day (273.9 per 2 days)\n3.  A builder repays 0.000001 tokens at `lastTimestamp + 2*86400 - 1`\n4.  `noOfDays` rounds down to 1 thereby accumulating `500_000 * 100 * 1 / 365000 = 136` tokens for 2 days\n5.  Therefore, the community owner only receives 5% APR with negligible expenses for the builder\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nThere are two possible mitigations:\n\n1.  Add a scalar to `noOfDays` so that any rounding which occurs is negligible\n\ni.e.\n\n```solidity\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) * SCALAR / 86400; // 24*60*60\n\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000 /\n                SCALAR;\n```\n\n2.  Remove the `noOfDays` calculation and calculate interest in one equation which reduces arithmetic rounding\n\n```solidity\nuint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                (block.timestamp -\n            _communityProject.lastTimestamp) /\n                365000 /\n                86400;\n```\n\n**[zgorizzo69 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/180)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code for the Community.sol contract. This bug allows a builder to halve the APR paid to a community owner by paying every 1.9999 days. This would allow a builder to advertise very high APR rates to secure funding, but then pay back much lower rates than advertised. This bug occurs in the calculation of `noOfDays` in `returnToLender()` which calculates the number of days since interest has last been calculated. If a builder repays a very small amount of tokens every 1.9999 days, then the `noOfDays` will be rounded down to `1 days` however `lastTimestamp` is updated to the current timestamp anyway, so the builder essentially accumulates only 1 day of interest after 2 days.\n\nThis is considered high severity because a community owner can have a drastic decrease in interest gained from a loan which counts as lost rewards. Additionally, this problem does not require a malicious builder because if a builder pays at a wrong time, the loaner receives less interest anyway.\n\nTwo possible mitigations have been proposed. The first solution is to add a scalar to `noOfDays` so that any rounding which occurs is negligible. The second solution is to remove the `noOfDays` calculation and calculate interest in one equation which reduces arithmetic rounding.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-08-rigor-protocol-contest",
      "sponsor_name": "Rigor Protocol",
      "sponsor_link": "https://twitter.com/Rigor_HQ",
      "quality_score": 3.5,
      "general_score": 1.5,
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/180",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "151",
      "slug": "h-02-builder-can-halve-the-interest-paid-to-a-community-owner-due-to-arithmetic-rounding-code4rena-rigor-protocol-rigor-protocol-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Rigor Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Rigor Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "2985",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 12,
      "protocol_id": "187",
      "title": "[H-04] Division rounding can make fraction-price lower than intended (down to zero)",
      "content": "_Submitted by 0xA5DF, also found by 0x52, exd0tpy, horsefacts, hyh, kenzo, Lambda, minhquanym, panprog, scaraven, shenwilly, and simon135_\n\nDivisions in EVM are rounded down, which means when the fraction price is close to 1 (e.g. 0.999) it would effectively be zero, when it's close to 2 (1.999) it would be rounded to 1 - losing close to 50% of the intended price.\n\n*   In case the proposer had any fractions, the buyout module puts them for sale and he can lose his fractions while getting in exchange either zero or a significantly lower price than intended\n*   Even when the proposer doesn't hold any fractions, if the buyout succeeds - the difference (i.e. `buyoutPrice - fractionPrice*totalSupply`) goes to those who cash out their fractions after the buyout ends.\n    *   That's going to disincentivize users to sell their fractions during the buyout, because they may get more if they keep it till the buyout ends.\n    *   In other words, not only that the extra money the proposer paid doesn't increase the chance of the buyout to succeed, it actually decreases it.\n\n### Proof of Concept\n\nI've added the following tests to `test/Buyout.t.sol`.\n\n```solidity\n\n    // add Eve to the list of users \n    function setUp() public {\n        setUpContract();\n        alice = setUpUser(111, 1);\n        bob = setUpUser(222, 2);\n        eve = setUpUser(333, 3);\n\n        vm.label(address(this), \"BuyoutTest\");\n        vm.label(alice.addr, \"Alice\");\n        vm.label(bob.addr, \"Bob\");\n        vm.label(eve.addr, \"Eve\");\n    }\n\n    ///////////////////////////////////\n\n    // a scenario where the price is zero, and the proposer ends up loosing all his fractions \n    function test_bugFractionPriceIsZero() public{\n        uint totalSupply = 21e17;\n        uint BOB_INITIAL_BALANCE = totalSupply / 2;\n        initializeBuyout(alice, bob, totalSupply, BOB_INITIAL_BALANCE, true);\n\n        // Bob starts a buyout with 1 ether for the other half of total fractions\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        eve.buyoutModule.buyFractions{value: 0}(vault, BOB_INITIAL_BALANCE);\n\n        // Eve got all Bob's fractions for the very tempting price of 0\n        assertEq(getFractionBalance(eve.addr), BOB_INITIAL_BALANCE);\n    }\n\n\n    ////////////////////////////////\n\n    // a scenario where the price is 1, and the fraction price ends up being \n    // 50% of intended price.\n    // The user who cashes his fractions after the sale gets the difference (0.9 ether in this case).\n    function test_bugFractionPriceIsOne() public{\n        uint totalSupply = 11e17;\n        uint BOB_INITIAL_BALANCE = totalSupply / 10;\n        initializeBuyout(alice, bob, totalSupply, BOB_INITIAL_BALANCE, true);\n\n        uint aliceFractionBalance =  totalSupply * 9 / 10;\n        uint256 buyoutPrice = 2 ether;\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n        assertEq(fractionPrice, 1);\n\n        // We need to approve the buyout even though Eve doesn't hold any fractions\n        eve.ferc1155 = new FERC1155BS(address(0), 333, token);\n        setApproval(eve, buyout, true);\n\n        eve.buyoutModule.start{value: buyoutPrice}(vault);\n        // alice selling all her fractions\n        alice.buyoutModule.sellFractions(vault, aliceFractionBalance);\n\n        // 4 days till buyout ends\n        vm.warp(block.timestamp + 4.1 days);\n\n        bob.buyoutModule.end(vault, burnProof);\n\n        bob.buyoutModule.cash(vault, burnProof);\n\n        // Alice revenue should be about 0.99 ether\n        uint256 aliceExpectedETHRevenue = fractionPrice * aliceFractionBalance;\n        // Bob revenue should be about 1.01 ether\n        uint256 bobExpectedETHRevenue = buyoutPrice - aliceExpectedETHRevenue;\n\n        // Bob earned more than Alice even though Alice had 9 times his fractions\n        // This means Bob got ~9 times ETH per fraction than Alice\n        assertTrue(bobExpectedETHRevenue > aliceExpectedETHRevenue);\n        \n        // Just make sure they have the expected balance\n        assertEq(getETHBalance(alice.addr), aliceExpectedETHRevenue + INITIAL_BALANCE);\n        assertEq(getETHBalance(bob.addr), bobExpectedETHRevenue + INITIAL_BALANCE);\n\n    }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\n#### Solution A: make sure `buyoutPrice = fractionPrice * totalSupply`\n\n*   Request the user to send the intended fraction price (as a function arg) and then make sure he sent enough ETH. This way the user is well aware of the fraction price.\n*   An advantage of this method is that the buyout price calculation is also more accurate (compared to `(msg.value * 100) /(100 - ((depositAmount * 100) / totalSupply))` which has a rounding of up to 1%)\n*   Optional - you can also refund the user if he sent too much ETH, though this is probably unnecessary since the UI should calculate the exact amount the user should send.\n\nProposed code for solution A:\n\n```diff\n     /// @param _vault Address of the vault\n-    function start(address _vault) external payable {\n+    function start(address _vault, uint256 _fractionPrice) external payable {\n         // Reverts if ether deposit amount is zero\n         if (msg.value == 0) revert ZeroDeposit();\n         // Reverts if address is not a registered vault\n@@ -66,6 +66,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         (, , State current, , , ) = this.buyoutInfo(_vault);\n         State required = State.INACTIVE;\n         if (current != required) revert InvalidState(required, current);\n+        if (fractionPrice == 0) revert ZeroFractionPrice();\n \n@@ -83,9 +84,10 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n \n         // Calculates price of buyout and fractions\n         // @dev Reverts with division error if called with total supply of tokens\n-        uint256 buyoutPrice = (msg.value * 100) /\n-            (100 - ((depositAmount * 100) / totalSupply));\n-        uint256 fractionPrice = buyoutPrice / totalSupply;\n+        uint256 fractionPrice = _fractionPrice;\n+        uint256 buyoutPrice = fractionPrice * totalSupply;\n+        uint256 requiredEth = fractionPrice * (totalSupply - depositAmount);\n+        if (msg.value != requiredEth) revert InvalidPayment();\n \n         // Sets info mapping of the vault address to auction struct\n```\n\n#### Solution B: Calculate the price at buy/sell time using `buyoutPrice`\n\n*   The problem with solution A is that it doesn't let much flexibility in case that total supply is large. In the example in the PoC (`totalSupply = 2.1e18`) the buyout price can be either 2.1 ETH or 4.2 ETH, if the user wants to offer 1.5 ETH or 3 ETH he can't do it.\n*   This solution solves this - instead of basing the buy/sell price on the fraction price - use the buyout price to calculate the buy/sell price.\n*   This would cause a slight differential price (buying 1K fractions would have a slightly different price than 1M fractions).\n    *   However, note that the rounding here is probably insignificant, since the rounding would be no more than 1 wei per buy/sell\n    *   Also, the more the users buy/sell the more accurate the price would be (the less you buy the more you'll pay, the less you sell the less you'd get).\n*   For selling just calculate  `price = (buyoutPrice * amount) / totalSupply`\n*   For buying do the same, just add 1 wei if there was any rounding (see code below)\n*   If you're worried about the rounding of the buyout price (compared to solution A), you can increase the coefficient (this doesn't cost any extra gas, and is nearly impossible to overflow):\n\n`(ethDeposit * 1e6) / (1e6 - ((fractionDeposit * 1e6) / totalSupply))`\n\nProposed code for solution B:\n\n```diff\n--- a/src/interfaces/IBuyout.sol\n+++ b/src/interfaces/IBuyout.sol\n@@ -20,7 +20,7 @@ struct Auction {\n     // Enum state of the buyout auction\n     State state;\n     // Price of fractional tokens\n-    uint256 fractionPrice;\n+    uint256 buyoutPrice;\n     // Balance of ether in buyout pool\n     uint256 ethBalance;\n     // Total supply recorded before a buyout started\n\n\n--- a/src/modules/Buyout.sol\n+++ b/src/modules/Buyout.sol\n@@ -85,14 +85,14 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         // @dev Reverts with division error if called with total supply of tokens\n         uint256 buyoutPrice = (msg.value * 100) /\n             (100 - ((depositAmount * 100) / totalSupply));\n-        uint256 fractionPrice = buyoutPrice / totalSupply;\n+        uint256 estimatedFractionPrice = buyoutPrice / totalSupply;\n \n         // Sets info mapping of the vault address to auction struct\n         buyoutInfo[_vault] = Auction(\n             block.timestamp,\n             msg.sender,\n             State.LIVE,\n-            fractionPrice,\n+ // replace fraction price with buyout price in the Auction struct\n+            buyoutPrice,\n             msg.value,\n             totalSupply\n         );\n@@ -102,7 +102,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n             msg.sender,\n             block.timestamp,\n             buyoutPrice,\n-            fractionPrice\n+            estimatedFractionPrice\n         );\n     }\n \n@@ -115,7 +115,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n             _vault\n         );\n         if (id == 0) revert NotVault(_vault);\n-        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n+        (uint256 startTime, , State current, uint256 buyoutPrice, , uint256 totalSupply ) = this\n             .buyoutInfo(_vault);\n         // Reverts if auction state is not live\n         State required = State.LIVE;\n@@ -135,7 +135,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         );\n \n         // Updates ether balance of pool\n-        uint256 ethAmount = fractionPrice * _amount;\n+        uint256 ethAmount = buyoutPrice * _amount / totalSupply;\n         buyoutInfo[_vault].ethBalance -= ethAmount;\n         // Transfers ether amount to caller\n         _sendEthOrWeth(msg.sender, ethAmount);\n@@ -153,7 +153,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         );\n         if (id == 0) revert NotVault(_vault);\n         // Reverts if auction state is not live\n-        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n+        (uint256 startTime, , State current, uint256 buyoutPrice, , uint256 totalSupply ) = this\n             .buyoutInfo(_vault);\n         State required = State.LIVE;\n         if (current != required) revert InvalidState(required, current);\n@@ -161,8 +161,13 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         uint256 endTime = startTime + REJECTION_PERIOD;\n         if (block.timestamp > endTime)\n             revert TimeExpired(block.timestamp, endTime);\n+\n+        uint256 price = (buyoutPrice * _amount) / totalSupply;\n+        if (price * totalSupply < buyoutPrice * _amount){\n+            price++;\n+        }\n         // Reverts if payment amount does not equal price of fractional amount\n-        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n+        if (msg.value != price) revert InvalidPayment();\n \n         // Transfers fractional tokens to caller\n         IERC1155(token).safeTransferFrom(\n\n\n```\n\n**[HardlyDifficult (judge) increased severity to High and commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/310#issuecomment-1201840359):**\n > Rounding impacting `fractionPrice` can significantly impact other math in this module. I think this is a High risk issue, given the right circumstances such as the example above where the buy price becomes zero, assets are compromised.\n> \n> Selecting this instance as the primary issue for including test code and the detailed recs.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Buyout.sol contract which is part of the code-423n4/2022-07-fractional repository on Github. The vulnerability is caused due to divisions in the Ethereum Virtual Machine (EVM) being rounded down, which means when the fraction price is close to 1 (e.g. 0.999) it would effectively be zero, when it's close to 2 (1.999) it would be rounded to 1 - loosing close to 50% of the intended price. This can cause the proposer to lose his fractions while getting in exchange either zero or a significantly lower price than intended. Even when the proposer doesn't hold any fractions, if the buyout succeeds - the difference (i.e. buyoutPrice - fractionPrice*totalSupply) goes to those who cash out their fractions after the buyout ends. This could disincentivize users to sell their fractions during the buyout, because they may get more if they keep it till the buyout ends.\n\nFoundry was used as the tool to identify the vulnerability.\n\nTwo solutions are proposed to mitigate the vulnerability. Solution A suggests to make sure buyoutPrice = fractionPrice * totalSupply and request the user to send the intended fraction price as a function arg. An advantage of this method is that the buyout price calculation is also more accurate. Solution B suggests to calculate the price at buy/sell time using buyoutPrice. This would cause a slight differential price, however, the rounding here is probably insignificant. If you're worried about the rounding of the buyout price, you can increase the coefficient.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
      "sponsor_name": "Fractional",
      "sponsor_link": "https://twitter.com/fractional_art",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-07-fractional",
      "github_link": "https://github.com/code-423n4/2022-07-fractional-findings/issues/310",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "144",
      "slug": "h-04-division-rounding-can-make-fraction-price-lower-than-intended-down-to-zero-code4rena-fractional-fractional-v2-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Fractional",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Fractional",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "25270",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 0,
      "protocol_id": "114",
      "title": "[H-02] Division Before Multiplication Can Lead To Zero Rounding Of Return Amount",
      "content": "_Submitted by kirk-baird, also found by csanuragjain, datapunk, and ladboy233_\n\nThere is a division before multiplication bug that exists in [`lend()`](https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L280) for the Swivel case.\n\nIf `order.premium` is less than `order.principal` then `returned` will round to zero due to the integer rounding.\n\nWhen this occurs the user's funds are essentially lost. That is because they transfer in the underlying tokens but the amount sent to `yield(u, y, returned, address(this))` will be zero.\n\n### Proof of Concept\n\n```solidity\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] calldata a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        // returned represents the number of underlying tokens to lend to yield\n        uint256 returned;\n\n        {\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity > m) {\n                    revert NotEqual('maturity');\n                }\n                // Determine the fee\n                uint256 fee = calculateFee(a[i]);\n                // Track accumulated fees\n                totalFee += fee;\n                // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees\n                lent += a[i] - fee;\n                // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)\n                returned += (a[i] - fee) * (order.premium / order.principal);\n\n                unchecked {\n                    i++;\n                }\n            }\n            // Track accumulated fee\n            fees[u] += totalFee;\n\n            // transfer underlying tokens from user to illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n            // fill the orders on swivel protocol\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            yield(u, y, returned, address(this));\n        }\n\n        emit Lend(p, u, m, lent);\n        return lent;\n    }\n```\n\nSpecifically the function `returned += (a[i] - fee) * (order.premium / order.principal);`\n\n### Recommended Mitigation Steps\n\nThe multiplication should occur before division, that is `((a[i] - fee) * order.premium) / order.principal);`.\n\n**[JTraversa (Illuminate) confirmed](https://github.com/code-423n4/2022-06-illuminate-findings/issues/48)** \n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-illuminate-findings/issues/48#issuecomment-1195909365):**\n > Also see how [Swivel Calculates it](https://github.com/Swivel-Finance/swivel/blob/0ce3edfd05e3546a10ff9d751ead219c0ba35d21/contracts/v2/swivel/Swivel.sol#L131)\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the `lend()` function of the 2022-06-illuminate codebase, which could potentially lead to users losing their funds. This bug occurs when the `order.premium` is less than `order.principal`. This bug is due to the code performing division before multiplication, which can lead to integer rounding and a resulting `returned` value of zero. If this occurs, the user’s funds will be transferred but the amount sent to `yield(u, y, returned, address(this))` will be zero.\n\nThe recommended mitigation steps are for the multiplication to occur before division, that is `((a[i] - fee) * order.premium) / order.principal);`. This has been confirmed by JTraversa (Illuminate) and Alex the Entreprenerd (warden) has suggested looking at how Swivel Calculates it.",
      "report_date": {},
      "contest_prize_txt": "$55,000 USDC",
      "contest_link": "https://code4rena.com/reports/2022-06-illuminate",
      "sponsor_name": "Illuminate",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-06-illuminate",
      "github_link": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/48",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "134",
      "slug": "h-02-division-before-multiplication-can-lead-to-zero-rounding-of-return-amount-code4rena-illuminate-illuminate-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Illuminate",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Illuminate",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        },
        {
          "tags_tag": {
            "title": "Precision Loss"
          }
        }
      ]
    }
  ]
}