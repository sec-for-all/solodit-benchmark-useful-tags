{
  "tag": "Assembly",
  "count": 2,
  "metadata": {
    "totalResults": 2,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 7,
    "reset": 1771760940
  },
  "findings": [
    {
      "id": "20908",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "981",
      "title": "M-5: Exponential and logarithmic price adapters will return incorrect pricing when moving from higher dp token to lower dp token",
      "content": "Source: https://github.com/sherlock-audit/2023-06-Index-judging/issues/42 \n\n## Found by \n0x52\n## Summary\n\nThe exponential and logarithmic price adapters do not work correctly when used with token pricing of different decimal places. This is because the resolution of the underlying expWad and lnWad functions is not fit for tokens that aren't 18 dp.\n\n## Vulnerability Detail\n\n[AuctionRebalanceModuleV1.sol#L856-L858](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L856-L858)\n\n    function _calculateQuoteAssetQuantity(bool isSellAuction, uint256 _componentQuantity, uint256 _componentPrice) private pure returns (uint256) {\n        return isSellAuction ? _componentQuantity.preciseMulCeil(_componentPrice) : _componentQuantity.preciseMul(_componentPrice);\n    }\n\nThe price returned by the adapter is used directly to call _calculateQuoteAssetQuantity which uses preciseMul/preciseMulCeil to convert from component amount to quote amount. Assume we wish to sell 1 WETH for 2,000 USDT. WETH is 18dp while USDT is 6dp giving us the following price:\n\n    1e18 * price / 1e18 = 2000e6\n\nSolving for price gives:\n\n    price = 2000e6\n\nThis establishes that the price must be scaled to:\n\n    price dp = 18 - component dp + quote dp\n\nPlugging in our values we see that our scaling of 6 dp makes sense.\n\n[BoundedStepwiseExponentialPriceAdapter.sol#L67-L80](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L67-L80)\n\n        uint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\n        // Protect against priceChange overflow\n        if (scalingFactor > type(uint256).max / expExpression) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 priceChange = scalingFactor * expExpression - WAD;\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\n\nGiven the pricing code and notably the simple scalingFactor it also means that priceChange must be in the same order of magnitude as the price which in this case is 6 dp. The issue is that on such small scales, both lnWad and expWad do not behave as expected and instead yield a linear behavior. This is problematic as the curve will produce unexpected behaviors under these circumstances selling the tokens at the wrong price. Since both functions are written in assembly it is very difficult to determine exactly what is going on or why this occurs but testing in remix gives the following values:\n\n    expWad(1e6) - WAD = 1e6\n    expWad(5e6) - WAD = 5e6\n    expWad(10e6) - WAD = 10e6\n    expWad(1000e6) - WAD = 1000e6\n\nAs seen above these value create a perfect linear scaling and don't exhibit any exponential qualities. Given the range of this linearity it means that these adapters can never work when selling from higher to lower dp tokens. \n\n## Impact\n\nExponential and logarithmic pricing is wrong when tokens have mismatched dp\n\n## Code Snippet\n\n[BoundedStepwiseExponentialPriceAdapter.sol#L28-L88](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L28-L88)\n\n[BoundedStepwiseLogarithmicPriceAdapter.sol#L28-L88](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseLogarithmicPriceAdapter.sol#L28-L88)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nscalingFactor should be scaled to 18 dp then applied via preciseMul instead of simple multiplication. This allows lnWad and expWad to execute in 18 dp then be scaled down to the correct dp.\n\n\n\n## Discussion\n\n**pblivin0x**\n\nAgree that scalingFactor should be 18 decimals and applied with preciseMul, will fix. \n\n**Oot2k**\n\nNot a duplicate \n\n**bizzyvinci**\n\nEscalate\n\nThis is invalid\n\n`FixedPointMathLib.expWad` and `FixedPointMathLib.lnWad` uses WAD as input and WAD as output. This is mentioned in [docs](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol#L120) and you can test it out on remix. Therefore, `exp(1) = FixedPointMathLib.expWad(WAD) / WAD` and `exp(5) = FixedPointMathLib.expWad(5*WAD) / WAD`.\n\n`expWad(1e6) - WAD = 1e6` is equal to `exp(1e-12) - 1 = 1e-12` which is absolutely correct.\n\nFor the formula to work, timeCoefficient has to be in WAD. @pblivin0x  should look at our DM around this time.\n\n<img width=\"840\" alt=\"Screenshot 2023-08-01 at 09 46 44\" src=\"https://github.com/sherlock-audit/2023-06-Index-judging/assets/22333930/1b224171-5a20-4836-95f6-3ed78078dda0\">\n\n\nHis comment: `scalingFactor should be 18 decimals and applied with preciseMul` is on a different matter. It's a plan for the future to allow decimal scalingFactor e.g 0.5, 2.5 rather than just integers like 1, 2, 3 etc.\n\nTo recap: \n`block.timestamp` is in seconds, therefore `timeBucket`, `_timeElapsed` and `bucketSize` are in seconds.\n`_componentPrice`, `initialPrice`, `minPrice`, `maxPrice`, `priceChange` and `FixedPointMathLib` are in WAD.\nTherefore, `expExpression`, `expArgument` and `timeCoefficient` has to also be in WAD.\n`scalingFactor` is just a scaler unit which the team plan to turn into WAD in the future for more precision with scaling.\n\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is invalid\n> \n> `FixedPointMathLib.expWad` and `FixedPointMathLib.lnWad` uses WAD as input and WAD as output. This is mentioned in [docs](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol#L120) and you can test it out on remix. Therefore, `exp(1) = FixedPointMathLib.expWad(WAD) / WAD` and `exp(5) = FixedPointMathLib.expWad(5*WAD) / WAD`.\n> \n> `expWad(1e6) - WAD = 1e6` is equal to `exp(1e-12) - 1 = 1e-12` which is absolutely correct.\n> \n> For the formula to work, timeCoefficient has to be in WAD. @pblivin0x  should look at our DM around this time.\n> \n> <img width=\"840\" alt=\"Screenshot 2023-08-01 at 09 46 44\" src=\"https://github.com/sherlock-audit/2023-06-Index-judging/assets/22333930/1b224171-5a20-4836-95f6-3ed78078dda0\">\n> \n> \n> His comment: `scalingFactor should be 18 decimals and applied with preciseMul` is on a different matter. It's a plan for the future to allow decimal scalingFactor e.g 0.5, 2.5 rather than just integers like 1, 2, 3 etc.\n> \n> To recap: \n> `block.timestamp` is in seconds, therefore `timeBucket`, `_timeElapsed` and `bucketSize` are in seconds.\n> `_componentPrice`, `initialPrice`, `minPrice`, `maxPrice`, `priceChange` and `FixedPointMathLib` are in WAD.\n> Therefore, `expExpression`, `expArgument` and `timeCoefficient` has to also be in WAD.\n> `scalingFactor` is just a scaler unit which the team plan to turn into WAD in the future for more precision with scaling.\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nSince scaling factor is not applied via precise mul in the current implementation, in order to work as the code is written it has to be have the same number of decimals as price and therefore can't be WAD, regardless of what sponsor has said in the discord comments. As I've shown in my issue these smaller values are not compatible with expWAD and lnWAD and will produce incorrect values, negatively affecting auction pricing. \n\n**bizzyvinci**\n\nThe [getPrice function](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L28-L88) can be broken down to the following after removing `boundary price` and type conversions.\n\n1. timeBucket = _timeElapsed / bucketSize\n2. expArgument = timeCoefficient * timeBucket\n3. expExpression = FixedPointMathLib.expWad(expArgument)\n4. priceChange = scalingFactor * expExpression - WAD\n5. price = initialPrice + priceChange (or minus)\n\nTo know what unit should be WAD or not, we need to look elsewhere.\n1. `_timeElapsed = block.timestamp - rebalanceInfo[_setToken].rebalanceStartTime` [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L806) and `rebalanceInfo[_setToken].rebalanceStartTime` is set to `block.timestamp` when startRebalance is called [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L275). Therefore `_timeElapsed`, `bucketSize` and `timeBucket` has to be seconds.\n2. `_componentPrice` is in precise unit or WAD based on calculation [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L857). Therefore `price`, `initialPrice` and `priceChange` have to also be in WAD.\n3. Formula 4 is wrong as pointed out in #39 therefore let's just focus on the multiplication part and assume `priceChange = scalingFactor * expExpression`. If `priceChange` is `WAD`, then `scalingFactor * expExpression` has to be WAD. Either `scalingFactor is WAD` or `expExpression` is WAD.\n4. FixedPointMathLib.expWad returns WAD, so `expExpression` is indeed WAD. So `scalingFactor` is basic unit.\n5. Furthermore, `FixedPointMathLib.expWad` takes WAD as input, and that input is `timeCoefficient * timeBucket`. We've established that `timeBucket` is seconds in 1, so therefore `timeCoefficient` has to be WAD.\n\nThe sponsor's message was referenced because \n* I was the one who decided that his initial statement `timeCoefficient and bucketSize are not in WAD` is wrong. So he might want to cross-check things again.\n* We had some discussions about scalingFactor and converting it to WAD around that time.\n\nIf scalingFactor is changed to WAD, then priceChange would be `WAD^2`. Therefore, we must use preciseMul to keep things balanced again. P.S: -WAD is ignored again.\n```solidity\n+ priceChange = scalingFactorWAD.preciseMul(expExpression)\n- priceChange = scalingFactorBasic * expExpression\n```\n\nThe 2 formula are the same thing because `preciseMul(a, b) = a * b / WAD` [code](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/lib/PreciseUnitMath.sol#L94-L96)\n```solidity\nfunction preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a.mul(b).div(PRECISE_UNIT);\n}\n```\n\n**IAm0x52**\n\n> _componentPrice is in precise unit or WAD based on calculation [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L857). Therefore price, initialPrice and priceChange have to also be in WAD.\n\nThis is incorrect. I've proven in my submission above that when going from an 18 dp token to 6 dp that price has to be 6 dp. Since scalingFactor is applied as a scaler and not via preciseMul then expArgument and expExpression have to also be in 6 dp as well. If you used a WAD expression for them the pricing would be completely wrong as it would return an 18 dp price. As I've shown expWAD returns incorrectly when inputting a 6 dp number.\n\n**IAm0x52**\n\nThe point of this issue is to prove that scaling factor must be applied via preciseMul or else the price cannot work as expect. To just say \"scaling factor should be applied via preciseMul\" is not a valid issue unless you can show why it's incorrect that it's not applied that way and the damages that it causes. \n\n**bizzyvinci**\n\nprecise unit is used for precision in calculation because the numbers could be very small and solidity does automatic rounding. When multiplying or dividing, preciseMul or preciseDiv is used to finally get rid of that precision. You can view the [PreciseUnitMath library](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/lib/PreciseUnitMath.sol) and the key take away are\n1. `PRECISE_UNIT = PRECISE_UNIT_INT = WAD = 1e18`\n2. `preciseMul(a, b) = a * b / WAD` and that only makes sense if a or b is WAD\n3. `preciseDiv(a, b) = a * WAD / b` and that only makes sense if b is WAD\n\nNow, why is `_componentPrice` in WAD? \nBecause `_componentQuantity` and the returned `quoteAssetQuantity` are not in WAD and preciseMul needs `b` to be WAD. `_componentQuantity` and `quoteAssetQuantity` are the raw quantity amount that would be transferred with `token.transfer`.\n\nhttps://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L856-858\n```solidity\nfunction _calculateQuoteAssetQuantity(bool isSellAuction, uint256 _componentQuantity, uint256 _componentPrice) private pure returns (uint256) {\n      return isSellAuction ? _componentQuantity.preciseMulCeil(_componentPrice) : _componentQuantity.preciseMul(_componentPrice);\n  }\n```\n\n\n**pblivin0x**\n\nI believe this is a valid medium\n\n**Oot2k**\n\nI agree that this is valid medium\n\n**bizzyvinci**\n\nI still stand by my escalation and I think my proof is sufficient cause it proves the following\n* _componentPrice in WAD\n* Right now, scalingFactor is not WAD cause that would be mathematically wrong. It must be a normal integer.\n* The unit of each parameters (e.g which one is seconds, WAD or int) to show that price does work correctly.\n* The team plans to make scalingFactor WAD and use preciseMul. They **must** use preciseMul to make sure priceChange remains a WAD (rather than WAD^2)\n* The migration of scalingFactor from integer scalar to WAD scalar **would not** change price nor priceChange because `preciseMul(a,b) = a * b / WAD`\n* The only effect the migration has is precision. scalingFactor could then be represented as decimals instead of just integers. \n\n\nIf anyone disagrees it would be nice if they state why. Or if there's a point that wasn't clear, I'm here to clarify.\n\n**bizzyvinci**\n\nI understand the proof might be daunting to comprehend so I'll recommend using pen and paper (and maybe remix with calculator) to make things easier.\n\n**bizzyvinci**\n\nI do agree that my escalation be rejected\n\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this a valid medium based on the above comments. \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [bizzyvinci](https://github.com/sherlock-audit/2023-06-Index-judging/issues/42/#issuecomment-1659888928): rejected\n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe changes are to update to 18 decimal `scalingFactor` in both the exponential and logarithmic adapter\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseLogarithmicPriceAdapter.sol#L73",
      "summary": "\nThis bug report is about the Exponential and Logarithmic Price Adapters which are used to convert token pricing of different decimal places. It was found by 0x52 and reported on GitHub. The issue is that when moving from higher dp token to lower dp token, the adapters do not work correctly due to the resolution of the underlying expWad and lnWad functions not being fit for tokens that aren't 18 dp. This is because the price returned by the adapter is used directly to call _calculateQuoteAssetQuantity which uses preciseMul/preciseMulCeil to convert from component amount to quote amount and the resolution of the functions is not suitable for smaller values.\n\nTesting in Remix showed that these functions produce a perfect linear scaling instead of an exponential one, meaning that the adapters can never work when selling from higher to lower dp tokens. As a result, exponential and logarithmic pricing is wrong when tokens have mismatched dp.\n\nThe team plan to turn scalingFactor into WAD in the future for more precision with scaling, and use preciseMul instead of simple multiplication. This would allow lnWad and expWad to execute in 18 dp then be scaled down to the correct dp.\n\nThe bug report was discussed and it was agreed that this is a valid medium issue. The team plan to fix it by turning scalingFactor into WAD in the future and using preciseMul instead of simple multiplication.",
      "report_date": {},
      "contest_prize_txt": "24000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/91",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-Index-judging/issues/42",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "91",
      "slug": "m-5-exponential-and-logarithmic-price-adapters-will-return-incorrect-pricing-when-moving-from-higher-dp-token-to-lower-dp-token-sherlock-none-index-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Index Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Index Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        },
        {
          "tags_tag": {
            "title": "Assembly"
          }
        }
      ]
    },
    {
      "id": "5708",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "304",
      "title": "[H-03] Wrong implementation of function LBPair.setFeeParameter can break the funcionality of LBPair and make userâ€™s tokens locked",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917\n\n\n## Vulnerability details\n\n## Vulnerable detail \nStruct `FeeParameters` contains 12 fields as follows: \n```solidity=\nstruct FeeParameters {\n    // 144 lowest bits in slot \n    uint16 binStep;\n    uint16 baseFactor;\n    uint16 filterPeriod; \n    uint16 decayPeriod; \n    uint16 reductionFactor; \n    uint24 variableFeeControl;\n    uint16 protocolShare;\n    uint24 maxVolatilityAccumulated; \n    \n    // 112 highest bits in slot \n    uint24 volatilityAccumulated;\n    uint24 volatilityReference;\n    uint24 indexRef;\n    uint40 time; \n}\n```\nFunction [`LBPair.setFeeParamters(bytes _packedFeeParamters)`](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L788-L790) is used to set the first 8 fields which was stored in 144 lowest bits of `LBPair._feeParameter`'s slot to 144 lowest bits of `_packedFeeParameters` (The layout of `_packedFeeParameters` can be seen [here](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L572-L584)).\n```solidity=\n/// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917\n\n/// @notice Internal function to set the fee parameters of the pair\n/// @param _packedFeeParameters The packed fee parameters\nfunction _setFeesParameters(bytes32 _packedFeeParameters) internal {\n    bytes32 _feeStorageSlot;\n    assembly {\n        _feeStorageSlot := sload(_feeParameters.slot)\n    }\n\n    /// [#explain]  it will get 112 highest bits of feeStorageSlot,\n    ///             and stores it in the 112 lowest bits of _varParameters \n    uint256 _varParameters \n        = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS/*=144*/);\n\n    /// [#explain]  get 144 lowest bits of packedFeeParameters \n    ///             and stores it in the 144 lowest bits of _newFeeParameters  \n    uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);\n\n    assembly {\n        // [$audit-high] wrong operation `or` here \n        //              Mitigate: or(_newFeeParameters, _varParameters << 144)    \n        sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))\n    }\n}\n```\nAs we can see in the implementation of `LBPair._setFeesParametes` above, it gets the 112 highest bits of `_feeStorageSlot` and stores it in the 112 lowest bits of `_varParameter`. Then it gets the 144 lowest bits of `packedFeeParameter` and stores it in the 144 lowest bits of `_newFeeParameters`. \n\nFollowing the purpose of function `setFeeParameters`, the new `LBPair._feeParameters` should form as follow: \n```\n// keep 112 highest bits remain unchanged \n// set 144 lowest bits to `_newFeeParameter`\n[...112 bits...][....144 bits.....]\n[_varParameters][_newFeeParameters]\n```\nIt will make `feeParameters = _newFeeParameters | (_varParameters << 144)`. But current implementation just stores the `or` value of `_varParameters` and `_newFeeParameter` into `_feeParameters.slot`. It forgot to shift left the `_varParameters` 144 bits before executing `or` operation. \n\nThis will make the value of `binStep`, ..., `maxVolatilityAccumulated` incorrect, and also remove the value (make the bit equal to 0) of `volatilityAccumulated`, ..., `time`.\n\n## Impact\n* Incorrect fee calculation when executing an action with LBPair (swap, flashLoan, mint)\n* Break the functionality of LBPair. The user can't swap/mint/flashLoan\n--> Make all the tokens stuck in the pools \n\n## Proof of concept \nHere is our test script to describe the impacts \n* https://gist.github.com/WelToHackerLand/012e44bb85420fb53eb0bbb7f0f13769\n\nYou can place this file into `/test` folder and run it using \n```bash=\nforge test --match-contract High1Test -vv\n```\n\nExplanation of test script:\n1. First we create a pair with `binStep = DEFAULT_BIN_STEP = 25`\n2. We do some actions (add liquidity -> mint -> swap) to increase the value of `volatilityAccumulated` from `0` to `60000`\n3. We call function `factory.setFeeParametersOnPair` to set new fee parameters. \n4. After that the value of `volatilityAccumulated` changed to value `0` (It should still be unchanged after `factory.setFeeParametersOnPair`) \n5. We check the value of `binStep` and it changed from`25` to `60025` \n    * `binStep` has that value because [line 915](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L915) set `binStep = uint16(volatilityAccumulated) | binStep = 60000 | 25 = 60025`. \n6. This change of `binStep` value will break all the functionality of `LBPair` cause `binStep > Constant.BASIS_POINT_MAX = 10000` \n--> `Error: BinStepOverflows` \n\n\n## Tools Used\nFoundry \n \n## Recommended Mitigation Steps\nModify function `LBPair._setFeesParaters` as follow: \n```solidity=\n/// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917\nfunction _setFeesParameters(bytes32 _packedFeeParameters) internal {\n    bytes32 _feeStorageSlot;\n    assembly {\n        _feeStorageSlot := sload(_feeParameters.slot)\n    }\n\n\n    uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);\n    uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);\n\n\n    assembly {\n        sstore(_feeParameters.slot, or(_newFeeParameters, shl(144, _varParameters)))\n    }\n}\n```",
      "summary": "\nThis bug report describes an issue with the function `LBPair.setFeeParamters(bytes _packedFeeParamters)` in the codebase of the project 2022-10-traderjoe. This function is used to set the first 8 fields of the `FeeParameters` struct, which is stored in 144 lowest bits of `LBPair._feeParameter`'s slot. \n\nThe issue is that the function forgets to shift left the `_varParameters` 144 bits before executing `or` operation, resulting in incorrect fee calculation when executing an action with LBPair (swap, flashLoan, mint). This will also break the functionality of LBPair, making all the tokens stuck in the pools. \n\nA proof of concept has been provided, along with a test script to demonstrate the impact of this issue. The recommended mitigation step is to modify the function `LBPair._setFeesParaters` as specified in the report.",
      "report_date": {},
      "contest_prize_txt": "$100,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-trader-joe-v2-contest",
      "sponsor_name": "Trader Joe",
      "sponsor_link": "https://twitter.com/traderjoe_xyz",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-traderjoe",
      "github_link": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/384",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "171",
      "slug": "h-03-wrong-implementation-of-function-lbpairsetfeeparameter-can-break-the-funcionality-of-lbpair-and-make-users-tokens-locked-code4rena-trader-joe-trader-joe-v2-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Trader Joe",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Trader Joe",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Assembly"
          }
        }
      ]
    }
  ]
}