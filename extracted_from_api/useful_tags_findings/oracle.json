{
  "tag": "Oracle",
  "count": 59,
  "metadata": {
    "totalResults": 59,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 16,
    "reset": 1771761120
  },
  "findings": [
    {
      "id": "61599",
      "kind": "MARKDOWN",
      "auditfirm_id": "11",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "3331",
      "title": "Missing staleness check in `PriceOracle::getTokenPrice`",
      "content": "**Description:** `PriceOracle.getTokenPrice()` relays `pythOracle.getPriceUnsafe()` but never verifies the price **publish time** or confidence interval. A price that is hours old (or intentionally frozen) is accepted as fresh.\n\n```solidity\nfunction getTokenPrice(address _token) external view returns (uint256) {\n    bytes32 _oracleID = oracleIDs[_token];\n\n    if (_oracleID == bytes32(0)) {\n        revert OracleNotExist(_token);\n    }\n\n    PythStructs.Price memory price = pythOracle.getPriceUnsafe(_oracleID);\n\n    return _scalePythPrice(price.price, price.expo);\n}\n```\n\n**Impact:** * Automation fees may be computed from obsolete data, letting attackers over- or under-pay.\n\n**Recommended Mitigation:** Consider using the [getPriceNoOlderThan](https://api-reference.pyth.network/price-feeds/evm/getPriceNoOlderThan) function instead of [getPriceUnsafe](https://api-reference.pyth.network/price-feeds/evm/getPriceUnsafe).\n\n**OctoDeFi:** Fixed in PR [\\#24](https://github.com/octodefi/strategy-builder-plugin/pull/24).\n\n**Cyfrin:** Verified. When the oracle reports prices older than 120 seconds, `PriceOracle` will return 0 such that the minimum fee will be used. This is a good solution, although a 0 price will cause panic revert due to division by zero in `calculateTokenAmount()`.\n\n**OctoDeFi:** Fixed in PR [\\#27](https://github.com/octodefi/strategy-builder-plugin/pull/27).\n\n**Cyfrin:** Verified. The 0 price case is now explicitly handled to avoid reverting and the threshold has been reduced to 60 seconds. It is possible that this threshold could be too restrictive for specific feeds, and it is recommended to be configured on a per-feed basis.\n\n**OctoDeFi:** Regarding the threshold, we also believe that 60 seconds is quite restrictive, especially considering this is a fee calculation and not a vault with collateral at risk.\n\nMost Pyth oracles update roughly every 1–2 seconds for major tokens. However, it's important to note that these are pull-based oracles, so smaller or less liquid tokens could have much slower update rates.\n\nIt might actually make sense to set the threshold much higher to really detect when an oracle is no longer functioning, rather than simply outdated. In any case, we can't fully prevent price manipulation through a single threshold alone.\n\n**Cyfrin:** Acknowledged.",
      "summary": "\nThe report describes a bug in the `PriceOracle.getTokenPrice()` function. The function uses the `pythOracle.getPriceUnsafe()` function to get the latest price, but it does not check the publish time or confidence interval of the price. This means that an old or intentionally frozen price can be accepted as fresh, which could lead to incorrect automation fees being calculated and potential attacks. The recommended solution is to use the `getPriceNoOlderThan` function instead. The bug has been fixed in the latest PRs by OctoDeFi and Cyfrin, but there may still be some concerns about the threshold for detecting outdated prices.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-07-17-cyfrin-octodefi-v2.0.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "missing-staleness-check-in-priceoraclegettokenprice-cyfrin-none-octodefi-markdown",
      "firm_name": "Cyfrin",
      "firm_logo_square": "Cyfrin_square.jpg",
      "protocol_name": "Octodefi",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
      },
      "protocols_protocol": {
        "name": "Octodefi",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Oracle"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "52750",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "2071",
      "title": "H-5: spTKNMinimalOracle `_calculateSpTknPerBase()` does not calculate correct price for podded or fraxlend pair pairedLpTKNs.",
      "content": "Source: https://github.com/sherlock-audit/2025-01-peapods-finance-judging/issues/445 \n\n## Found by \nbretzel, pkqs90\n\n\n### Summary\n\nspTKNMinimalOracle `_calculateSpTknPerBase()` does not calculate correct price for podded or fraxlend pair pairedLpTKNs.\n\n### Root Cause\n\nFirst, let’s clarify the denomination: tokenA/tokenB represents how much tokenB is worth per tokenA. For example, ETH/USDC = 3000 means 1 ETH is equivalent to 3000 USDC.\n\nThe `_calculateSpTknPerBase()` function is used to calculate baseTKN/spTKN. It starts with the `_priceBasePerPTkn18` variable, which is pTKN/baseTKN.\n\nNow, we need to convert pTKN to spTKN. Because spTKN is the Uniswap V2 LP of pTKN and pairedLpTKN, the idea is to use the Uniswap V2 LP fair pricing formula. In order to do that, we need the price of pairedLpTKN/baseTKN.\n\nFor normal pods, baseTKN is equal to pairedLpTKN (e.g USDC as pairedLpTKN). However, pods (e.g. pOHM) and fraxlend pair (self-lending pods e.g. fUSDC) tokens are also supported. The bug here is, for both podded tokens and fraxlend pair tokens, the formula is wrong.\n\nFrom this doc, https://docs.google.com/document/d/1Z-T_07QpJlqXlbBSiC_YverKFfu-gcSkOBzU1icMRkM/edit?tab=t.0, the spTKN is first priced against pairedLpTKN (i.e. spTKN/pairedLpTKN), then converted to spTKN/baseTKN.\n\nThe two bugs here are:\n\n1. The current code calculates `_basePerSpTkn18` as if pairedLpTKN/baseTKN is 1:1. However, this is incorrect. We should convert pTKN/baseTKN (which is `_priceBasePerPTkn18`) to pTKN/pairedLpTKN by dividing a `sqrt(ratio)` to the formula, assuming `ratio` to be the asset/share ratio of either podded token or fraxlend pair (Recall that fair LP pricing formula is `fairPrice = 2 * sqrt(k * priceToken1 * priceToken2) / lpSuppply`).\n\n2. After calculating `_basePerSpTkn18` (spTKN/pairedLpTKN), the code reverses it to pairedLpTKN/spTKN, then multiply the asset/share ratio. However, the correct order is to first multiply the asset/share ratio to get spTKN/baseTKN, and then reverse it, and finally we can get baseTKN/spTKN.\n\nhttps://github.com/sherlock-audit/2025-01-peapods-finance/blob/main/contracts/contracts/lvf/LeverageManager.sol#L60\n\n```solidity\n    function _calculateSpTknPerBase(uint256 _price18) internal view returns (uint256 _spTknBasePrice18) {\n        uint256 _priceBasePerPTkn18 = _calculateBasePerPTkn(_price18);\n        address _pair = _getPair();\n\n        (uint112 _reserve0, uint112 _reserve1) = V2_RESERVES.getReserves(_pair);\n        uint256 _k = uint256(_reserve0) * _reserve1;\n        uint256 _kDec = 10 ** IERC20Metadata(IUniswapV2Pair(_pair).token0()).decimals()\n            * 10 ** IERC20Metadata(IUniswapV2Pair(_pair).token1()).decimals();\n        uint256 _avgBaseAssetInLp18 = _sqrt((_priceBasePerPTkn18 * _k) / _kDec) * 10 ** (18 / 2);\n@>      uint256 _basePerSpTkn18 =\n            (2 * _avgBaseAssetInLp18 * 10 ** IERC20Metadata(_pair).decimals()) / IERC20(_pair).totalSupply();\n        require(_basePerSpTkn18 > 0, \"V2R\");\n@>      _spTknBasePrice18 = 10 ** (18 * 2) / _basePerSpTkn18;\n\n        // if the base asset is a pod, we will assume that the CL/chainlink pool(s) are\n        // pricing the underlying asset of the base asset pod, and therefore we will\n        // adjust the output price by CBR and unwrap fee for this pod for more accuracy and\n        // better handling accounting for liquidation path\n        if (BASE_IS_POD) {\n            _spTknBasePrice18 = _checkAndHandleBaseTokenPodConfig(_spTknBasePrice18);\n        } else if (BASE_IS_FRAX_PAIR) {\n            _spTknBasePrice18 = IFraxlendPair(BASE_TOKEN).convertToAssets(_spTknBasePrice18);\n        }\n    }\n```\n\n### Internal pre-conditions\n\nN/A\n\n### External pre-conditions\n\nN/A\n\n### Attack Path\n\nN/A\n\n### Impact\n\nPods with podded token or fraxlend pair token as pairedLpTKN would have incorrect oracle result, leading to overestimating or underestimating borrow asset value in Fraxlend.\n\n### PoC\n\nN/A\n\n### Mitigation\n\nFix the formula accordingly. The correct code should be:\n\n```solidity\n    function _calculateSpTknPerBase(uint256 _price18) internal view returns (uint256 _spTknBasePrice18) {\n        uint256 _priceBasePerPTkn18 = _calculateBasePerPTkn(_price18);\n        address _pair = _getPair();\n\n        uint256 cbr;\n        if (BASE_IS_POD) {\n            cbr = _checkAndHandleBaseTokenPodConfig(1e18);\n        } else if (BASE_IS_FRAX_PAIR) {\n            cbr = IFraxlendPair(BASE_TOKEN).convertToAssets(1e18);\n        }\n\n        (uint112 _reserve0, uint112 _reserve1) = V2_RESERVES.getReserves(_pair);\n        uint256 _k = uint256(_reserve0) * _reserve1;\n        uint256 _kDec = 10 ** IERC20Metadata(IUniswapV2Pair(_pair).token0()).decimals()\n            * 10 ** IERC20Metadata(IUniswapV2Pair(_pair).token1()).decimals();\n        uint256 _avgBaseAssetInLp18 = _sqrt((_priceBasePerPTkn18 * _k * 1e18) / _kDec / cbr) * 10 ** (18 / 2);\n        uint256 _basePerSpTkn18 =\n            (2 * _avgBaseAssetInLp18 * 10 ** IERC20Metadata(_pair).decimals()) / IERC20(_pair).totalSupply();\n        _basePerSpTkn18 = _basePerSpTkn18 * cbr / 1e18;\n        require(_basePerSpTkn18 > 0, \"V2R\");\n        _spTknBasePrice18 = 10 ** (18 * 2) / _basePerSpTkn18;\n    }\n```",
      "summary": "\nThe bug report is about an issue with the calculation of prices for certain types of paired tokens in the Peapods Finance platform. This bug was found by two individuals and has been identified as having two root causes. The first is an incorrect formula used to convert one type of token to another, and the second is an incorrect order of operations in the code. This bug affects pods and fraxlend pair tokens, and can lead to incorrect pricing and estimation of asset values. The report includes a proposed solution to fix the formula and mitigate the bug.",
      "report_date": {},
      "contest_prize_txt": "120000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/749",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2025-01-peapods-finance-judging/issues/445",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "749",
      "slug": "h-5-sptknminimaloracle-_calculatesptknperbase-does-not-calculate-correct-price-for-podded-or-fraxlend-pair-pairedlptkns-sherlock-peapods-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Peapods",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Peapods",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "49233",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "2062",
      "title": "H-4: BondOracleAdapter will cause massive loss of funds for a large number of bond tokens",
      "content": "Source: https://github.com/sherlock-audit/2024-12-plaza-finance-judging/issues/440 \n\n## Found by \n0x52, ZoA, bladeee\n\n### Summary\n\nBondOracleAdapter both directly returns the price from the pool and hardcodes the oracle decimals to bondToken.decimals(). The combination of these two factors will cause the adapter to return an incorrect value for any bondToken that is not alphanumerically greater than USDC. The dex pool always prices tokenA in terms of tokenB and because the decimals of the oracle are hardcoded to the decimals of the bond token, the bond token must be tokenB or else the decimals will be incorrect. This incorrect pricing will cause massive loss of funds to user withdrawing from the pool as the market price will be much too low.\n\nWhen initializing the BondOracleAdapter, it pulls the pool address from the getPool mapping. While this will pull the relevant pool for those tokens, it does not ensure that the tokens are in the correct order.\n\n[CLFactory.sol#L91-L93](https://github.com/velodrome-finance/slipstream/blob/7b50de4648ec340891a8d5c1366c83983308d3b9/contracts/core/CLFactory.sol#L91-L93)\n\n        getPool[token0][token1][tickSpacing] = pool;\n        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses\n        getPool[token1][token0][tickSpacing] = pool;\n\nWe see that get pool is populated in both orders even though they are sorted alphanumerically. Therefore when the pool is retrieved for BondOracleAdapter the tokens can be in any order.\n\n[BondOracleAdapter#L113](https://github.com/sherlock-audit/2024-12-plaza-finance/blob/main/plaza-evm/src/BondOracleAdapter.sol#L113)\n\n    return (uint80(0), int256(getPriceX96FromSqrtPriceX96(getSqrtTwapX96)), block.timestamp, block.timestamp, uint80(0));\n\nWe see that when price is returned it is always returned directly as returned by the underlying dex pool. The issues is that if the bond token is not tokenB then the decimal of the return value will be the liquidity token rather than the bond token.\n\n[Pool.sol#L519-L521](https://github.com/sherlock-audit/2024-12-plaza-finance/blob/main/plaza-evm/src/Pool.sol#L519-L521)\n\n    if (marketRate != 0 && marketRate < redeemRate) {\n      redeemRate = marketRate;\n    }\n\nAs a result when redeeming bond tokens the value will be significantly lower than expected and will result in bond holders losing large amounts of value.\n\n### Root Cause\n\n[BondOracleAdapter#L113](https://github.com/sherlock-audit/2024-12-plaza-finance/blob/main/plaza-evm/src/BondOracleAdapter.sol#L113) always return price directly\n\n[BondOracleAdapter.sol#L62](https://github.com/sherlock-audit/2024-12-plaza-finance/blob/main/plaza-evm/src/BondOracleAdapter.sol#L62) always assumes that price is denominated in bond tokens\n\n### Internal Pre-conditions\n\naddress(bondToken) > address(liquidityToken)\n\n### External Pre-conditions\n\nN/A\n\n### Attack Path\n\nN/A\n\n### Impact\n\nLoss of funds for redeeming bond token holders\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nBondOracleAdapter#initialize should set decimals to either bondToken or liquidityToken depending on token order in the pool",
      "summary": "\nThe BondOracleAdapter has a bug that can cause users to lose a lot of money when withdrawing bond tokens from a pool. This happens because the adapter uses the pool price and hardcodes the decimals to the bond token, which can only work for tokens that come after USDC in the alphabet. This incorrect pricing can result in significant losses for users. The bug is caused by the adapter always returning the price directly and assuming that it is denominated in bond tokens. The bug can be prevented by setting the decimals to either the bond token or the liquidity token, depending on the token order in the pool. ",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/682",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-12-plaza-finance-judging/issues/440",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "682",
      "slug": "h-4-bondoracleadapter-will-cause-massive-loss-of-funds-for-a-large-number-of-bond-tokens-sherlock-plaza-finance-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Plaza Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Plaza Finance",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "44372",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "1948",
      "title": "H-2: Attackers can drain the `OracleLess` contract by creating an order with a `malicious tokenIn` and executing it with a `malicious target`.",
      "content": "Source: https://github.com/sherlock-audit/2024-11-oku-judging/issues/357 \n\n## Found by \n0xaxaxa, BugPull, Ragnarok, whitehair0330\n### Summary\n\nIn the `OracleLess` contract, the `createOrder()` function does not verify whether the `tokenIn` is a legitimate ERC20 token, allowing attackers to create an order with a malicious token. Additionally, the `fillOrder()` function does not check if the `target` and `txData` are valid, enabling attackers to execute their order with a malicious `target` and `txData`.\n\n### Root Cause\n\nThe [OracleLess.createOrder()](https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol#L38-L67) function does not verify whether `tokenIn` is a legitimate ERC20 token.\n\nAdditionally, the [OracleLess.fillOrder()](https://github.com/sherlock-audit/2024-11-oku/blob/main/oku-custom-order-types/contracts/automatedTrigger/OracleLess.sol#L103-L148) function does not check if `target` and `txData` are valid.\n\n### Internal pre-conditions\n\n### External pre-conditions\n\n### Attack Path\n\nLet's consider the following scenario:\n\n1. Alice, the attacker, creates a malicious token.\n\n2. Alice creates an order with her malicious token:\n\n    - `tokenIn`: Alice's malicious token\n    - `tokenOut`: `WETH`\n    - `minAmountOut`: 0\n3. Alice calls the `fillOrder()` function to execute her malicious order, setting parameters as follows:\n\n    - `target`: address of `USDT`\n    - `txData`: transfer all `USDT` in the `OracleLess` contract to Alice.\n        ```solidity\n            function fillOrder(\n                ...\n\n        118     (uint256 amountOut, uint256 tokenInRefund) = execute(\n                    target,\n                    txData,\n                    order\n                );\n\n                ...\n            }\n        ```\n    - At line 118 of the `fillOrder()` function, `execute()` is invoked:\n        <details>\n            <summary> execute() </summary>\n\n                function execute(\n                    address target,\n                    bytes calldata txData,\n                    Order memory order\n                ) internal returns (uint256 amountOut, uint256 tokenInRefund) {\n                    //update accounting\n                    uint256 initialTokenIn = order.tokenIn.balanceOf(address(this));\n                    uint256 initialTokenOut = order.tokenOut.balanceOf(address(this));\n\n                    //approve\n            237     order.tokenIn.safeApprove(target, order.amountIn);\n\n                    //perform the call\n            240     (bool success, bytes memory reason) = target.call(txData);\n\n                    if (!success) {\n                        revert TransactionFailed(reason);\n                    }\n\n                    uint256 finalTokenIn = order.tokenIn.balanceOf(address(this));\n                    require(finalTokenIn >= initialTokenIn - order.amountIn, \"over spend\");\n                    uint256 finalTokenOut = order.tokenOut.balanceOf(address(this));\n\n                    require(\n            251         finalTokenOut - initialTokenOut > order.minAmountOut,\n                        \"Too Little Received\"\n                    );\n\n                    amountOut = finalTokenOut - initialTokenOut;\n                    tokenInRefund = order.amountIn - (initialTokenIn - finalTokenIn);\n                }\n        </details>\n        \n        - At line 237 of the `execute()` function, `tokenIn.safeApprove()` is called. Alice made her malicious `tokenIn` as follows:\n            ```solidity\n                function approve(address spender, uint256 amount) public virtual override returns (bool) {\n                    WETH.transfer(msg.sender, 1);\n                    return true;\n                }\n            ```\n            This transfers 1 wei of `WETH` to the `OracleLess` contract.\n        - At line 240, all `USDT` are transferred to Alice, as `target` is `USDT` and `txData` is set to transfer to Alice.\n        - At line 251, `finalTokenOut - initialTokenOut` will be 1, as the contract has already received 1 wei. Thus, the require statement will pass since `order.minAmountOut` was set 0.\n\nAs a result, Alice can drain all `USDT` from the `OracleLess` contract.\n\n### Impact\n\nAttackers can drain the `OracleLess` contract by using malicious `token`, `target`, and `txData`.\n\n### PoC\n\n### Mitigation\n\nIt is recommended to implement a whitelist mechanism for `token`, `target`, and `txData`.",
      "summary": "\nThe `OracleLess` contract has a vulnerability that allows attackers to drain all `USDT` from the contract. This is caused by the `createOrder()` function not verifying if the `tokenIn` is a legitimate ERC20 token and the `fillOrder()` function not checking if the `target` and `txData` are valid. This allows attackers to create an order with a malicious token and execute it with a malicious `target` and `txData`, resulting in all `USDT` being transferred to the attacker. A recommended solution is to implement a whitelist mechanism for `token`, `target`, and `txData` to prevent this vulnerability.",
      "report_date": {},
      "contest_prize_txt": "14600 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/641",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-11-oku-judging/issues/357",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "641",
      "slug": "h-2-attackers-can-drain-the-oracleless-contract-by-creating-an-order-with-a-malicious-tokenin-and-executing-it-with-a-malicious-target-sherlock-okus-new-order-types-contract-contest-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Oku's New Order Types Contract Contest",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Oku's New Order Types Contract Contest",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "49820",
      "kind": "GIT",
      "auditfirm_id": "20",
      "impact": "HIGH",
      "finders_count": 30,
      "protocol_id": "1896",
      "title": "Potential underflow vulnerability in score range calculation of `LLMOracleCoordinator::finalizeValidation`, leading to DoS.",
      "content": "## Summary\n\nThe `LLMOracleCoordinator::finalizeValidation` function calculates the range for valid scores depending on the result of the expression `score >= _mean - _stddev`. If `_mean` is less than `_stddev`, this calculation leads to an underflow error, causing a revert that will fail the transaction. This behavior prevents successful validation completion and rewards distribution, disrupting normal contract operations and usability.\n\n## Description\n\nIn the `LLMOracleCoordinator::finalizeValidation` function, scores are evaluated within a standard deviation range around the mean, using the criteria `(_mean - _stddev)` and `(_mean + _stddev)`, see \\[<https://github.com/Cyfrin/2024-10-swan-dria/blob/main/contracts/llm/LLMOracleCoordinator.sol#L343>]:\n\n```js\nif ((score >= _mean - _stddev) && (score <= _mean + _stddev))\n```\n\nHowever, in cases where `_mean < _stddev`, such as some valid edge case where for example `scores[] = [0,1,0,1,2]`, the calculation of `_mean - _stddev` attempts to produce a negative value.\n\nSince Solidity’s uint256 type does not support negative numbers, this results in an underflow, triggering an automatic revert and causing the transaction to fail. The edge case described results in `_stddev = 1` and `_mean = 0`, which causes the check `score >= _mean - _stddev` to revert, as `_mean - _stddev` evaluates to a negative result.\n\nThe same issue exists also in \\[<https://github.com/Cyfrin/2024-10-swan-dria/blob/main/contracts/llm/LLMOracleCoordinator.sol#L368>]:\n\n### Exploit Scenario\n\nFor the input `scores[] = [0, 1, 0, 1, 2]`, the standard deviation and mean calculated by `Statistics.stddev(scores)` in `LLMOracleCoordinator::finalizeValidation` are `_stddev = 1` and `_mean = 0`. Note that the calculation using the `Statistics.sol` library would be successful in this case. That can be quickly checked in Remix:\n\n```js\ndecoded input\t{\n\t        \"uint256[] data\": [\n\t\t            \"0\",\n\t\t            \"1\",\n\t\t            \"0\",\n\t\t            \"1\",\n\t\t            \"2\"\n\t            ]}\ndecoded output\t{\n\t        \"0\": \"uint256: ans 1\",\n\t        \"1\": \"uint256: mean 0\"\n                }\n```\n\nWhen performing the range check in `(score >= _mean - _stddev)` (see \\[<https://github.com/Cyfrin/2024-10-swan-dria/blob/main/contracts/llm/LLMOracleCoordinator.sol#L343>]), the `_mean - _stddev` calculation attempts to compute 0 - 1, which underflows as it is not representable within the unsigned integer type, triggering a revert. The same problem was also found at \\[<https://github.com/Cyfrin/2024-10-swan-dria/blob/main/contracts/llm/LLMOracleCoordinator.sol#L368>].\n\n### PoC\n\nFor the proof of concept, we will stick to the same score values as shown in the section above. Here is the test case and setup, please paste it into the `LLMOracleCoordinator.test.ts` file and adjust the `this.beforeAll(async function ())` section with additional validators, like this:\n\n```js\n// Add validators to the setUp\nthis.beforeAll(async function () {\n    // assign roles, full = oracle that can do both generation & validation\n    const [deployer, dum, req1, gen1, gen2, gen3, gen4, gen5, val1, val2, val3, val4, val5] = await ethers.getSigners();\n    dria = deployer;\n    requester = req1;\n    dummy = dum;\n    generators = [gen1, gen2, gen3, gen4, gen5];\n    validators = [val1, val2, val3, val4, val5];\n    ...........\n    ...........\n    ...........\ndescribe(\"underflow in score range calculation\", function () {\n    const [numGenerations, numValidations] = [1, 5];\n    const scores = [\n        parseEther(\"0\"), \n        parseEther(\"0.000000000000000001\"),  \n        parseEther(\"0\"),\n        parseEther(\"0.000000000000000001\"),\n        parseEther(\"0.000000000000000002\")\n    ];\n    let generatorAllowancesBefore: bigint[];\n    let validatorAllowancesBefore: bigint[];\n\n    this.beforeAll(async () => {\n        taskId++;\n\n        generatorAllowancesBefore = await Promise.all(\n            generators.map((g) => token.allowance(coordinatorAddress, g.address))\n        );\n        validatorAllowancesBefore = await Promise.all(\n            validators.map((v) => token.allowance(coordinatorAddress, v.address))\n        );\n    });\n\n    it(\"should make a request\", async function () {\n        await safeRequest(coordinator, token, requester, taskId, input, models, {\n            difficulty,\n            numGenerations,\n            numValidations,\n        });\n    });\n\n    it(\"should respond to each generation\", async function () {\n      const availableGenerators = generators.length;\n      const generationsToRespond = Math.min(numGenerations, availableGenerators);\n  \n      expect(availableGenerators).to.be.at.least(generationsToRespond);\n  \n      for (let i = 0; i < generationsToRespond; i++) {\n          await safeRespond(coordinator, generators[i], output, metadata, taskId, BigInt(i));\n      }\n    });\n\n\n    // UNDERFLOW TEST\n    it(\"it should underflow calculating score ranges for inner mean\", async function () {\n      const requestBefore = await coordinator.requests(taskId);\n      console.log(`Request status before validation: ${requestBefore.status}`);\n  \n      for (let i = 0; i < numValidations; i++) {\n          console.log(`Validating with validator at index ${i} with address: ${validators[i].address}`);\n          console.log(`Score being used: ${scores[i].toString()}, Task ID: ${taskId}`);\n  \n\n          try {\n              if (i < numValidations - 1) {\n                  \n                  await safeValidate(coordinator, validators[i], [scores[i]], metadata, taskId, BigInt(i));\n                  console.log(`Validation succeeded for validator at index ${i}`);\n              } else {\n                // For the last validator, expect a revert without a specific error\n                await safeValidate(coordinator, validators[i], [scores[i]], metadata, taskId, BigInt(i));\n                console.log(`Validation succeeded for validator at index ${i}`); // This should not run if it reverts\n            }\n          } catch (error:any) {\n              if (i < numValidations - 1) {\n                  console.error(`Validation failed for validator at index ${i} with error: ${error.message}`);\n              } else {\n                if (error instanceof Error) {\n                  console.error(`Validation failed for validator at index ${i}: ${error.message}`);\n              } else {\n                  console.error(`Validation failed for validator at index ${i}: ${JSON.stringify(error)}`);\n              }\n            }\n          }\n      }\n  \n      // Confirm the tasks status\n      const finalRequest = await coordinator.requests(taskId);\n      console.log(`Request status after all validations: ${finalRequest.status}`);\n  \n      // Confirm the status is still 'PendingValidation'\n      expect(finalRequest.status).to.equal(TaskStatus.PendingValidation);\n    }); \n  });\n\n```\n\nThe test can be run with `yarn test ./test/LLMOracleCoordinator.test.ts --verbose` .\nHere are the logs:\n\n```js\nRequest status before validation: 2\nValidating with validator at index 0 with address: 0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f\nScore being used: 0, Task ID: 3\nValidation succeeded for validator at index 0\nValidating with validator at index 1 with address: 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720\nScore being used: 1, Task ID: 3\nValidation succeeded for validator at index 1\nValidating with validator at index 2 with address: 0xBcd4042DE499D14e55001CcbB24a551F3b954096\nScore being used: 0, Task ID: 3\nValidation succeeded for validator at index 2\nValidating with validator at index 3 with address: 0x71bE63f3384f5fb98995898A86B02Fb2426c5788\nScore being used: 1, Task ID: 3\nValidation succeeded for validator at index 3\nValidating with validator at index 4 with address: 0xFABB0ac9d68B0B445fB7357272Ff202C5651694a\nScore being used: 2, Task ID: 3\nValidation failed for validator at index 4: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation overflowed outside of an unchecked block)\nRequest status after all validations: 2\n```\n\nAs you can see from the error logs, the transaction failed with an error message: `panic code 0x11 (Arithmetic operation overflowed outside of an unchecked block)`. And the problem was not the use of a buggy `Statistics.sol` library, but the logic behind the score range calculation in `LLMOracleCoordinator::finalizeValidation`.\n\n## Impact\n\nTasks with scores causing `_mean < _stddev` cannot complete, leading to a halt in the validation process and blocking reward distribution. Since scores submitted by prior validators to the `TaskValidation` struct array are immutable, tasks may become permanently locked in `PendingValidation` status, posing a potential DoS vulnerability.\n\n## Tools Used\n\nManual Code Review, Remix, Hardhat\n\n## Recommendations\n\n`LLMOracleCoordinator::finalizeValidation` needs to be refactored. You could think about rewriting both underflow-prone conditions in `finalizeValidation` using only addition operations, adjusting the logic to avoid subtraction:\n\n```diff\n\nfor (uint256 v_i = 0; v_i < task.parameters.numValidations; ++v_i) {\n    uint256 score = scores[v_i];\n-    if ((score >= _mean - _stddev) && (score <= _mean + _stddev)) {\n+    if ((score + _stddev >= _mean) && (score <= _mean + _stddev))\n        innerSum += score;\n        innerCount++;\n\n        _increaseAllowance(validations[taskId][v_i].validator, task.validatorFee);\n        }\n    }\n    ........\n    ........\nfor (uint256 g_i = 0; g_i < task.parameters.numGenerations; g_i++) {\n    // ignore lower outliers\n-    if (generationScores[g_i] >= mean - generationDeviationFactor * stddev) {\n+    if (generationScores[g_i] + generationDeviationFactor * stddev >= mean)    \n        _increaseAllowance(responses[taskId][g_i].responder, task.generatorFee);\n    }\n}\n```\n\nAfter applying the suggested fixes, the issues are mitigated. Adjust the last line in the PoC to `expect(finalRequest.status).to.equal(TaskStatus.Completed);` and run the test with `yarn test ./test/LLMOracleCoordinator.test.ts`, it will pass.",
      "summary": "\nThis bug report discusses a potential issue in the code of the `LLMOracleCoordinator` contract that could lead to a denial of service (DoS) attack. The function `finalizeValidation` is responsible for calculating the range of valid scores for a task. However, if the mean (average) score is lower than the standard deviation (a measure of how spread out the scores are), an underflow error can occur. This causes the transaction to fail and prevents the task from being completed, disrupting the normal operation of the contract.\n\nThe bug can be triggered by a specific set of scores, such as [0, 1, 0, 1, 2]. In this case, the calculation attempts to produce a negative number, which is not supported by the unsigned integer type used in the contract. This results in a revert and the task becoming permanently stuck in the validation process.\n\nThe bug was discovered through a manual code review and can be replicated using Remix and Hardhat. To fix the issue, the `finalizeValidation` function should be refactored to avoid subtraction and use only addition operations. After applying the suggested fix, the bug is mitigated and the test passes. ",
      "report_date": {},
      "contest_prize_txt": "21000 USDC",
      "contest_link": "https://codehawks.cyfrin.io/c/cm2ooiwzk0003mx0tt5wiu88x",
      "sponsor_name": "Swan",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/Cyfrin/2024-10-swan-dria",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "cm2ooiwzk0003mx0tt5wiu88x",
      "slug": "potential-underflow-vulnerability-in-score-range-calculation-of-llmoraclecoordinatorfinalizevalidation-leading-to-dos-codehawks-swan-dria-git",
      "firm_name": "Codehawks",
      "firm_logo_square": "codehawks_square.png",
      "protocol_name": "Dria",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Codehawks",
        "logo_square": "codehawks_square.png"
      },
      "protocols_protocol": {
        "name": "Dria",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "36224",
      "kind": "GIT",
      "auditfirm_id": "20",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "1431",
      "title": "LibUsdOracle returns the wrong price for Uniswap Oracle",
      "content": "## Vulnerability Details\n\nThe Generalised Oracle is broken for the external tokens that use Uniswap. This is happening for two reasons: \n\n1. The token passed as a base token for the `OracleLibrary.getQuoteAtTick` is incorrect. The base token should be the token the protocol wants to fetch the price from, not the quote token. Take into consideration the following scenario: Fetching the price for WBTC. \n\n```Solidity\n            // LibUsdOracle -> getTokenPriceFromExternal\n            address chainlinkToken = IUniswapV3PoolImmutables(oracleImpl.target).token0();\n            chainlinkToken = chainlinkToken == token\n                ? IUniswapV3PoolImmutables(oracleImpl.target).token1()\n                : token;\n            tokenPrice = LibUniswapOracle.getTwap(\n                lookback == 0 ? LibUniswapOracle.FIFTEEN_MINUTES : uint32(lookback),\n                oracleImpl.target,\n@>                chainlinkToken, // @audit baseToken: chainlinkToken is USDC\n                token, // @audit quoteToken - WBTC\n                uint128(10) ** uint128(IERC20Decimals(token).decimals()) // @audit base token amount\n```\n\nThe function getTwap: \n\n```Solidity\n    function getTwap(\n        uint32 lookback,\n        address pool,\n        address token1, // @audit USDC\n        address token2, // @audit WBTC\n        uint128 oneToken // @audit 1e8\n    ) internal view returns (uint256 price) {\n        (bool success, int24 tick) = consult(pool, lookback);\n        if (!success) return 0;\n@>        price = OracleLibrary.getQuoteAtTick(tick, oneToken, token1, token2); // @audit token1 == USDC \n    }\n```\n\nDue to this, the protocol is trying to fetch the price of the amount 1e8 in USDC, using as quote price `WBTC`, instead of the intended behavior that should be quoting the price of 1 WBTC(1e8) in USDC. \n\n* The second issue is that the `getTwap` function can return values with varying decimals. The protocol assumes a 6-decimal return value, but some stablecoins, like `DAI`, have 18 decimals.\n\nNotice that at the end of the flow for returning the price on the `getTokenPriceFromExternal` the token price is divided by 6.\n\n```Solidity\n  uint256 chainlinkTokenPrice = LibChainlinkOracle.getTokenPrice(\n                chainlinkOraclePriceAddress,\n                LibChainlinkOracle.FOUR_HOUR_TIMEOUT,\n                lookback\n            );\n  return tokenPrice.mul(chainlinkTokenPrice).div(1e6); // @audit assume uniswap price is 6 decimals \n```\n\nIf the quote token is DAI, for instance, the value will be significantly higher than expected in the `LibUsdOracle`. All other oracles in the protocol, such as `LibChainlinkOracle` and `LibWsethUsdOracle`, return values based on 6 decimals. The `LibUniswapOracle` has worked well so far because Beanstalk hasn't introduced stablecoins with decimals != 6. Therefore, the `getTwap` function should be modified to return values quoted with 6 decimals.\n\n## Impact\n\n* LibUsdOracle can't return the correct price for any external token using Uniswap as Oracle. \n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\n1. 1st: Use `token` as the base token to ensure the `chainlinkToken` (quote token) returns the correct price.\n\n```diff\n\n            tokenPrice = LibUniswapOracle.getTwap(\n                lookback == 0 ? LibUniswapOracle.FIFTEEN_MINUTES : uint32(lookback),\n                oracleImpl.target,\n-                chainlinkToken,\n-                token,\n+                token,\n+                chainlinkToken,\n                uint128(10) ** uint128(IERC20Decimals(token).decimals())\n            );\n```\n\n* 2nd: Modify the `getTwap` function to always return the value in 6 decimal precision. Additionally, rename the variables for better clarity and usability.\n\n```diff\n+   uint256 constant PRECISION = 1e6;\n+\n+ /**\n+ * @notice Given a tick and a token amount, calculates the amount of token received in exchange\n+ * @param baseTokenAmount Amount of baseToken to be converted.\n+ * @param baseToken Address of the ERC20 token contract used as the baseAmount denomination.\n+ * @param quoteToken Address of the ERC20 token contract used as the quoteAmount denomination.\n+ * @return price Amount of quoteToken. Value has 6 decimal precision.\n+ */\nfunction getTwap(\n        uint32 lookback,\n        address pool,\n-        address token1,\n-        address token2,\n-        uint128 oneToken\n+        address baseToken,\n+        address quoteToken,\n+        uint128 baseTokenAmount\n    ) internal view returns (uint256 price) {\n        (bool success, int24 tick) = consult(pool, lookback);\n        if (!success) return 0;\n-        price = OracleLibrary.getQuoteAtTick(tick, oneToken, token1, token2);\n+        price = OracleLibrary.getQuoteAtTick(tick, baseTokenAmount, baseToken, quoteToken);\n\n+         uint256 baseTokenDecimals = IERC20Decimals(baseToken).decimals();\n+         uint256 quoteTokenDecimals = IERC20Decimals(quoteToken).decimals();\n+         int256 factor = int256(baseTokenDecimals) - int256(quoteTokenDecimals);\n+          \n+         // decimals are the same. i.e. DAI/WETH\n+         if (factor == 0) return price.mul(PRECISION).div(baseTokenDecimals);\n+\n+        // scale decimals\n+        if (factor > 0) {\n+            price = price.mul(10 ** uint256(factor));\n+        } else {\n+            price = price.div(10 ** uint256(-factor));\n+        }\n+\n+        // set 1e6 precision\n+        price.mul(PRECISION).div(baseTokenDecimals);\n\n    }\n```\n\nUnit tests \n\n* Change the `OracleDeployer` file to use the correct values(ticks, price) for the pools. The values for the WBTC/USDC for instance are not correct, which leads to a faulty test on `oracle.t.sol`to pass. This data can be extracted here: <https://etherscan.io/address/0x99ac8cA7087fA4A2A1FB6357269965A2014ABc35#readContract>",
      "summary": "\nThe LibUsdOracle is not returning the correct price for external tokens that use Uniswap as their oracle. This is due to two reasons: the base token being used is incorrect and the getTwap function can return values with varying decimals. This causes the LibUsdOracle to not return the correct price for any external tokens using Uniswap as their oracle. The issue can be fixed by using the token as the base token and modifying the getTwap function to always return values with 6 decimal precision. It is also recommended to update the OracleDeployer file with correct values for WBTC/USDC to ensure accurate testing. ",
      "report_date": {},
      "contest_prize_txt": "250000 USDC",
      "contest_link": "https://codehawks.cyfrin.io/c/clw9e11e4001gdv0iigjylx5n",
      "sponsor_name": "Beanstalk",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/Cyfrin/2024-05-beanstalk-the-finale",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "clw9e11e4001gdv0iigjylx5n",
      "slug": "libusdoracle-returns-the-wrong-price-for-uniswap-oracle-codehawks-beanstalk-the-finale-git",
      "firm_name": "Codehawks",
      "firm_logo_square": "codehawks_square.png",
      "protocol_name": "Beanstalk: The Finale",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Codehawks",
        "logo_square": "codehawks_square.png"
      },
      "protocols_protocol": {
        "name": "Beanstalk: The Finale",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "36223",
      "kind": "GIT",
      "auditfirm_id": "20",
      "impact": "HIGH",
      "finders_count": 5,
      "protocol_id": "1431",
      "title": "LibUsdOracle will compromise Beanstalk peg due to wrong price and DoS",
      "content": "## Vulnerability Details\n\nThe function `getUsdPrice`from `LibUsdOracle` should return the token value in USD.  For example, one of its consumers is the function [`getMintFertilizerOut`](https://github.com/Cyfrin/2024-05-beanstalk-the-finale/blob/4e0ad0b964f74a1b4880114f4dd5b339bc69cd3e/protocol/contracts/beanstalk/barn/FertilizerFacet.sol#L117-L122):\n\n`fertilizerAmountOut = tokenAmountIn.div(LibUsdOracle.getUsdPrice(barnRaiseToken));`\n\nThe goal of this function is to return the fertilizer amount with 0 decimals, therefore if the WETH value is at \\$1000 and the user would provide 1 WETH:\n\n`tokenAmountIn = 1e18.div(1e15) = 1e3 = 1000`\n\nAnother critical use case for `getUsdPrice` is: fetching the ratios to calculate the deltaB.\n\n```solidity\n function getRatiosAndBeanIndex(\n        IERC20[] memory tokens,\n        uint256 lookback\n    ) internal view returns (uint[] memory ratios, uint beanIndex, bool success) {\n        success = true;\n        ratios = new uint[](tokens.length);\n        beanIndex = type(uint256).max;\n        for (uint i; i < tokens.length; ++i) {\n            if (C.BEAN == address(tokens[i])) {\n                beanIndex = i;\n                ratios[i] = 1e6;\n            } else {\n@>                ratios[i] = LibUsdOracle.getUsdPrice(address(tokens[i]), lookback); // @audit expect value return in USD\n                if (ratios[i] == 0) {\n                    success = false;\n                }\n            }\n        }\n        require(beanIndex != type(uint256).max, \"Bean not in Well.\");\n    }\n```\n\nThe function `getRatiosAndBeanIndex` is used throughout the system, including in processes like `Sunrise` and `Convert`, to help Bean maintain its peg.\n\n* The first issue is that the price returned by `getUsdPrice` will be incorrect for tokens that use \"external oracle\" due to the duplicated division using `1e24`.\n\n```solidity\n// getUsdPrice\n\n@>        uint256 tokenPrice = getTokenPriceFromExternal(token, lookback);\n        if (tokenPrice == 0) return 0;\n@>        return uint256(1e24).div(tokenPrice);\n\n\n// getTokenPriceFromExternal\n\n//returns uint256(1e24).div(result from chainlink with 6 decimals)\n            return\n@>                uint256(1e24).div(\n                    LibChainlinkOracle.getTokenPrice(\n                        chainlinkOraclePriceAddress,\n                        LibChainlinkOracle.FOUR_HOUR_TIMEOUT,\n                        lookback\n                    )\n                );\n\n```\n\nThis will result in an inaccurate price. For example, when the price of WBTC is \\$50,000, it will return `50000e6` instead of the correct value `2e13`. This discrepancy will cause Beanstalk to consider an erroneous ratio, resulting in an incorrect DeltaB.\n\nBeanstalk uses deltaB to determine:\n\n* Whether the system is Above or below the peg\n* Sow and Pods(issuing debt)\n* Flood\n* Convert\n\nIn a nutshell, all components from Beanstalk will be affected by DeltaBs originating from tokens using Oracle with encodedType `0x01`. \n\n* The second issue is that the `getTokenPriceFromExternal` doesn't check for the return from the Oracle value before div:\n\n```solidity\n return\n@>                uint256(1e24).div(\n                    LibChainlinkOracle.getTokenPrice(\n                        chainlinkOraclePriceAddress,\n                        LibChainlinkOracle.FOUR_HOUR_TIMEOUT,\n                        lookback\n                    )\n                );\n```\n\nWhen the Chainlink Oracle fails to fetch the price it returns 0. Hence, the function will revert due to `uint256(1e24).div(0)`.\n\n## PoC\n\n1. For the incorrect price:\n\nAdd the following test on `oracle.t.sol`\n\n```solidity\nfunction test_getUsdPrice_whenExternalToken_priceIsInvalid() public {\n        // pre condition: encode type 0x01 \n\n        // WETH price is 1000\n        uint256 priceWETH = OracleFacet(BEANSTALK).getUsdPrice(C.WETH);\n        assertEq(priceWETH, 1e15);  //  1e18/1e3 = 1e15\n\n        // WBTC price is 50000\n        uint256 priceWBTC = OracleFacet(BEANSTALK).getUsdPrice(WBTC);\n        assertEq(priceWBTC, 2e13); // 1e24.div(50000e6) = 2e13\n    }\n```\n\nRun: `forge test --match-test test_getUsdPrice_whenExternalToken_priceIsInvalid`\n\nOutput:\n\n```javascript\nFailing tests:\nEncountered 1 failing test in test/foundry/silo/oracle.t.sol:OracleTest\n[FAIL. Reason: assertion failed: 50000000000 != 20000000000000] test_getUsdPrice_whenExternalToken_priceIsInvalid() (gas: 64594)\n```\n\n1. For the DoS when Chainlink oracle returns 0:\n   Add this test on `oracle.t.sol`\n\n```solidity\n// first -  import {MockChainlinkAggregator} from \"contracts/mocks/chainlink/MockChainlinkAggregator.sol\";\n\nfunction test_getUsdPrice_willDoS_whenOracleFail() public { \n        // pre condition: encode type 0x01 and oracle fail\n        MockChainlinkAggregator(WBTC_USD_CHAINLINK_PRICE_AGGREGATOR).setOracleFailure();\n\n        // action\n        vm.expectRevert();\n        OracleFacet(BEANSTALK).getUsdPrice(WBTC);\n    }\n```\n\nRun: `forge test --match-test test_getUsdPrice_willDoS_whenOracleFail`\n\nOutput:\n\n```javascript\nRan 1 test for test/foundry/silo/oracle.t.sol:OracleTest\n[PASS] test_getUsdPrice_willDoS_whenOracleFail() (gas: 21500)\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 259.13ms\n```\n\n## Impact\n\nHigh.\n\n* Incorrect price: This will compromise the entire system, as all peg-related components, including Sunrise and Convert, depend on the price.\n* DoS: Sunrise will revert and disrupt all other components that rely on the price.  The risk of a DoS is increased due to `stepOracle` calling multiple tokens(instead of one as previously) to fetch their prices, raising the chances of an Oracle failure.\n\n## Tools Used\n\nManual Review & Foundry\n\n## Recommendations\n\n* To fix both issues: On `getTokenPriceFromExternal` return the price from Chainlink directly, instead of scaling it.\n\n```diff\nreturn LibChainlinkOracle.getTokenPrice(\n                        chainlinkOraclePriceAddress,\n                        LibChainlinkOracle.FOUR_HOUR_TIMEOUT,\n                        lookback\n                    );\n```",
      "summary": "\nThis bug report discusses a vulnerability in the LibUsdOracle function that could compromise the Beanstalk peg and cause a Denial of Service (DoS). The function `getUsdPrice` is supposed to return the token value in USD, but it has two issues. \n\nThe first issue is that the price returned by `getUsdPrice` will be incorrect for tokens that use an \"external oracle\" due to a duplicated division using `1e24`. This means that the price will be inaccurate, which can cause Beanstalk to consider an erroneous ratio, resulting in an incorrect DeltaB. This affects all components of Beanstalk that rely on DeltaB, including determining whether the system is above or below the peg, issuing debt, and converting tokens.\n\nThe second issue is that the `getTokenPriceFromExternal` function does not check for the return value from the Oracle before dividing. This means that if the Chainlink Oracle fails to fetch the price, the function will revert due to `uint256(1e24).div(0)`, causing a DoS.\n\nTo demonstrate these issues, tests were created that showed incorrect prices and DoS when the Chainlink Oracle fails. The impact of these issues is high, as they can compromise the entire system and disrupt all components that rely on the price. To fix these issues, the recommendation is to return the price from Chainlink directly instead of scaling it. ",
      "report_date": {},
      "contest_prize_txt": "250000 USDC",
      "contest_link": "https://codehawks.cyfrin.io/c/clw9e11e4001gdv0iigjylx5n",
      "sponsor_name": "Beanstalk",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/Cyfrin/2024-05-beanstalk-the-finale",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "clw9e11e4001gdv0iigjylx5n",
      "slug": "libusdoracle-will-compromise-beanstalk-peg-due-to-wrong-price-and-dos-codehawks-beanstalk-the-finale-git",
      "firm_name": "Codehawks",
      "firm_logo_square": "codehawks_square.png",
      "protocol_name": "Beanstalk: The Finale",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Codehawks",
        "logo_square": "codehawks_square.png"
      },
      "protocols_protocol": {
        "name": "Beanstalk: The Finale",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "36221",
      "kind": "GIT",
      "auditfirm_id": "20",
      "impact": "HIGH",
      "finders_count": 10,
      "protocol_id": "1431",
      "title": "`LibChainlinkOracle::getTokenPrice` will always return instantaneuous prices",
      "content": "## Summary\n\nThe `LibChainlinkOracle::getTokenPrice` function has a parameter of `lookback` in order to determine how many seconds ago do we want to obtain the twap of a chainlink price feed. However, this is implemented in a wrong way\n\n## Relevant GitHub Links:\nhttps://github.com/Cyfrin/2024-05-beanstalk-the-finale/blob/main/protocol/contracts/libraries/Oracle/LibChainlinkOracle.sol#L39-L48\n\n## Vulnerability Details\n\nWhen `LibChainlinkOracle::getTokenPrice` is called, it returns a different price calculation depending on the `lookback` parameter passed to the function:\n\n```Solidity\n    function getTokenPrice(\n        address priceAggregatorAddress,\n        uint256 maxTimeout,\n        uint256 lookback\n    ) internal view returns (uint256 price) {\n        return\n            lookback > 0\n                ? getPrice(priceAggregatorAddress, maxTimeout)\n                : getTwap(priceAggregatorAddress, maxTimeout, lookback);\n    }\n```\n\nIn this case the ternary operator returns the function `getPrice` (instantaneous price) when lookback > 0 and `getTwap` when lookback == 0. As we can see, the conditional for returning the different price computation is wrong because it returns the twap price when lookback = 0, which is basically the instantaneous price and it returns the current price when the lookback parameter is greater than 0, when it should return the twap according to the amount of lookback passed.\n\nThe correct behaviour should be that when `lookback` is set to 0, it should return the instantaneous price \"`getPrice`\" and when it is greater than 0 it should return the \"`getTwap`\" function passing it the lookback parameter.\n\n## Impact\n\nMedium, no matter what `lookback` will be, the instantaneous price from the chainlink oracle will be returned.\n\nChainlink is not manipulable but the functionality clearly does not work as intended and can return unexpected results.\n\n## Tools Used\n\nManual review\n\n## Recommendations\n\n```diff\n    function getTokenPrice(\n        address priceAggregatorAddress,\n        uint256 maxTimeout,\n        uint256 lookback\n    ) internal view returns (uint256 price) {\n        return\n-            lookback > 0\n+            lookback == 0\n                ? getPrice(priceAggregatorAddress, maxTimeout)\n                : getTwap(priceAggregatorAddress, maxTimeout, lookback);\n    }\n```",
      "summary": "\nSummary:\n\nThe function `LibChainlinkOracle::getTokenPrice` is supposed to return a price based on a certain time period called `lookback`. However, due to a mistake in the code, the function always returns the instantaneous price, regardless of the `lookback` value. This can lead to unexpected results and needs to be fixed. The recommended solution is to change the conditional statement in the code to correctly return the twap price when `lookback` is greater than 0 and the instantaneous price when `lookback` is equal to 0. Manual review was used to identify this issue. ",
      "report_date": {},
      "contest_prize_txt": "250000 USDC",
      "contest_link": "https://codehawks.cyfrin.io/c/clw9e11e4001gdv0iigjylx5n",
      "sponsor_name": "Beanstalk",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/Cyfrin/2024-05-beanstalk-the-finale",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "clw9e11e4001gdv0iigjylx5n",
      "slug": "libchainlinkoraclegettokenprice-will-always-return-instantaneuous-prices-codehawks-beanstalk-the-finale-git",
      "firm_name": "Codehawks",
      "firm_logo_square": "codehawks_square.png",
      "protocol_name": "Beanstalk: The Finale",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Codehawks",
        "logo_square": "codehawks_square.png"
      },
      "protocols_protocol": {
        "name": "Beanstalk: The Finale",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "31171",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "1321",
      "title": "H-2: Requested oracle versions, which have expired, must return this oracle version as invalid, but they return it as a normal version with previous version's price instead",
      "content": "Source: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/6 \n\n## Found by \nbin2chen, panprog\n## Summary\n\nEach market action requests a new oracle version which must be commited by the keepers. However, if keepers are unable to commit requested version's price (for example, no price is available at the time interval, network or keepers are down), then after a certain timeout this oracle version will be commited as invalid, using the previous valid version's price.\n\nThe issue is that when this expired oracle version is used by the market (using `oracle.at`), the version returned will be valid (`valid = true`), because oracle returns version as invalid only if `price = 0`, but the `commit` function sets the previous version's price for these, thus it's not 0.\n\nThis leads to market using invalid versions as if they're valid, keeping the orders (instead of invalidating them), which is a broken core functionality and a security risk for the protocol.\n\n## Vulnerability Detail\n\nWhen requested oracle version is commited, but is expired (commited after a certain timeout), the price of the previous valid version is set to this expired oracle version:\n```solidity\nfunction _commitRequested(OracleVersion memory version) private returns (bool) {\n    if (block.timestamp <= (next() + timeout)) {\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\n        _prices[version.timestamp] = version.price;\n    } else {\n        // @audit previous valid version's price is set for expired version\n        _prices[version.timestamp] = _prices[_global.latestVersion]; \n    }\n    _global.latestIndex++;\n    return true;\n}\n```\n\nLater, `Market._processOrderGlobal` reads the oracle version using the `oracle.at`, invalidating the order if the version is invalid:\n```solidity\nfunction _processOrderGlobal(\n    Context memory context,\n    SettlementContext memory settlementContext,\n    uint256 newOrderId,\n    Order memory newOrder\n) private {\n    OracleVersion memory oracleVersion = oracle.at(newOrder.timestamp);\n\n    context.pending.global.sub(newOrder);\n    if (!oracleVersion.valid) newOrder.invalidate();\n```\n\nHowever, expired oracle version will return `valid = true`, because this flag is only set to `false` if `price = 0`:\n```solidity\nfunction at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n    (oracleVersion.timestamp, oracleVersion.price) = (timestamp, _prices[timestamp]);\n    oracleVersion.valid = !oracleVersion.price.isZero(); // @audit <<< valid = false only if price = 0\n}\n```\n\nThis means that `_processOrderGlobal` will treat this expired oracle version as valid and won't invalidate the order.\n\n## Impact\n\nMarket uses invalid (expired) oracle versions as if they're valid, keeping the orders (instead of invalidating them), which is a broken core functionality and a security risk for the protocol.\n\n## Code Snippet\n\n`KeeperOracle._commitRequested` sets `_prices` to the last valid version's price for expired versions:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol#L153-L162\n\n`Market._processOrderGlobal` reads the oracle version using the `oracle.at`, invalidating the order if the version is invalid:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L604-L613\n\n`KeeperOracle.at` returns `valid = false` only if `price = 0`, but since expired version has valid price, it will be returned as a valid version:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol#L109-L112\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd validity map along with the price map to `KeeperOracle` when recording commited price.\n\n\n\n## Discussion\n\n**nevillehuang**\n\n@arjun-io @panprog @bin2chen66 For the current supported tokens in READ.ME, I think medium severity remains appropriate given they are both stablecoins. Do you agree?\n\n**arjun-io**\n\n> @arjun-io @panprog @bin2chen66 For the current supported tokens in READ.ME, I think medium severity remains appropriate given they are both stablecoins. Do you agree?\n\nI'm not entirely sure how the stablecoin in use matters here? Returning an invalid versions as valid can be very detrimental in markets where invalid versions can be triggered at will (such as in markets that close) which can result in users being able to open or close positions when they shouldn't be able to\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/equilibria-xyz/perennial-v2/pull/308",
      "summary": "\nThis bug report is about an issue where requested oracle versions that have expired are not being handled correctly. Instead of being marked as invalid, they are being treated as valid and given the previous version's price. This can cause problems in the market as it may result in orders being kept open instead of being invalidated. This bug has been found by bin2chen and panprog and is considered a medium severity issue. The team has fixed this issue in the latest update. ",
      "report_date": {},
      "contest_prize_txt": "65500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/254",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/6",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "254",
      "slug": "h-2-requested-oracle-versions-which-have-expired-must-return-this-oracle-version-as-invalid-but-they-return-it-as-a-normal-version-with-previous-versions-price-instead-sherlock-perennial-v2-update-2-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Perennial V2 Update #2",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Perennial V2 Update #2",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Oracle"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "26484",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "1078",
      "title": "M-2: commitRequested() front-run  malicious invalid oralce",
      "content": "Source: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/27 \n\n## Found by \nbin2chen\nBoth `commitRequested()` and `commit()` can modify `lastCommittedPublishTime`, and both check that they cannot `pythPrice.publishTime<=lastCommittedPublishTime`.\nThis allows a malicious user to front-run `commitRequested()` to execute `commit()`, causing `commitRequested()` to revert, invalid oralce\n\n## Vulnerability Detail\n\nExecution of the `commitRequested()` method restricts the `lastCommittedPublishTime` from going backward.\n\n```solidity\n    function commitRequested(uint256 versionIndex, bytes calldata updateData)\n        public\n        payable\n        keep(KEEPER_REWARD_PREMIUM, KEEPER_BUFFER, updateData, \"\")\n    {\n...\n\n@>      if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n@>        lastCommittedPublishTime = pythPrice.publishTime;\n...\n```\n`commit()` has a similar limitation and can set `lastCommittedPublishTime`.\n\n```solidity\n    function commit(uint256 versionIndex, uint256 oracleVersion, bytes calldata updateData) external payable {\n        if (\n            versionList.length > versionIndex &&                // must be a requested version\n            versionIndex >= nextVersionIndexToCommit &&         // must be the next (or later) requested version\n@>          oracleVersion == versionList[versionIndex]          // must be the corresponding timestamp\n        ) {\n            commitRequested(versionIndex, updateData);\n            return;\n        }\n...\n@>      if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n@>      lastCommittedPublishTime = pythPrice.publishTime;\n....\n```\n\nThis leads to a situation where anyone can front-run `commitRequested()` and use his `updateData` to execute `commit()`.\nIn order to satisfy the `commit()` constraint, we need to pass a `commit()` parameter set as follows\n\n1. versionIndex= nextVersionIndexToCommit\n2. oracleVersion = versionList[versionIndex]  - 1    and oralceVersion > _latestVersion\n3. pythPrice.publishTime >= versionList[versionIndex]  - 1  + MIN_VALID_TIME_AFTER_VERSION\n\nThis way `lastCommittedPublishTime` will be modified, causing `commitRequested()` to execute with `revert PythOracleNonIncreasingPublishTimes`\n\nExample:\nGiven: \nnextVersionIndexToCommit = 10\nversionList[10]   = 200  \n_latestVersion    = 100  \n\nwhen:\n 1. keeper exexute commitRequested(versionIndex = 10 , VAA{ publishTime = 205})\n 2. front-run execute `commit(versionIndex = 10 , oracleVersion = 200-1 , VAA{ publishTime = 205})\n     * versionIndex= nextVersionIndexToCommit    （pass）\n     * oracleVersion = versionList[versionIndex]  - 1    and oralceVersion > _latestVersion  (pass) \n     * pythPrice.publishTime >= versionList[versionIndex]  - 1  + MIN_VALID_TIME_AFTER_VERSION  (pass)\n\n\nBy the time the `keeper` submits the next VVA, the price may have passed its expiration date\n\n## Impact\n\nIf the user can control the oralce invalidation, it can lead to many problems\ne.g. invalidating `oracle` to one's own detriment, not having to take losses\nMaliciously destroying other people's profits, etc.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L174\n\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L129\n\n## Tool used\n\nManual Review\n\n## Recommendation\ncheck `pythPrice` whether valid for `nextVersionIndexToCommit`\n```diff\n    function commit(uint256 versionIndex, uint256 oracleVersion, bytes calldata updateData) external payable {\n        // Must be before the next requested version to commit, if it exists\n        // Otherwise, try to commit it as the next request version to commit\n        if (\n            versionList.length > versionIndex &&                // must be a requested version\n            versionIndex >= nextVersionIndexToCommit &&         // must be the next (or later) requested version\n            oracleVersion == versionList[versionIndex]          // must be the corresponding timestamp\n        ) {\n            commitRequested(versionIndex, updateData);\n            return;\n        }\n\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(oracleVersion, updateData);\n\n        // Price must be more recent than that of the most recently committed version\n        if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Oracle version must be more recent than that of the most recently committed version\n        uint256 minVersion = _latestVersion;\n        uint256 maxVersion = versionList.length > versionIndex ? versionList[versionIndex] : current();\n\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n        if (versionIndex > nextVersionIndexToCommit && block.timestamp <= versionList[versionIndex - 1] + GRACE_PERIOD)\n            revert PythOracleGracePeriodHasNotExpiredError();\n        if (oracleVersion <= minVersion || oracleVersion >= maxVersion) revert PythOracleVersionOutsideRangeError();\n+       if (nextVersionIndexToCommit < versionList.length) {\n+           if (\n+               pythPrice.publishTime >= versionList[nextVersionIndexToCommit] + MIN_VALID_TIME_AFTER_VERSION &&\n+               pythPrice.publishTime <= versionList[nextVersionIndexToCommit] + MAX_VALID_TIME_AFTER_VERSION\n+           ) revert PythOracleUpdateValidForPreviousVersionError();\n+       }\n\n\n        _recordPrice(oracleVersion, pythPrice);\n        nextVersionIndexToCommit = versionIndex;\n        _latestVersion = oracleVersion;\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n4 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> borderline low/medium. The issue is valid and can force keepers to re-submit if they're frontrun. It's still always possible to submit a price with publishTime which is at MAX_VALID_TIME_AFTER_VERSION away from version time, but this still interfere oracle keepers process and increases chances of invalid version. Definitely not high, because it doesn't break things, just forces to re-submit transactions and keepers can also front-run each other, so reverted keep transactions are not something possible only due to this issue. Probably a better fix is to commitRequested instead of just commit if publishTime is between MIN and MAX valid time.\n\n**n33k** commented:\n> invalid, expected behavior for commitRequested to revert because commit alreay provided the oracleVersion\n\n**0xyPhilic** commented:\n> invalid because there is no proof of funds loss\n\n**polarzero** commented:\n> Medium. Not sure what the incentive would be for an attacker to do this, and the impact it would have, but I'd rather have it downgraded than ignored.",
      "summary": "\nA bug report has been found in the Sherlok Audit GitHub repository which affects the `commitRequested()` and `commit()` methods of the PythOracle contract. The bug allows a malicious user to front-run `commitRequested()` and execute `commit()` by passing a set of parameters that satisfy the constraints of the `commit()` method. This causes `commitRequested()` to revert, invalidating the oralce. This can lead to many problems, such as invalidating `oracle` to one's own detriment, not having to take losses, maliciously destroying other people's profits, etc. The code snippets and tool used to find the bug have been provided in the report. The vulnerability was discussed by four people, and it was concluded to be a medium severity bug. A better fix for the bug has also been suggested.",
      "report_date": {},
      "contest_prize_txt": "14500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/112",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-09-perennial-judging/issues/27",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "112",
      "slug": "m-2-commitrequested-front-run-malicious-invalid-oralce-sherlock-perennial-v2-fix-review-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Perennial V2 Fix Review",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Perennial V2 Fix Review",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Derivatives"
            },
            "score": 10.16
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Front-Running"
          }
        }
      ]
    },
    {
      "id": "29460",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 27,
      "protocol_id": "1058",
      "title": "[H-07] Incorrect precision assumed from RdpxPriceOracle creates multiple issues related to value inflation/deflation",
      "content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L372> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L381> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L539> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1160>\n\nThe `RdpxEthPriceOracle`, available in the audit repo [here](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol), provides the `RdpxV2Core`, the `UniV2LiquidityAmo` and the `PerpetualAtlanticVault` contracts the necessary values for `rdpx` related price calculations.\n\nThe issue is that these contracts expect the returned values to be in `1e8` precision (as stated in the natspec [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1224), [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L378) and [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/IPerpetualAtlanticVault.sol#L20C1-L24C65)). But the returned precision [is actually `1e18`](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol#L243).\n\nThis difference creates multiple issues throughout the below contracts:\n\n| Contract                     | Function               | Effect                                                       |\n| ---------------------------- | ---------------------- | ------------------------------------------------------------ |\n| `rdpxV2Core.sol`             | `getRdpxPrice()`       | Returns an `1e18` value when `1e8` expected                  |\n|                              | `calculateBondCost()`  | Deflates the `rdpxRequired`                                  |\n|                              | `calculateAmounts()`   | Inflates the `rdpxRequiredInWeth`                            |\n|                              | `_transfer()`          | Inflates `rdpxAmountInWeth` and may cause possible underflow |\n| `UniV2LiquidityAmo`          | `getLpPriceInEth()`    | Overestimates the lp value                                   |\n| `ReLp.sol`                   | `reLP()`               | Inflates min token amounts                                   |\n| `PerpetualAtlanticVault.sol` | `getUnderlyingPrice()` | Returns `1e18` instead of `1e8`                              |\n|                              | `calculatePremium()`   | Inflates the premium calculation                             |\n\n### Proof of Concept\n\nThe `RdpxEthPriceOracle.sol` file can be found [here](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol)\n\nIt exposes the following functions used in the audit:\n\n*   [`getLpPriceInEth()`](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol#L200)\n*   [`getRdpxPriceInEth()`](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol#L243)\n\nThese two functions provide the current price denominated in `ETH`, with a precision in `1e18`, as confirmed by their respective natspec comments:\n\n```\n    /// @dev Returns the price of LP in ETH in 1e18 decimals\n    function getLpPriceInEth() external view override returns (uint) {\n    ...\n\n    /// @notice Returns the price of rDPX in ETH\n    /// @return price price of rDPX in ETH in 1e18 decimals\n    function getRdpxPriceInEth() external view override returns (uint price) {\n\n```\n\nBut, in the contracts from the audit repo, the business logic (and even the natspec) assumes the returned precision will be `1e8`. See below:\n\nIn the `RdpxV2Core` contract the assumption that the price returned from the oracle is clearly noted in the [natspec](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1227C1-L1227C1) of the `getRdpxPrice()` function:\n\n      /**\n       * @notice Returns the price of rDPX against ETH\n       * @dev    Price is in 1e8 Precision\n       * @return rdpxPriceInEth rDPX price in ETH\n       **/\n      function getRdpxPrice() public view returns (uint256) {\n        return\n          IRdpxEthOracle(pricingOracleAddresses.rdpxPriceOracle)\n            .getRdpxPriceInEth();\n      }\n\nIn `UniV2LiquidityAmo` the assumption is noted [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L378):\n\n      /**\n       * @notice Returns the price of a rDPX/ETH Lp token against the alpha token\n       * @dev    Price is in 1e8 Precision\n       * @return uint256 LP price\n       **/\n      function getLpPrice() public view returns (uint256) {\n\nAnd it has business logic implication here:\n\n      function getLpTokenBalanceInWeth() external view returns (uint256) {\n        return (lpTokenBalance * getLpPrice()) / 1e8;\n      }\n\nIn `PerpetualAtlanticVault` it is noted [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/IPerpetualAtlanticVault.sol#L21):\n\n      /**\n       * @notice Returns the price of the underlying in ETH in 1e8 precision\n       * @return uint256 the current underlying price\n       **/\n      function getUnderlyingPrice() external view returns (uint256);\n\nAnd the business logic implications in this contract are primarily found in the `calculatePremium` function, where the premium is divided by `1e8`:\n\n      function calculatePremium(\n        uint256 _strike,\n        uint256 _amount,\n        uint256 timeToExpiry,\n        uint256 _price\n      ) public view returns (uint256 premium) {\n        premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(\n          _strike,\n          _price > 0 ? _price : getUnderlyingPrice(),\n          getVolatility(_strike),\n          timeToExpiry\n        ) * _amount) / 1e8);\n      }\n\nFrom the audit files it's clear that the assumption was that the returned price would be in `1e8`, but this is Dopex's own `RdpxPriceOracle`, so was likely a simple oversight which slipped through testing as a `MockRdpxEthPriceOracle` was implemented to simplify testing, which mocked the values from the oracle, but only to a `1e8` precision.\n\n### Recommended Mitigation Steps\n\nFor price feeds where `WETH` will be token B, it is convention (although not a standard, as far as the reviewer is aware), that the precision returned will be `1e18`. See [here](https://ethereum.stackexchange.com/questions/92508/do-all-chainlink-feeds-return-prices-with-8-decimals-of-precision).\n\nAs the sponsor indicated that the team might move to Chainlink oracles, it is suggested to modify the `RdpxV2Core`, `PerpetualAtlanticVault`, `UniV2Liquidity` and the `ReLp` contracts to work with the returned `1e18` precision, assuming that the keep the token pair as rdpx/WETH.\n\n**[psytama (Dopex) confirmed and commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/549#issuecomment-1733729931):**\n > The issue is in the oracle contract which returns 1e18.\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/549#issuecomment-1759261378):**\n > Seems like the Warden grouped a bunch of consequences down to the root cause of the oracle precision.\n> \n> I'll need to determine how to group / ungroup findings as there seem to be multple impacts but a single root cause.\n\n***\n\n",
      "summary": "\nThis bug report is regarding the `RdpxEthPriceOracle`, a contract available on the audit repo which provides the `RdpxV2Core`, the `UniV2LiquidityAmo`, and the `PerpetualAtlanticVault` contracts with necessary values for `rdpx` related price calculations. The issue is that these contracts expect the returned values to be in `1e8` precision, but the returned precision is actually `1e18`. This difference creates multiple issues throughout the contracts such as inflating the `rdpxRequiredInWeth`, deflating the `rdpxRequired`, inflating the `rdpxAmountInWeth`, overestimating the lp value, inflating min token amounts and inflating the premium calculation.\n\nThe `RdpxEthPriceOracle.sol` file can be found [here](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol) and it exposes the two functions `getLpPriceInEth()` and `getRdpxPriceInEth()` which provide the current price denominated in `ETH`, with a precision in `1e18`.\n\nIt is suggested to modify the `RdpxV2Core`, `PerpetualAtlanticVault`, `UniV2Liquidity` and the `ReLp` contracts to work with the returned `1e18` precision, assuming that the team keeps the token pair as rdpx/WETH.",
      "report_date": {},
      "contest_prize_txt": "125000",
      "contest_link": "https://code4rena.com/reports/2023-08-dopex",
      "sponsor_name": "Dopex",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-08-dopex",
      "github_link": "https://github.com/code-423n4/2023-08-dopex-findings/issues/549",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "278",
      "slug": "h-07-incorrect-precision-assumed-from-rdpxpriceoracle-creates-multiple-issues-related-to-value-inflationdeflation-code4rena-dopex-dopex-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Dopex",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Dopex",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "24318",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "1049",
      "title": "H-3: CurveTricryptoOracle#getPrice contains math error that causes LP to be priced completely wrong",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/100 \n\n## Found by \n0x52, Kow\n\nCurveTricryptoOracle#getPrice incorrectly divides the LP price by the price of ETH which causes it to return the price of LP in terms of ETH instead of USD\n\n## Vulnerability Detail\n\n[CurveTricryptoOracle.sol#L57-L62](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L57-L62)\n\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n\nAfter the LP price has been calculated in USD it is mistakenly divided by the price of ETH causing the contract to return the LP price in terms of ETH rather than USD. This leads to LP that is massively undervalued causing positions which are actually heavily over collateralized to be liquidated.\n\n## Impact\n\nHealthy positions are liquidated due to incorrect LP pricing\n\n## Code Snippet\n\n[CurveTricryptoOracle.sol#L48-L65](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L48-L65)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDon't divide the price by the price of ETH\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because lpPrice is considered in ETH so dividing by ETH/USD price returns the final result in USD\n\n**Kral01** commented:\n> there is a precision value\n\n\n\n**Gornutz**\n\nJudges accurately state why the division by ETH/USD is required to return the proper USD value.\n\n**Shogoki**\n\nClosing in regards to other judges and sponsors comments.\n\n**IAm0x52**\n\nThis is valid. The code being used here was borrowed from the Sentiment [CurveTriCryptoOracle](https://arbiscan.io/address/0x4e828a117ddc3e4dd919b46c90d4e04678a05504#code), which is specifically meant to return the price in terms of ETH. This oracle is meant to return the valuation in USD which means the division by the price of ETH needs to be dropped.\n\n**Shogoki**\n\n> This is valid. The code being used here was borrowed from the Sentiment [CurveTriCryptoOracle](https://arbiscan.io/address/0x4e828a117ddc3e4dd919b46c90d4e04678a05504#code), which is specifically meant to return the price in terms of ETH. This oracle is meant to return the valuation in USD which means the division by the price of ETH needs to be dropped.\n\nMaybe was a bit quick in closing. Will reopen it and we will take a deeper look at it.",
      "summary": "\nThis bug report is about an issue found in the CurveTricryptoOracle#getPrice function of the codebase. The bug causes the Liquidation Price (LP) to be priced completely wrong due to a math error. The code snippet in question is located at CurveTricryptoOracle.sol#L57-L62 and it incorrectly divides the LP price by the price of ETH which causes it to return the price of LP in terms of ETH instead of USD. This leads to healthy positions being liquidated due to incorrect LP pricing. \n\nThe issue was initially found by 0x52 and Kow and then discussed by other members of the Sherlock Audit team. The team concluded that the code was borrowed from the Sentiment CurveTriCryptoOracle which is meant to return the price in terms of ETH. As the oracle is meant to return the valuation in USD, the division by the price of ETH needs to be dropped. The issue was then reopened for further investigation.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/104",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/100",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "104",
      "slug": "h-3-curvetricryptooraclegetprice-contains-math-error-that-causes-lp-to-be-priced-completely-wrong-sherlock-none-blueberry-update-3-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update #3",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update #3",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "24317",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "1049",
      "title": "H-2: CurveTricryptoOracle incorrectly assumes that WETH is always the last token in the pool which leads to bad LP pricing",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/98 \n\n## Found by \n0x52, Vagner\n\nCurveTricryptoOracle assumes that WETH is always the last token in the pool (`tokens[2]`). This is incorrect for a majority of tricrypto pools and will lead to LP being highly overvalued.\n\n## Vulnerability Detail\n\n[CurveTricryptoOracle.sol#L53-L63](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L53-L63)\n\n        if (tokens.length == 3) {\n            /// tokens[2] is WETH\n            uint256 ethPrice = base.getPrice(tokens[2]);\n            return\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n        }\n\nWhen calculating LP prices, CurveTricryptoOracle#getPrice always assumes that WETH is the second token in the pool. This isn't the case which will cause the LP to be massively overvalued.\n\nThere are 6 tricrypto pools currently deployed on mainnet. Half of these pools have an asset other than WETH as token[2]:\n\n        0x4ebdf703948ddcea3b11f675b4d1fba9d2414a14 - CRV\n        0x5426178799ee0a0181a89b4f57efddfab49941ec - INV\n        0x2889302a794da87fbf1d6db415c1492194663d13 - wstETH\n\n## Impact\n\nLP will be massively overvalued leading to overborrowing and protocol insolvency\n\n## Code Snippet\n\n[CurveTricryptoOracle.sol#L48-L65](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L48-L65)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere is no need to assume that WETH is the last token. Simply pull the price for each asset and input it into lpPrice.\n\n\n\n\n\n## Discussion\n\n**IAm0x52**\n\nEscalate\n\nThis is not a dupe of #105. This will cause a large number of tricrypto pools to be overvalued which presents a serious risk to the protocol.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is not a dupe of #105. This will cause a large number of tricrypto pools to be overvalued which presents a serious risk to the protocol.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\nAgree. \nThis is not a duplicate of #105 \nThis can become its own main report and #20 is a duplicate of it.\n\nThere were some issues with (de)duplication. I would resolve like this.\n#98 is the duplicate with #20 \n#105 is duplicate with #42 \n\n**hrishibhat**\n\nResult:\nHigh \nHas duplicates\nThis is a valid high issue based on the description\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/98/#issuecomment-1694746548): accepted",
      "summary": "\nA bug report has been identified in the CurveTricryptoOracle.sol code which incorrectly assumes that WETH is always the last token in the pool. This issue was found by 0x52 and Vagner and can lead to LP being highly overvalued. The code snippet from the CurveTricryptoOracle.sol file which is causing the issue is located at line 53-63. This issue can cause LP to be massively overvalued, leading to overborrowing and protocol insolvency. A manual review was used to identify this bug. \n\nThe recommended resolution to this issue is to not assume that WETH is the last token in the pool and instead pull the price for each asset and input it into lpPrice. The bug report was escalated by 0x52, who noted that this issue could cause a large number of tricrypto pools to be overvalued, which presents a serious risk to the protocol. Shogoki agreed with the escalation and noted that #98 was the duplicate with #20 and #105 was duplicate with #42. Hrishibhat concluded that this is a valid high issue. Finally, the escalations were successfully resolved.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/104",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/98",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "104",
      "slug": "h-2-curvetricryptooracle-incorrectly-assumes-that-weth-is-always-the-last-token-in-the-pool-which-leads-to-bad-lp-pricing-sherlock-none-blueberry-update-3-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update #3",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update #3",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Configuration"
          }
        },
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        }
      ]
    },
    {
      "id": "24316",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "1049",
      "title": "H-1: Stable BPT valuation is incorrect and can be exploited to cause protocol insolvency",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/97 \n\n## Found by \n0x52\n\nThe current methodology for valuing Stable BPT is incorrect and can lead to significant over valuation of the stable BPT.\n\n## Vulnerability Detail\n\n[StableBPTOracle.sol#L48-L53](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/StableBPTOracle.sol#L48-L53)\n\n        uint256 minPrice = base.getPrice(tokens[0]);\n        for(uint256 i = 1; i != length; ++i) {\n            uint256 price = base.getPrice(tokens[i]);\n            minPrice = (price < minPrice) ? price : minPrice;\n        }\n        return minPrice.mulWadDown(pool.getRate());\n\nThe above block is used to calculate the price. Finding the min price of all assets in the pool then multiplying by the current rate of the pool. This is nearly identical to how stable curve LP is priced. Balancer pools are a bit different and this methodology is incorrect for them. Lets look at a current mainnet pool to see the problem. Take the wstETH/aETHc pool. Currently getRate() = 1.006. The lowest price is aETHc at 2,073.23. This values the LP at 2,085.66. The issue is that the LPs actual value is 1,870.67 (nearly 12% overvalued) which can be checked [here](https://app.apy.vision/pools/balancerv2_eth-wstETH-ankrETH-0xdfe6e7e18f6cc65fa13c8d8966013d4fda74b6ba).\n\nOvervaluing the LP as such can cause protocol insolvency as the borrower can overborrow against the LP, leaving the protocol with bad debt.\n\n## Impact\n\nProtocol insolvency due to overborrowing\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/StableBPTOracle.sol#L37-L54\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nStable BPT oracles need to use a new pricing methodology\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because there is no sufficient data/explanations to support the explained issue\n\n**Kral01** commented:\n> only an issue if the protocol uses this LP pair\n\n\n\n**IAm0x52**\n\nEscalate\n\nThis is not a dupe of #100. Though it focuses on a similar area of the code, the underlying issue is completely different. StableBPT is value highly incorrectly for some pools and it will cause significant damage to the protocol.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is not a dupe of #100. Though it focuses on a similar area of the code, the underlying issue is completely different. StableBPT is value highly incorrectly for some pools and it will cause significant damage to the protocol.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> ing the LP as such can cause protocol insolvency as the borrower can overborrow against the LP, leaving the protocol with bad debt.\n\nYes, not a duplicate of #100 \n@Gornutz can you take a look at this?\n\n**Gornutz**\n\nConfirm this is not a duplicate of #100  \n\n**hrishibhat**\n\nResult:\nHigh \nUnique\nConsidering this a valid high issue as the wrong price is calculated and returned\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/97/#issuecomment-1694746948): accepted",
      "summary": "\nThis bug report is about an issue with the Stable BPT valuation methodology, which can lead to significant overvaluation of the stable BPT. This can cause protocol insolvency as the borrower can overborrow against the LP, leaving the protocol with bad debt. The issue was found by 0x52 and was confirmed by Gornutz and Hrishibhat. The code snippet that was identified to be the cause of the issue was located at StableBPTOracle.sol#L48-L53. The issue was discussed by 0xPhilic and Kral01, who both concluded that the issue was valid and unique. The issue was then escalated by IAm0x52 and Shogoki, and the escalation was accepted by sherlock-admin2. The issue is considered a valid high issue as the wrong price is calculated and returned, leading to potential protocol insolvency.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/104",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/97",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "104",
      "slug": "h-1-stable-bpt-valuation-is-incorrect-and-can-be-exploited-to-cause-protocol-insolvency-sherlock-none-blueberry-update-3-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update #3",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update #3",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "19115",
      "kind": "MARKDOWN",
      "auditfirm_id": "15",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "851",
      "title": "Chainlink price is used without checking validity",
      "content": "**Severity:** Medium\n\n**Context:** [`Helper.sol#L75-L78`](https://github.com/getmetafinance/meta/blob/00bbac1613fa69e4c180ff53515451df4df9f69e/contracts/musd/Helper.sol#L75-L78)\n\n**Description:**\nThe Meta protocol relies on a Chainlink price oracle to calculate the excess income distributed to all mUSD holders.\nHowever, the current implementation lacks checks for the staleness of the price obtained from Chainlink.\n\n```solidity\nfunction getPriceOfRewardToken() external view returns (uint256) {\n(,int256 price,,,) = priceFeed.latestRoundData();//@audit chainlink price feed - stale price check is missing\nreturn (uint256(price) * Constants.PINT) / PRICE_FEED_PRECISION;\n}\n```\n\nThis omission can lead to issues if Chainlink starts a new round and struggles to establish consensus on the new value for the oracle. Without proper checks, consumers of this contract may continue using outdated, stale, or incorrect data if oracles are unable to submit and start a new round. Possible reasons for this could include Chainlink nodes abandoning the oracle, chain congestion, or vulnerabilities/attacks on the Chainlink system.\n\nAdditionally, it is important to check if the Arbitrum sequencer is active.\nPlease refer to the issue at https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/3 for more information.\n\n**Impact**\nThis vulnerability is classified as MEDIUM because it affects user assets only when the Chainlink oracle is in bad status.\n\n**Recommendation:**\nTo address this issue, it is recommended to implement checks to ensure that the price returned by Chainlink is not stale. The following code snippet can be used to validate the price obtained from Chainlink:\n\n```solidity\n( roundId, rawPrice, , updateTime, answeredInRound ) = priceFeed.latestRoundData();\nrequire(rawPrice > 0, \"Chainlink price <= 0\");\nrequire(updateTime != 0, \"Incomplete round\");\nrequire(answeredInRound >= roundId, \"Stale price\");\n```\n\n**Meta Team:**\n\nFixed in the latest commit. Added the checks on the price value and also sequencer validation.\n\n```diff\n\n+    function isSequencerActive() internal view returns (bool) {\n+        (, int256 answer, uint256 startedAt,,) = sequencer.latestRoundData();\n+        if (block.timestamp - startedAt <= GRACE_PERIOD_TIME || answer == 1)\n+            return false;\n+        return true;\n+    }\n\nfunction getPriceOfRewardToken() external view returns (uint256) {\n(uint80 roundId,int256 price,,uint256 updateTime, uint80 answeredInRound) = priceFeed.latestRoundData();\n+       require(isSequencerActive(), \"HLP: Sequencer is down\");\n+       require(price > 0, \"HLP: Invalid chainlink price\");\n+       require(updateTime > 0, \"HLP: Incomplete round\");\n+       require(answeredInRound >= roundId, \"HLP: Stale price\");\nreturn (uint256(price) * Constants.PINT) / PRICE_FEED_PRECISION;\n}\n\n```\n\n**Hans:**\nVerified.",
      "summary": "\nThe bug report is about a vulnerability in the Meta protocol that affects user assets when the Chainlink oracle is in bad status. The current implementation lacks checks for the staleness of the price obtained from Chainlink, which can lead to issues if Chainlink starts a new round and struggles to establish consensus on the new value for the oracle. It is also important to check if the Arbitrum sequencer is active.\n\nTo address this issue, it is recommended to implement checks to ensure that the price returned by Chainlink is not stale. The following code snippet can be used to validate the price obtained from Chainlink:\n\n```solidity\n( roundId, rawPrice, , updateTime, answeredInRound ) = priceFeed.latestRoundData();\nrequire(rawPrice > 0, \"Chainlink price <= 0\");\nrequire(updateTime != 0, \"Incomplete round\");\nrequire(answeredInRound >= roundId, \"Stale price\");\n```\n\nThe Meta Team fixed the issue in the latest commit by adding the checks on the price value and also sequencer validation. Hans verified the changes.\n\nThe severity of this vulnerability is classified as MEDIUM because it affects user assets only when the Chainlink oracle is in bad status.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hans/2023-07-13-Meta.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "chainlink-price-is-used-without-checking-validity-hans-none-meta-markdown_",
      "firm_name": "Hans",
      "firm_logo_square": "hans_square.jpg",
      "protocol_name": "Meta",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Hans",
        "logo_square": "hans_square.jpg"
      },
      "protocols_protocol": {
        "name": "Meta",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        },
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "19153",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "854",
      "title": "M-1: ChainlinkAggregator: binary search for roundId does not work correctly and Oracle can even end up temporarily DOSed",
      "content": "Source: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/4 \n\n## Found by \nroguereddwarf\n## Summary\nWhen a phase switchover occurs, it can be necessary that phases need to be searched for a `roundId` with a timestamp as close as possible but bigger than `targetTimestamp`.\n\nFinding the `roundId` with the closest possible timestamp is necessary according to the sponsor to minimize the delay of position changes:\n\n![2023-05-25_13-55](https://github.com/roguereddwarf/images/assets/118631472/0eb0a93b-1a5e-41b2-91c4-884a51aed432)\n\nThe binary search algorithm is not able to find this best `roundId` which thereby causes unintended position changes.\n\nAlso it can occur that the `ChainlinkAggregator` library is unable to find a valid `roundId` at all (as opposed to only not finding the \"best\").\n\nThis would cause the Oracle to be temporarily DOSed until there are more valid rounds.\n\n## Vulnerability Detail\nLet's look at the binary search algorithm:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L123-L156\n\nThe part that we are particularly interested in is:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L139-L149\n\nLet's say in a phase there's only one valid round (`roundId=1`) and the timestamp for this round is greater than `targetTimestamp`\n\nWe would expect the `roundId` that the binary search finds to be `roundId=1`.\n\nThe binary search loop is executed with `minRoundId=1` and `maxRoundId=1001`.\n\nAll the above conditions can easily occur in reality, they represent the basic scenario under which this algorithm executes.\n\n`minRoundId` and `maxRoundId` change like this in the iterations of the loop:\n\n```text\nminRoundId=1\nmaxRoundId=1001\n\n-> \n\nminRoundId=1\nmaxRoundId=501\n\n-> \n\nminRoundId=1\nmaxRoundId=251\n\n-> \n\nminRoundId=1\nmaxRoundId=126\n\n-> \n\nminRoundId=1\nmaxRoundId=63\n\n-> \n\nminRoundId=1\nmaxRoundId=32\n\n-> \n\nminRoundId=1\nmaxRoundId=16\n\n-> \n\nminRoundId=1\nmaxRoundId=8\n\n-> \n\nminRoundId=1\nmaxRoundId=4\n\n-> \n\nminRoundId=1\nmaxRoundId=2\n\nNow the loop terminates because\nminRoundId + 1 !< maxRoundId\n\n```\n\nSince we assumed that `roundId=2` is invalid, the function returns `0` (`maxTimestamp=type(uint256).max`):\n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L153-L155\n\nIn the case that `latestRound.roundId` is equal to the `roundId=1`  (i.e. same phase and same round id which could not be found) there would be no other valid rounds that the `ChainlinkAggregator` can find which causes a temporary DOS.\n\n## Impact\nAs explained above this would result in sub-optimal and unintended position changes in the best case.\nIn the worst-case the Oracle can be temporarily DOSed, unable to find a valid `roundId`.\n\nThis means that users cannot interact with the perennial protocol because the Oracle cannot be synced.\nSo they cannot close losing trades which is a loss of funds.\n\nThe DOS can occur since the while loop searching the phases does not terminate:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L88-L91\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L123-L149\n\n## Tool used\nManual Review\n\n## Recommendation\nI recommend to add a check if `minRoundId` is a valid solution for the binary search.\nIf it is, `minRoundId` should be used to return the result instead of `maxRoundId`:\n\n```diff\n         // If the found timestamp is not greater than target timestamp or no max was found, then the desired round does\n         // not exist in this phase\n-        if (maxTimestamp <= targetTimestamp || maxTimestamp == type(uint256).max) return 0;\n+        if ((minTimestamp <= targetTimestamp || minTimestamp == type(uint256).max) && (maxTimestamp <= targetTimestamp || maxTimestamp == type(uint256).max)) return 0;\n \n+        if (minTimestamp > targetTimestamp) {\n+            return _aggregatorRoundIdToProxyRoundId(phaseId, uint80(minRoundId));\n+        }\n         return _aggregatorRoundIdToProxyRoundId(phaseId, uint80(maxRoundId));\n     }\n```\n\nAfter applying the changes, the binary search only returns `0` if both `minRoundId` and `maxRoundId` are not a valid result.\n\nIf this line is passed we know that either of both is valid and we can use `minRoundId` if it is the better result.\n\n\n\n## Discussion\n\n**roguereddwarf**\n\nEscalate for 10 USDC\n\nI think this should be a \"High\" severity finding.\nThe binary search lies at the core of the protocol.\nAll functionality for users to open / close trades and liquidations relies on the Chainlink oracle.\n\nBy not finding a valid `roundId` obviously many users are put at risk of losing funds (-> not being able to close trades).\n\nSimilarly when an unintended (i.e. sub-optimal) `roundId` is found this leads to a similar scenario where settlements / liquidations occur at unintended prices.\n\nIn summary, the fact that the binary search algorithm lies at the core of the protocol and there is a very direct loss of funds makes me think this should be \"High\" severity.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I think this should be a \"High\" severity finding.\n> The binary search lies at the core of the protocol.\n> All functionality for users to open / close trades and liquidations relies on the Chainlink oracle.\n> \n> By not finding a valid `roundId` obviously many users are put at risk of losing funds (-> not being able to close trades).\n> \n> Similarly when an unintended (i.e. sub-optimal) `roundId` is found this leads to a similar scenario where settlements / liquidations occur at unintended prices.\n> \n> In summary, the fact that the binary search algorithm lies at the core of the protocol and there is a very direct loss of funds makes me think this should be \"High\" severity.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nComment from watson:\n[Chainlink: ETH/USD](https://etherscan.io/address/0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419#readContract) has been deployed for 3 years, and the current phaseID is only 6. The binary search is only triggered when [this condition](https://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/ChainlinkFeedOracle.sol#L117) is met, that is, when a new phaseID is generated. This is infrequent.\nThis is from the [chainlink docs](https://docs.chain.link/data-feeds/historical-data#roundid-in-proxy): `phaseId` is incremented each time the underlying aggregator implementation is updated.\n\n**KenzoAgada**\n\nThe issue is dependent upon a Chainlink changing of phase (which is quite infrequent) and the new phase having only 1 round.\nThe impact as stated in the finding is that in those conditions, the product flywheel is jammed until further rounds are issued. (Then, the algorithm will correctly return round 2.)\nSo the impact is only very temporary and rare DOS (which can impact user funds).\n\nI think escalation is invalid and medium severity is appropriate.\n\n**arjun-io**\n\nTo add here - the binary search is also a backup solution to simply checking if roundId + 1 exists in the previous phase ([code](https://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L70)). So additionally the last seen round in the previous phase has to be the very last roundID in that phase\n\n**jacksanford1**\n\nAgree with Medium due to Kenzo's reasons (unlikely and temporary situation which only indirectly could result in user funds loss due to liquidations). cc @roguereddwarf \n\n**roguereddwarf**\n\nAgreed\n\n**jacksanford1**\n\nResult:\nMedium\nUnique\nUnlikely and temporary situation which only indirectly could result in user funds loss due to liquidations is part of the reason why this is not being upgraded to a High. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [roguereddwarf](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/4/#issuecomment-1614471358): rejected",
      "summary": "\nThis bug report is about an issue in the ChainlinkAggregator library in the 2023-05-perennial project. The issue is that when a phase switchover occurs, the binary search algorithm is not able to find the best roundId with the closest possible timestamp, which can cause unintended position changes. It can also occur that the ChainlinkAggregator library is unable to find a valid roundId at all, which would cause the Oracle to be temporarily DOSed until there are more valid rounds. \n\nThe binary search loop is executed with minRoundId=1 and maxRoundId=1001, and if the only valid roundId is 1, the loop will not be able to find it and return 0 instead. This would mean that the Oracle is unable to find any valid roundId, resulting in a temporary DOS.\n\nThe impact of this issue is that users cannot interact with the perennial protocol because the Oracle cannot be synced, and they cannot close losing trades, leading to a potential loss of funds.\n\nThe code snippet of the binary search algorithm can be found at https://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L123-L149. The recommendation is to add a check if minRoundId is a valid solution for the binary search, and if so, use minRoundId instead of maxRoundId.\n\nThe tool used to find this bug was manual review.\n\nThe discussion was about whether this should be escalated for 10 USDC, with roguereddwarf thinking it should be High severity, and sherlock-admin, KenzoAgada, and jacksanford1 thinking it should be Medium severity. After discussion, it was decided that the severity should be Medium, as it is an unlikely and temporary situation which only indirectly could result in user funds loss due to liquidations. The escalations were then resolved successfully.",
      "report_date": {},
      "contest_prize_txt": "81000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/79",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-perennial-judging/issues/4",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "79",
      "slug": "m-1-chainlinkaggregator-binary-search-for-roundid-does-not-work-correctly-and-oracle-can-even-end-up-temporarily-dosed-sherlock-none-perennial-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Perennial",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Perennial",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "19171",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 15,
      "protocol_id": "855",
      "title": "M-2: PriceOracle will use the wrong price if the Chainlink registry returns price outside min/max range",
      "content": "Source: https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/25 \n\n## Found by \n0x52, 0x8chars, Angry\\_Mustache\\_Man, Bauchibred, BenRai, BugBusters, Jaraxxus, Madalad, R-Nemes, bitsurfer, branch\\_indigo, deadrxsezzz, shaka, thekmj, tsvetanovv\n## Summary\n\nChainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. The result is that if an asset experiences a huge drop in value (i.e. LUNA crash) the price of the oracle will continue to return the minPrice instead of the actual price of the asset. This would allow user to continue borrowing with the asset but at the wrong price. This is exactly what happened to [Venus on BSC when LUNA imploded](https://rekt.news/venus-blizz-rekt/).\n\n## Vulnerability Detail\n\nNote there is only a check for `price` to be non-negative, and not within an acceptable range.\n\n```solidity\nfunction getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n    (, int256 price,,,) = registry.latestRoundData(base, quote);\n    require(price > 0, \"invalid price\");\n\n    // Extend the decimals to 1e18.\n    return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n}\n```\nhttps://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L66-L72\n\nA similar issue is seen [here](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18).\n\n## Impact\n\nThe wrong price may be returned in the event of a market crash. An adversary will then be able to borrow against the wrong price and incur bad debt to the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L66-L72\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement the proper check for each asset. **It must revert in the case of bad price**.\n\n```solidity\nfunction getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n    (, int256 price,,,) = registry.latestRoundData(base, quote);\n    require(price >= minPrice && price <= maxPrice, \"invalid price\"); // @audit use the proper minPrice and maxPrice for each asset\n\n    // Extend the decimals to 1e18.\n    return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n}\n```\n\n\n\n## Discussion\n\n**ibsunhub**\n\nIt's not practical to setup the min price and max price for individual asset. It's hard to define a reasonable range for each asset and it will make oracle configuration more complex. It's much easier to make human error.\n\nAlso, we had an off-chain backend system to monitor the price from ChainLink. If the price is off, we would intervene to pause the oracle.\n\n**0xffff11**\n\n@ibsunhub If the oracle is paused, wouldn't functions that require of that oracle response also be paused during that time? \n\n**ibsunhub**\n\nYes, functions that need to retrieve the price will revert. They are `borrow`, `redeem`, `transferIBToken`, and `liquidate`.\n\n**0xffff11**\n\nSo, I see what the watson points out. I see that you have an off-chain safeguard for this. Therefore, I would mark the issue as invalid. Though I don't think the solution should be to revert. Liquidations can be key while oracle is paused. I think the fix should be the one from https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/433 (secondary oracle and a try catch)\n\n**0xffff11**\n\nInvalid, Iron has an off-chain safeguard for price deviation that would prevent this\n\n**iamjakethehuman**\n\nEscalate for 10 USDC\nThe off-chain safeguard is never mentioned. Watsons are not supposed to know it exists.\nAlso, the supposed solution imposes an even larger risk as any user would be able to enter tbe market of which the oracle reverts and avoid liquidations. Issue should be marked as valid and another solution should be proposed.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> The off-chain safeguard is never mentioned. Watsons are not supposed to know it exists.\n> Also, the supposed solution imposes an even larger risk as any user would be able to enter tbe market of which the oracle reverts and avoid liquidations. Issue should be marked as valid and another solution should be proposed.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ADK0010**\n\nAlso the contest page doesn't talk about any off-chain safeguards.\n\n![ironbank_escalation](https://github.com/sherlock-audit/2023-05-ironbank-judging/assets/87230982/87ca067f-cbe0-44a2-b15f-956b7e0e3c5c)\n\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nThis is a valid medium \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [iamjakethehuman](https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/25/#issuecomment-1606059538): accepted\n\n**ib-tycho**\n\nHow do you establish a reasonable minimum and maximum price range for each asset? \nThe incident related to Venus that you mentioned was caused by the inherent risk of the LUNA token itself. Evaluating the risk associated with an asset should always be taken into account when listing it. I disagree with relying solely on manual human input for setting the price range, as it does not address the underlying issue faced by Venus. Therefore, we will not make changes to address this matter.",
      "summary": "\nThis bug report is about the PriceOracle in the Ironbank protocol, which is used to retrieve the price of an asset from a Chainlink registry. It was found by a team of auditors, including 0x52, 0x8chars, Angry_Mustache_Man, Bauchibred, BenRai, BugBusters, Jaraxxus, Madalad, R-Nemes, bitsurfer, branch_indigo, deadrxsezzz, shaka, thekmj, and tsvetanovv, and it was identified through manual review. \n\nThe issue is that the PriceOracle will use the wrong price if the Chainlink registry returns a price outside of the predetermined minimum and maximum range. This could allow an adversary to borrow against the wrong price and incur bad debt to the protocol. This was seen in the case of Venus on BSC when LUNA imploded. \n\nThe code snippet that was identified as the source of the issue is located at https://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L66-L72. The recommendation to address this issue is to implement the proper check for each asset and revert in the case of bad price. \n\nThe discussion around the issue involved the implementation of an off-chain safeguard to monitor the price from ChainLink and intervene to pause the oracle if the price is off. It was also discussed that it is not practical to setup the min price and max price for individual asset, as it is hard to define a reasonable range for each asset and it will make oracle configuration more complex. \n\nThe result of the discussion was that the issue was marked as invalid, as Ironbank had an off-chain safeguard for price deviation that would prevent this. However, it was also suggested that another solution should be proposed, such as the one from https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/433, which involves a secondary oracle and a try catch. \n\nFinally, the escalation was accepted and the issue was marked as a valid medium. The resolution is that Ironbank will not make any changes to address this matter, as evaluating the risk associated with an asset should always",
      "report_date": {},
      "contest_prize_txt": "45000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/84",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/25",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "84",
      "slug": "m-2-priceoracle-will-use-the-wrong-price-if-the-chainlink-registry-returns-price-outside-minmax-range-sherlock-none-iron-bank-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Iron Bank",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Iron Bank",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        }
      ]
    },
    {
      "id": "19141",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 88,
      "protocol_id": "853",
      "title": "M-1: Calls to Oracles don't check for stale prices",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/31 \n\n## Found by \n0x2e, 0xHati, 0xPkhatri, 0xRobocop, 0xSmartContract, 0xStalin, 0xeix, 0xlmanini, 0xyPhilic, Angry\\_Mustache\\_Man, Aymen0909, Bauchibred, Bauer, Brenzee, BugBusters, Delvir0, DevABDee, Diana, Dug, Fanz, GimelSec, HonorLt, J4de, Kodyvim, Kose, Lilyjjo, Madalad, MohammedRizwan, Nyx, PNS, PTolev, Pheonix, PokemonAuditSimulator, Proxy, RaymondFam, Saeedalipoor01988, SaharDevep, SanketKogekar, Schpiel, T1MOH, TheNaubit, VAD37, WATCHPUG, \\_\\_141345\\_\\_, ast3ros, berlin-101, capy\\_, chainNue, chaithanya\\_gali, chalex.eth, ctf\\_sec, curiousapple, dacian, evilakela, georgits, giovannidisiena, immeas, josephdara, juancito, kiki\\_dev, kutugu, lil.eth, martin, ni8mare, nobody2018, pavankv241, peanuts, qbs, qckhp, saidam017, sakshamguruji, sam\\_gmk, sashik\\_eth, sayan\\_, shaka, shealtielanz, simon135, ss3434, tallo, theOwl, toshii, tsvetanovv, twicek, ustas, vagrant, w42d3n, warRoom, whiteh4t9527\n## Summary\nCalls to Oracles don't check for stale prices.\n\n## Vulnerability Detail\nNone of the oracle calls check for stale prices, for example [StableOracleDAI.getPriceUSD()](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L48):\n```solidity\n(, int256 price, , , ) = priceFeedDAIETH.latestRoundData();\n\nreturn\n    (wethPriceUSD * 1e18) /\n    ((DAIWethPrice + uint256(price) * 1e10) / 2);\n```\n\n## Impact\nOracle price feeds can become stale due to a variety of [reasons](https://ethereum.stackexchange.com/questions/133242/how-future-resilient-is-a-chainlink-price-feed/133843#133843). Using a stale price will result in incorrect calculations in most of the key functionality of USSD & USSDRebalancer contracts.\n\n## Code Snippet\n[StableOracleDAI.getPriceUSD()](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L48)\n[StableOracleWBGL.getPriceUSD()](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWBGL.sol#L36-L38)\n[StableOracleWBTC.getPriceUSD()](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWBTC.sol#L23-L25)\n[StableOracleWETH.getPriceUSD()](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWETH.sol#L23-L25)\n\n## Tool used\nManual Review\n\n## Recommendation\nRead the ``updatedAt`` parameter from the calls to ``latestRoundData()`` and verify that it isn't older than a set amount, eg:\n\n```solidity\nif (updatedAt < block.timestamp - 60 * 60 /* 1 hour */) {\n   revert(\"stale price feed\");\n}\n```",
      "summary": "\nA bug report has been issued on the USSD-Judging repository on Github. The bug was found by a team of 33 members, who identified that calls to Oracles don't check for stale prices. This means that the Oracle price feeds can become stale due to a variety of reasons, resulting in incorrect calculations in most of the key functionality of USSD & USSDRebalancer contracts. The bug was identified through manual review and the recommendation is to read the ``updatedAt`` parameter from the calls to ``latestRoundData()`` and verify that it isn't older than a set amount. If it is, the call should be reverted with the message \"stale price feed\". This bug should be addressed as soon as possible to ensure accuracy in the calculations of the key functionality of USSD & USSDRebalancer contracts.",
      "report_date": {},
      "contest_prize_txt": "12000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/82",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 1,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/31",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "82",
      "slug": "m-1-calls-to-oracles-dont-check-for-stale-prices-sherlock-none-ussd-autonomous-secure-dollar-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "USSD - Autonomous Secure Dollar",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Algo-Stables"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "19139",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 86,
      "protocol_id": "853",
      "title": "H-10: Wrong Oracle feed addresses",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/817 \n\n## Found by \n0xGusMcCrae, 0xHati, 0xPkhatri, 0xRobocop, 0xStalin, 0xeix, 0xlmanini, 0xyPhilic, 14si2o\\_Flint, ADM, Aymen0909, Bahurum, Bauchibred, Bauer, BenRai, Brenzee, BugHunter101, Delvir0, DevABDee, Dug, G-Security, GimelSec, HonorLt, J4de, JohnnyTime, Juntao, Kirkeelee, Kodyvim, Kose, Lilyjjo, Madalad, PNS, PTolev, PokemonAuditSimulator, Proxy, Saeedalipoor01988, SaharDevep, Schpiel, SensoYard, T1MOH, TheNaubit, Vagner, Viktor\\_Cortess, WATCHPUG, \\_\\_141345\\_\\_, ashirleyshe, ast3ros, berlin-101, blockdev, chainNue, chalex.eth, ck, ctf\\_sec, curiousapple, dacian, evilakela, giovannidisiena, immeas, innertia, juancito, kie, kiki\\_dev, kutugu, lil.eth, martin, mrpathfindr, neumo, ni8mare, nobody2018, peanuts, pengun, qpzm, ravikiran.web3, saidam017, sakshamguruji, sam\\_gmk, sashik\\_eth, shaka, shogoki, simon135, theOwl, the\\_endless\\_sea, toshii, twicek, ustas, whiteh4t9527\n## Summary\n\nWrong Oracle feed addresses will result in wrong prices.\n\n## Vulnerability Detail\n\nStableOracleWBTC.sol#L17 the address is not the BTC/USD feed address.\n\nStableOracleDAI.sol#L28, `DAIEthOracle` is wrong.\n\nStableOracleDAI.sol#L30, address for `ethOracle` is address zero (a hanging todo).\n\nStableOracleWBGL.sol#L19, the address for staticOracleUniV3 is wrong, the current one is actually the univ3 pool address.\n\n## Impact\n\nWrong prices for collateral assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleWBTC.sol#L8-L28\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L23-L31\n\nhttps://github.com/USSDofficial/ussd-contracts/blob/f44c726371f3152634bcf0a3e630802e39dec49c/contracts/oracles/StableOracleWBGL.sol#L17-L22\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse correct addresses.",
      "summary": "\nThis bug report is about the wrong Oracle feed addresses in the StableOracleWBTC.sol, StableOracleDAI.sol, and StableOracleWBGL.sol files. These addresses, if not corrected, will result in wrong prices for collateral assets. A manual review was conducted by 0xGusMcCrae, 0xHati, 0xPkhatri, 0xRobocop, 0xStalin, 0xeix, 0xlmanini, 0xyPhilic, 14si2o_Flint, ADM, Aymen0909, Bahurum, Bauchibred, Bauer, BenRai, Brenzee, BugHunter101, Delvir0, DevABDee, Dug, G-Security, GimelSec, HonorLt, J4de, JohnnyTime, Juntao, Kirkeelee, Kodyvim, Kose, Lilyjjo, Madalad, PNS, PTolev, PokemonAuditSimulator, Proxy, Saeedalipoor01988, SaharDevep, Schpiel, SensoYard, T1MOH, TheNaubit, Vagner, Viktor_Cortess, WATCHPUG, __141345__, ashirleyshe, ast3ros, berlin-101, blockdev, chainNue, chalex.eth, ck, ctf_sec, curiousapple, dacian, evilakela, giovannidisiena, immeas, innertia, juancito, kie, kiki_dev, kutugu, lil.eth, martin, mrpathfindr, neumo, ni8mare, nobody2018, peanuts, pengun, qpzm, ravikiran.web3, saidam017, sakshamguruji, sam_gmk, sashik_eth, shaka, shogoki, simon135, theOwl, the_endless_sea, toshii, twicek, ustas, whiteh4t9527. The wrong addresses were found in the following lines in the code snippet: StableOracleWBTC.sol#L17, StableOracleDAI.sol#L28, StableOracleDAI.sol#L30, and StableOracleWBGL",
      "report_date": {},
      "contest_prize_txt": "12000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/82",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/817",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "82",
      "slug": "h-10-wrong-oracle-feed-addresses-sherlock-none-ussd-autonomous-secure-dollar-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "USSD - Autonomous Secure Dollar",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Algo-Stables"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Configuration"
          }
        }
      ]
    },
    {
      "id": "18479",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "823",
      "title": "M-12: chainlinkAdaptor uses the same heartbeat for both feeds which is highly dangerous",
      "content": "Source: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/449 \n\n## Found by \n0x52, ast3ros\n## Summary\nchainlinkAdaptor uses the same heartbeat for both feeds when checking if the data feed is fresh. The issue with this is that the [USDC/USD](https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd) oracle has a 24 hour heartbeat, whereas the [average](https://data.chain.link/ethereum/mainnet/crypto-usd/eth-usd) has a heartbeat of 1 hour. Since they use the same heartbeat the heartbeat needs to be slower of the two or else the contract would be nonfunctional most of the time. The issue is that it would allow the consumption of potentially very stale data from the non-USDC feed.\n\n## Vulnerability Detail\n\nSee summary\n\n## Impact\n\nEither near constant downtime or insufficient staleness checks\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/adaptor/chainlinkAdaptor.sol#L43-L55\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse two separate heartbeat periods\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nThe contract are trying to get the latest price in here:https://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/adaptor/chainlinkAdaptor.sol#LL47C1-L47C1\n\nAnd the heartbeat is trying to prevent chainlink stop updating. It is the same as chainlink's heartbeat.\nhttps://docs.chain.link/data-feeds/price-feeds/addresses/?network=arbitrum#Arbitrum%20Mainnet\n\n**iamjakethehuman**\n\nEscalate for 10 USDC\nI don’t think the sponsor properly understood the issue. On Arbitrum, as well as pretty much any other network, different token pairs have different heartbeats. If the oracle gets the latest price for two pairs with different heartbeats, using the same heartbeat variable for validation would cause either one of the following:\n1. Oracle will be down (will revert) most of the time.\n2. Oracle will allow for stale prices\n\nWhen validating prices for two different token pairs, two different heartbeats must be used.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> I don’t think the sponsor properly understood the issue. On Arbitrum, as well as pretty much any other network, different token pairs have different heartbeats. If the oracle gets the latest price for two pairs with different heartbeats, using the same heartbeat variable for validation would cause either one of the following:\n> 1. Oracle will be down (will revert) most of the time.\n> 2. Oracle will allow for stale prices\n> \n> When validating prices for two different token pairs, two different heartbeats must be used.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**JoscelynFarr**\n\nhttps://github.com/JOJOexchange/smart-contract-EVM/commit/c4270e0dc4da0db56173e39d8b6318e47999a07d\nhttps://github.com/JOJOexchange/JUSDV1/commit/f1699ae81e81eb190914d1c2ae491a825389daac\nfix \n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nGiven that the code uses the same heartbeat to validate both assets, when both assets can have different heartbeats, considering this issue a valid medium\n\nSponsor comment:\n> got it, we will accept this issue\n\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [iamjakethehuman](https://github.com/sherlock-audit/2023-04-jojo-judging/issues/449/#issuecomment-1568436039): accepted\n\n**IAm0x52**\n\nFix looks good. Contract now uses separate heartbeats for asset and USDC",
      "summary": "\nIssue M-12 is a bug found by 0x52 and ast3ros in the chainlinkAdaptor contract, which uses the same heartbeat for both feeds when checking if the data feed is fresh. This is highly dangerous as the USDC/USD oracle has a 24 hour heartbeat, whereas the average has a heartbeat of 1 hour. This means that the heartbeat needs to be slower of the two or else the contract would be nonfunctional most of the time, and would allow the consumption of potentially very stale data from the non-USDC feed. \n\nThe code snippet can be found at https://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/adaptor/chainlinkAdaptor.sol#L43-L55, and the impact of this bug is either near constant downtime or insufficient staleness checks. The recommendation is to use two separate heartbeat periods. \n\nThe bug was discussed and escalated for 10 USDC, with iamjakethehuman noting that the oracle will be down or allow for stale prices if the same heartbeat is used for both token pairs. This was accepted by the sponsor, and the fix was implemented with a commit at https://github.com/JOJOexchange/smart-contract-EVM/commit/c4270e0dc4da0db56173e39d8b6318e47999a07d and https://github.com/JOJOexchange/JUSDV1/commit/f1699ae81e81eb190914d1c2ae491a825389daac. The fix looks good, and the contract now uses separate heartbeats for asset and USDC.",
      "report_date": {},
      "contest_prize_txt": "52000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/70",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-jojo-judging/issues/449",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "70",
      "slug": "m-12-chainlinkadaptor-uses-the-same-heartbeat-for-both-feeds-which-is-highly-dangerous-sherlock-none-jojo-exchange-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "JOJO Exchange",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "JOJO Exchange",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        }
      ]
    },
    {
      "id": "20779",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 17,
      "protocol_id": "917",
      "title": "[M-10] Exchange Rate can be manipulated",
      "content": "\n<https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/VToken.sol#L1463> <br><https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/VToken.sol#L1421> <br><https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/VToken.sol#L756>\n\nA malicious user can manipulate the protocol to receive greater rewards from the `RewardsDistributor` than they should. To achieve this, the attacker manipulates the `exchangeRate`.\n\nThe attacker `mint`s into the `VToken` contract legitimately but also `transfer`s an amount of tokens directly to the `VToken` contract. This inflates the `exchangeRate` for all subsequent users who `mint` and has the following impact:\n\n1.  Allows the attacker to push their leverage past the market `collateralFactor`\n2.  Violates the internal accounting when `borrowing` and `repaying`, causing the `totalBorrows` and the sum of the individual account borrows to become out of sync. I.e. the `totalBorrows` can become `0` while there are still some loans outstanding, leading to loss of earned interest.\n3.  The attacker can use the leverage to repeatedly `borrow` + `mint` into the `VToken` in order to inflate their share of the token rewards issued by the rewards distributor.\n\nThis means that all subsequent `minter`s receive less `VTokens` than they should.\n\nThe attack cost is the loss of the `transfer` into the `VToken` contract. But it must be noted that the attacker still receives around 65-75% of the (`attackTokens` + `mintTokens`) back.\n\nThe permanent side-effect of this exploit is that the minting of `VTokens` to any subsequent users remains stunted, as there is no direct mechanism to clear the excess underlying tokens from the contract. This can taint this Pool permanently.\n\nThis exploit becomes more profitable as block count accrues and more `REWARD_TOKENS` are issued, or, for example, if VENUS sets up greater rewards to incentivize supplying into a particular Pool; these increased rewards are a normal practice in DeFi and could be a prime target for this manipulation.\n\n### Proof of Concept\n\nIn this scenario an attacker:\n\n1.  Needs \\~60 underlying tokens (supply 10 underlying, 20 direct transfer, 30 interest).\n2.  Gets \\~5 times more rewards than other users.\n3.  Is still able to withdraw \\~50 underlying tokens from the `VToken`.\n4.  \\~10 tokens are now stuck in the contract, permanently tainting the exchange rate.\n\nA detailed Proof of Concept illustrating the case can be found in this [gist](https://gist.github.com/lokithe5th/cda577cc1b50cb91cfe1d4b1eccecc7e).\n\nThe gist simulates and walks through the attack using the repo's test suite as a base.\nThe exploit is commented on throughout its various steps.\n\n### Tools Used\n\nManual Code Review.\nHardhat + modified tests from repo.\n\n### Recommended Mitigation Steps\n\nWhen contract calculations depend on calls to an `ERC20.balanceOf`, there is always a risk of a malicious user sending tokens directly to the contract to manipulate the calculations to their benefit.\n\nThe simplest solution would be to have a check that the expected amount of underlying is equal to the actual amount of underlying, and if not, have the `mint` function sweep these additional underlying tokens into the next `minter's` calculations, reducing the economic incentive and eliminating the exaggerated effect on the exchange rate.\n\n### Assessed type\n\nToken-Transfer\n\n**[chechu (Venus) disputed and commented via duplicate issue #314](https://github.com/code-423n4/2023-05-venus-findings/issues/314#issuecomment-1560106779):**\n > The attack would indeed be feasible if we didn’t require an initial supply.\n\n**[0xean (judge) commented via duplicate issue #314](https://github.com/code-423n4/2023-05-venus-findings/issues/314#issuecomment-1569220872):**\n >@chechu - can you point me to this in the codebase?\n\n**[chechu (Venus) commented via duplicate issue #314](https://github.com/code-423n4/2023-05-venus-findings/issues/314#issuecomment-1570021693):**\n>Our fault, we **allow** an initial supply, but we don't **require** it. https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Pool/PoolRegistry.sol#L321\n>\n>The origin of the confusion is that we'll provide, for sure, an initial supply on every market that we'll add to the `PoolRegistry`, and the process to add new markets is under the control of the Governance (so, the community will have to vote for it). For that reason, we really assumed that there will be an initial supply, but now we realized we are not requiring it in the code. We'll do it, just to avoid any confusion or potential error.\n>\n>We won't integrate the Oracles, but the initial idea is to provide at least `$`10,000 as an initial supply on each new market. That \"check\" will be done externally, when the VIP is prepared to be proposed to the community.\n\n**[chechu (Venus) commented](https://github.com/code-423n4/2023-05-venus-findings/issues/220#issuecomment-1637858904):**\n>> 1. Allows the attacker to push their leverage past the market collateralFactor\n>\n>This is wrong. If you mint (receiving X `vTokens`) and then you transfer underlying tokens to the market, your X `vTokens` will have a greater value because the exchange rate is greater after the donation. In the PoC:\n>\n>1. The attacker mints 10 WBTC -> `vTokens` received: 10\n>2. The attacker donates 20 WBTC -> this change the exchange rate from 1000000000000000000 to 2000000000000000000, so, basically, the `vTokens` previously minted now can be redeemed receiving the double amount of WBTC (that is the expected effect of this donation).\n>\n>So, the value of the 10 `vTokens` of the attacker after the donation is 20 WBTC, not 10 WBTC. For that reason, the user can borrow 13 WBTC (13 < 20 * 0.7, where 0.7 is the collateral factor).\n>\n>The attacker could get a similar (actually better) effect minting more `vTokens` supplying the 20 WBTC tokens, instead of donating them. Moreover, donating is a benefit for every user with `vTokens` before the donation, while minting only benefits the minter.\n>\n>To demonstrate it, you can replace the following statement in the PoC:\n>\n>```\n>await mockWBTC.connect(attacker).transfer(vWBTC.address, convertToUnit(20, 8))\n>```\n>\n>with this one:\n>\n>```\n>await vWBTC.connect(attacker).mint(convertToUnit(20, 8));\n>```\n>\n>And the output of the PoC will be the same.\n>\n>> 2. Violates the internal accounting when borrowing and repaying causing the `totalBorrows` and the sum of the individual account borrows to become out of sync. I.E. the `totalBorrows` can become 0 while their are still some loans outstanding, leading to loss of earned interest.\n>\n>This is not because of the transfer (donation), but because of the known rounding issues associated with the used math; which can generate small differences among the `totalBorrow` variable and the sum of the individual borrowed amounts.\n>\n>> 3. The attacker can use the leverage to repeatedly borrow + mint into the `VToken` in order to inflate their share of the token rewards issued by the rewards distributor.\n>\n>That is true, but, again, it's independent of the donations. Users can use the leverage to increase their positions and therefore get more rewards. The main downside of leveraging is the cost (every X `WBTC` borrowed that are then supplied implies a cost for the user proportional to the reserve factor of the market). So, taking into account that the total rewards to distribute are fixed, the leverage can make sense depending on the total suppliers and borrowers.\n>\n>> The permanent side-effect of this exploit is that the minting of `VTokens` to any subsequent users remains stunted as there is no direct mechanism to clear the excess underlying tokens from the contract. This can taint this `Pool` permanently.\n>\n>Donations to markets are supported, and there aren't known negative side effects on regular scenarios. If the liquidity of the market is very low, donations can facilitate issues related to rounding (like in the Hundred Finance attack, https://twitter.com/danielvf/status/1647329491788677121), but every market in Venus starts with a minimum liquidity that should reduce these risks.\n>\n>Finally, in the PoC, some redeems operations fail because those users still have some borrowed amount. Printing the error thrown you can see how the error is `InsufficientLiquidity`, thrown in the `Comptroller._checkRedeemAllowed` function. To repay 100% of the debt, the best option is to invoke the `repayBorrow` providing an big amount as parameter. The function will get only the borrowed amount (considering interest accrued until that block).\n\n**[thebrittfactor (C4) commented](https://github.com/code-423n4/2023-05-venus-findings/issues/220#issuecomment-1655683997):**\n>Sponsor requested additional feedback from the warden in regards to this submission after the Post-Judging QA period. C4 staff reached out to the warden directly with that request.\n\n**[LokiThe5th (warden) commented](https://github.com/code-423n4/2023-05-venus-findings/issues/220#issuecomment-1655683997):**\n\n>Thank you for the feedback. I don't have access to my original notes anymore, but will try to provide clarity where I can. To be clear, in retrospect, this submission seems to have conflated a few issues while trying to demonstrate the exchange rate issue.\n>\n>> This is wrong. If you mint (receiving X `vTokens`) and then you transfer underlying tokens to the market, your X `vTokens` will have a greater value because the exchange rate is greater after the donation. \n>\n>Yes, you are correct. The exchange rate is manipulated (which is the issue). To be more specific, the attacker *appears* to be able to push past the collateral factor when *considering the amount of `vToken` held by the attacker*. The intention here is to demonstrate this exchange rate manipulation through borrowing past what the internal accounting would hold the attacker's safe collateral factor would be.\n>\n>> This is not because of the transfer (donation), but because of the known rounding issues associated with the used math; which can generate small differences among the `totalBorrow` variable and the sum of the individual borrowed amounts.  \n>\n>Indeed, rounding in Solidity is a known issue. It may well be that the direct transfer only served to exacerbate this issue when compared with the control scenario.\n>\n>> That is true, but, again, it's independent of the donations. Users can use the leverage to increase their positions and therefore get more rewards. The main downside of leveraging is the cost (every X `WBTC` borrowed that are then supplied implies a cost for the user proportional to the reserve factor of the market). So, taking into account that the total rewards to distribute are fixed, the leverage can make sense depending on the total suppliers and borrowers.  \n>\n>You are correct that this is independent of donations. Users using leverage in this way to increase their rewards is likely a separate issue.  \n>\n>> Donations to markets are supported, and there aren't known negative side effects on regular scenarios. If the liquidity of the market is very low, donations can facilitate issues related to rounding (like in the Hundred Finance attack, https://twitter.com/danielvf/status/1647329491788677121), but every market in Venus starts with a minimum liquidity that should reduce these risks.  \n>\n>In the context of modular markets exchange rate manipulation can be damaging. It is good practice to explicitly handle (or not handle) donations in the accounting logic for the contract. For example, in the standard `UniswapV2Pair` contracts calculations are made using an internal tracking of `reserves` to avoid this issue. \n>\n>> Finally, in the PoC, some redeems operations fail because those users still have some borrowed amount. Printing the error thrown you can see how the error is `InsufficientLiquidity`, thrown in the `Comptroller._checkRedeemAllowed` function. To repay 100% of the debt, the best option is to invoke the `repayBorrow` providing an big amount as parameter. The function will get only the borrowed amount (considering interest accrued until that block).\n>\n>You are correct. Some redeems fail because some users still have borrowed amounts. In the preceeding code these users tried repay their borrows using their exact `borrowBalance` from the call to `VToken.getAccountSnapshot(user)`. It would be acceptable for a user to assume that should they try to `repayBorrow` with this outstanding amount. If memory serves, this failure of repayment using the returned `borrowBalance` happened in exchange manipulation scenarios, but not others. But this may have been a mistaken assumption if that is not the case. If so, it would also be a separate issue.\n\n**[chechu (Venus) commented](https://github.com/code-423n4/2023-05-venus-findings/issues/220#issuecomment-1655688392):**\n>Hey @LokiThe5th - Thanks for your message.\n>\n>> To be more specific, the attacker appears to be able to push past the collateral factor when considering the amount of `vToken` held by the attacker.\n>\n>I think that is not precise. The donation doesn't allow users to break the rule of the collateral factor. The donation is increasing the value of the `vTokens`, so any user with `vTokens` before the donation will be able to borrow more tokens. That is correct, expected, and doesn't generate any issue.\n>\n>You call it manipulation, and I can see your point because with a donation the user is able to change the value of the exchange rate. Personally, I don't think this is a manipulation, because the user doesn't get any benefit by doing it. As I said, if the attacker mints instead of donating the same amount, he would be able to borrow more tokens (in a regular scenario, not being the first and only supplier).\n>\n>Example:\n>* Initial exchange rate: 1 (1 underlying token == 1 `vToken`)\n>* User 1 mints 1,000 tokens, receiving 1,000 `vTokens`. Exchange rate is not affected, so, it's 1\n>* Attacker 1 mints 1,000 tokens, receiving 1,000 `vTokens`. Exchange rate is not affected, so, it's 1\n>* Attacker 1 donates 2,000 tokens, not receiving anything, but changing the exchange rate, that now will be 2 (total cash / total `vTokens` minted)\n>\n>So, now the 1,000 `vTokens` have more value (the attacker would be able to redeem 1,000 `vTokens` and receive 2,000 tokens, instead of the original 1,000 tokens they minted). And therefore, the \"borrowing power\" of the attacker is greater. The attacker can borrow more assets from another market, because now his 1,000 `vTokens` has more value.\n>\n>But, that is a bad strategy by the attacker, because by doing the donation User 1 also received a benefit. Now, User 1 can redeem their 1,000 `vTokens`, receiving 2,000 tokens. Not only their original 1,000 tokens.\n>\n>A better strategy by the attacker would be to mint 2,000 tokens, instead of donating them. This way, the exchange rate doesn't change (so User 1 doesn't receive any benefit) and the \"borrowing power\" of the attacker is even higher (3,000 tokens, instead of 2,000 tokens achieved via the donation).\n>\n>So, yes, with a donation you are able to update the exchange rate, but you won't get any benefit, and you will lose resources.\n>\n>> Indeed, rounding in Solidity is a known issue. It may well be that the direct transfer only served to exacerbate this issue when compared with the control scenario.\n>\n>If you mint instead of donating, the rounding issue appears too. So, I don't think the donation exacerbates the rounding issue.\n>\n>> In the context of modular markets exchange rate manipulation can be damaging. It is good practice to explicitly handle (or not handle) donations in the accounting logic for the contract. For example, in the standard `UniswapV2Pair` contracts calculations are made using an internal tracking of reserves to avoid this issue.\n>\n>In the Venus protocol, I think donations benefit every `vToken` holder and don't affect future holders, because for a user getting `vTokens`, the relevant events happen from the `vTokens` are minted until they are redeemed. It doesn't matter what happened before. Moreover, the exchange rate is never decreasing. So, IMO, we can avoid the internal tracking of cash in the markets.\n>\n>> this failure of repayment using the returned `borrowBalance` happened in exchange manipulation scenarios, but not others.\n>\n>I think the failures of repayments are associated with the rounding issues, not with donations. I modified the provided PoC, transforming the donation into a mint, and this issue is still there. I think the impact is low because users are not able to repay 100% of their debt only in edge cases, with 1 or 2 borrowers in the market and after several blocks. With a regular number of borrowers, users shouldn't have any problem repaying their debt, and therefore redeeming their `vTokens`\n>\n>Thank you again for your time reviewing the code. We really appreciate it. Your comments push us to improve the code (and to understand it better, tbh). We are totally open to trying to clarify any doubts.\n\n***\n\n",
      "summary": "\nThis bug report describes a malicious user manipulating the protocol to receive greater rewards from the `RewardsDistributor` than they should. The attack works by the attacker minting into the `VToken` contract legitimately, and then transferring an amount of tokens directly to the `VToken` contract, which inflates the `exchangeRate` for all subsequent users who `mint`. This causes the attacker to be able to push their leverage past the market `collateralFactor`, violating the internal accounting when `borrowing` and `repaying`, and allowing the attacker to use the leverage to repeatedly `borrow` + `mint` into the `VToken` in order to inflate their share of the token rewards issued by the rewards distributor. This means that all subsequent `minter`s receive less `VTokens` than they should, and the attack cost is the loss of the `transfer` into the `VToken` contract.\n\nA Proof of Concept illustrating the case can be found in a [gist](https://gist.github.com/lokithe5th/cda577cc1b50cb91cfe1d4b1eccecc7e), which simulates and walks through the attack using the repo's test suite as a base. The exploit is commented on throughout its various steps.\n\nTools used for this bug report included manual code review and Hardhat + modified tests from the repo.\n\nThe recommended mitigation steps for this bug include having a check that the expected amount of underlying is equal to the actual amount of underlying, and if not, having the `mint` function sweep these additional underlying tokens into the next `minter's` calculations, reducing the economic incentive and eliminating the exaggerated effect on the exchange rate.\n\nThe assessed type of this bug is Token-Transfer. After the Post-Judging QA period, additional feedback from the warden was requested from the sponsor, which was provided. The warden clarified that in retrospect, this submission seemed to have conflated a few issues while trying to demonstrate the exchange rate issue, and that donations to markets are supported and there aren't known negative side effects on regular scenarios.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-05-venus",
      "sponsor_name": "Venus Protocol",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-05-venus",
      "github_link": "https://github.com/code-423n4/2023-05-venus-findings/issues/220",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "236",
      "slug": "m-10-exchange-rate-can-be-manipulated-code4rena-venus-protocol-venus-protocol-isolated-pools-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Venus Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Venus Protocol",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "18507",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 9,
      "protocol_id": "617",
      "title": "M-13: Missing checks for whether Arbitrum Sequencer is active",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/142 \n\n## Found by \n0xepley, Bauchibred, Bauer, Brenzee, J4de, ctf\\_sec, deadrxsezzz, tallo, tsvetanovv\n## Summary\n\nMissing checks for whether Arbitrum Sequencer is active\n\n## Vulnerability Detail\n\nthe onchain deployment context is changed, in prev contest the protocol only attemps to deploy the code to ethereum while in the current contest\n\nthe protocol intends to deploy to arbtrium as well!\n\nChainlink recommends that users using price oracles, check whether the Arbitrum sequencer is active\n\nhttps://docs.chain.link/data-feeds#l2-sequencer-uptime-feeds\n\nIf the sequencer goes down, the index oracles may have stale prices, since L2-submitted transactions (i.e. by the aggregating oracles) will not be processed.\n\n## Impact\n\nStale prices, e.g. if USDC were to de-peg while the sequencer is offline, stale price is used and can result in false liquidation or over-borrowing.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L76-L98\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse sequencer oracle to determine whether the sequencer is offline or not, and don't allow orders to be executed while the sequencer is offline.",
      "summary": "\nThis bug report is about the missing checks for whether the Arbitrum Sequencer is active. It was found by 0xepley, Bauchibred, Bauer, Brenzee, J4de, ctf\\_sec, deadrxsezzz, tallo, and tsvetanovv. The protocol intends to deploy to Arbtrium, and Chainlink recommends that users using price oracles check whether the Arbitrum sequencer is active. If the sequencer goes down, the index oracles may have stale prices which can result in false liquidation or over-borrowing. The code snippet for this issue can be found at the given link. The tool used was Manual Review. The recommendation is to use sequencer oracle to determine whether the sequencer is offline or not, and not to allow orders to be executed while the sequencer is offline.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/69",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/142",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "m-13-missing-checks-for-whether-arbitrum-sequencer-is-active-sherlock-none-blueberry-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Missing-Logic"
          }
        },
        {
          "tags_tag": {
            "title": "L2 Sequencer"
          }
        },
        {
          "tags_tag": {
            "title": "Arbitrum"
          }
        }
      ]
    },
    {
      "id": "18504",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 8,
      "protocol_id": "617",
      "title": "M-10: Issue 94 from previous contest has not been fixed",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118 \n\n## Found by \n0x52, Bauchibred, cducrest-brainbot, deadrxsezzz, helpMePlease, kaysoft, peanuts, tsvetanovv\n## Summary\n\n[Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94) still exists exactly even though it was marked as \"will fix\".\n\n## Vulnerability Detail\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n## Impact\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n## Code Snippet\n\n[ChainlinkAdapterOracle.sol#L77-L97](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L77-L97)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)",
      "summary": "\nThis bug report is about Issue M-10, which is related to Issue 94 from a previous contest. It was found by eight members of the Sherlock Audit team, and it has not been fixed even though it was marked as \"will fix\". The vulnerability details, impact, code snippet, and recommendation can be found in Issue 94. It was found using manual review. This issue needs to be addressed as soon as possible.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/69",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "m-10-issue-94-from-previous-contest-has-not-been-fixed-sherlock-none-blueberry-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Missing-Logic"
          }
        }
      ]
    },
    {
      "id": "18501",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "617",
      "title": "M-7: BlueBerryBank#getPositionValue causes DOS if reward token is added that doens't have an oracle",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/115 \n\n## Found by \n0x52, nobody2018\n## Summary\n\ncollToken.pendingRewards pulls the most recent reward list from Aura/Convex. In the event that reward tokens are added to pools that don't currently have an oracle then it will DOS every action (repaying, liquidating, etc.). While this is only temporary it prevents liquidation which is a key process that should have 100% uptime otherwise the protocol could easily be left with bad debt.\n\n## Vulnerability Detail\n\n[BlueBerryBank.sol#L408-L413](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L408-L413)\n\n          (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n              pos.collToken\n          ).pendingRewards(pos.collId, pos.collateralSize);\n          for (uint256 i; i < tokens.length; i++) {\n              rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n          }\n\nUsing the pendingRewards method pulls a fresh list of all tokens. When a token is added as a reward but can't be priced then the call to getTokenValue will revert. Since getPostionValue is used in liquidations, it temporarily breaks liquidations which in a volatile market can cause bad debt to accumulate.\n\n## Impact\n\nTemporary DOS to liquidations which can result in bad debt\n\n## Code Snippet\n\n[BlueBerryBank.sol#L392-L417](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L392-L417)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReturn zero valuation if extra reward token can't be priced.",
      "summary": "\nThis bug report is about BlueBerryBank#getPositionValue which is a function in the BlueBerryBank.sol file. It is found by 0x52, nobody2018 and it causes a Denial-of-Service (DOS) attack if reward tokens are added to pools that don't have an oracle. This means that liquidations, which are a key process that should have 100% uptime, are temporarily prevented which can result in bad debt accumulating in a volatile market. \n\nThe code snippet for this vulnerability can be found in BlueBerryBank.sol#L392-L417. It was found through manual review. \n\nThe recommendation for this bug is to return a zero valuation if extra reward tokens can't be priced. This should prevent the DOS attack and keep the liquidation process running smoothly.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/69",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/115",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "m-7-blueberrybankgetpositionvalue-causes-dos-if-reward-token-is-added-that-doenst-have-an-oracle-sherlock-none-blueberry-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Denial-Of-Service"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Liquidation"
          }
        }
      ]
    },
    {
      "id": "18493",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "617",
      "title": "H-13: `BalancerPairOracle` can be manipulated using read-only reentrancy",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/141 \n\n## Found by \ncuthalion0x\n## Summary\n\n`BalancerPairOracle.getPrice` makes an external call to `BalancerVault.getPoolTokens` without checking the Balancer Vault's reentrancy guard. As a result, the oracle can be trivially manipulated to liquidate user positions prematurely.\n\n## Vulnerability Detail\n\nIn February, the Balancer team disclosed a read-only reentrancy vulnerability in the Balancer Vault. The detailed disclosure can be found [here](https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345). In short, all Balancer pools are susceptible to manipulation of their external queries, and all integrations must now take an extra step of precaution when consuming data. Via reentrancy, an attacker can force token balances and BPT supply to be out of sync, creating very inaccurate BPT prices.\n\nSome protocols, such as Sentiment, remained unaware of this issue for a few months and were later [hacked](https://twitter.com/spreekaway/status/1643313471180644360) as a result.\n\n`BalancerPairOracle.getPrice` makes a price calculation of the form `f(balances) / pool.totalSupply()`, so it is clearly vulnerable to synchronization issues between the two data points. A rough outline of the attack might look like this:\n\n```solidity\nAttackerContract.flashLoan() ->\n    // Borrow lots of tokens and trigger a callback.\n    SomeProtocol.flashLoan() ->\n        AttackerContract.exploit()\n\nAttackerContract.exploit() ->\n    // Join a Balancer Pool using the borrowed tokens and send some ETH along with the call.\n    BalancerVault.joinPool() ->\n        // The Vault will return the excess ETH to the sender, which will reenter this contract.\n        // At this point in the execution, the BPT supply has been updated but the token balances have not.\n        AttackerContract.receive()\n\nAttackerContract.receive() ->\n    // Liquidate a position using the same Balancer Pool as collateral.\n    BlueBerryBank.liquidate() ->\n        // Call to the oracle to check the price.\n        BalancerPairOracle.getPrice() ->\n            // Query the token balances. At this point in the execution, these have not been updated (see above).\n            // So, the balances are still the same as before the start of the large pool join.\n            BalancerVaul.getPoolTokens()\n\n            // Query the BPT supply. At this point in the execution, the supply has already been updated (see above).\n            // So, it includes the latest large pool join, and as such the BPT supply has grown by a large amount.\n            BalancerPool.getTotalSupply()\n\n            // Now the price is computed using both balances and supply, and the result is much smaller than it should be.\n            price = f(balances) / pool.totalSupply()\n\n        // The position is liquidated under false pretenses.\n```\n\n## Impact\n\nUsers choosing Balancer pool positions (such as Aura vaults) as collateral can be prematurely liquidated due to unreliable price data.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L70-L92\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe Balancer team recommends utilizing their [official library](https://github.com/balancer/balancer-v2-monorepo/blob/3ce5138abd8e336f9caf4d651184186fffcd2025/pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol) to safeguard queries such as `Vault.getPoolTokens`. However, the library makes a state-modifying call to the Balancer Vault, so it is not suitable for `view` functions such as `BalancerPairOracle.getPrice`. There are then two options:\n1. Invoke the library somewhere else. Perhaps insert a hook into critical system functions like `BlueBerryBank.liquidate`.\n2. Adapt a slightly different read-only solution that checks the Balancer Vault's reentrancy guard without actually entering.",
      "summary": "\nThis bug report is about the `BalancerPairOracle` contract, which is used to calculate the price of a Balancer Pool Token (BPT). The issue is that the `BalancerPairOracle.getPrice` function makes an external call to `BalancerVault.getPoolTokens` without checking the Balancer Vault's reentrancy guard. This means that the Oracle can be manipulated to liquidate user positions prematurely, as the price calculation is based on a combination of token balances and BPT supply.\n\nThe vulnerability was found by cuthalion0x and was initially disclosed by the Balancer team in February. It was later exploited in a hack of the Sentiment protocol.\n\nThe code snippet provided is from the `BalancerPairOracle.sol` file, line 70 to 92. The tool used was manual review.\n\nThe Balancer team recommends using their official library to safeguard queries such as `Vault.getPoolTokens`. However, this library makes a state-modifying call to the Balancer Vault, so it is not suitable for `view` functions such as `BalancerPairOracle.getPrice`. There are two possible solutions: 1. Invoke the library somewhere else, such as in critical system functions like `BlueBerryBank.liquidate`, or 2. Adapt a slightly different read-only solution that checks the Balancer Vault's reentrancy guard without actually entering.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/69",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/141",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "h-13-balancerpairoracle-can-be-manipulated-using-read-only-reentrancy-sherlock-none-blueberry-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Read-only Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Flash Loan"
          }
        }
      ]
    },
    {
      "id": "18484",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "617",
      "title": "H-4: Potential flash loan attack vulnerability in `getPrice` function of CurveOracle",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/123 \n\n## Found by \nBauer, helpMePlease\n## Summary\nDuring a security review of the `getPrice` function in the CurveOracle, a potential flash loan attack vulnerability was identified.\n\n## Vulnerability Detail\nThe `getPrice` function retrieves the spot price of each token in a Curve LP pool, calculates the minimum price among them, and multiplies it by the virtual price of the LP token to determine the USD value of the LP token. If the price of one or more tokens in the pool is manipulated, this can cause the minimum price calculation to be skewed, leading to an incorrect USD value for the LP token. This can be exploited by attackers to make a profit at the expense of other users.\n\n## Impact\nThis vulnerability could potentially allow attackers to manipulate the price of tokens in Curve LP pools and profit at the expense of other users. If exploited, this vulnerability could result in significant financial losses for affected users.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/oracle/CurveOracle.sol#L122\n\n## Tool used\n\nManual Review\n\n## Recommendation\nuse TWAP to determine the prices of the underlying assets in the pool.",
      "summary": "\nA security review of the `getPrice` function in the CurveOracle revealed a potential flash loan attack vulnerability. The `getPrice` function retrieves the spot price of each token in a Curve LP pool, calculates the minimum price among them, and multiplies it by the virtual price of the LP token to determine the USD value of the LP token. If the price of one or more tokens in the pool is manipulated, this can cause the minimum price calculation to be skewed, leading to an incorrect USD value for the LP token. This can be exploited by attackers to make a profit at the expense of other users. If exploited, this vulnerability could result in significant financial losses for affected users. The code snippet for this vulnerability can be found at  https://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/oracle/CurveOracle.sol#L122. The security review was conducted manually. The recommendation to mitigate this vulnerability is to use TWAP (Time-Weighted Average Price) to determine the prices of the underlying assets in the pool.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/69",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/123",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "h-4-potential-flash-loan-attack-vulnerability-in-getprice-function-of-curveoracle-sherlock-none-blueberry-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Lending Pool"
          }
        },
        {
          "tags_tag": {
            "title": "Flash Loan"
          }
        }
      ]
    },
    {
      "id": "18538",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 19,
      "protocol_id": "613",
      "title": "M-1: ControllerPeggedAssetV2: outdated price may be used which can lead to wrong depeg events",
      "content": "Source: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/70 \n\n## Found by \n0xRobocop, 0xnirlin, ABA, Ch\\_301, Delvir0, Saeedalipoor01988, ShadowForce, TrungOre, ast3ros, bin2chen, carrot, evan, kaysoft, lemonmon, martin, minhtrng, p0wd3r, peanuts, roguereddwarf\n\n## Summary\nThe `updatedAt` timestamp in the price feed response is not checked. So outdated prices may be used.\n\n## Vulnerability Detail\nThe following checks are performed for the chainlink price feed:\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L299-L315\n\nAs you can see the `updatedAt` timestamp is not checked.\nSo the price may be outdated.\n\n## Impact\nThe price that is used by the Controller can be outdated. This means that a depeg event may be caused due to an outdated price which is incorrect. Only current prices must be used to check for a depeg event.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L273-L318\n\n## Tool used\nManual Review\n\n## Recommendation\nIntroduce a reasonable limit for how old the price can be and revert if the price is older:\n```diff\niff --git a/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol b/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol\nindex 0587c86..cf2dcf5 100644\n--- a/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol\n+++ b/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol\n@@ -275,8 +275,8 @@ contract ControllerPeggedAssetV2 {\n             ,\n             /*uint80 roundId*/\n             int256 answer,\n-            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n-            ,\n+            uint256 startedAt, \n+            uint256 updatedAt, /*uint80 answeredInRound*/\n \n         ) = sequencerUptimeFeed.latestRoundData();\n \n@@ -314,6 +314,8 @@ contract ControllerPeggedAssetV2 {\n \n         if (answeredInRound < roundID) revert RoundIDOutdated();\n \n+        if (updatedAt < block.timestamp - LIMIT) revert PriceOutdated();\n+\n         return price;\n     }\n```\n\n\n\n## Discussion\n\n**3xHarry**\n\nconsidering this\n\n**3xHarry**\n\nfix PR: https://github.com/Y2K-Finance/Earthquake/pull/141\n\n**IAm0x52**\n\nFix looks good. Controller will now revert if price is stale",
      "summary": "\nThis bug report is about the issue M-1 in the ControllerPeggedAssetV2 of the Y2K-Finance project. It was found by 0xRobocop, 0xnirlin, ABA, Ch\\_301, Delvir0, Saeedalipoor01988, ShadowForce, TrungOre, ast3ros, bin2chen, carrot, evan, kaysoft, lemonmon, martin, minhtrng, p0wd3r, peanuts, roguereddwarf and was identified using manual review.\n\nThe issue is that the `updatedAt` timestamp in the price feed response is not checked. This means that outdated prices may be used, which can lead to wrong depeg events. This is because the price used by the Controller can be outdated and only current prices must be used to check for a depeg event.\n\nThe code snippet of the ControllerPeggedAssetV2.sol can be found at https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L273-L318.\n\nThe recommendation is to introduce a reasonable limit for how old the price can be and revert if the price is older. A fix PR was created which can be found at https://github.com/Y2K-Finance/Earthquake/pull/141 and it was accepted by IAm0x52. The fix looks good and the Controller will now revert if the price is stale.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/57",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/70",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "57",
      "slug": "m-1-controllerpeggedassetv2-outdated-price-may-be-used-which-can-lead-to-wrong-depeg-events-sherlock-none-y2k-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Y2K",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Y2K",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        }
      ]
    },
    {
      "id": "8715",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "12",
      "title": "H-1: Adversary can sandwich oracle updates to exploit vault",
      "content": "Source: https://github.com/sherlock-audit/2023-03-olympus-judging/issues/1 \n\n## Found by \n0x52\n\n## Summary\n\nBLVaultLido added a mechanism to siphon off all wstETH obtained from mismatched pool and oracle prices. This was implemented to fix the problem that the vault could be manipulated to the attackers gain. This mitigation however does not fully address the issue and the same issue is still exploitable by sandwiching oracle update.\n\n## Vulnerability Detail\n\n[BLVaultLido.sol#L232-L240](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L232-L240)\n\n        uint256 wstethOhmPrice = manager.getTknOhmPrice();\n        uint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\n        // Take any arbs relative to the oracle price for the Treasury and return the rest to the owner\n        uint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n            ? expectedWstethAmountOut\n            : wstethAmountOut;\n        if (wstethAmountOut > wstethToReturn)\n            wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n\nIn the above lines we can see that the current oracle price is used to calculate the expected amount of wstETH to return to the user. In theory this should prevent the attack but an attacker can side step this sandwiching the oracle update.\n\nExample:\n\nThe POC is very similar to before except now it's composed of two transactions sandwiching the oracle update. Chainlink oracles have a tolerance threshold of 0.5% before updating so we will use that as our example value. The current price is assumed to be 0.995 wstETH/OHM. The oracle price (which is about to be updated) is currently 1:1\n\n    Transaction 1:\n    \n    Balances before attack (0.995:1)\n    Liquidity: 79.8 OHM 80.2 wstETH\n    Adversary: 20 wstETH\n    \n    Swap OHM so that pool price matches pre-update oracle price:\n    Liquidity: 80 OHM 80 wstETH\n    Adversary: -0.2 OHM 20.2 wstETH\n    \n    Balances after adversary has deposited to the pool:\n    Liquidity: 100 OHM 100 wstETH\n    Adversary: -0.2 OHM 0.2 wstETH\n    \n    Balances after adversary sells wstETH for OHM (0.5% movement in price):\n    Liquidity: 99.748 OHM 100.252 wstETH\n    Adversary: 0.052 OHM -0.052 wstETH\n    \n    Sandwiched Oracle Update:\n    \n    Oracle updates price of wstETH to 0.995 OHM. Since the attacker already sold wstETH to balance \n    the pool to the post-update price they will be able to withdraw the full amount of wstETH.\n    \n    Transaction 2:\n    \n    Balances after adversary removes their liquidity:\n    Liquidity: 79.798 OHM 80.202 wstETH\n    Adversary: 0.052 OHM 19.998 wstETH\n    \n    Balances after selling profited OHM:\n    Liquidity: 79.849 OHM 80.152 wstETH\n    Adversary: 20.05 wstETH\n\nAs shown above it's still profitable to exploit the vault by sandwiching the oracle updates. With each oracle update the pool can be repeatedly attacked causing large losses.\n\n## Impact\n\nVault will be attacked repeatedly for large losses\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L203-L256\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo prevent this I would recommend locking the user into the vault for some minimum amount of time (i.e. 24 hours)\n\n## Discussion\n\n**0xLienid**\n\nThis is kind of similar to #029 in terms of underlying cause (knowledge of oracle update price)\n\n**0xLienid**\n\nFix Implementation: https://github.com/0xLienid/sherlock-olympus/pull/3/files",
      "summary": "\nThis bug report is about the vulnerability found in the BLVaultLido code of the Olympus protocol, which is an Ethereum-based DeFi protocol. The vulnerability allows an adversary to exploit the vault by sandwiching the oracle update and siphon off all the wstETH obtained from mismatched pool and oracle prices. This was implemented to fix the problem that the vault could be manipulated to the attackers gain, but it does not fully address the issue. \n\nThe vulnerability is detailed in the BLVaultLido.sol#L232-L240 code snippet. It is explained with an example that shows how the attack is profitable for the attacker. The impact of this vulnerability is that the vault will be attacked repeatedly for large losses.\n\nThe bug was found by 0x52 and was detected using manual review. The recommendation given is to lock the user into the vault for some minimum amount of time (i.e. 24 hours). Additionally, a fix implementation was provided by 0xLienid.",
      "report_date": {},
      "contest_prize_txt": "10000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/60",
      "sponsor_name": "Olympus",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-03-olympus-judging/issues/1",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "60",
      "slug": "h-1-adversary-can-sandwich-oracle-updates-to-exploit-vault-sherlock-olympus-olympus-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Olympus Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Olympus Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Sandwich Attack"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "6689",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "13",
      "title": "M-3: _validateAndGetPrice() doesn't check If Arbitrum sequencer is down in Chainlink feeds",
      "content": "Source: https://github.com/sherlock-audit/2023-02-bond-judging/issues/1 \n\n## Found by \nAvci\n\n## Summary\nWhen utilizing Chainlink in L2 chains like Arbitrum, it's important to ensure that the prices provided are not falsely perceived as fresh, even when the sequencer is down. This vulnerability could potentially be exploited by malicious actors to gain an unfair advantage.\n\n## Vulnerability Detail\nThere is no check: \n```soldity\nsolidity function _validateAndGetPrice(AggregatorV2V3Interface feed_, uint48 updateThreshold_)\n        internal\n        view\n        returns (uint256)\n    {\n        // Get latest round data from feed\n        (uint80 roundId, int256 priceInt, , uint256 updatedAt, uint80 answeredInRound) = feed_\n            .latestRoundData();\n        // @audit check if Arbitrum L2 sequencer is down in Chainlink feeds: medium\n        // Validate chainlink price feed data\n        // 1. Answer should be greater than zero\n        // 2. Updated at timestamp should be within the update threshold\n        // 3. Answered in round ID should be the same as the round ID\n        if (\n            priceInt <= 0 ||\n            updatedAt < block.timestamp - uint256(updateThreshold_) ||\n            answeredInRound != roundId\n        ) revert BondOracle_BadFeed(address(feed_));\n        return uint256(priceInt);\n    }\n```\n## Impact\ncould potentially be exploited by malicious actors to gain an unfair advantage.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-bond-0xdanial/blob/0d6f979c9f361bc1101f429b3bb09264577b9a71/bonds/src/BondChainlinkOracle.sol#L129\n## Tool used\n\nManual Review\n\n## Recommendation\ncode example of Chainlink:\nhttps://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code \n\n\n## Discussion\n\n**Oighty**\n\nAgree this should be fixed for using the Chainlink Oracle Contract on L2s. I think the best way to handle is to have a mainnet version of the contract (as is) and L2 version of the contract which implements the sequencer feed check.\n\n**UsmannK**\n\nEscalate for 10 USDC.\n\nWatson states that the arbitrum sequencer may temporarily go down and cause stale prices to be read from the oracle. This is incorrect; the arbitrum sequencer going down cannot result in stale prices to be accepted. \n\nStale prices will have an old `updatedAt` timestamp and be rejected by the following code:\nhttps://github.com/sherlock-audit/2023-02-bond/blob/8a326a4b39fdaf9eaf5911cfd3e9676a83c24a58/bonds/src/BondChainlinkOracle.sol#L141-L146\n\n```solidity\n        // Validate chainlink price feed data\n        // 1. Answer should be greater than zero\n        // 2. Updated at timestamp should be within the update threshold\n        // 3. Answered in round ID should be the same as the round ID\n        if (\n            priceInt <= 0 ||\n            updatedAt < block.timestamp - uint256(updateThreshold_) ||\n            answeredInRound != roundId\n        ) revert BondOracle_BadFeed(address(feed_));\n```\n\nThe watson's link (https://docs.chain.link/data-feeds/l2-sequencer-feeds#arbitrum) is actually a metadata feed about historical uptime/downtime data that is not related to the supposed issue.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> Watson states that the arbitrum sequencer may temporarily go down and cause stale prices to be read from the oracle. This is incorrect; the arbitrum sequencer going down cannot result in stale prices to be accepted. \n> \n> Stale prices will have an old `updatedAt` timestamp and be rejected by the following code:\n> https://github.com/sherlock-audit/2023-02-bond/blob/8a326a4b39fdaf9eaf5911cfd3e9676a83c24a58/bonds/src/BondChainlinkOracle.sol#L141-L146\n> \n> ```solidity\n>         // Validate chainlink price feed data\n>         // 1. Answer should be greater than zero\n>         // 2. Updated at timestamp should be within the update threshold\n>         // 3. Answered in round ID should be the same as the round ID\n>         if (\n>             priceInt <= 0 ||\n>             updatedAt < block.timestamp - uint256(updateThreshold_) ||\n>             answeredInRound != roundId\n>         ) revert BondOracle_BadFeed(address(feed_));\n> ```\n> \n> The watson's link (https://docs.chain.link/data-feeds/l2-sequencer-feeds#arbitrum) is actually a metadata feed about historical uptime/downtime data that is not related to the supposed issue.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Oighty**\n\nIssue fixed here: https://github.com/Bond-Protocol/bonds/pull/53\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/pull/53\n\n**hrishibhat**\n\nEscalation rejected\n\nUpdating the escalation resolution.  \nConsidering this issue as a valid medium, additional sponsor comments:\n> If it updates again within the update threshold. The feeds typically can update several times within a threshold period if the price is moving a lot\nwhen the sequencer is down, the new price won't be reported to the chain. the feed on the L2 will return the value it had when it went down\n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Updating the escalation resolution.  \n> Considering this issue as a valid medium, additional sponsor comments:\n> > If it updates again within the update threshold. The feeds typically can update several times within a threshold period if the price is moving a lot\n> when the sequencer is down, the new price won't be reported to the chain. the feed on the L2 will return the value it had when it went down\n> \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about a vulnerability found in the BondChainlinkOracle.sol smart contract. The vulnerability exists in the _validateAndGetPrice() function, which does not check if the Arbitrum sequencer is down in Chainlink feeds. This means that stale prices can be accepted, which malicious actors could potentially exploit to gain an unfair advantage. The code snippet for this function can be found at https://github.com/sherlock-audit/2023-02-bond-0xdanial/blob/0d6f979c9f361bc1101f429b3bb09264577b9a71/bonds/src/BondChainlinkOracle.sol#L129.\n\nThe vulnerability was found by Avci and manually reviewed. The recommendation is to implement a check for the sequencer in the L2 version of the contract, and a code example of Chainlink can be found at https://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code.\n\nThe issue was discussed by Oighty, UsmannK, and sherlock-admin. Oighty suggested having a mainnet version of the contract and an L2 version of the contract which implements the sequencer feed check. UsmannK suggested escalating the issue for 10 USDC, but sherlock-admin rejected the escalation after further discussion. Watson's link (https://docs.chain.link/data-feeds/l2-sequencer-feeds#arbitrum) was actually a metadata feed about historical uptime/downtime data that is not related to the supposed issue.\n\nThe issue was fixed in https://github.com/Bond-Protocol/bonds/pull/53, and the escalation was rejected. Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "report_date": {},
      "contest_prize_txt": "25000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/53",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-bond-judging/issues/1",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "53",
      "slug": "m-3-_validateandgetprice-doesnt-check-if-arbitrum-sequencer-is-down-in-chainlink-feeds-sherlock-bond-protocol-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Bond Protocol Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Bond Protocol Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        },
        {
          "tags_tag": {
            "title": "L2 Sequencer"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "6663",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "32",
      "title": "M-16: ChainlinkAdapterOracle will return the wrong price for asset if underlying aggregator hits minAnswer",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18 \n\n## Found by \n0x52\n\n## Summary\n\nChainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. The result is that if an asset experiences a huge drop in value (i.e. LUNA crash) the price of the oracle will continue to return the minPrice instead of the actual price of the asset. This would allow user to continue borrowing with the asset but at the wrong price. This is exactly what happened to [Venus on BSC when LUNA imploded](https://rekt.news/venus-blizz-rekt/). \n\n## Vulnerability Detail\n\nChainlinkAdapterOracle uses the [ChainlinkFeedRegistry](https://etherscan.io/address/0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf) to obtain the price of the requested tokens.\n\n    function latestRoundData(\n      address base,\n      address quote\n    )\n      external\n      view\n      override\n      checkPairAccess()\n      returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n      )\n    {\n      uint16 currentPhaseId = s_currentPhaseId[base][quote];\n      //@audit this pulls the Aggregator for the requested pair\n      AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n      require(address(aggregator) != address(0), \"Feed not found\");\n      (\n        roundId,\n        answer,\n        startedAt,\n        updatedAt,\n        answeredInRound\n      ) = aggregator.latestRoundData();\n      return _addPhaseIds(roundId, answer, startedAt, updatedAt, answeredInRound, currentPhaseId);\n    }\n\nChainlinkFeedRegistry#latestRoundData pulls the associated aggregator and requests round data from it. ChainlinkAggregators have minPrice and maxPrice circuit breakers built into them. This means that if the price of the asset drops below the minPrice, the protocol will continue to value the token at minPrice instead of it's actual value. This will allow users to take out huge amounts of bad debt and bankrupt the protocol.\n\nExample:\nTokenA has a minPrice of $1. The price of TokenA drops to $0.10. The aggregator still returns $1 allowing the user to borrow against TokenA as if it is $1 which is 10x it's actual value.\n\nNote:\nChainlink oracles are used a just one piece of the OracleAggregator system and it is assumed that using a combination of other oracles, a scenario like this can be avoided. However this is not the case because the other oracles also have their flaws that can still allow this to be exploited. As an example if the chainlink oracle is being used with a UniswapV3Oracle which uses a long TWAP then this will be exploitable when the TWAP is near the minPrice on the way down. In a scenario like that it wouldn't matter what the third oracle was because it would be bypassed with the two matching oracles prices. If secondary oracles like Band are used a malicious user could DDOS relayers to prevent update pricing. Once the price becomes stale the chainlink oracle would be the only oracle left and it's price would be used.\n\n## Impact\n\nIn the event that an asset crashes (i.e. LUNA) the protocol can be manipulated to give out loans at an inflated price\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L66-L84\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChainlinkAdapterOracle should check the returned answer against the minPrice/maxPrice and revert if the answer is outside of the bounds:\n\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        \n    +   if (answer >= maxPrice or answer <= minPrice) revert();\n    \n    \n\n## Discussion\n\n**Gornutz**\n\nThe aggregator is responding with answers from the multiple of oracle sources\n\n**IAm0x52**\n\nEscalate for 50 USDC\n\nThis is not a dupe of #94\n\n```The aggregator is responding with answers from the multiple of oracle sources```\n\nThis comment is true but in my submission I address this exact issue and why it's still an issue even if the aggregator has multiple sources:\n\n> Note:\n> Chainlink oracles are used a just one piece of the OracleAggregator system and it is assumed that using a combination of other oracles, a scenario like this can be avoided. However this is not the case because the other oracles also have their flaws that can still allow this to be exploited. As an example if the chainlink oracle is being used with a UniswapV3Oracle which uses a long TWAP then this will be exploitable when the TWAP is near the minPrice on the way down. In a scenario like that it wouldn't matter what the third oracle was because it would be bypassed with the two matching oracles prices. If secondary oracles like Band are used a malicious user could DDOS relayers to prevent update pricing. Once the price becomes stale the chainlink oracle would be the only oracle left and it's price would be used.```\n\nEven with the structure of aggregator there are still lots of scenarios where this could cause an issue. The chainlink oracle needs to revert at min/max answer because otherwise it risk returning the wrong price and causing the collateral to be overvalued leading to huge amounts of abuse.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC\n> \n> This is not a dupe of #94\n> \n> ```The aggregator is responding with answers from the multiple of oracle sources```\n> \n> This comment is true but in my submission I address this exact issue and why it's still an issue even if the aggregator has multiple sources:\n> \n> > Note:\n> > Chainlink oracles are used a just one piece of the OracleAggregator system and it is assumed that using a combination of other oracles, a scenario like this can be avoided. However this is not the case because the other oracles also have their flaws that can still allow this to be exploited. As an example if the chainlink oracle is being used with a UniswapV3Oracle which uses a long TWAP then this will be exploitable when the TWAP is near the minPrice on the way down. In a scenario like that it wouldn't matter what the third oracle was because it would be bypassed with the two matching oracles prices. If secondary oracles like Band are used a malicious user could DDOS relayers to prevent update pricing. Once the price becomes stale the chainlink oracle would be the only oracle left and it's price would be used.```\n> \n> Even with the structure of aggregator there are still lots of scenarios where this could cause an issue. The chainlink oracle needs to revert at min/max answer because otherwise it risk returning the wrong price and causing the collateral to be overvalued leading to huge amounts of abuse.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Gornutz**\n\nGiven the multi-aggregator setup we will use, once price hits Chainlink's oracles will at their min value. The other oracles will respond with a price well below that min value and will have a large enough deviation to cause a revert. Since the assets will be pooling from Chainlink / Band / Twap. Think setting a min / max inside of the chainlink oracle directly will potentially cause additional attack vectors to be created.\n\n**hrishibhat**\n\nEscalation accepted\n\nNot a duplicate of #94 \nThis issue is a valid medium\nGiven the unlikely edge case of Chainlink hitting minimum value as a result of a serious price movement and resulting in undercollateralized borrowing. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This issue is a valid medium\n> Given the unlikely edge case of Chainlink hitting minimum value as a result of a serious price movement and resulting in undercollateralized borrowing. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the ChainlinkAdapterOracle which could return the wrong price for an asset if the underlying aggregator hits minAnswer. The issue was found by 0x52 and is related to the ChainlinkFeedRegistry which pulls the associated aggregator and requests round data from it. The aggregator has minPrice and maxPrice circuit breakers built into them, so if the price of the asset drops below the minPrice, the protocol will continue to value the token at minPrice instead of its actual value. This would allow users to take out huge amounts of bad debt and bankrupt the protocol. \n\nThe code snippet for this issue can be found at https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L66-L84. The impact of this issue is that in the event that an asset crashes (i.e. LUNA), the protocol can be manipulated to give out loans at an inflated price. \n\nThe recommendation is that ChainlinkAdapterOracle should check the returned answer against the minPrice/maxPrice and revert if the answer is outside of the bounds. There was discussion about how this issue could still be exploitable even with the multi-aggregator setup and the use of other oracles. The issue was accepted and the contestants' payouts and scores will be updated according to the changes made on this issue.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/41",
      "sponsor_name": "Blueberry",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "41",
      "slug": "m-16-chainlinkadapteroracle-will-return-the-wrong-price-for-asset-if-underlying-aggregator-hits-minanswer-sherlock-blueberry-blueberry-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "6659",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 16,
      "protocol_id": "32",
      "title": "M-12: Chainlink's latestRoundData  return stale or incorrect result",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94 \n\n## Found by \n8olidity, tsvetanovv, WatchDogs, Nyx, Avci, obront, Aymen0909, SPYBOY, HonorLt, csanuragjain, koxuan, evan, rbserver, hl\\_, peanuts, Chinmay\n\n## Summary\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L76\n\n## Vulnerability Detail\n\n## Impact\nOn ChainlinkAdapterOracle.sol, you are using latestRoundData, but there is no check if the return value indicates stale data. \n```solidity\nfunction getPrice(address _token) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[_token];\n        if (token == address(0)) token = _token;\n\n        uint256 maxDelayTime = maxDelayTimes[token];\n        if (maxDelayTime == 0) revert NO_MAX_DELAY(_token);\n\n        // try to get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n\n        return (answer.toUint256() * 1e18) / 10**decimals;\n    }\n```\nThis could lead to stale prices according to the Chainlink documentation:\nhttps://docs.chain.link/data-feeds/price-feeds/historical-data\nRelated report:\nhttps://github.com/code-423n4/2021-05-fairside-findings/issues/70\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L76\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd the below check for returned data\n```solidity\nfunction getPrice(address _token) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[_token];\n        if (token == address(0)) token = _token;\n\n        uint256 maxDelayTime = maxDelayTimes[token];\n        if (maxDelayTime == 0) revert NO_MAX_DELAY(_token);\n\n        // try to get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (uint80 roundID, int256 answer, uint256 timestamp, uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        //Solution\n        require(updatedAt >= roundID, \"Stale price\");\n        require(timestamp != 0,\"Round not complete\");\n        require(answer > 0,\"Chainlink answer reporting 0\");\n\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n\n        return (answer.toUint256() * 1e18) / 10**decimals;\n    }\n```",
      "summary": "\nThis bug report is related to Chainlink's latestRoundData returning incorrect or stale results. The issue was found by 8olidity, tsvetanovv, WatchDogs, Nyx, Avci, obront, Aymen0909, SPYBOY, HonorLt, csanuragjain, koxuan, evan, rbserver, hl_, peanuts, and Chinmay. The code snippet for the vulnerability can be found at https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L76.\n\nThe vulnerability is that there is no check for the returned data from the latestRoundData to determine if it is stale. According to the Chainlink documentation, this could lead to stale prices. The impact of the vulnerability is that it could lead to incorrect prices being used, which could have serious implications for users.\n\nThe tool used to find the vulnerability was manual review. The recommendation is to add a check for the returned data to determine if it is stale. The code snippet for this is provided in the report. \n\nIn summary, this bug report is related to Chainlink's latestRoundData returning incorrect or stale results. The issue was found by multiple people and the tool used to detect it was manual review. The recommendation is to add a check for the returned data to determine if it is stale.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/41",
      "sponsor_name": "Blueberry",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "41",
      "slug": "m-12-chainlinks-latestrounddata-return-stale-or-incorrect-result-sherlock-blueberry-blueberry-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Missing-Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Data Validation"
          }
        }
      ]
    },
    {
      "id": "16144",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "35",
      "title": "[M-01] Low data feed frequency from Tellor makes your protocol vulnerable to flash loan attacks",
      "content": "\nAn attacker can stale Tellor Oracle for several hours cheaply and perform a flash loan attack to profit.\n\n### Proof of Concept\n\nTo explain this issue I will first compare Chainlink to Tellor.\n\nMost ERC-20 tokens are in general much more volatile than ETH and BTC. In Chainlink,  there are triggers of 0,5% for BTC and ETH and 1% for other assets. This is to ensure that you are cutting error by those values.\n\nTellor, on the other hand, is an *optimistic oracle*. Stakers use the oracle system to put data on chain `submitValue(..)` that are directly shown in the oracle. The security lies the fact that data consumers should wait some **dispute windows** in order to give time to others to dispute data and remove incorrect or malicious data.\n\nThis is what happened in a Liquity bug found last year, they were reading instant data.\\[2]\n\nBeing explained this and back to your code you have essentially two bugs\n\n### First bug: Default disputetime = 20 minutes\n\nIn `TellorCaller.sol` you have the following statement\n\n`(bytes memory data, uint256 timestamp) = getDataBefore(_queryId, block.timestamp - 20 minutes)`\n\nMaybe you are using 20 minutes because this is the default value in Tellor documentation. However, in Liquity they are using 15 minutes for ETH because they say that have been made an analysis of ETH volatility behaviour.\\[2]\n\nBasically there is a tradeoff between the volatility of an asset and the dispute time. More time is safer to have time to dipute but more likely to read a so old value.  Less dispute time you have less error but no time to dispute can put you at risk of reading a manipulated value.\n\nIn your case, you are using more volatile assets so in theory, if Liquity analysis is correct, you should be using less time for ERC20 assets.\n\nOf course this requires a deeper analysis but I am not doing it because the second bug makes this unnecessary as it has a higher impact.\n\n### Second bug: Data feed frequency in Tellor is very low so it is cheap to break\n\nI will briefly explain some Tellor security designs.\n\nTellor bases his security design in an exponential cost to dispute. They have a several-round voting to dispute a single value but we are interested in the *Cost of Stalling* (CoS) the System.\n\nTo stale the system we need to dipute every single value for a given period, for a given asset.\n\nAccording to whitepaper cost starts at  `baseFee`  and increase with the following formula\n\n`𝑑𝑖𝑠𝑝𝑢𝑡𝑒𝐹𝑒𝑒𝑖𝑑,𝑡,𝑟>1 = 𝑑𝑖𝑠𝑝𝑢𝑡𝑒𝐹𝑒𝑒𝑖 × 2 𝑑𝑖𝑠𝑝𝑢𝑡𝑒𝑅𝑜𝑢𝑛𝑑𝑠𝑖𝑑,𝑡−1`\n\nWhere\n\n𝑑𝑖𝑠𝑝𝑢𝑡𝑒𝐹𝑒𝑒𝑖 is the initial dispute fee (`baseFee`)\n\n𝑑𝑖𝑠𝑝𝑢𝑡𝑒𝑅𝑜𝑢𝑛𝑑𝑠𝑖𝑑 is the number of disputes open for a specific ID\n\nIn Ethereum, there is a block every 15 seconds so stalling the system for 8 minutes (32 blocks) will cost an attacker around `2^32 * 10 TRB`  = 687 Billons of dollars! ... (10TRB = 160USD). Not bad at all.\n\nTellor team has similar values in different docs around internet.\n\n​However, this is nice if we **always assume that one data is sent every block (an ideal system)**.\n\nAnd here is where the real nightmare comes. Current frequency for data in Tellor is very low, **that you are reading data once an hour or less!!**.\n\nEven worse for Optimism and Polygon `basedisputeFee` is only 1TRB . (vs 10 TRB in Ethereum)\n\nThis design was thought considering that these chains are faster so if you data is sent every block then breaking the system would be prohibitively expensive. Again, security depends on the frequency of data.\n\nIn our real word, Tellor is producing data in Optimism as low as in Ethereum so in the end it is 10 times cheaper to break.\n\n### Cost to Stale ETH/USD pair in Optimism\n\nLets calculate the CoS ETH/USD pair for 4 hours.\n\nWatching this Tellor contracts we can get that baseFee is 1TRB\n\n<https://optimistic.etherscan.io/address/0x46038969d7dc0b17bc72137d07b4ede43859da45#readContract> ==> `getDataFee()` = 1TRB\n\nNow, read data in a four hour range using the function.\n\n`getMultipleValuesBefore()`\n\nParameters passed\n\n`queryId =  0x83a7f3d48786ac2667503a61e8c415438ed2922eb86a2906e4ee66d9a2ce4992` (ID for asking ETH/USD pair value)\n\n`timestamp =  1678147200` (7 march 2023 at 0:00)\n\n`_max age = 14400` (4 hours earlier = 14400 seconds)\n\n`_maxCount = 1000` (doesn't really matter)\n\nWe get only 4 values with the following timestamps \\[1678135628,1678139237,1678142833,1678146437]\n\nThe *CoS* Tellor ETH/USD pair for these four hours would have been\n\n`1TRB + 2TRB + 4TRB + 8 TRB  = 15TRB`\n\n`15TRB * 16USD = 240 USD`\n\nThis means that for a little 240 bucks you can Stale 4 hours the Oracle which is not acceptable at all as I will show you an attacking scenario.\n\nEthereum has moved only 1%, not so critical this time, however volatille ERC20 used as a collateral can have much bigger changes.\n\nYou can query more data with different timestamps\n\n**Attacking Scenario: Flash Loan to profit**\n\nSteps:\n\n1.  Write a contract that checks if Chainlink is working\n\n2.  Meanwhile a second script that tracks values for all your collateral assets\n\n3.  When Chainlink is broken do\n\n4.  Stall all your collateral data from Tellor using `dispute`.   (10 collateral for `$2500`)\n\n5.  Suppose that you see an increase of 10% one of the colaterral  call it ABC and ETH not moving so much\n\n6.  Ask for a Flash Loan ETH in Uniswap\n\n7.  Mint LUSD for ETH at Ethos\n\n8.  Redeem LUSD for collateral ABC.    You get a 10% discount because Oracle is staled 4 hours ago\n\n9.  Exchange LUSD for ETHEREUM in Uniswap.\n\n10. Return ETH to the flash loan plus interest\n\n11. Enjoy!\n\nNote that this attack can be improved if you perform the loan on a falling collateral to mint more LUSD.\n\nThe only level of protection you have is the fact that Chainlink is working, in Liquity it is more difficult because it should be an important change of ETH value in those 4 hours.\n\n### Recommended\n\nThere are two solutions in my opinion\n\n**Solution 1:  Tellor tip mechanism**\n\nTellor whitepaper:\n\n*\"Parties who wish to build reporter support for their query should follow best practices when selecting data for their query (publish data specification on github, promote/ educate in the community), but will also need to tip a higher amount to incentivize activity\"*\n\n​This means that in order to use data safely you need to pay to be sure that frequency is secure taking into account the impact of the volatility and the time to dispute.\n\nI didn't mention earlier but the cost to dispute is exponential but capped by the staking amount of the reporter, so no real billons of dollars in fact.\n\nHere is the documentation how you can fund for a feed <https://docs.tellor.io/tellor/getting-data/funding-a-feed>\n\n**Solution 2: Do not use Tellor**\n\nUnlike Liquity, you need to fund several feeds so I don't know if this is cost effective but you have options to fund fees only when Chainlink is broken but you need to investigate on that.\n\nIn any case you have a function to set the oracle that I am reporting as medium so no sure if you need to use two oracles.\n\n### References\n\n1.  Tellor White Paper <https://tellor.io/whitepaper/>\n2.  Liquity Tellor issue 2022 <https://www.liquity.org/blog/tellor-issue-and-fix>\n\n**[c4-sponsor labeled](https://github.com/code-423n4/2023-02-ethos-findings/issues/772)** sponsor disputed\n\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-02-ethos-findings/issues/772#issuecomment-1459942559):**\n > This submission is interesting, but _may_ be invalid. The cost of stalling calculation assumes that attacker would only need to stall 4 price updates in 4 hours, however once stalling starts it would make sense for new price reports to appear very quickly, as soon as the next block. In other words, the sample warden has looked at only contains 4 updates because they were all legit.\n> \n> I have not verified this reasoning, but ask for sponsor to take a look and give their thoughts.\n\n**[tess3rac7 (Ethos Reserve) disputed and commented](https://github.com/code-423n4/2023-02-ethos-findings/issues/772#issuecomment-1466290128):**\n > It relies on **ALL** of the following to be true:\n> - chainlink broken\n> - tellor stalled for > 4 hours somehow by a malicious attacker\n> - no other tellor reporter realizing/recognizing this\n> - sharp movement in one collateral price during that timeframe\n> - not much movement in another collateral price during that timeframe\n> \n> Probability of all of the above happening together almost negligible. Moreover, it seems the report doesn't take into account:\n> - Redemption fee, which could be a very large % if the attacker is looking to drain the system\n> \n> Also forwarded this to our contacts at Tellor and this was their take:\n> \n> > So for the first one, it’s fair.  A lot of times people have trouble waiting the 20 minutes and there always is a risk that the price will change drastically in those 20 minutes, but unfortunately it’s just something that happens when you deal with decentralized systems (e.g. exchanges wait several blocks for confirmation, Maker waits an hour before updating its oracle).  And not to mention, the price can move very drastically even in the 12 second block time of Ethereum, so if the goal is to never have a stale price, it’s literally impossible.  You just need to design a system that can slow down and won’t break if this happens (which Liquity did and I’m presuming you guys did something similar)\n> \n> > For the second “bug”, the main flaw comes in the presumption of no outside actors looking to save the system or benefit from the attack.  When a good value is disputed on tellor, this is actually a profitable opportunity for any reporter.  Assuming the voting mechanism is not broken (as in the analysis), anyone who simply submits a good value will (after 4 rounds), double their TRB in 2 days.  (the voting period). This means that for 4 hours, you would need all of the reporters to not realize this.  This is a similar assumption as saying you could throw a uniswap pool and expect no one to see an arbitrage opportunity.  The second false assumption is that the current optimism report rate is how often the ETH/USD feed will update forever.  This is just wrong.  There are few reports on Optimism because there are no tips on Optimism and no one has even told any reporters (or the team) that they are live and would like more reports.  For relatively cheap, you can easily have several reports an hour, and even more if you’d like to pay for it.  Honestly however, you should probably just keep it on a 4 hour pace or a something that looks at the price change so as you aren’t over-paying or updating a same value.\n> \n> > Additionally, there are measures that you as a team could take to  dissuade an attacker.  For one, you could move the 4 hour stale period longer (no reason 4 hours is a golden number).  Second, you can stake reporters and report yourself.  If you have a large number of stakes ready to report on Optimism, you could simply listen for disputes and act as a reporter of last resort while you alert the other reporters to come and join the fun.  Simply having this amount publicly known or ready would probably be enough to raise the costs to a high enough to prevent any attack.\n> \n> Based on all of the above, I'm leaning towards \"not an issue.\"\n\n**[peritoflores (warden) commented](https://github.com/code-423n4/2023-02-ethos-findings/issues/772#issuecomment-1468102917):**\n > Hi Team, sorry for that but it is either I am so wrong or you could be drained.<br>\n> First, I have explained @Trust that reporters cannot just send reports every block after being disputed. This depends of how much they have staked.<br> \n> ![image](https://user-images.githubusercontent.com/89490285/224994796-8b65ae2e-4c2b-4274-921d-9a02d6300ceb.png)\n> \n> Secondly, there are only two reporters to protect the real system with a total staked valued at 5kUSD\n> \n> [TELLOR ORACLE AT OPTIMISM](https://optimistic.etherscan.io/address/0xD9157453E2668B2fc45b7A803D3FEF3642430cC0)\n> \n> ![image](https://user-images.githubusercontent.com/89490285/224999714-3c76b081-03bd-46ac-a507-fe50381f642b.png)\n> \n> **Tellor reporters are**<br>\n> 0x50a86759d495ecfa7c301071d6b0bdd4bd664ab0 ---> 200 trb locked<br>\n> 0xaac7da260fb6d047314e213f672b7d3d9503a1f7 ---> 130 trb locked<br>\n> \n> Unless people are watching off-chain to bridge TRB to optimism, dispute, stake and then submit a new value it is possible to take the oracle with only 5k or less.    \n> After disputing is not mandatory to submit a value.\n> \n> **About Tellor answer**<br>\n> I agree with almost all they said. The dispute is profitable even to double your money, but I am just interested in stale the system. The question is that if it is possible to get a correct value on time.<br>\n> What they explained about tips, of course I agree, in fact it is the solution that I proposed. \n> \n> **About your words**<br>\n> `chainlink broken`<br>    \n>  --->   This is the only condition \n>     \n> `tellor stalled for > 4 hours somehow by a malicious attacker        --->`<br>\n> This is just an example can be more or even less time.\n> \n> `no other tellor reporter realizing/recognizing this       -->`<br>\n> \n> As I explained there are only 2 reporters in the live system to protect you\n> \n> `sharp movement in one collateral price during that timeframe`<br> \n> `not much movement in another collateral price during that timeframe`\n>  \n> That happened last weekend when USDC was falling down\n> \n> On March 11 From 1:00 AM to 5AM USDC lost almost 15% of its value.<br>\n> However other crypto where not moving.\n> \n> Note that uniswap fees are only 0,3% plus gas cost.\n> \n> **An improved flash loan attack to drain collateral**\n> \n> Note that this attack is devastator because it is like an incredibly profitable arbitrage that can be performed in every block.\n> \n> While in arbitrage oportunities prices got balanced after the swap.\n> \n> Here the attacker can still hold the oracle and repeat the attack.\n\n**[Trust (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-02-ethos-findings/issues/772#issuecomment-1475967662):**\n > 1. Ethos relies on Tellor and plenty of logic faciliates the use of both CL/Tellor oracles, so the assumption of Chainlink downtime is definitely in-scope for medium severity.\n> 2. Having heard both sides, it seems the required attack indeed does not require _unreasonble_ amount of effort by an attacker (esp. regarding two live reporters). \n> 3. Given the execution of the attack is possible, likelihood of it generating big profits at protocol's expense is high.\n> \n> For these reasons, medium severity is most appropriate here.\n\n**[tess3rac7 (Ethos Reserve) commented](https://github.com/code-423n4/2023-02-ethos-findings/issues/772#issuecomment-1476503552):**\n > I'm still unclear as to how we can overlook redemption fees and claim that this will be profitable for an attacker looking to drain collateral.\n> \n> Redemption fees scales with:\n> - frequency of redemption, please see https://www.liquity.org/blog/on-price-stability-of-liquity\n> - amount being redeemed (proportional to the debt size of the market), please see https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/TroveManager.sol#L1411\n> \n> If the attacker decides to redeem in one large TX, the fee will be very high, not nearly enough to offset the hypothetical 10% gain in the warden's example. Here are some discord messages of Liquity's dev explaining:<br>\n> ![Screenshot from 2023-03-20 11-55-09](https://user-images.githubusercontent.com/95557476/226397690-99cdc145-036b-4f51-84af-e45f7c082021.png)\n> \n> If the attacker decides to redeem in smaller successive TXs, the base rate would keep increasing as explained in the blog post linked above.\n\n\n\n***\n\n",
      "summary": "\nThis bug report explains how an attacker can exploit a vulnerability in the Tellor Oracle system to perform a flash loan attack and profit from it. The vulnerability lies in the fact that the data feed frequency from Tellor is very low, which makes it cheap to break. This means that an attacker can stale Tellor Oracle for several hours cheaply and perform a flash loan attack. The report explains that the security of the system depends on the frequency of data sent. It also explains the cost to stale the ETH/USD pair in Optimism and an attacking scenario. Finally, the report suggests two solutions to make the system more secure. The first solution is to use the Tellor tip mechanism, where parties who wish to build reporter support for their query need to pay to be sure that frequency is secure. The second solution is to not use Tellor.",
      "report_date": {},
      "contest_prize_txt": "$144,750 USDC",
      "contest_link": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
      "sponsor_name": "Ethos Reserve",
      "sponsor_link": "https://twitter.com/EthosReserve",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-02-ethos",
      "github_link": "https://github.com/code-423n4/2023-02-ethos-findings/issues/772",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "216",
      "slug": "m-01-low-data-feed-frequency-from-tellor-makes-your-protocol-vulnerable-to-flash-loan-attacks-code4rena-ethos-reserve-ethos-reserve-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Ethos Reserve",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Ethos Reserve",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Flash Loan"
          }
        }
      ]
    },
    {
      "id": "17527",
      "kind": "PDF",
      "auditfirm_id": "9",
      "impact": "LOW",
      "finders_count": 2,
      "protocol_id": "769",
      "title": "Oracles can be invalid in at most one way",
      "content": "## Drift Protocol Security Assessment\n\n**Difficulty:** High  \n**Type:** Patching  \n**Target:** programs/drift/src/math/oracle.rs  \n\n## Description\nThe Drift Protocol codebase represents oracle validity using an `enum`, which does not allow an oracle to be invalid in more than one way. Furthermore, the code that determines an oracle’s validity imposes an implicit hierarchy on the ways an oracle could be invalid. This design is fragile and likely to cause future problems.\n\nThe `OracleValidity` enum is shown in Figure 14.1, and the code that determines an oracle’s validity is shown in Figure 14.2. Note that if an oracle is, for example, both “too volatile” and “too uncertain,” the oracle will be labeled simply `TooVolatile`. A caller that does not account for this fact and simply checks whether an oracle is `TooUncertain` could overlook oracles that are both “too volatile” and “too uncertain.”\n\n```rust\npub enum OracleValidity {\n    Invalid,\n    TooVolatile,\n    TooUncertain,\n    StaleForMargin,\n    InsufficientDataPoints,\n    StaleForAMM,\n    Valid,\n}\n```\n*Figure 14.1: programs/drift/src/math/oracle.rs#L21–L29*\n\n```rust\npub fn oracle_validity(\n    last_oracle_twap: i64,\n    oracle_price_data: &OraclePriceData,\n    valid_oracle_guard_rails: &ValidityGuardRails,\n) -> DriftResult<OracleValidity> {\n    ...\n    let oracle_validity = if is_oracle_price_nonpositive {\n        OracleValidity::Invalid\n    } else if is_oracle_price_too_volatile {\n        OracleValidity::TooVolatile\n    } else if is_conf_too_large {\n        OracleValidity::TooUncertain\n    } else if is_stale_for_margin {\n        OracleValidity::StaleForMargin\n    } else if !has_sufficient_number_of_data_points {\n        OracleValidity::InsufficientDataPoints\n    } else if is_stale_for_amm {\n        OracleValidity::StaleForAMM\n    } else {\n        OracleValidity::Valid\n    };\n    Ok(oracle_validity)\n}\n```\n*Figure 14.2: programs/drift/src/math/oracle.rs#L163–L230*\n\n## Exploit Scenario\nAlice, a Drift Protocol developer, is unaware of the implicit hierarchy among the `OracleValidity` variants. Alice writes code like `oracle_validity != OracleValidity::TooUncertain` and unknowingly introduces a bug into the codebase.\n\n## Recommendations\n- **Short term:** Represent oracle validity as a set of flags. This will allow oracles to be invalid in more than one way, which will result in more robust and maintainable code.\n- **Long term:** Thoroughly test all code that relies on oracle validity. This will help ensure the code’s correctness following the aforementioned change.",
      "summary": "",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-12-driftlabs-driftprotocol-securityreview.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-12-driftlabs-driftprotocol-securityreview.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/2022-12-driftlabs-driftprotocol-securityreview.pdf",
      "pdf_page_from": 44,
      "contest_id": "",
      "slug": "oracles-can-be-invalid-in-at-most-one-way-trailofbits-drift-protocol-pdf",
      "firm_name": "TrailOfBits",
      "firm_logo_square": "trailofbits_square.png",
      "protocol_name": "Drift Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "TrailOfBits",
        "logo_square": "trailofbits_square.png"
      },
      "protocols_protocol": {
        "name": "Drift Protocol",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "18768",
      "kind": "MARKDOWN",
      "auditfirm_id": "12",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "833",
      "title": "[M-02] Check for stale data before trusting Chainlink's response",
      "content": "Much of the math in the protocol is based on the data provided by Chainlink's ETH-USD feed.\n\nAccording to [Chainlink's documentation](https://docs.chain.link/data-feeds/price-feeds/historical-data), it is important to provide additional checks that the data is fresh:\n\n- If answeredInRound is less than roundId, the answer is being carried over.\n- A timestamp with zero value means the round is not complete and should not be used.\n\n**Recommendation**\n\nAdd the following checks to the \\_getEthPrice() function to ensure the data is fresh and accurate:\n\n```solidity\nfunction _getEthPrice() public view returns (uint) {\n(uint80 roundID, int256 price,, uint256 timeStamp, uint80 answeredInRound) = oracle.latestRoundData();\nrequire(timeStamp != 0);\nrequire(answeredInRound >= roundID);\nreturn price.toUint256();\n}\n```\n\n**Review**\nFix confirmed in [PR #10](https://github.com/DyadStablecoin/contracts-v3/pull/10).",
      "summary": "\nThis bug report is about the math in a protocol that is based on the data provided by Chainlink's ETH-USD feed. According to Chainlink's documentation, the data needs to be checked for freshness and accuracy. To do this, the _getEthPrice() function should be updated with two checks, as seen in the code snippet included in the report. This recommendation was reviewed and confirmed in the pull request #10, which can be found in the Github repository for DyadStablecoin contracts-v3.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-02-12-Dyad.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "m-02-check-for-stale-data-before-trusting-chainlinks-response-zachobront-none-dyad-markdown",
      "firm_name": "ZachObront",
      "firm_logo_square": "ZachObront_square.png",
      "protocol_name": "Dyad",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "ZachObront",
        "logo_square": "ZachObront_square.png"
      },
      "protocols_protocol": {
        "name": "Dyad",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Oracle"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        },
        {
          "tags_tag": {
            "title": "Validation"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "6212",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "253",
      "title": "[M-07] Last collateral check is not safe",
      "content": "\nLiquidation might work incorrectly.\n\n### Proof of Concept\n\nThere is a function `purchaseLiquidationAuctionNFT()` to allow liquidators to purchase NFTs on auction.\n\nIn the line 273, the protocol checks if the current NFT is the last collateral using the `collateralValueCached`.\n\nBut it might be possible for Reservoir Oracle to return zero (for whatever reason) and in that case `collateralValueCached` will be zero even when the `_vaultInfo[auction.nftOwner][auction.auctionAssetContract].count!=0`.\n\nOne might argue that it is impossible for the Reservoir oracle to return zero output but I think it is safe not to rely on it.\n\n```solidity\nPaprController.sol\n264:     function purchaseLiquidationAuctionNFT(\n265:         Auction calldata auction,\n266:         uint256 maxPrice,\n267:         address sendTo,\n268:         ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n269:     ) external override {\n270:         uint256 collateralValueCached = underwritePriceForCollateral(\n271:             auction.auctionAssetContract, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo\n272:         ) * _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count;\n273:         bool isLastCollateral = collateralValueCached == 0;//@audit not safe\n274:\n275:         uint256 debtCached = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].debt;\n276:         uint256 maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget());\n277:         /// anything above what is needed to bring this vault under maxDebt is considered excess\n278:         uint256 neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached;\n279:         uint256 price = _purchaseNFTAndUpdateVaultIfNeeded(auction, maxPrice, sendTo);time\n280:         uint256 excess = price > neededToSaveVault ? price - neededToSaveVault : 0;\n281:         uint256 remaining;\n282:\n283:         if (excess > 0) {\n284:             remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);\n285:         } else {\n286:             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), price);\n287:             remaining = debtCached - price;\n288:         }\n289:\n290:         if (isLastCollateral && remaining != 0) {\n291:             /// there will be debt left with no NFTs, set it to 0\n292:             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);\n293:         }\n294:     }\n295:\n\n```\n\n### Recommended Mitigation Steps\n\nChange the line 273 as below.\n\n```soliditiy\nbool isLastCollateral = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count == 0;\n```\n**[wilsoncusack (Backed) confirmed and commented](https://github.com/code-423n4/2022-12-backed-findings/issues/216#issuecomment-1370075373):**\n > Not sure if this was flagged in other issues but the outcome of this is significant: if we incorrectly think that it is a user's last NFT, then we will set their debt to 0. If they did in fact have other NFTs in, then they can withdraw these for free!\n\n**[trust1995 (judge) commented](https://github.com/code-423n4/2022-12-backed-findings/issues/216#issuecomment-1374537725):**\n > The impact of `underwritePriceForCollateral()` returning 0 when `count != 0` is clear. However, user has not specified a single plausible reason as to how the oracle could return 0. From my knowledge, it should not be possible with standard oracles, and therefore the finding can at most be treated as a Low level find. \n> Medium severity should clearly define hypotheticals, which are missing in the above report.\n\n**[hansfriese (warden) commented](https://github.com/code-423n4/2022-12-backed-findings/issues/216#issuecomment-1374573062):**\n > @trust1995 Please note that it is possible for the Reservoir oracle (that is used in this protocol) to return zero price.\n> \n> I tried their [test suite](https://docs.reservoir.tools/reference/getoraclecollectionscollectionflooraskv1) using a collection 0x495f947276749Ce646f68AC8c248420045cb7b5e.\n> \n> From the protocol's viewpoint, Reservoir is still an external dependency and I think no assumptions should be made about it.\n> \n> I reached out to the Reservoir protocol dev team regarding this and got a reply as below.\n> \n> ![screenshot_48](https://user-images.githubusercontent.com/45533148/211182410-db128844-3791-4bd6-9418-fbf6e9656dc0.png)\n> \n> After all, the Reservoir team also warns that it is not safe to assume their return price can not be zero.\n> \n\n**[trust1995 (judge) commented](https://github.com/code-423n4/2022-12-backed-findings/issues/216#issuecomment-1374787813):**\n > After deliberating on the decision with another judge, believe it is best to give warden the benefit of the doubt regarding hypotheticals surrounding zero return value. Will award Medium.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `purchaseLiquidationAuctionNFT()` function in the file `PaprController.sol` on line 273. The vulnerability is that the protocol checks if the current NFT is the last collateral using the `collateralValueCached`. But it might be possible for Reservoir Oracle to return zero (for whatever reason) and in that case `collateralValueCached` will be zero even when the `_vaultInfo[auction.nftOwner][auction.auctionAssetContract].count!=0`. This might cause the liquidation to work incorrectly.\n\nThe bug was found through manual review. The recommended mitigation step is to change the line 273 to `bool isLastCollateral = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count == 0;`. This will ensure that the liquidation works correctly and the vulnerability is eliminated.",
      "report_date": {},
      "contest_prize_txt": "$60,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-12-papr-contest",
      "sponsor_name": "Backed Protocol",
      "sponsor_link": "https://twitter.com/backed_xyz",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-12-backed",
      "github_link": "https://github.com/code-423n4/2022-12-backed-findings/issues/216",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "196",
      "slug": "m-07-last-collateral-check-is-not-safe-code4rena-backed-protocol-papr-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Backed Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Backed Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "6354",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 18,
      "protocol_id": "78",
      "title": "[M-24] Chainlink price feed is not sufficiently validated and can return stale price",
      "content": "\nAs mentioned by <https://docs.tigris.trade/protocol/oracle>, \"Prices provided by the oracle network are also compared to Chainlink's public price feeds for additional security. If prices have more than a 2% difference the transaction is reverted.\" The Chainlink price verification logic in the following `TradingLibrary.verifyPrice` function serves this purpose. However, besides that `IPrice(_chainlinkFeed).latestAnswer()` uses Chainlink's deprecated `latestAnswer` function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale. When `assetChainlinkPriceInt != 0` is `true`, it is still possible that `assetChainlinkPriceInt` is stale in which the Chainlink price verification would compare the off-chain price against a stale price returned by the Chainlink price feed. For a off-chain price that has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, which makes the price verification much less secure.\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122>\n\n```solidity\n    function verifyPrice(\n        uint256 _validSignatureTimer,\n        uint256 _asset,\n        bool _chainlinkEnabled,\n        address _chainlinkFeed,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        mapping(address => bool) storage _isNode\n    )\n        external view\n    {\n        ...\n        if (_chainlinkEnabled && _chainlinkFeed != address(0)) {\n            int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n            if (assetChainlinkPriceInt != 0) {\n                uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n                require(\n                    _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n                    _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n                );\n            }\n        }\n    }\n```\n\nBased on <https://docs.chain.link/docs/historical-price-data>, the following can be done to avoid using a stale price returned by the Chainlink price feed.\n\n1.  The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function.\n2.  `roundId` and `answeredInRound` are also returned. \"You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh.\"\n3.  \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"\n\n### Proof of Concept\n\nThe following steps can occur for the described scenario.\n\n1.  Alice calls the `Trading.initiateMarketOrder` function, which eventually calls the `TradingLibrary.verifyPrice` function, to initiate a market order.\n2.  When the `TradingLibrary.verifyPrice` function is called, the off-chain price is compared to the price returned by the Chainlink price feed for the position asset.\n3.  The price returned by the Chainlink price feed is stale, and the off-chain price has less than a 2% difference when comparing to this stale price.\n4.  Alice's `Trading.initiateMarketOrder` transaction goes through. However, this transaction should revert because the off-chain price has more than a 2% difference if comparing to a more current price returned by the Chainlink price feed.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L113> can be updated to the following code.\n\n```solidity\n            (uint80 roundId, int256 assetChainlinkPriceInt, , uint256 updatedAt, uint80 answeredInRound) = IPrice(_chainlinkFeed).latestRoundData();\n            require(answeredInRound >= roundId, \"price is stale\");\n            require(updatedAt > 0, \"round is incomplete\");\n```\n\n**[GainsGoblin (Tigris Trade) acknowledged and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/655#issuecomment-1377551479):**\n > We don't want a trader's trade to revert just because the chainlink feed is a round behind.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/655#issuecomment-1383083924):**\n > The Warden has pointed out to a possible risk related to the price oracle returning stale data.\n> \n> Alternatively to checking for latest round, a check for `updatedAt` to not be too far in the past should also help mitigate the risk of offering an incorrect price which can lead to value extraction or unintended behaviour.\n> \n> Because of the risk, I do agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/655#issuecomment-1407824582):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177187 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `TradingLibrary.verifyPrice` function of the code-423n4/2022-12-tigris repository. This function is used to compare an off-chain price to a price returned by a Chainlink price feed. The problem is that the function uses Chainlink's deprecated `latestAnswer` function, which does not guarantee that the price returned by the Chainlink price feed is not stale. This means that if the off-chain price has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, making the price verification much less secure. \n\nTo avoid using a stale price returned by the Chainlink price feed, the `latestRoundData` function can be used instead of the deprecated `latestAnswer` function. Additionally, `roundId` and `answeredInRound` are also returned, and can be checked against the current `roundId`. Finally, the timestamp on the round can be validated to make sure the round is complete.\n\nThe recommended mitigation step is to update the `TradingLibrary.verifyPrice` function to the code provided in the report. This code uses the `latestRoundData` function, checks the `roundId` and `answeredInRound` against the current `roundId`, and validates the timestamp on the round.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
      "sponsor_name": "Tigris Trade",
      "sponsor_link": "https://twitter.com/TigrisTrades",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/655",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "192",
      "slug": "m-24-chainlink-price-feed-is-not-sufficiently-validated-and-can-return-stale-price-code4rena-tigris-trade-tigris-trade-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Tigris Trade",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Tigris Trade",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Derivatives"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Algo-Stables"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        }
      ]
    },
    {
      "id": "5699",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "81",
      "title": "M-7: `latestRoundData()` has no check for round completeness",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/200 \n\n## Found by \n\\_\\_141345\\_\\_, 8olidity, yixxas, caventa, HonorLt\n\n## Summary\n\nNo check for round completeness could lead to stale prices and wrong price return value, or outdated price. The functions rely on accurate price feed might not work as expected, sometimes can lead to fund loss. \n\n\n## Vulnerability Detail\n\nThe oracle wrapper `getOraclePrice()` call out to an oracle with `latestRoundData()` to get the price of some token. Although the returned timestamp is checked, there is no check for round completeness.\n\nAccording to Chainlink's documentation, this function does not error if no answer has been reached but returns 0 or outdated round data. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations. Oracle reliance has historically resulted in crippled on-chain systems, and complications that lead to these outcomes can arise from things as simple as network congestion.\n\n## Reference\nChainlink documentation:\nhttps://docs.chain.link/docs/historical-price-data/#historical-rounds\n\n## Impact\n\nIf there is a problem with chainlink starting a new round and finding consensus on the new value for the oracle (e.g. chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale data (if oracles are unable to submit no new round is started).\n\nThis could lead to stale prices and wrong price return value, or outdated price.\n\nAs a result, the functions rely on accurate price feed might not work as expected, sometimes can lead to fund loss. The impacts vary and depends on the specific situation like the following:\n- incorrect liquidation\n    - some users could be liquidated when they should not\n    - no liquidation is performed when there should be\n- wrong price feed \n    - causing inappropriate loan being taken, beyond the current collateral factor\n    - too low price feed affect normal bor\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_Base.sol#L164-L181\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nValidate data feed for round completeness:\n```solidity\n    function getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256 ) {\n        (\n            uint80 roundID,\n            int signedPrice,\n            /*uint startedAt*/,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = _priceFeed.latestRoundData();\n        //check for Chainlink oracle deviancies, force a revert if any are present. Helps prevent a LUNA like issue\n        require(signedPrice > 0, \"Negative Oracle Price\");\n        require(timeStamp >= block.timestamp - HEARTBEAT_TIME , \"Stale pricefeed\");\n        require(signedPrice < _maxPrice, \"Upper price bound breached\");\n        require(signedPrice > _minPrice, \"Lower price bound breached\");\n        require(answeredInRound >= roundID, \"round not complete\");\n\n        uint256 price = uint256(signedPrice);\n        return price;\n    }\n```\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. \n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/5c656e791e70ecdfe26f9807438498384d7f6108",
      "summary": "\nThis bug report is about an issue found in the oracle wrapper `getOraclePrice()` of the Velo-Deposit-Tokens contract. This function calls out to an oracle with `latestRoundData()` to get the price of some token, however, there is no check for round completeness. As a result, the returned data might be outdated, leading to stale prices and wrong price return value. This could cause the functions relying on accurate price feed to not work as expected, and sometimes can lead to fund loss.\n\nThe impact of this issue varies depending on the situation, such as incorrect liquidation, wrong price feed, and inappropriate loan being taken. A code snippet and a reference to Chainlink's documentation are provided for further understanding.\n\nThe issue was found by \\_\\_141345\\_\\_, 8olidity, yixxas, caventa, HonorLt, and was fixed by kree-dotcom. The recommendation is to validate data feed for round completeness by adding a check for `answeredInRound >= roundID`.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/22",
      "sponsor_name": "Isomorph",
      "sponsor_link": "",
      "quality_score": 3,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/200",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "22",
      "slug": "m-7-latestrounddata-has-no-check-for-round-completeness-sherlock-isomorph-isomorph-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Isomorph",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Isomorph",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Privacy"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "5693",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "81",
      "title": "M-1: DepositReceipt_Base.sol#L21 : HEARTBEAT_TIME gap is too huge",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/256 \n\n## Found by \nak1\n\n## Summary\n\nHEARTBEAT_TIME = 24 hours could not be safe. The oracle data still be stale one.\n\n## Vulnerability Detail\n\noracle is using the HEARTBEAT_TIME  as 24 hours. Since the price of oracle could vary in the time gap of 3 hours, using 24 hours could be still dangerous.\n\n## Impact\nStale data used. Front runnable issue.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_Base.sol#L21\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse 3 hours as hearbeat.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor Confirmed. 24Hrs was originally for the sUSD chainlink feed, as seen here it can and should be much lower for other price feeds https://data.chain.link/optimism/mainnet/crypto-usd/eth-usd (mouse over trigger parameters)\n\n**kree-dotcom**\n\nclicked wrong button\n\n**kree-dotcom**\n\n3 hours as recommended by the auditor does not seem sufficient. Some Optimism price feeds such as ETH/USD and OP/USD have Heartbeats of 1200s or 20min. Currently we cannot find a method to fetch this via the oracle address and it looks like the Heartbeat sensitivity would have to be set per deployment of the depositReceipt.\n\n**kree-dotcom**\n\nFixed, https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/398f40cce538461396966ac22273f846d56f6f27\n\n`HEARTBEAT_TIME` is now an immutable var that is set by the deployer for each instance of a depositReceipt.",
      "summary": "\nThis bug report is about the `HEARTBEAT_TIME` variable in the `DepositReceipt_Base.sol` file located at line 21. It was found by ak1 and the vulnerability is that the `HEARTBEAT_TIME` is set to 24 hours, which could lead to stale data being used. This could potentially create a front runnable issue. The recommended solution is to use 3 hours as the `HEARTBEAT_TIME`. \n\nThe discussion then followed, with kree-dotcom noting that 3 hours may not be sufficient and that the `HEARTBEAT_TIME` should be set per deployment of the depositReceipt. It was then fixed, with `HEARTBEAT_TIME` now an immutable var that is set by the deployer for each instance of a depositReceipt.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/22",
      "sponsor_name": "Isomorph",
      "sponsor_link": "",
      "quality_score": 2,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/256",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "22",
      "slug": "m-1-depositreceipt_basesoll21-heartbeat_time-gap-is-too-huge-sherlock-isomorph-isomorph-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Isomorph",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Isomorph",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Privacy"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "25726",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 24,
      "protocol_id": "94",
      "title": "[M-12] During oracle outages or feeder outages/disagreement, the `ParaSpaceFallbackOracle` is not used",
      "content": "\nIf the feeders haven't updated their prices within the default six-hour time window, the floor oracle will revert when requests are made to get the current price, and these reverts are not caught by the wrapper oracle which handles the fallback oracle, so rather than using the fallback oracle in these cases, the calls will revert, leading to liquidations to fail (see my other submission for the full chain from the floor oracle to the liquidation function).\n\nAdditionally, the code uses the deprecated chainlink `latestAnswer()` API for its token requests, which may revert once it is no longer supported\n\n### Proof of Concept\n\n`getPrice()` will fail if the values are stale:\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #1\n\n236      function getPrice(address _asset)\n237          external\n238          view\n239          override\n240          returns (uint256 price)\n241      {\n242 @>       uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n243          require(\n244              (block.number - updatedAt) <= config.expirationPeriod,\n245 @>           \"NFTOracle: asset price expired\"\n246          );\n247          return assetPriceMap[_asset].twap;\n248:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L236-L248>\n\nThey can be stale due to too much price skew, or the feeders being down, e.g. due to another bug:\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #2\n\n369          // config maxPriceDeviation as multiple directly(not percent) for simplicity\n370          if (priceDeviation >= config.maxPriceDeviation) {\n371              return false;\n372:         }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L369-L372>\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #3\n\n376      function _finalizePrice(address _asset, uint256 _twap) internal {\n377          PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n378          assetPriceMapEntry.twap = _twap;\n379 @>       assetPriceMapEntry.updatedAt = block.number;\n380          assetPriceMapEntry.updatedTimestamp = block.timestamp;\n381          emit AssetDataSet(\n382              _asset,\n383              assetPriceMapEntry.twap,\n384              assetPriceMapEntry.updatedAt\n385          );\n386:     }\n```\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L376-L386>\n\nThe wrapper oracle does not use a try-catch, so it can't swallow these reverts and allow the fallback oracle to be used:\n\n```solidity\nFile: /paraspace-core/contracts/misc/ParaSpaceOracle.sol   #4\n\n114      /// @inheritdoc IPriceOracleGetter\n115      function getAssetPrice(address asset)\n116          public\n117          view\n118          override\n119          returns (uint256)\n120      {\n121          if (asset == BASE_CURRENCY) {\n122              return BASE_CURRENCY_UNIT;\n123          }\n124  \n125          uint256 price = 0;\n126          IEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n127          if (address(source) != address(0)) {\n128 @>           price = uint256(source.latestAnswer());\n129          }\n130          if (price == 0 && address(_fallbackOracle) != address(0)) {\n131 @>           price = _fallbackOracle.getAssetPrice(asset);\n132          }\n133  \n134          require(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n135          return price;\n136:     }\n```\n\n<br><https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136>\n\n### Recommended Mitigation Steps\n\nUse a try-catch when fetching the normal `latestAnswer()`, and use the fallback if it failed.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a problem with the floor oracle in the Paraspace platform, which is used to get the current price of an asset. If the feeders haven't updated their prices within the default six-hour time window, the floor oracle will revert when requests are made to get the current price, and these reverts are not caught by the wrapper oracle which handles the fallback oracle. This means that rather than using the fallback oracle in these cases, the calls will revert, leading to liquidations to fail. Additionally, the code uses the deprecated chainlink `latestAnswer()` API for its token requests, which may revert once it is no longer supported.\n\nThe bug is caused by the `getPrice()` function in the NFTFloorOracle.sol file, which will fail if the values are stale. This can be due to too much price skew, or the feeders being down, for example due to another bug. The wrapper oracle does not use a try-catch, so it can't swallow these reverts and allow the fallback oracle to be used.\n\nThe recommended mitigation steps are to use a try-catch when fetching the normal `latestAnswer()`, and use the fallback if it failed.",
      "report_date": {},
      "contest_prize_txt": "$192,500 USDC",
      "contest_link": "https://code4rena.com/reports/2022-11-paraspace",
      "sponsor_name": "ParaSpace",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/420",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "186",
      "slug": "m-12-during-oracle-outages-or-feeder-outagesdisagreement-the-paraspacefallbackoracle-is-not-used-code4rena-paraspace-paraspace-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "ParaSpace",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "ParaSpace",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "15995",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 24,
      "protocol_id": "94",
      "title": "[M-12] During oracle outages or feeder outages/disagreement, the ParaSpaceFallbackOracle is not used",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136\n\n\n## Vulnerability details\n\n## Impact\nIf the feeders haven't updated their prices within the default six-hour time window, the floor oracle will revert when requests are made to get the current price, and these reverts are not caught by the wrapper oracle which handles the fallback oracle, so rather than using the fallback oracle in these cases, the calls will revert, leading to liquidations to fail (see my other submission for the full chain from the floor oracle to the liquidation function).\n\nAdditionally, the code uses the deprecated chainlink `latestAnswer()` API for its token requests, which may revert once it is no longer supported\n\n## Proof of Concept\n`getPrice()` will fail if the values are stale:\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #1\n\n236      function getPrice(address _asset)\n237          external\n238          view\n239          override\n240          returns (uint256 price)\n241      {\n242 @>       uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n243          require(\n244              (block.number - updatedAt) <= config.expirationPeriod,\n245 @>           \"NFTOracle: asset price expired\"\n246          );\n247          return assetPriceMap[_asset].twap;\n248:     }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L236-L248\n\nThey can be stale due to too much price skew, or the feeders being down, e.g. due to another bug:\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #2\n\n369          // config maxPriceDeviation as multiple directly(not percent) for simplicity\n370          if (priceDeviation >= config.maxPriceDeviation) {\n371              return false;\n372:         }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L369-L372\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #3\n\n376      function _finalizePrice(address _asset, uint256 _twap) internal {\n377          PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n378          assetPriceMapEntry.twap = _twap;\n379 @>       assetPriceMapEntry.updatedAt = block.number;\n380          assetPriceMapEntry.updatedTimestamp = block.timestamp;\n381          emit AssetDataSet(\n382              _asset,\n383              assetPriceMapEntry.twap,\n384              assetPriceMapEntry.updatedAt\n385          );\n386:     }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L376-L386\n\nThe wrapper oracle does not use a try-catch, so it can't swallow these reverts and allow the fallback oracle to be used:\n```solidity\nFile: /paraspace-core/contracts/misc/ParaSpaceOracle.sol   #4\n\n114      /// @inheritdoc IPriceOracleGetter\n115      function getAssetPrice(address asset)\n116          public\n117          view\n118          override\n119          returns (uint256)\n120      {\n121          if (asset == BASE_CURRENCY) {\n122              return BASE_CURRENCY_UNIT;\n123          }\n124  \n125          uint256 price = 0;\n126          IEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n127          if (address(source) != address(0)) {\n128 @>           price = uint256(source.latestAnswer());\n129          }\n130          if (price == 0 && address(_fallbackOracle) != address(0)) {\n131 @>           price = _fallbackOracle.getAssetPrice(asset);\n132          }\n133  \n134          require(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n135          return price;\n136:     }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136\n\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nUse a try-catch when fetching the normal `latestAnswer()`, and use the fallback if it failed",
      "summary": "\nThis bug report is about the ParaSpaceOracle.sol contract. It is a smart contract that is used to fetch asset prices from a feeder oracle and a fallback oracle. If the feeders haven't updated their prices within the default six-hour time window, the floor oracle will revert when requests are made to get the current price. These reverts are not caught by the wrapper oracle which handles the fallback oracle, so rather than using the fallback oracle in these cases, the calls will revert, leading to liquidations to fail. Additionally, the code uses the deprecated chainlink `latestAnswer()` API for its token requests, which may revert once it is no longer supported.\n\nThe bug can be reproduced by calling the `getPrice()` function, which will fail if the values are stale. This can be caused by too much price skew, or the feeders being down. The wrapper oracle does not use a try-catch, so it can't swallow these reverts and allow the fallback oracle to be used.\n\nThe recommended mitigation step is to use a try-catch when fetching the normal `latestAnswer()`, and use the fallback if it failed.",
      "report_date": {},
      "contest_prize_txt": "$192,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-paraspace-contest",
      "sponsor_name": "ParaSpace",
      "sponsor_link": "https://twitter.com/ParaSpace_NFT",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/420",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "186",
      "slug": "m-12-during-oracle-outages-or-feeder-outagesdisagreement-the-paraspacefallbackoracle-is-not-used-code4rena-paraspace-paraspace-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "ParaSpace",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "ParaSpace",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        }
      ]
    },
    {
      "id": "15978",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "94",
      "title": "[H-05] Attacker can manipulate low TVL Uniswap V3 pool to borrow and swap to make Lending Pool in loss",
      "content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L176>\n\nIn Paraspace protocol, any Uniswap V3 position that are consist of ERC20 tokens that Paraspace support can be used as collateral to borrow funds from Paraspace pool. The value of the Uniswap V3 position will be sum of value of ERC20 tokens in it.\n\n```solidity\nfunction getTokenPrice(uint256 tokenId) public view returns (uint256) {\n    UinswapV3PositionData memory positionData = getOnchainPositionData(\n        tokenId\n    );\n\n    PairOracleData memory oracleData = _getOracleData(positionData);\n\n    (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts\n        .getAmountsForLiquidity(\n            oracleData.sqrtPriceX96,\n            TickMath.getSqrtRatioAtTick(positionData.tickLower),\n            TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n            positionData.liquidity\n        );\n\n    (\n        uint256 feeAmount0,\n        uint256 feeAmount1\n    ) = getLpFeeAmountFromPositionData(positionData);\n\n    return // @audit can be easily manipulated with low TVL pool\n        (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /\n            10**oracleData.token0Decimal) +\n        (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /\n            10**oracleData.token1Decimal);\n}\n```\n\nHowever, Uniswap V3 can have multiple pools for the **same pairs** of ERC20 tokens with **different fee** params. A fews has most the liquidity, while other pools have extremely little TVL or even not created yet. Attackers can abuse it, create low TVL pool where liquidity in this pool mostly (or fully) belong to attacker’s position, deposit this position as collateral and borrow token in Paraspace pool, swap to make the original position reduce the original value and cause Paraspace pool in loss.\n\n### Proof of Concept\n\nConsider the scenario where WETH and DAI are supported as collateral in Paraspace protocol.\n\n1.  Alice (attacker) create a new WETH/DAI pool in Uniswap V3 and add liquidity with the following amount<br>\n    `1e18 wei WETH - 1e6 wei DAI = 1 WETH - 1e-12 DAI ~= 1 ETH`<br>\n    Let's just assume Alice position has price range from `[MIN_TICK, MAX_TICK]` so the math can be approximately like Uniswap V2 - constant product.<br>\n    Note that this pool only has liquidity from Alice.\n2. Alice deposit this position into Paraspace, value of this position is approximately `1 WETH` and Alice borrow maximum possible amount of USDC.\n3. Alice make swap in her WETH/DAI pool in Uniswap V3 to make the position become<br>\n    `1e6 wei WETH - 1e18 wei DAI = 1e-12 WETH - 1 DAI ~= 1 DAI`\n\nPlease note that the math I've done above is approximation based on Uniswap V2 formula `x * y = k` because Alice provided liquidity from `MIN_TICK` to `MAX_TICK`.<br>\nFor more information about Uniswap V3 formula, please check their whitepaper here: <https://uniswap.org/whitepaper-v3.pdf>.\n\n### Recommended Mitigation Steps\n\nConsider adding whitelist, only allowing pool with enough TVL to be collateral in Paraspace protocol.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1376406262):** \n> Overinflated severity\n\n**[minhquanym (warden) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1400899415):**\n > Hi @LSDan,\n> Maybe there is a misunderstanding here. I believed I gave enough proof to make it a High issue and protocol can be at loss.<br>\n> You can think of it as using Uniswap V3 pool as a price Oracle. However, it did not even use TWA price but spot price and pool with low liquidity is really easy to be manipulated. We all can see many examples about Price manipulation attacks recently and they had a common cause that price can be changed in one block.<br>\n> About the Uniswap V3 pool with low liquidity, you can check out this one https://etherscan.io/address/0xbb256c2F1B677e27118b0345FD2b3894D2E6D487.<br>\n> This is a USDC-USDT pool with only `$8k` in it.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1403968688):**\n > This is not true because Alice's pool will be immediately arbed each time she attempts a price manipulation. Accordingly, this issue only exists when a pair has very low liquidity on UniV3 and no liquidity elsewhere. I would have accepted this as a QA, but it does not fall into the realm of a high risk issue.\n> \n> I'm open to accepting this as a medium if you can give me a more concrete scenario where the value that Alice is extracting from the protocol through this attack is sustainable and significant enough to exceed the gas price of creating a new UniV3 pool.\n\n**[minhquanym (warden) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1404042265):**\n > @LSDan, Please correct me if I'm wrong but I don't think Alice's pool can be arbed when the whole attack happens in 1 transaction. Because of that, I still believe that this is a High. For example, \n> 1. price before manipulation is `p1`\n> 2. flash loan and swap to change the price to `p2`\n> 3. add liquidity and borrow at price `p2`\n> 4. change the price back to `p1`\n> 5. repay the flash loan\n> \n> That's basically the idea. You can see price is back to `p1` at the end. \n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1404876330):**\n > Ok yeah... I see what you're saying now. This could be used to drain the pool because the underlying asset price comes from a different oracle. So if Alice creates a pool with 100 USDC and 100 USDT, and drops 3mm USDC from a flash loan into it, the external oracle will value the LP at `$3mm`. High makes sense. Thanks for the additional clarity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Paraspace protocol, which allows users to use Uniswap V3 positions as collateral to borrow funds from Paraspace pools. Uniswap V3 has multiple pools for the same pairs of ERC20 tokens with different fee parameters. Attackers can abuse this vulnerability by creating low TVL pools where the liquidity mostly or fully belongs to their own position, and then deposit this position as collateral and borrow token in Paraspace pool. This would allow them to reduce the original value of the position and cause Paraspace pool to suffer a loss. \n\nThe recommended mitigation steps for this vulnerability is to consider adding a whitelist, only allowing pools with enough TVL to be collateral in Paraspace protocol. This would help prevent attackers from creating low TVL pools and exploiting the vulnerability.",
      "report_date": {},
      "contest_prize_txt": "$192,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-paraspace-contest",
      "sponsor_name": "ParaSpace",
      "sponsor_link": "https://twitter.com/ParaSpace_NFT",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-11-paraspace",
      "github_link": "https://github.com/code-423n4/2022-11-paraspace-findings/issues/407",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "186",
      "slug": "h-05-attacker-can-manipulate-low-tvl-uniswap-v3-pool-to-borrow-and-swap-to-make-lending-pool-in-loss-code4rena-paraspace-paraspace-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "ParaSpace",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "ParaSpace",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "3508",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "110",
      "title": "H-1: An update gap in Chainlink's feed can malfunction the whole market",
      "content": "Source: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/42 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nThe `roundId` that is used for settling the price change and pushing the `latestExecutedEpochIndex` forward is strictly limited to be in a precise period of time. When there is no such `roundId`, the system will freeze and lock everyone out.\n\n## Vulnerability Detail\n\nThe check at L127 makes it impossible to use a roundId that was created at a later time than `relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH`.\n\nHowever, when the `EPOCH_LENGTH` is larger than the Chainlink feed's heartbeat length, or Chainlink failed to post a feed within the expected heartbeat for whatever reason, then it would be impossible to find a suitable roundId (as it does not exist) to push the epoch forward due to the rather strict limitation for the roundId.\n\n## Impact\n\nAs a result, the whole system will malfunction and no one can enter or exit the market.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L188-L195\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider allowing the `roundId` not to falls into the epoch, and use the previous roundId's price when that's the case:\n\n```diff\n    for (uint32 i = 0; i < lengthOfEpochsToExecute; i++) {\n      // Get correct data\n      (, int256 currentOraclePrice, uint256 currentOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i]);\n\n      // Get Previous round data to validate correctness.\n-      (, , uint256 previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i] - 1);\n+      (, int256 previousOraclePrice, uint256 previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i] - 1);\n\n      // Check if there was a 'phase change' AND the `_currentOraclePrice` is zero.\n      if ((oracleRoundIdsToExecute[i] >> 64) > (latestExecutedOracleRoundId >> 64) && previousOracleUpdateTimestamp == 0) {\n        // NOTE: if the phase changes, then we want to correct the phase of the update.\n        //       There is no guarantee that the phaseID won't increase multiple times in a short period of time (hence the while loop).\n        //       But chainlink does promise that it will be sequential.\n        // View how phase changes happen here: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol#L335\n        while (previousOracleUpdateTimestamp == 0) {\n          // NOTE: re-using this variable to keep gas costs low for this edge case.\n          latestExecutedOracleRoundId = (((latestExecutedOracleRoundId >> 64) + 1) << 64) | uint64(oracleRoundIdsToExecute[i] - 1);\n\n          (, , previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(latestExecutedOracleRoundId);\n        }\n      }\n\n      // This checks the price given is valid and falls within the correct window.\n      // see https://app.excalidraw.com/l/2big5WYTyfh/4PhAp1a28s1\n      if (\n        previousOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT ||\n        currentOracleUpdateTimestamp < relevantEpochStartTimestampWithMEWT\n-        currentOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH\n      ) revert InvalidOracleExecutionRoundId({oracleRoundId: oracleRoundIdsToExecute[i]});\n\n+      // If the new roundId does not falls into the epoch, use the prev roundId then\n+      if (currentOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH) {\n+        currentOraclePrice = previousOraclePrice;\n+      }\n\n      if (currentOraclePrice <= 0) revert InvalidOraclePrice({oraclePrice: currentOraclePrice});\n\n      missedEpochPriceUpdates[i] = currentOraclePrice;\n\n      relevantEpochStartTimestampWithMEWT += EPOCH_LENGTH;\n    }\n```\n\n## Discussion\n\n**JasoonS**\n\nThanks - we had a long internal debate discussion about this.\n\nWe decided that it is best to make the parameters (such as epoch length) long enough such that this is extremely unlikely to happen.\n\nWe have done some extensive latency and heartbeat analysis on chainlink oracles - as well as had an in-details discussion about how gas price spikes can cause delays to prices being pushed on chain (a side note - this is why a large mewt/minimumExecutionWatingTime is required - otherwise a gas price spike/griefing attack would be more feasible). I'll link some of that to this issue in a bit if that is interesting to you.\n\nAnyway - getting back to this issue - we believe it is better to leave the market paused if such an anomaly happens and give us time to analyse what happened. It is a sort of risk protection mechanism. Either we upgrade market for a fix (which will be under timelock), or we deprecate the market.\n\nI think our users will appreciate our prudence.\n\nOne thing to consider is that withdrawals also won't be processed in this edge case (maybe a good think?). I'll have another chat with the team on that.\n\nAgree that your solution is pretty benign too since there will just be no price change.\n\n**moose-code**\n\n@WooSungD would be useful if you could post that graph of chainlink prices on the analysis we did. \n\n**moose-code**\n\nFor more context, a few weeks ago we had detailed disscussion with the chainlink team, as you can't even rely on the hearbeat with certainty. \n\nE.g. the heartbeat of 27sec on polygon still showed outliers where we waited for up to 180 seconds in some cases for a new price because of big gas spikes. This is why we conducted the analysis so carefully, we want to make sure that we don't miss a chainlink price.\n\nHowever if we do miss a price, the auto deprecation means the system fails very gracefully, the markets are paused and everyone can simply withdraw after a cooldown period. \n\n**WooSungD**\n\nHere are some graphs showing the distribution of heartbeat (in seconds) for ETH-USD price feed on Chainlink Polygon.\n\n<img width=\"1641\" alt=\"image\" src=\"https://user-images.githubusercontent.com/88306711/202707461-cb8107d9-436f-44aa-af73-e9801c12aae3.png\">\n\n\n<img width=\"1654\" alt=\"image\" src=\"https://user-images.githubusercontent.com/88306711/202707525-b0dbb6d1-fd10-4aaa-bd93-b30dae6ef8cb.png\">\n\n\nThe outliers for the heartbeat mean that our MEWT needs to be longer (longer than max outlier necessarily) to prevent front-running.\n\nThe causes of outliers ito heartbeat were network congestion and gas spikes, according to the Chainlink team\n\n**moose-code**\n\nAfter chatting with the chainlink team more on this, the one potential attack vector (that seems unrealistic) that I can point out is spamming the polygon chain to the point where it delays the chainlink price update from being mined until the point where no valid price exists.\n\nThis would be extremely expensive and simply cause the market to deprecate (no financial gain). \n\n**Evert0x**\n\nWe still think this is a high severity issue as it can make the protocol malfunction",
      "summary": "\nThis bug report is about an update gap in Chainlink's feed which can malfunction the whole market. The check at L127 makes it impossible to use a roundId that was created at a later time than `relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH`. When the `EPOCH_LENGTH` is larger than the Chainlink feed's heartbeat length, or Chainlink failed to post a feed within the expected heartbeat for whatever reason, then it would be impossible to find a suitable roundId (as it does not exist) to push the epoch forward due to the rather strict limitation for the roundId. As a result, the whole system will malfunction and no one can enter or exit the market.\n\nThe bug was found by WATCHPUG and the code snippet can be viewed at https://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L188-L195. The tool used was Manual Review.\n\nThe recommendation was to consider allowing the `roundId` not to falls into the epoch, and use the previous roundId's price when that's the case. This was discussed further by team members, who decided that it is best to make the parameters (such as epoch length) long enough such that this is extremely unlikely to happen. They also found that withdrawals will not be processed in this edge case, which is a good thing. The team also noted that the attack vector of spamming the polygon chain to the point where it delays the chainlink price update from being mined until the point where no valid price exists is extremely expensive and simply cause the market to deprecate (no financial gain).\n\nDespite this, the team still considers this to be a high severity issue as it can make the protocol malfunction.",
      "report_date": {},
      "contest_prize_txt": "25000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/15",
      "sponsor_name": "Float Capital",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/42",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "15",
      "slug": "h-1-an-update-gap-in-chainlinks-feed-can-malfunction-the-whole-market-sherlock-float-capital-float-capital-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Float Capital",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Float Capital",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Derivatives"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        }
      ]
    },
    {
      "id": "5747",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "126",
      "title": "[M-18] Protocol’s usability becomes very limited when access to Chainlink oracle data feed is blocked",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363\n\n\n## Vulnerability details\n\n## Impact\nBased on the current implementation, when the protocol wants to use Chainlink oracle data feed for getting a collateral token's price, the fixed price for the token should not be set. When the fixed price is not set for the token, calling the `Oracle` contract's `viewPrice` or `getPrice` function will execute `uint price = feeds[token].feed.latestAnswer()`. As https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/ mentions, it is possible that Chainlink’s \"multisigs can immediately block access to price feeds at will\". When this occurs, executing `feeds[token].feed.latestAnswer()` will revert so calling the `viewPrice` and `getPrice` functions also revert, which cause denial of service when calling functions like `getCollateralValueInternal` and`getWithdrawalLimitInternal`. The `getCollateralValueInternal` and`getWithdrawalLimitInternal` functions are the key elements to the core functionalities, such as borrowing, withdrawing, force-replenishing, and liquidating; with these functionalities facing DOS, the protocol's usability becomes very limited.\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105\n```solidity\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n```\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144\n```solidity\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n```\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347\n```solidity\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n```\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327\n```solidity\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n```\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363\n```solidity\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n```\n\n## Proof of Concept\nThe following steps can occur for the described scenario.\n1. Chainlink oracle data feed is used for getting the collateral token's price so the fixed price for the token is not set.\n2. Alice calls the `depositAndBorrow` function to deposit some of the collateral token and borrows some DOLA against the collateral.\n3. Chainlink's multisigs suddenly blocks access to price feeds so executing `feeds[token].feed.latestAnswer()` will revert.\n4. Alice tries to borrow more DOLA but calling the `borrow` function, which eventually executes `feeds[token].feed.latestAnswer()`, reverts.\n5. Alice tries to withdraw the deposited collateral but calling the `withdraw` function, which eventually executes `feeds[token].feed.latestAnswer()`, reverts.\n6. Similarly, calling the `forceReplenish` and `liquidate` functions would all revert as well.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `Oracle` contract's `viewPrice` and `getPrice` functions can be updated to refactor `feeds[token].feed.latestAnswer()` into `try feeds[token].feed.latestAnswer() returns (int256 price) { ... } catch Error(string memory) { ... }`. The logic for getting the collateral token's price from the Chainlink oracle data feed should be placed in the `try` block while some fallback logic when the access to the Chainlink oracle data feed is denied should be placed in the `catch` block. If getting the fixed price for the collateral token is considered as a fallback logic, then setting the fixed price for the token should become mandatory, which is different from the current implementation. Otherwise, fallback logic for getting the token's price from a fallback oracle is needed.",
      "summary": "\nThis bug report details a vulnerability in the code of the 2022-10-inverse protocol. The vulnerability occurs when the protocol uses a Chainlink oracle data feed for getting a collateral token's price, and the fixed price for the token is not set. When Chainlink's multisigs block access to price feeds, executing `feeds[token].feed.latestAnswer()` will revert, resulting in denial of service when calling functions like `getCollateralValueInternal` and`getWithdrawalLimitInternal`. This can affect the core functionalities of the protocol, such as borrowing, withdrawing, force-replenishing, and liquidating.\n\nThe recommended mitigation steps for this vulnerability are to refactor `feeds[token].feed.latestAnswer()` into `try feeds[token].feed.latestAnswer() returns (int256 price) { ... } catch Error(string memory) { ... }` and add fallback logic in the `catch` block for when access to the Chainlink oracle data feed is denied. If a fixed price for the collateral token is to be used as the fallback logic, then setting the fixed price for the token should become mandatory. Otherwise, fallback logic for getting the token's price from a fallback oracle is needed.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
      "sponsor_name": "Inverse Finance",
      "sponsor_link": "https://twitter.com/InverseFinance",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-inverse",
      "github_link": "https://github.com/code-423n4/2022-10-inverse-findings/issues/586",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "175",
      "slug": "m-18-protocols-usability-becomes-very-limited-when-access-to-chainlink-oracle-data-feed-is-blocked-code4rena-inverse-finance-inverse-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Inverse Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Inverse Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "5744",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 15,
      "protocol_id": "126",
      "title": "[M-15] Oracle assumes token and feed decimals will be limited to 18 decimals",
      "content": "\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L87><br>\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L121><br>\n\nThe `Oracle` contract normalizes prices in both `viewPrices` and `getPrices` functions to adjust for potential decimal differences between feed and token decimals and the expected return value.\n\nHowever these functions assume that `feedDecimals` and `tokenDecimals` won't exceed 18 since the normalization calculation is `36 - feedDecimals - tokenDecimals`, or that at worst case the sum of both won't exceed 36.\n\nThis assumption should be safe for certain cases, for example WETH is 18 decimals and the ETH/USD chainlink is 8 decimals, but may cause an overflow (and a revert) for the general case, rendering the Oracle useless in these cases.\n\n### Proof of Concept\n\nIf `feedDecimals + tokenDecimals > 36` then the expression `36 - feedDecimals - tokenDecimals` will be negative and (due to Solidity 0.8 default checked math) will cause a revert.\n\n### Recommended Mitigation Steps\n\nIn case `feedDecimals + tokenDecimals` exceeds 36, then the proper normalization procedure would be to **divide** the price by `10 ** decimals`. Something like this:\n\n    uint normalizedPrice;\n\n    if (feedDecimals + tokenDecimals > 36) {\n        uint decimals = feedDecimals + tokenDecimals - 36;\n        normalizedPrice = price / (10 ** decimals)\n    } else {\n        uint8 decimals = 36 - feedDecimals - tokenDecimals;\n        normalizedPrice = price * (10 ** decimals);\n    }\n\n**[08xmt (Inverse) confirmed and commented](https://github.com/code-423n4/2022-10-inverse-findings/issues/533#issuecomment-1351469171):**\n > Fixed in https://github.com/InverseFinance/FrontierV2/pull/25<br>\n> Also pretty sure this is a dupe\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the Oracle contract of the code-423n4/2022-10-inverse repository. The `viewPrices` and `getPrices` functions are used to normalize prices to adjust for potential decimal differences between feed and token decimals and the expected return value. \n\nThe bug is caused by an assumption that `feedDecimals` and `tokenDecimals` won't exceed 18, as the normalization calculation is `36 - feedDecimals - tokenDecimals`. This assumption is not safe for the general case, as it may cause an overflow (and a revert) if the sum of both is greater than 36, rendering the Oracle useless.\n\nA proof of concept has been provided to demonstrate the vulnerability. If `feedDecimals + tokenDecimals > 36` then the expression `36 - feedDecimals - tokenDecimals` will be negative and will cause a revert.\n\nThe recommended mitigation step is to divide the price by `10 ** decimals` if `feedDecimals + tokenDecimals` exceeds 36. This should be done in place of the current normalization procedure.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
      "sponsor_name": "Inverse Finance",
      "sponsor_link": "https://twitter.com/InverseFinance",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-inverse",
      "github_link": "https://github.com/code-423n4/2022-10-inverse-findings/issues/533",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "175",
      "slug": "m-15-oracle-assumes-token-and-feed-decimals-will-be-limited-to-18-decimals-code4rena-inverse-finance-inverse-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Inverse Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Inverse Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "5743",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 7,
      "protocol_id": "126",
      "title": "[M-14] Two day low oracle used in Market.liquidate() makes the system highly at risk in an oracle attack ",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L596\nhttps://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L594\nhttps://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L597\n\n\n## Vulnerability details\n\n## Impact\nUsage of the 2 day low exchange rate when trying to liquidate is highly risky as it incentives even more malicious agents to control the price feed for a short period of time. By controlling shortly the feed, it puts at risk any debt opened for a 2 day period + the collateral released will be overshoot during the liquidation\n\n## Proof of Concept\nThe attack can be done by either an attack directly on the feed to push bad data, or in the case of Chainlink manipulating for a short period of time the markets to force an update from Chainlink. Then when either of the attacks has been made the attacker call `Oracle.getPrice()`. It then gives a 2 day period to the attacker (and any other agent who wants to liquidate) to liquidate any escrow. \n\nThis has a second drawback, we see that we use the same value at line 596, which is used to compute the liquidator reward (l.597), leading to more collateral released than expected. For instance manipulating once the feed and bring the ETH/USD rate to 20 instead of 2000, liquidator will earn 100 more than he should have had.\n\n## Tools Used\n\n## Recommended Mitigation Steps\nInstead of using the 2 day lowest price during the liquidation, the team could either take the current oracle price, while still using the 2 day period for any direct agent interaction to minimise attacks both from users side and liquidators side",
      "summary": "\nThis bug report is about a vulnerability in the Market.sol code on the 2022-10-inverse GitHub repository. The vulnerability could be exploited by malicious agents to control the price feed for a short period of time and liquidate any escrow. This could result in more collateral being released than expected, leading to a financial loss for the user. The team has recommended mitigation steps such as taking the current oracle price instead of the 2 day lowest price during the liquidation, while still using the 2 day period for any direct agent interaction. This would help to minimise attacks from both users and liquidators.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
      "sponsor_name": "Inverse Finance",
      "sponsor_link": "https://twitter.com/InverseFinance",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-inverse",
      "github_link": "https://github.com/code-423n4/2022-10-inverse-findings/issues/469",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "175",
      "slug": "m-14-two-day-low-oracle-used-in-marketliquidate-makes-the-system-highly-at-risk-in-an-oracle-attack-code4rena-inverse-finance-inverse-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Inverse Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Inverse Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "5740",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "126",
      "title": "[M-11] viewPrice doesn’t always report dampened price",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L91\n\n\n## Vulnerability details\n\n## Impact\nOracle's `viewPrice` function doesn't report a dampened price until `getPrice` is called and today's price is updated. This will impact the public read-only functions that call it:\n- [getCollateralValue](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L312);\n- [getCreditLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L334) (calls `getCollateralValue`);\n- [getLiquidatableDebt](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L578) (calls `getCreditLimit`);\n- [getWithdrawalLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L370).\n\nThese functions are used to get on-chain state and prepare values for write calls (e.g. calculate withdrawal amount before withdrawing or calculate a user's debt that can be liquidated before liquidating it). Thus, wrong values returned by these functions can cause withdrawal of a wrong amount or liquidation of a wrong debt or cause reverts.\n## Proof of Concept\n```solidity\n// src/test/Oracle.t.sol\nfunction test_viewPriceNoDampenedPrice_AUDIT() public {\n    uint collateralFactor = market.collateralFactorBps();\n    uint day = block.timestamp / 1 days;\n    uint feedPrice = ethFeed.latestAnswer();\n\n    //1600e18 price saved as daily low\n    oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), day), feedPrice);\n\n    vm.warp(block.timestamp + 1 days);\n    uint newPrice = 1200e18;\n    ethFeed.changeAnswer(newPrice);\n    //1200e18 price saved as daily low\n    oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);\n\n    vm.warp(block.timestamp + 1 days);\n    newPrice = 3000e18;\n    ethFeed.changeAnswer(newPrice);\n\n    //1200e18 should be twoDayLow, 3000e18 is current price. We should receive dampened price here.\n    // Notice that viewPrice is called before getPrice.\n    uint viewPrice = oracle.viewPrice(address(WETH), collateralFactor);\n    uint price = oracle.getPrice(address(WETH), collateralFactor);\n    assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);\n\n    assertEq(price, 1200e18 * 10_000 / collateralFactor);\n\n    // View price wasn't dampened.\n    assertEq(viewPrice, 3000e18);\n}\n```\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nConsider this change:\n```diff\n--- a/src/Oracle.sol\n+++ b/src/Oracle.sol\n@@ -89,6 +89,9 @@ contract Oracle {\n             uint day = block.timestamp / 1 days;\n             // get today's low\n             uint todaysLow = dailyLows[token][day];\n+            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n+                todaysLow = normalizedPrice;\n+            }\n             // get yesterday's low\n             uint yesterdaysLow = dailyLows[token][day - 1];\n             // calculate new borrowing power based on collateral factor\n```",
      "summary": "\nThis bug report is about a vulnerability in Oracle's `viewPrice` function in the code-423n4/2022-10-inverse repository on GitHub. The vulnerability impacts the public read-only functions that call it, which are used to get on-chain state and prepare values for write calls. This can cause withdrawal of a wrong amount or liquidation of a wrong debt or cause reverts.\n\nThe proof of concept was a manual review of the code, and the recommended mitigation step is to consider the change in the code provided. This change will ensure that the viewPrice is dampened until the getPrice function is called and today's price is updated.\n\nIn conclusion, this bug report is about a vulnerability in the code-423n4/2022-10-inverse repository on GitHub that impacts the public read-only functions that call it. The proof of concept was a manual review of the code, and the recommended mitigation step is to consider the change in the code provided.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
      "sponsor_name": "Inverse Finance",
      "sponsor_link": "https://twitter.com/InverseFinance",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-inverse",
      "github_link": "https://github.com/code-423n4/2022-10-inverse-findings/issues/404",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "175",
      "slug": "m-11-viewprice-doesnt-always-report-dampened-price-code4rena-inverse-finance-inverse-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Inverse Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Inverse Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "5736",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "126",
      "title": "[M-07] Oracle’s two-day feature can be gamed",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L124\n\n\n## Vulnerability details\n\n## Impact\nThe two-day feature of the oracle can be gamed where you only have to manipulate the oracle for ~2 blocks.\n\n## Proof of Concept\nThe oracle computes the day using:\n```sol\nuint day = block.timestamp / 1 days;\n```\n\nSince we're working with `uint` values here, the following is true:\n$1728799 / 86400 = 1$\n$172800 / 86400 = 2$\n\nMeaning, if you manipulate the oracle at the last block of day $X$, e.g. 23:59:50, and at the first block of day $X + 1$, e.g. 00:00:02, you bypass the two-day feature of the oracle. You only have to manipulate the oracle for two blocks.\n\nThis is quite hard to pull off. I'm also not sure whether there were any instances of Chainlink oracle manipulation before. But, since you designed this feature to prevent small timeframe oracle manipulation I think it's valid to point this out.\n\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nIf you increase it to a three-day interval you can fix this issue. Then, the oracle has to be manipulated for at least 24 hours.",
      "summary": "\nThis bug report is about how the two-day feature of the oracle can be gamed. The oracle computes the day using a mathematical formula. If the oracle is manipulated at the last block of day X and the first block of day X+1, it bypasses the two-day feature of the oracle. This makes it possible to manipulate the oracle for only two blocks. To fix this issue, the oracle can be increased to a three-day interval, so the oracle has to be manipulated for at least 24 hours.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
      "sponsor_name": "Inverse Finance",
      "sponsor_link": "https://twitter.com/InverseFinance",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-inverse",
      "github_link": "https://github.com/code-423n4/2022-10-inverse-findings/issues/278",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "175",
      "slug": "m-07-oracles-two-day-feature-can-be-gamed-code4rena-inverse-finance-inverse-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Inverse Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Inverse Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Rounding"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Bypass limit"
          }
        }
      ]
    },
    {
      "id": "3338",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "137",
      "title": "M-13: Rely On Balancer Oracle Which Is Not Updated Frequently",
      "content": "Source: https://github.com/sherlock-audit/2022-09-notional-judging/issues/67 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe vault relies on Balancer Oracle which is not updated frequently.\n\n## Vulnerability Detail\n\n> Note: This issue affects the MetaStable2 balancer leverage vault\n\nWithin the `TwoTokenPoolUtils._getOraclePairPrice` function, it compute the pair price from the Balancer Oracle by calling the `BalancerUtils._getTimeWeightedOraclePrice` function which will in turn call the `IPriceOracle(pool).getTimeWeightedAverage` function to get the  time-weighted average pair prices (e.g. stETH/ETH). The Balancer pool that will be polled for the pair price can be found at https://etherscan.io/address/0x32296969Ef14EB0c6d29669C550D4a0449130230.\n\nThe issue is that this pool only handled ~1.5 transactions per day based on the last 5 days' data. In terms of average, the price will only be updated once every 16 hours. There are also many days that there is only 1 transaction. The following shows the number of transactions for each day within the audit period.\n\n- 5 Oct 2022 - 3 transactions\n- 4 Oct 2022 - 1 transaction\n- 3 Oct 2022 - 1 transaction\n- 2 Oct 2022 - 2 transactions\n- 1 Oct 2022 - 1 transaction\n\nNote that the price will only be updated whenever a transaction (e.g. swap) within the Balancer pool is triggered. Due to the lack of updates, the price provided by Balancer Oracle will not reflect the true value of the assets. Considering the stETH/ETH Balancer pool, the price of the stETH or ETH provided will not reflect the true value in the market.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L66\n\n```solidity\nFile: TwoTokenPoolUtils.sol\n066:     /// @notice Gets the oracle price pair price between two tokens using a weighted\n067:     /// average between a chainlink oracle and the balancer TWAP oracle.\n068:     /// @param poolContext oracle context variables\n069:     /// @param oracleContext oracle context variables\n070:     /// @param tradingModule address of the trading module\n071:     /// @return oraclePairPrice oracle price for the pair in 18 decimals\n072:     function _getOraclePairPrice(\n073:         TwoTokenPoolContext memory poolContext,\n074:         OracleContext memory oracleContext, \n075:         ITradingModule tradingModule\n076:     ) internal view returns (uint256 oraclePairPrice) {\n077:         // NOTE: this balancer price is denominated in 18 decimal places\n078:         uint256 balancerWeightedPrice;\n079:         if (oracleContext.balancerOracleWeight > 0) {\n080:             uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n081:                 address(poolContext.basePool.pool),\n082:                 IPriceOracle.Variable.PAIR_PRICE,\n083:                 oracleContext.oracleWindowInSeconds\n084:             );\n085: \n086:             if (poolContext.primaryIndex == 1) {\n087:                 // If the primary index is the second token, we need to invert\n088:                 // the balancer price.\n089:                 balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n090:             }\n091: \n092:             balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n093:         }\n094: \n095:         uint256 chainlinkWeightedPrice;\n096:         if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n097:             (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n098:                 poolContext.primaryToken, poolContext.secondaryToken\n099:             );\n100:             require(rate > 0);\n101:             require(decimals >= 0);\n102: \n103:             if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n104:                 rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n105:             }\n106: \n107:             // No overflow in rate conversion, checked above\n108:             chainlinkWeightedPrice = uint256(rate) * \n109:                 (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n110:         }\n111: \n112:         oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n113:             BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n114:     }\n```\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/BalancerUtils.sol#L21\n\n```solidity\nFile: BalancerUtils.sol\n21:     function _getTimeWeightedOraclePrice(\n22:         address pool,\n23:         IPriceOracle.Variable variable,\n24:         uint256 secs\n25:     ) internal view returns (uint256) {\n26:         IPriceOracle.OracleAverageQuery[]\n27:             memory queries = new IPriceOracle.OracleAverageQuery[](1);\n28: \n29:         queries[0].variable = variable;\n30:         queries[0].secs = secs;\n31:         queries[0].ago = 0; // now\n32: \n33:         // Gets the balancer time weighted average price denominated in the first token\n34:         return IPriceOracle(pool).getTimeWeightedAverage(queries)[0];\n35:     }\n```\n\n## Impact\n\nThe price provided by the function will not reflect the true value of the assets. It might be overvalued or undervalued. The affected function is being used in almost all functions within the vault. For instance, this function is part of the critical `_convertStrategyToUnderlying` function that computes the value of the strategy token in terms of its underlying assets. As a result, it might cause the following:\n\n  - Vault Settlement - Vault settlement requires computing the underlying value of the strategy tokens. It involves dealing with a large number of assets, and thus even a slight slippage in the price will be significantly amplified.\n  - Deleverage/Liquidation of Account - If the price provided does not reflect the true value, users whose debt ratio is close to the liquidation threshold might be pre-maturely deleveraged/liquidated since their total asset value might be undervalued.\n  - Borrowing - If the price provided does not reflect the true value, it might be possible that the assets of some users might be overvalued, and thus they are able to over-borrow from the vault.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L66\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/BalancerUtils.sol#L21\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAlthough it is not possible to obtain a price pair that truly reflects the true value of an asset in the real world, the vault should attempt to minimize inaccuracy and slippage as much as possible. This can be done by choosing and using a more accurate Oracle that is updated more frequently instead of using the Balancer Oracle that is infrequently updated. \n\nChainlink should be used as the primary Oracle for price pair. If a secondary Oracle is needed for a price pair, consider using [Teller](https://tellor.io/) Oracle instead of Balancer Oracle. Some example of how Chainlink and Tellor works together in a live protocol can be found [here](https://www.liquity.org/blog/price-oracles-in-liquity)\n\nObtaining the time-weight average price of BTP LP token from Balancer Oracle is fine as the Balancer pool is the source of truth. However, getting the price of ETH or stETH from Balancer Oracle would not be a good option. \n\nOn a side note, it was observed that the weightage of the price pair is Balancer Oracle - 60% and Chainlink - 40%. Thus, this theoretically will reduce the impact of inaccurate prices provided by Balancer Oracle by around half. However, the team should still consider using a better Oracle as almost all the functions within the vault depends on the accurate price of underlying assets to operate.\n\nNote: For the stETH/ETH balancer leverage vault, the price pair is computed based on a weighted average of Balancer Oracle and Chainlink. Based on the test script, the weightage is Balancer Oracle - 60% and Chainlink - 40%.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/scripts/BalancerEnvironment.py#L45\n\n```python\nFile: BalancerEnvironment.py\n45:             \"maxRewardTradeSlippageLimitPercent\": 5e6,\n46:             \"balancerOracleWeight\": 0.6e4, # 60%\n47:             \"settlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n```\n\n## Discussion\n\n**jeffywu**\n\n@T-Woodward \n\n**T-Woodward**\n\nYes, the threat you are talking about is potentially true however it depends on the time window you choose for the balancer price oracle and the particular pool. If it's a short time window and the pool is liquid and highly active, then the balancer pool is not a totally unreasonable source of truth.\n\nHaving said that, we do plan on removing the dependency to Balancer pool oracles entirely due to manipulation concerns so I will confirm this issue.\n\n**jeffywu**\n\nThis issue is not a duplicate of the Chainlink issues, it should be separate.",
      "summary": "\nThis bug report concerns the MetaStable2 balancer leverage vault, which relies on Balancer Oracle to compute the pair price between two tokens using a weighted average. The issue is that this pool only handled ~1.5 transactions per day based on the last 5 days' data, meaning the price will only be updated once every 16 hours. This lack of updates means the price provided by Balancer Oracle will not reflect the true value of the assets, potentially leading to inaccurate vault settlements, pre-mature deleveraging/liquidation of accounts, and over-borrowing from the vault. \n\nTo mitigate this issue, the team should consider using a more accurate Oracle that is updated more frequently instead of using the Balancer Oracle. Chainlink should be used as the primary Oracle for price pair, and Tellor Oracle could be used as a secondary. Additionally, the weightage of the price pair should be adjusted to reduce the impact of inaccurate prices provided by Balancer Oracle. \n\nThe team plans to remove the dependency to Balancer pool oracles entirely due to manipulation concerns, and this issue should be treated as separate from the Chainlink issues.",
      "report_date": {},
      "contest_prize_txt": "100000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/2",
      "sponsor_name": "Notional",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-notional-judging/issues/67",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "2",
      "slug": "m-13-rely-on-balancer-oracle-which-is-not-updated-frequently-sherlock-notional-notional-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Notional",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Notional",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "3366",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "150",
      "title": "M-10: ERC4626Oracle Vulnerable To Price Manipulation",
      "content": "Source: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/133-M \n## Found by \nxiaoming90, IllIllI\n\n## Summary\n\nERC4626 oracle is vulnerable to price manipulation. This allows an attacker to increase or decrease the price to carry out various attacks against the protocol.\n\n## Vulnerability Detail\n\nThe `getPrice` function within the `ERC4626Oracle` contract is vulnerable to price manipulation because the price can be increased or decreased within a single transaction/block.\n\nBased on the `getPrice` function, the price of the LP token of an ERC4626 vault is dependent on the `ERC4626.previewRedeem` and `oracleFacade.getPrice` functions. If the value returns by either `ERC4626.previewRedeem` or `oracleFacade.getPrice` can be manipulated within a single transaction/block, the price of the LP token of an ERC4626 vault is considered to be vulnerable to price manipulation.\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/oracle/src/erc4626/ERC4626Oracle.sol#L8\n\n```solidity\nFile: ERC4626Oracle.sol\n35:     function getPrice(address token) external view returns (uint) {\n36:         uint decimals = IERC4626(token).decimals();\n37:         return IERC4626(token).previewRedeem(\n38:             10 ** decimals\n39:         ).mulDivDown(\n40:             oracleFacade.getPrice(IERC4626(token).asset()),\n41:             10 ** decimals\n42:         );\n43:     }\n```\n\nIt was observed that the `ERC4626.previewRedeem` couldbe manipulated within a single transaction/block. As shown below, the `previewRedeem` function will call the `convertToAssets` function. Within the `convertToAssets`, the number of assets per share is calculated based on the current/spot total assets and current/spot supply that can be increased or decreased within a single block/transaction by calling the vault's deposit, mint, withdraw or redeem functions. This allows the attacker to artificially inflate or deflate the price within a single block/transaction.\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/tokens/utils/ERC4626.sol#L154\n\n```solidity\nFile: ERC4626.sol\n154:     function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n155:         return convertToAssets(shares);\n156:     }\n```\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/tokens/utils/ERC4626.sol#L132\n\n```solidity\nFile: ERC4626.sol\n132:     function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n133:         uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n134: \n135:         return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n136:     }\n```\n\n## Impact\n\nThe attacker could perform price manipulation to make the apparent value of an asset to be much higher or much lower than the true value of the asset. Following are some risks of price manipulation:\n\n- An attacker can increase the value of their collaterals to increase their borrowing power so that they can borrow more assets than they are allowed from Sentiment.\n- An attacker can decrease the value of some collaterals and attempt to liquidate another user account prematurely.\n\n## Recommendation\n\nAvoid using `previewRedeem` function to calculate the price of the LP token of an ERC4626 vault. Consider implementing TWAP so that the price cannot be inflated or deflated within a single block/transaction or within a short period of time.\n\n## Sentiment Team\nDepends on the integration itself, so there's no action that can be taken right now.\n\n## Lead Senior Watson\nAcknowledged.",
      "summary": "\nERC4626 oracle is vulnerable to price manipulation, which was discovered by xiaoming90 and IllIllI. This vulnerability allows an attacker to increase or decrease the price of the LP token of an ERC4626 vault within a single transaction/block. This is possible because the `getPrice` function is dependent on the `ERC4626.previewRedeem` and `oracleFacade.getPrice` functions, and the number of assets per share is calculated based on the current/spot total assets and current/spot supply that can be increased or decreased within a single block/transaction.\n\nThe attacker could use this vulnerability to make the apparent value of an asset to be much higher or much lower than the true value of the asset. This could be used to increase their borrowing power, or to liquidate another user account prematurely.\n\nTo avoid this vulnerability, the team should avoid using `previewRedeem` function to calculate the price of the LP token of an ERC4626 vault. Instead, they should consider implementing TWAP (Time Weighted Average Price) so that the price cannot be inflated or deflated within a single block/transaction or within a short period of time.",
      "report_date": {},
      "contest_prize_txt": "75000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/1",
      "sponsor_name": "Sentiment",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/133-M",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "1",
      "slug": "m-10-erc4626oracle-vulnerable-to-price-manipulation-sherlock-sentiment-sentiment-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sentiment",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sentiment",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Flash Loan"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "5773",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 18,
      "protocol_id": "152",
      "title": "[H-01] Incorrect handling of `pricefeed.decimals()`",
      "content": "\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/oracles/PegOracle.sol#L46-L83>\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L299-L300>\n\n### Impact\n\nWrong math for handling pricefeed decimals. This code will only work for pricefeeds of 8 decimals, any others give wrong/incorrect data. The maths used can be shown in three lines:\n\n```solidity\nnowPrice = (price1 * 10000) / price2;\nnowPrice = nowPrice * int256(10**(18 - priceFeed1.decimals()));\nreturn nowPrice / 1000000;\n```\n\nLine1: adds 4 decimals\nLine2: adds (18 - d) decimals, (where d = pricefeed.decimals())\nLine3:  removes 6 decimals\n\nTotal: adds (16 - d) decimals\n\nwhen d=8, the contract correctly returns an 8 decimal number. However, when d = 6, the function will return a 10 decimal number. This is further raised by (18-d = 12) decimals when checking for depeg event, leading to a 22 decimal number which is 4 orders of magnitude incorrect.\n\nif d=18, (like usd-eth pricefeeds) contract fails / returns 0.\n\nAll chainlink contracts which give price in eth, operate with 18 decimals. So this can cripple the system if added later.\n\n### Proof of Concept\n\nRunning the test  AssertTest.t.sol:testPegOracleMarketCreation and changing the line on\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/test/AssertTest.t.sol#L30>\n\nto\n\n```solidity\nPegOracle pegOracle3 = new PegOracle(\n            0xB1552C5e96B312d0Bf8b554186F846C40614a540,  //usd-eth contract address\n            btcEthOracle\n        );\n```\n\ngives this output\n\n    oracle3price1: 1085903802394919427                                                                                                                                                                               \n    oracle3price2: 13753840915281064000                                                                                                                                                                              \n    oracle3price1 / oracle3price2: 0\n\nreturning an oracle value of 0. Simulating with a mock price feed of 6 decimals gives results 4 orders of magnitude off.\n\n### Tools Used\n\nFoundry, VS-Code\n\n### Recommended Mitigation Steps\n\nSince only the price ratio is calculated, there is no point in increasing the decimal by (18-d) in the second line. Proposed solution:\n\n```solidity\nnowPrice = (price1 * 10000) / price2;\nnowPrice = nowPrice * int256(10**(priceFeed1.decimals())) * 100;\nreturn nowPrice / 1000000;\n```\n\nThis returns results in d decimals, no matter the value of d.\n\n**[MiguelBits (Y2K Finance) confirmed](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/195)** \n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the PegOracle.sol file of the 2022-09-y2k-finance Github repository. The vulnerability is caused by incorrect maths for handling pricefeed decimals. The code only works for pricefeeds of 8 decimals, any others give wrong/incorrect data. This can lead to a contract failure or incorrect data when the pricefeed is set to 6 or 18 decimals. To test the vulnerability, the AssertTest.t.sol:testPegOracleMarketCreation was run and the results showed an oracle value of 0. Simulating with a mock price feed of 6 decimals gave results 4 orders of magnitude off. The recommended mitigation step is to change the second line of the code to return results in d decimals, no matter the value of d.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-09-y2k-finance-contest",
      "sponsor_name": "Y2k Finance",
      "sponsor_link": "https://twitter.com/Y2kFinance",
      "quality_score": 5,
      "general_score": 2,
      "source_link": "https://code4rena.com/reports/2022-09-y2k-finance",
      "github_link": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/195",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "162",
      "slug": "h-01-incorrect-handling-of-pricefeeddecimals-code4rena-y2k-finance-y2k-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Y2k Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Y2k Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "7239",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "72",
      "title": "Missing checks for Chainlink oracle",
      "content": "## Severity: Medium Risk\n\n## Context\n- ConnextPriceOracle.sol#L98\n- ConnextPriceOracle.sol#L153\n\n## Description\nThe `ConnextPriceOracle.getTokenPrice()` function goes through a series of oracles. At each step, it has a few validations to avoid incorrect prices. If such validations succeed, the function returns the non-zero oracle price. \n\nFor the Chainlink oracle, `getTokenPrice()` ultimately calls `getPriceFromChainlink()`, which has the following validation:\n\n```solidity\nif (answer == 0 || answeredInRound < roundId || updateAt == 0) {\n    // answeredInRound > roundId ===> ChainLink Error: Stale price\n    // updatedAt = 0 ===> ChainLink Error: Round not complete\n    return 0;\n}\n```\n\n`updateAt` refers to the timestamp of the round. This value isn’t checked to ensure it is recent. Additionally, it is important to be aware of the `minAnswer` and `maxAnswer` of the Chainlink oracle; these values are not allowed to be reached or surpassed. See the Chainlink API reference for documentation on `minAnswer` and `maxAnswer`, as well as this piece of code: `OffchainAggregator.sol`.\n\n## Recommendation\n- Determine the tolerance threshold for `updateAt`. If `block.timestamp - updateAt` exceeds that threshold, return 0, which is consistent with how the current validations are handled.\n- Consider having off-chain monitoring to identify when the market price moves out of `[minAnswer, maxAnswer]` range.\n\n## Connext\nRecency check is implemented in PR 1602. Off-chain monitoring will be considered.\n\n## Spearbit\nVerified and acknowledged.",
      "summary": "\nThis report is about a bug found in the ConnextPriceOracle.sol file at lines 98 and 153. The bug is related to the getTokenPrice() function which goes through a series of oracles and returns a non-zero oracle price if all validations succeed. The bug is that the updateAt value, which is the timestamp of the round, is not checked to make sure it is recent. Additionally, the minAnswer and maxAnswer of the Chainlink oracle are not checked to make sure they are not reached or surpassed. \n\nThe recommendation is to determine the tolerance threshold for updateAt and if the block.timestamp - updateAt exceeds that threshold, return 0. Additionally, consider having off-chain monitoring to identify when the market price moves out of the [minAnswer, maxAnswer] range. Connext has implemented a recency check in PR 1602 and will consider off-chain monitoring. Spearbit has verified and acknowledged this report.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Connext-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Connext-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Connext-Spearbit-Security-Review.pdf",
      "pdf_page_from": 27,
      "contest_id": "",
      "slug": "missing-checks-for-chainlink-oracle-spearbit-connext-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Connext",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Connext",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        }
      ]
    },
    {
      "id": "3228",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 21,
      "protocol_id": "160",
      "title": "[M-24] [NAZ-M1] Chainlink's `latestRoundData` Might Return Stale Results",
      "content": "_Submitted by 0xNazgul, also found by &#95;&#95;141345&#95;&#95;, 0x1f8b, ak1, brgltd, cccz, csanuragjain, Dravee, Guardian, hyh, IllIllI, itsmeSTYJ, Jujic, Lambda, pashov, peachtea, rbserver, reassor, Sm4rty, TomJ, and zzzitron_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L161><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L170><br>\n\nAcross these contracts, you are using Chainlink's `latestRoundData` API, but there is only a check on `updatedAt`. This could lead to stale prices according to the Chainlink documentation:\n\n*   [Historical Price data](https://docs.chain.link/docs/historical-price-data/#historical-rounds)\n*   [Checking Your returned answers](https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round)\n\nThe result of `latestRoundData` API will be used across various functions, therefore, a stale price from Chainlink can lead to loss of funds to end-users.\n\n### Recommended Mitigation Steps\n\nConsider adding the missing checks for stale data.\n\nFor example:\n\n```js\n(uint80 roundID ,answer,, uint256 timestamp, uint80 answeredInRound) = AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData();\n\nrequire(answer > 0, \"Chainlink price <= 0\"); \nrequire(answeredInRound >= roundID, \"Stale price\");\nrequire(timestamp != 0, \"Round not complete\");\n```\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/441#issuecomment-1238528515):**\n > Agree. We'll add the additional checks.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that could lead to loss of funds to end-users. The vulnerability is caused by the use of Chainlink's `latestRoundData` API without a check on `updatedAt`. This could lead to the use of stale prices across various functions. Manual review was used to detect the vulnerability. To mitigate this vulnerability, it is recommended to add checks for stale data, such as checking that the answer to a round is being carried over from a previous round, and that the round is complete. This should ensure that the correct, up-to-date data is used.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
      "sponsor_name": "Olympus DAO",
      "sponsor_link": "https://twitter.com/olympusdao",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/441",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "156",
      "slug": "m-24-naz-m1-chainlinks-latestrounddata-might-return-stale-results-code4rena-olympus-dao-olympus-dao-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Olympus DAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Olympus DAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA Lending"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        },
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        }
      ]
    },
    {
      "id": "2967",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "189",
      "title": "[M-09] Unhandled chainlink revert would lock all price oracle access",
      "content": "_Submitted by bardamu, also found by berndartmueller, codexploder, Alex the Entreprenerd, and horsefacts_\n\nCall to `latestRoundData` could potentially revert and make it impossible to query any prices. Feeds cannot be changed after they are configured (<https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBPrices.sol#L115>) so this would result in a permanent denial of service.\n\n### Proof of Concept\n\nChainlink's multisigs can immediately block access to price feeds at will. Therefore, to prevent denial of service scenarios, it is recommended to query Chainlink price feeds using a defensive approach with Solidity’s try/catch structure. In this way, if the call to the price feed fails, the caller contract is still in control and can handle any errors safely and explicitly.\n\n<https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBPrices.sol#L69>\n\n    if (_feed != IJBPriceFeed(address(0))) return _feed.currentPrice(_decimals);\n\n<https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBChainlinkV3PriceFeed.sol#L42-L44>\n\n    function currentPrice(uint256 _decimals) external view override returns (uint256) {\n      // Get the latest round information. Only need the price is needed.\n      (, int256 _price, , , ) = feed.latestRoundData();\n\nRefer to <https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/> for more information regarding potential risks to account for when relying on external price feed providers.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nSurround the call to `latestRoundData()` with `try/catch` instead of calling it directly. In a scenario where the call reverts, the catch block can be used to call a fallback oracle or handle the error in any other suitable way.\n\n**[mejango (Juicebox) acknowledged](https://github.com/code-423n4/2022-07-juicebox-findings/issues/59)**\n\n**[jack-the-pug (judge) commented](https://github.com/code-423n4/2022-07-juicebox-findings/issues/59#issuecomment-1200414043):**\n > Good catch! Seems like we should update this function to allow changing the feed contract:\n> \n> https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBPrices.sol#L109-L121\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the JBChainlinkV3PriceFeed.sol smart contract. The vulnerability could potentially lead to a permanent denial of service if the call to the `latestRoundData` function reverts. The proof of concept for this vulnerability involves Chainlink's multisigs which can block access to price feeds at will. To prevent denial of service scenarios, it is recommended to use a defensive approach with Solidity's try/catch structure. This way, if the call to the price feed fails, the caller contract is still in control and can handle any errors safely and explicitly. The recommended mitigation steps for this vulnerability include surrounding the call to `latestRoundData()` with `try/catch` instead of calling it directly. In a scenario where the call reverts, the catch block can be used to call a fallback oracle or handle the error in any other suitable way.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-07-juicebox-v2-contest",
      "sponsor_name": "Juicebox",
      "sponsor_link": "https://twitter.com/juiceboxETH",
      "quality_score": 3.75,
      "general_score": 3.333333333333333,
      "source_link": "https://code4rena.com/reports/2022-07-juicebox",
      "github_link": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/59",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "143",
      "slug": "m-09-unhandled-chainlink-revert-would-lock-all-price-oracle-access-code4rena-juicebox-juicebox-v2-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Juicebox",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Juicebox",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "DOS"
          }
        }
      ]
    },
    {
      "id": "2957",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 33,
      "protocol_id": "189",
      "title": "[H-01] Oracle data feed can be outdated yet used anyways which will impact payment logic",
      "content": "_Submitted by 0xNineDec, also found by 0x1f8b, 0x29A, 0x52, 0xdanial, 0xDjango, 0xf15ers, bardamu, cccz, Cheeezzyyyy, Chom, codexploder, defsec, Franfran, Alex the Entreprenerd, Green, hake, hansfriese, horsefacts, hubble, hyh, IllIllI, jonatascm, kebabsec, Meera, oyc&#95;109, pashov, rbserver, Ruhum, simon135, tabish, tintin, and zzzitron_\n\n<https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBChainlinkV3PriceFeed.sol#L44>\n\n<https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBPrices.sol#L57>\n\n<https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L387>\n\n<https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L585>\n\n<https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L661>\n\n<https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L830>\n\n<https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L868>\n\n### Impact\n\nThe current implementation of `JBChainlinkV3PriceFeed` is used by the protocol to showcase how the feed will be retrieved via Chainlink Data Feeds. The feed is used to retrieve the `currentPrice`, which is also used afterwards by `JBPrices.priceFor()`, then by `JBSingleTokenPaymentTerminalStore.recordPaymentFrom()`, `JBSingleTokenPaymentTerminalStore.recordDistributionFor`, `JBSingleTokenPaymentTerminalStore.recordUsedAllowanceOf`, `JBSingleTokenPaymentTerminalStore._overflowDuring` and `JBSingleTokenPaymentTerminalStore._currentTotalOverflowOf`.\nAlthough the current feeds are calculated by a non implemented IJBPriceFeed, if the implementation of the price feed is the same as the showcased in`JBChainlinkV3PriceFeed`, the retrieved data can be outdated or out of bounds.\n\nIt is important to remember that the sponsor said on the dedicated Discord Channel that also oracle pricing and data retrieval is inside the scope.\n\n### Proof of Concept\n\nChainlink classifies their data feeds into four different groups regarding how reliable is each source thus, how risky they are. The groups are *Verified Feeds, Monitored Feeds, Custom Feeds and Specialized Feeds* (they can be seen [here](https://docs.chain.link/docs/selecting-data-feeds/#data-feed-categories)). The risk is the lowest on the first one and highest on the last one.\n\nA strong reliance on the price feeds has to be also monitored as recommended on the [Risk Mitigation section](https://docs.chain.link/docs/selecting-data-feeds/#risk-mitigation). There are several reasons why a data feed may fail such as unforeseen market events, volatile market conditions, degraded performance of infrastructure, chains, or networks, upstream data providers outage, malicious activities from third parties among others.\n\nChainlink recommends using their data feeds along with some controls to prevent mismatches with the retrieved data. Along some recommendations, the feed can include circuit breakers (for extreme price events), contract update delays (to ensure that the injected data into the protocol is fresh enough), manual kill-switches (to cease connection in case of found bug or vulnerability in an upstream contract), monitoring (control the deviation of the data) and soak testing (of the price feeds).\n\nThe `feed.lastRoundData()` interface parameters [according to Chainlink](https://docs.chain.link/docs/price-feeds-api-reference/) are the following:\n\n    function latestRoundData() external view\n        returns (\n            uint80 roundId,             //  The round ID.\n            int256 answer,              //  The price.\n            uint256 startedAt,          //  Timestamp of when the round started.\n            uint256 updatedAt,          //  Timestamp of when the round was updated.\n            uint80 answeredInRound      //  The round ID of the round in which the answer was computed.\n        )\n\nRegarding Juicebox itself, only the `answer` is used on the `JBChainlinkV3PriceFeed.currentPrice()` implementation. The retrieved price of the `priceFeed` can be outdated and used anyways as a valid data because no timestamp tolerance of the update source time is checked while storing the return parameters of `feed.latestRoundData()` inside `JBChainlinkV3PriceFeed.currentPrice()` as recommended by Chainlink in [here](https://docs.chain.link/docs/using-chainlink-reference-contracts/#check-the-timestamp-of-the-latest-answer). The usage of outdated data can impact on how the Payment terminals work regarding pricing calculation and value measurement.\n\nPrecisely the following protocol logic within `JBSingleTokenPaymentTerminalStore​‌` will work unexpectedly regarding value management.\n\n*   `recordPaymentFrom()`:\n\n    This function handles the minting of a project tokens according to a data source if one is given. If the retrieved value of the oracle is outdated, the `_weightRatio` at [Line 387](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L387) will return an incorrect value and then the `tokenCount` calculated amount will suffer from this mismatch, impacting in the amount of tokens minted.\n\n*   `recordDistributionFor()`:\n\n    Performs the recording of recently distributed funds for a project. On [line 580](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L580) the `distributedAmount` is computed and if the boolean check is false, then the call will perform a call to `priceFor` at [line 585](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L585). If the returned oracle value is not adjusted with current market prices, the `distributedAmount` will also drag that error computing an incorrect `distributedAmount`. Afterwards, because the `distributedAmount` is also used to update the token balances of the `msg.sender` ([line 598](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L598)) it means that the mismatch impacts on the modified balance.\n\n*   `recordUsedAllowanceOf()`:\n\n    Keeps record of used allowances of a project. It returns are analogue to the ones shown at `recordDistributionFor` where the `usedAmount` resembles the `distributedAmount`. The `usedAmount` is also used to update the project's balance. If the data of the oracle is outdated, the `usedAmount` will be calculated dragging that error.\n\n*   `_overflowDuring()`:\n\n    Used to get the amount that is overflowing relative to a specified cycle. The data retrieved from the oracle is used to calculate the value of `_distributionLimitRemaining` on [line 827](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L827) which is used later to calculate the return value if the boolean check performed at line 834 is true. Because the return of this function is the current balance of a project minus the amount that can be still distributed, if the amount that can still be distributed is wrong so will be the subtraction thus the return value.\n\n*   `_currentTotalOverflowOf()`:\n\n    Similar to the latter but used to get the overflow of all the terminals of a project. If the retrieved data has a mismatch with the market, the `_totalOverflow18Decimal` calculated on [line 866](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L827) if the boolean check is false will drag this mismatch which will also be dragged into the final return of the function.\n\nThe issues of those miscalculations impact on every project currently minted, which also affects subsequently on each user that has tokens of a project resulting in a high reach impact.\n\n### Recommended Mitigation Steps\n\nAs Chainlink [recommends](https://docs.chain.link/docs/using-chainlink-reference-contracts/#check-the-timestamp-of-the-latest-answer):\n\n> Your application should track the `latestTimestamp` variable or use the `updatedAt` value from the `latestRoundData()` function to make sure that the latest answer is recent enough for your application to use it. If your application detects that the reported answer is not updated within the heartbeat or within time limits that you determine are acceptable for your application, pause operation or switch to an alternate operation mode while identifying the cause of the delay.\n>\n> During periods of low volatility, the heartbeat triggers updates to the latest answer. Some heartbeats are configured to last several hours, so your application should check the timestamp and verify that the latest answer is recent enough for your application.\n\nIt is recommended to add a tolerance that compares the `updatedAt` return timestamp from `latestRoundData()` with the current block timestamp and ensure that the `priceFeed` is being updated with the required frequency.\n\nIf the `ETH/USD` is the only one that is needed to retrieve, because it is the most popular and available pair. It can also be useful to add other oracle to get the price feed (such as Uniswap's). This can be used as a redundancy in the case of having one oracle that returns outdated values (what is outdated and what is up to date can be determined by a tolerance as mentioned).\n\n**[mejango (Juicebox) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-07-juicebox-findings/issues/138#issuecomment-1182192760):**\n > There is also a good description in this duplicate #[78](https://github.com/code-423n4/2022-07-juicebox-findings/issues/78)\n\n**mejango (Juicebox) resolved:**\n> PR with fix: [PR #1](https://github.com/jbx-protocol/juice-contracts-v3/pull/1)\n\n**berndartmueller (warden) reviewed mitigation:**\n> Appropriate validations to prevent price staleness, round incompleteness and a negative price is put in place now.\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the implementation of the `JBChainlinkV3PriceFeed` contract. This contract is used by the protocol to retrieve the `currentPrice` from a Chainlink Data Feed. The retrieved data can be outdated or out of bounds, which can have an impact on how the Payment terminals work regarding pricing calculation and value measurement.\n\nThe `feed.lastRoundData()` interface parameters includes a timestamp of when the round was updated. Chainlink recommends using their data feeds along with some controls to prevent mismatches with the retrieved data. This includes circuit breakers, contract update delays, manual kill-switches, monitoring, and soak testing.\n\nThe protocol logic within `JBSingleTokenPaymentTerminalStore​‌` can be affected by the outdated data. This includes `recordPaymentFrom()`, `recordDistributionFor()`, `recordUsedAllowanceOf()`, `_overflowDuring()`, and `_currentTotalOverflowOf()`. All of these functions can result in incorrect token balances and value measurements.\n\nIt is recommended to add a tolerance that compares the `updatedAt` return timestamp from `latestRoundData()` with the current block timestamp and ensure that the `priceFeed` is being updated with the required frequency. Additionally, adding another oracle to get the price feed (such as Uniswap's) can be used as a redundancy in case one of the oracles returns outdated values.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-07-juicebox-v2-contest",
      "sponsor_name": "Juicebox",
      "sponsor_link": "https://twitter.com/juiceboxETH",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-07-juicebox",
      "github_link": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/138",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "143",
      "slug": "h-01-oracle-data-feed-can-be-outdated-yet-used-anyways-which-will-impact-payment-logic-code4rena-juicebox-juicebox-v2-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Juicebox",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Juicebox",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        }
      ]
    },
    {
      "id": "2126",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "235",
      "title": "[H-01] Avoidance of Liquidation Via Malicious Oracle",
      "content": "_Submitted by BowTiedWardens, also found by gzeon, and hyh_\n\nIssue: Arbitrary oracles are permitted on construction of loans, and there is no check that the lender agrees to the used oracle.\n\nConsequences: A borrower who requests a loan with a malicious oracle can avoid legitimate liquidation.\n\n### Proof of Concept\n\n*   Borrower requests loan with an malicious oracle\n*   Lender accepts loan unknowingly\n*   Borrowers's bad oracle is set to never return a liquidating rate on `oracle.get` call.\n*   Lender cannot call `removeCollateral` to liquidate the NFT when it should be allowed, as it will fail the check on [L288](https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L288)\n*   To liquidate the NFT, the lender would have to whitehat along the lines of H-01, by atomically updating to an honest oracle and calling `removeCollateral`.\n\n### Mitigations\n\n*   Add `require(params.oracle == accepted.oracle)` as a condition in `_lend`\n*   Consider only allowing whitelisted oracles, to avoid injection of malicious oracles at the initial loan request stage\n\n**[cryptolyndon (AbraNFT) confirmed and commented](https://github.com/code-423n4/2022-04-abranft-findings/issues/136#issuecomment-1119136462):**\n > Oracle not compared to lender agreed value: confirmed, and I think this is the first time I've seen this particular vulnerability pointed out. Not marking the entire issue as a duplicate for that reason.\n> \n> Oracle not checked on loan request: Not an issue, first reported in #62.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the code of the NFTPairWithOracle.sol contract. The issue is that when a borrower requests a loan, there is no check that the lender agrees to the used oracle, which means that a borrower can request a loan with a malicious oracle and avoid legitimate liquidation. This can be proven through a proof of concept, where the borrower requests a loan with a malicious oracle, the lender unknowingly accepts the loan, and the bad oracle is set to never return a liquidating rate on the oracle.get call. To liquidate the NFT, the lender would have to whitehat by atomically updating to an honest oracle and calling removeCollateral. There are two proposed mitigations to this issue. The first is to add a condition that requires that the oracle used must be the accepted oracle in the _lend function. The second is to consider only allowing whitelisted oracles, to avoid injection of malicious oracles at the initial loan request stage.",
      "report_date": {},
      "contest_prize_txt": "$50,000 MIM",
      "contest_link": "https://code4rena.com/contests/2022-04-abranft-contest",
      "sponsor_name": "Abracadabra Money",
      "sponsor_link": "https://twitter.com/MIM_Spell",
      "quality_score": 3,
      "general_score": 1,
      "source_link": "https://code4rena.com/reports/2022-04-abranft",
      "github_link": "https://github.com/code-423n4/2022-04-abranft-findings/issues/136",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "113",
      "slug": "h-01-avoidance-of-liquidation-via-malicious-oracle-code4rena-abracadabra-money-abranft-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Abracadabra Money",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Abracadabra Money",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Oracle"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "1351",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 12,
      "protocol_id": "423",
      "title": "[M-01] Oracle data feed is insufficiently validated",
      "content": "_Submitted by throttle, also found by 0x1f8b, cccz, defsec, hack3r-0m, hyh, kenzo, leastwood, sirhashalot, TomFrenchBlockchain, WatchPug, and ye0lde_\n\nPrice can be stale and can lead to wrong `quoteAmount` return value\n\n#### Proof of Concept\n\nOracle data feed is insufficiently validated. There is no check for stale price and round completeness.\nPrice can be stale and can lead to wrong `quoteAmount` return value\n\n```javascript\nfunction _peek(\n    bytes6 base,\n    bytes6 quote,\n    uint256 baseAmount\n) private view returns (uint256 quoteAmount, uint256 updateTime) {\n    ...\n\n    (, int256 daiPrice, , , ) = DAI.latestRoundData();\n    (, int256 usdcPrice, , , ) = USDC.latestRoundData();\n    (, int256 usdtPrice, , , ) = USDT.latestRoundData();\n\n    require(\n        daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0,\n        \"Chainlink pricefeed reporting 0\"\n    );\n\n    ...\n}\n```\n\n#### Recommended Mitigation Steps\n\nValidate data feed\n\n```javascript\nfunction _peek(\n    bytes6 base,\n    bytes6 quote,\n    uint256 baseAmount\n) private view returns (uint256 quoteAmount, uint256 updateTime) {\n    ...\n    (uint80 roundID, int256 daiPrice, , uint256 timestamp, uint80 answeredInRound) = DAI.latestRoundData();\n    require(daiPrice > 0, \"ChainLink: DAI price <= 0\");\n    require(answeredInRound >= roundID, \"ChainLink: Stale price\");\n    require(timestamp > 0, \"ChainLink: Round not complete\");\n\n    (roundID, int256 usdcPrice, , timestamp, answeredInRound) = USDC.latestRoundData();\n    require(usdcPrice > 0, \"ChainLink: USDC price <= 0\");\n    require(answeredInRound >= roundID, \"ChainLink: Stale USDC price\");\n    require(timestamp > 0, \"ChainLink: USDC round not complete\");\n\n    (roundID, int256 usdtPrice, , timestamp, answeredInRound) = USDT.latestRoundData();\n    require(usdtPrice > 0, \"ChainLink: USDT price <= 0\");\n    require(answeredInRound >= roundID, \"ChainLink: Stale USDT price\");\n    require(timestamp > 0, \"ChainLink: USDT round not complete\");\n\n    ...\n}\n```\n\n**[iamsahu (Yield) confirmed and resolved](https://github.com/code-423n4/2022-01-yield-findings/issues/136)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-01-yield-findings/issues/136#issuecomment-1039639929):**\n > When using Chainlink Price feeds it is important to ensure the price feed data was updated recently.\n> While getting started with chainlink requires just one line of code, it is best to add additional checks for in production environments.\n> \n> I believe the finding to be valid and Medium severity to be appropriate.\n> \n> The sponsor has mitigated in a subsequent PR.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the 'throttle' handle. The vulnerability in this handle is that the Oracle data feed is insufficiently validated, which can lead to a stale price and wrong return value. The proof of concept is that there is no check for stale price and round completeness, and the impact of this is that the quoteAmount return value can be wrong. The tool used for this bug report is manual review. The recommended mitigation steps are to validate the data feed, which can be done by adding code to the _peek() function to check for stale prices and round completeness. This code will require the prices to be greater than zero, and the round to be complete.",
      "report_date": {},
      "contest_prize_txt": "$30,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-01-yield-convex-contest",
      "sponsor_name": "Yield",
      "sponsor_link": "https://twitter.com/yield",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-01-yield",
      "github_link": "https://github.com/code-423n4/2022-01-yield-findings/issues/136",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "80",
      "slug": "m-01-oracle-data-feed-is-insufficiently-validated-code4rena-yield-yield-convex-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Yield",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Yield",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Chainlink"
          }
        },
        {
          "tags_tag": {
            "title": "Stale Price"
          }
        }
      ]
    },
    {
      "id": "1363",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "302",
      "title": "[H-05] Flash loan price manipulation in purchasePyroFlan()",
      "content": "## Handle\n\nsirhashalot\n\n\n## Vulnerability details\n\n## Impact\n\nThe comment on [line 54](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/FlanBackstop.sol#L54) of FlanBackstop.sol states \"the opportunity for price manipulation through flash loans exists\", and I agree that this is a serious risk. While the acceptableHighestPrice variable attempts to limit the maximum price change of the flan-stablecoin LP, a flashloan sandwich attack can still occur within this limit and make up for the limitation with larger volumes or multiple flashloan attacks. Flashloan price manipulation is the cause for many major hacks, including [bZx](https://bzx.network/blog/postmortem-ethdenver), [Harvest](https://rekt.news/harvest-finance-rekt/), and others.\n\n## Proof of Concept\n\n[Line 83](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/FlanBackstop.sol#L83) of FlanBackstop.sol calculates the price of flan to stablecoin in the Uniswap pool based on the balances at a single point in time. Pool balances at a single point in time can be manipulated with flash loans, which can skew the numbers to the extreme. The single data point of LP balances is used to calculate [the growth variable in line 103](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/FlanBackstop.sol#L103), and the growth variable influences the quantity of pyroflan a user receives in [the premium calculation on line 108](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/FlanBackstop.sol#L108).\n```\nuint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;\nuint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;\nuint256 premium = (flanToMint * (growth / 2)) / 100;\n```\n\nProblems can occur when the volumes that the `purchasePyroFlan()` function sends to the Uniswap pool are large compared to the pool's liquidity volume, or if the Uniswap pool price is temporarily tilted with a flashloan (or a whale). Because this function purposefully changes the exchange rate of the LP, by transferring tokens to the LP in a 2-to-1 ratio, a large volume could caught a large price impact in the LP. The code attempts to protect against this manipulation in [line 102](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/FlanBackstop.sol#L102) with a require statement, but this can be worked around by reducing the volume per flashloan and repeating the attack multiple times. A user can manipulate the LP, especially when the LP is new with low liquidity, in order to achieve large amounts of flan and pyroflan.\n\n## Recommended Mitigation Steps\n\nUse a TWAP instead of the pool price at a single point in time to increase the cost of performing a flashloan sandwich attack. See [the Uniswap v2 price oracle solution ](https://docs.uniswap.org/protocol/V2/concepts/core-concepts/oracles)documentation for more explanations on how Uniswap designed an approach to providing asset prices while reducing the change of manipulation.",
      "summary": "\nThis bug report is about the potential for price manipulation through flash loans in the FlanBackstop.sol code. Flashloan price manipulation is the cause for many major hacks, including bZx, Harvest, and others. The code calculates the price of flan to stablecoin in the Uniswap pool based on the balances at a single point in time, which can be manipulated with flash loans. A user can manipulate the LP, especially when the LP is new with low liquidity, in order to achieve large amounts of flan and pyroflan. The code attempts to protect against this manipulation, but the attack can still be repeated multiple times. The recommended mitigation steps are to use a TWAP instead of the pool price at a single point in time to increase the cost of performing a flashloan sandwich attack. TWAP is a Uniswap v2 price oracle solution that provides asset prices while reducing the change of manipulation.",
      "report_date": {},
      "contest_prize_txt": "$90,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-01-behodler-contest",
      "sponsor_name": "Behodler",
      "sponsor_link": "https://twitter.com/BehodlerAMM",
      "quality_score": 4,
      "general_score": 4.999242017104216,
      "source_link": "https://code4rena.com/reports/2022-01-behodler",
      "github_link": "https://github.com/code-423n4/2022-01-behodler-findings/issues/231",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "78",
      "slug": "h-05-flash-loan-price-manipulation-in-purchasepyroflan-code4rena-behodler-behodler-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Behodler",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Behodler",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Flash Loan"
          }
        },
        {
          "tags_tag": {
            "title": "TWAP"
          }
        }
      ]
    },
    {
      "id": "1192",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "261",
      "title": "[H-09] `PriceOracle` Does Not Filter Price Feed Outliers",
      "content": "_Submitted by leastwood_\n\n#### Impact\n\nIf for whatever reason the Chainlink oracle returns a malformed price due to oracle manipulation or a malfunctioned price, the result will be passed onto users, causing unintended consequences as a result.\n\nIn the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L149-L161>\n```solidity\nfunction getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n    uint256 _price;\n    uint256 _decimals;\n    (_price, _decimals) = getChainlinkLatestPrice(num, den);\n    if (_decimals != 0) {\n        return (_price, _decimals);\n    }\n    (_price, _decimals) = getUniswapLatestPrice(num, den);\n    if (_decimals != 0) {\n        return (_price, _decimals);\n    }\n    revert(\"PriceOracle::getLatestPrice - Price Feed doesn't exist\");\n}\n```\nThe above code outlines how prices are utilised regardless of their actual value (assuming it is always a non-zero value).\n\n#### Recommended Mitigation Steps\n\nConsider querying both the Chainlink oracle and Uniswap pool for latest prices, ensuring that these two values are within some upper/lower bounds of each other. It may also be useful to track historic values and ensure that there are no sharp changes in price. However, the first option provides a level of simplicity as UniswapV3's TWAP implementation is incredibly resistant to flash loan attacks. Hence, the main issue to address is a malfunctioning Chainlink oracle.\n\n**[ritik99 (Sublime) disputed](https://github.com/code-423n4/2021-12-sublime-findings/issues/51#issuecomment-1007996594):**\n > The described suggestion is fairly complex - besides the increase in code complexity, we'd also have to decide the bounds within which the Uniswap and Chainlink oracles should report prices that won't be trivial. We've also noted in the [assumptions](https://github.com/code-423n4/2021-12-sublime#assumptions--design-choices) section of our contest repo that oracles are assumed to be accurate\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/51#issuecomment-1018064762):**\n > \" We expect these feeds to be fairly reliable.\" - Based on this quote, I am going to leave this open at the current risk level.  These are valid changes that could significantly reduce the risk of the implementation and unintended liquidations. \n> \n> Fairly reliable != 100% reliable\n> \n\n\n",
      "summary": "\nThis bug report concerns the Chainlink oracle, which is used to retrieve prices for users. If the oracle returns a malformed or malfunctioned price, this could cause unintended consequences for users. The proof of concept provided is a snippet of code which outlines how prices are utilised regardless of their actual value. To mitigate this issue, the report recommends querying both the Chainlink oracle and Uniswap pool for latest prices, ensuring that these two values are within some upper/lower bounds of each other. Additionally, tracking historic values and ensuring there are no sharp changes in price may also be useful. The main issue to address is a malfunctioning Chainlink oracle.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-12-sublime-contest",
      "sponsor_name": "Sublime",
      "sponsor_link": "https://twitter.com/sublimefinance",
      "quality_score": 3,
      "general_score": 4.5,
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/51",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "61",
      "slug": "h-09-priceoracle-does-not-filter-price-feed-outliers-code4rena-sublime-sublime-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Sublime",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Sublime",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "TWAP"
          }
        }
      ]
    },
    {
      "id": "1015",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "322",
      "title": "[H-30] Newly Registered Assets Skew Consultation Results",
      "content": "_Submitted by leastwood_\n\n#### Impact\n\nThe `TwapOracle.consult()` function iterates over all token pairs which belong to either `VADER` or USDV\\` and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. This helps to further protect against price manipulation attacks as the price is averaged out over the various registered token pairs.\n\nIf a new asset is added by first registering the token pair and aggregator, the consultation result for that token pair will remain skewed until the next update interval. This is due to the fact that the native asset amount will return `0` due to the default `price1Average` value being used. However, the Chainlink oracle will return a valid result. As a result, the query will be skewed in favour of `sumUSD` resulting in incorrect consultations.\n\nI'd classify this issue as high risk as the oracle returns false results upon being consulted. This can lead to issues in other areas of the protocol that use this data in performing sensitive actions.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L115-L157>\n- <https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L314>\n- <https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L322-L369>\n\n#### Tools Used\n\nManual code review.\n\n#### Recommended Mitigation Steps\n\nConsider performing proper checks to ensure that if `pairData.price1Average._x == 0`, then the Chainlink aggregator is not queried and not added to `sumUSD`. Additionally, it may be useful to fix the current check to assert that the `pairData.price1Average.mul(1).decode144()` result is not `0`, found [here](https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L129-L132). `require(sumNative != 0)` is used to assert this, however, this should be `require(pairData.price1Average.mul(1).decode144() != 0)` instead.\n\n**[SamSteinGG (Vader) confirmed](https://github.com/code-423n4/2021-11-vader-findings/issues/249)**\n>The TWAP oracle module has been completely removed and redesigned from scratch as LBTwap that is subject of the new audit.\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `TwapOracle.consult()` function of the VADER and USDV protocols. This function iterates over all token pairs which belong to either `VADER` or USDV` and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. If a new asset is added by first registering the token pair and aggregator, the consultation result for that token pair will remain skewed until the next update interval. This is due to the fact that the native asset amount will return `0` due to the default `price1Average` value being used. As a result, the query will be skewed in favour of `sumUSD` resulting in incorrect consultations. This can lead to issues in other areas of the protocol that use this data in performing sensitive actions, making it a high risk issue.\n\nThe recommended mitigation steps for this vulnerability include performing proper checks to ensure that if `pairData.price1Average._x == 0`, then the Chainlink aggregator is not queried and not added to `sumUSD`, as well as fixing the current check to assert that the `pairData.price1Average.mul(1).decode144()` result is not `0`.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-11-vader-protocol-contest",
      "sponsor_name": "Vader Protocol",
      "sponsor_link": "https://twitter.com/VaderProtocol",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2021-11-vader",
      "github_link": "https://github.com/code-423n4/2021-11-vader-findings/issues/249",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "52",
      "slug": "h-30-newly-registered-assets-skew-consultation-results-code4rena-vader-protocol-vader-protocol-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Vader Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Vader Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Oracle"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    }
  ]
}