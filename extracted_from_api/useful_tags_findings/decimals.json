{
  "tag": "Decimals",
  "count": 45,
  "metadata": {
    "totalResults": 45,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 18,
    "reset": 1771761000
  },
  "findings": [
    {
      "id": "33351",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "1433",
      "title": "M-1: `accPointsPerShare` can reach a very large value leading to overflows",
      "content": "Source: https://github.com/sherlock-audit/2024-05-sophon-judging/issues/36 \n\n## Found by \nZdravkoHr.\n## Summary\nEach pool tracks the amount of points that should be distributed for one share of its LP token in the `accPointsPerShare` variable. This variable can reach very large values causing integer overflows. This is dangerous as it puts the protocol's functionality at great risks.\n\n## Vulnerability Detail\nThis is the code that calculates `accPointsPerShare`. `pointReward` is a variable with 36 decimals precision because `blockMultiplier` and `pointsPerBlock` have both 18 decimals. The result is then divided by `lpSupply`. \n```solidity\n        uint256 blockMultiplier = _getBlockMultiplier(pool.lastRewardBlock, getBlockNumber());\n        uint256 pointReward =\n            blockMultiplier *\n            _pointsPerBlock *\n            _allocPoint /\n            totalAllocPoint;\n\n        pool.accPointsPerShare = pointReward /\n            lpSupply +\n            pool.accPointsPerShare;\n```\n\nThe problem with this approach is that lpSupply can be a small value. It can happen either naturally (for example, tokens with low decimals, like USDC and USDT) or on purpose (by a malicious depositor).\n\nThe malicious depositor can deposit just 1 wei of the lp token and wait 1 block to update the `accPointsPerShare` variable. Since `lpSupply` will be equal to 1, `accPointsPerShare` will remain a value with 36 decimals.\n\nLet's now have a look at [pendingPoints()](https://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L357C1-L385C1)\n```solidity\n    function _pendingPoints(uint256 _pid, address _user) internal view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n\n        uint256 accPointsPerShare = pool.accPointsPerShare * 1e18;\n\n        uint256 lpSupply = pool.amount;\n        if (getBlockNumber() > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 blockMultiplier = _getBlockMultiplier(pool.lastRewardBlock, getBlockNumber());\n\n            uint256 pointReward =\n                blockMultiplier *\n                pointsPerBlock *\n                pool.allocPoint /\n                totalAllocPoint;\n\n            accPointsPerShare = pointReward *\n                1e18 /\n                lpSupply +\n                accPointsPerShare;\n        }\n\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n    }\n\n```\n`pool.accPointsPerShare` is multipled by 1e18 once again, resulting in 54 decimals. This is not the end, in the return statement this value will be multiplied once again by `user.amount.` Depending on the token's decimals, the value will be scaled again. For 18 decimals, the value will reach 72 decimals. This will result in unexpected overflows because `type(uint256).max < 1e78`  \n\n\n```solidity\n        return user.amount *\n            accPointsPerShare \n```\n\n## Proof of Concept\nIn this test a first depositor deposits 1 wei worth of our Mock token to inflate the `accPointsPerShare`. In the next block, a honest depositor deposits `10_000` tokens. When `pendingPoints` is called, the transaction reverts because of an overflow.\n```solidity\n    function testOverflow() public {\n        vm.startPrank(deployer);\n        MockERC20 usdc = new MockERC20(\"Mock USDC Token\", \"MockUSDC\", 18);\n        usdc.mint(address(deployer), 10000e18);\n        dai.mint(address(deployer), 1000e18);\n\n        uint256 usdcId = sophonFarming.add(60000, address(usdc), \"\", false);\n\n        dai.approve(address(sophonFarming), 1000e18);\n        usdc.approve(address(sophonFarming), 10000e18);\n\n        sophonFarming.depositDai(1000e18, 0);\n        sophonFarming.deposit(usdcId, 1, 0);\n\n        vm.roll(block.number + 1);\n\n        sophonFarming.massUpdatePools();\n\n        address[] memory users = new address[](1);\n        users[0] = deployer;\n\n        uint256[][] memory pendingPoints = sophonFarming.getPendingPoints(\n            users\n        );\n\n        for (uint i = 0; i < pendingPoints.length; i++) {\n            uint256 poolsLength = pendingPoints[i].length;\n\n            for (uint j = 0; j < poolsLength; j++) {\n                uint256 currentPoints = pendingPoints[i][j];\n                console.log(currentPoints);\n            }\n        }\n\n        sophonFarming.deposit(usdcId, 10000e18 - 1, 0);\n\n        vm.roll(block.number + 1);\n\n        sophonFarming.massUpdatePools();\n\n        pendingPoints = sophonFarming.getPendingPoints(users);\n\n        for (uint i = 0; i < pendingPoints.length; i++) {\n            uint256 poolsLength = pendingPoints[i].length;\n\n            for (uint j = 0; j < poolsLength; j++) {\n                uint256 currentPoints = pendingPoints[i][j];\n                console.log(currentPoints);\n            }\n        }\n    }\n```\n\n## Impact\nThe `accPointsPerShare` variable becomes too large and breaks contract functionality\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L423-L432\nhttps://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L357C1-L385C1\n## Tool used\n\nManual Review\n\n## Recommendation\nA possible solution may be to set a floor that a user has to deposit and also scale by a smaller value.\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  invalid because getPendingPoints() will not practically be used till point farming has ended. The higher precision adopted is by design\n\n**0xreadyplayer1** commented:\n>  even in the stated case - being the worst - the value goes uptil 1e72 and not 1e77 which is needed for overflow - the issue might exist but the watson was not able to clearly show the exploit about what happens if the price goes this large.\n\n\n\n**ZdravkoHr**\n\nEscalate\nThe value 1e72 will be multiplied by the user amount, thus causing the overflow as in the provided proof of concept.\n\n**sherlock-admin3**\n\n> Escalate\n> The value 1e72 will be multiplied by the user amount, thus causing the overflow as in the provided proof of concept.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mystery0x**\n\nThe extreme edge case isn't going to happen. You see, the user amount is only 1 wei when multiplying with the inflated accPointsPerShare (due to division by 1 wei of `lpSupply`). \n\nSo, when `user.amount` and `pool.amount` become sizable amounts (updated via the next [`_deposit()`](https://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L616-L617), `lpSupply` will no longer be 1 wei but rather whatever that has been last updated on [`pool.amount`](https://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L363) in `_pendingPoints()`.\n\n**WangSecurity**\n\nDo I understand correctly that the user still can deposit into the protocol by dividing their deposit into several ones? So they can successfully deposit all 10_000 tokens as the POC and later users will not have problems? @ZdravkoHr is it correct or not?\n\nAnd @mystery0x as I understand, user.amount and pool.amount will be updated after the point when the revert happens, no? Cause if what you're saying is correct, the POC wouldn't work, no? Or the POC is wrong?\n\n**ZdravkoHr**\n\nWhen lpSupply becomes an 1e18 value, the accPointsPerShare will already be a very large value because in the updatePool function the amount is being added, not overwritten.\n\n@WangSecurity, the problem is not that the user can't deposit, but that getPendingPoints will revert when the whole process depends on it\n\n**mystery0x**\n\n> When lpSupply becomes an 1e18 value, the accPointsPerShare will already be a very large value because in the updatePool function the amount is being added, not overwritten.\n\nCan you run the test and show us the result reverting? I don’t think it’s going to be a problem since division by lpSupply (1e18) at this point is going to make accPointsPerShare diminished prior to having it multiplied to user.amount.\n\n**ZdravkoHr**\n\nThe division by `1e18` will reduce the decimals of the `pointReward`, however this result will be added to the already big enough `pool.accPointsPerShare` value because there is an addition operation.\n\nHere is the result of the PoC: \n![image](https://github.com/sherlock-audit/2024-05-sophon-judging/assets/42611094/b239619a-02cb-41ad-8336-a2d967927598)\n\n\n**mystery0x**\n\n@ZdravkoHr Hmm... addition would cause overflow for the max value of uint256?\n\nWe agree that the first addend `user.amount * accPointsPerShare /1e36` is already curbed after the second call. How big can the second addend `user.rewardSettled` initially go? Can you plug in some practical numbers for these two addends and then the summation of both?\n\n```\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n```\n\n**ZdravkoHr**\n\nBut how is the first calculation curbed if there is an addition in any subsequent call and not assignment? The value will babe large decimals initially and will continue growing, there seems to be no way to decrease it\n\n**mystery0x**\n\n> But how is the first calculation curbed if there is an addition in any subsequent call and not assignment? The value will babe large decimals initially and will continue growing, there seems to be no way to decrease it\n\n`pointReward * 1e18 / lpSupply` is trivial as `lpSupply` is no longer 1 wei but 1e18:\n\n```\n            accPointsPerShare = pointReward *\n                1e18 /\n                lpSupply +\n                accPointsPerShare;\n```\nJust plug in some numbers, and I'm sure no issues are going to be found. You're not multiplying two big numbers (rather just adding) in the last arithmetic operation of function `_pendingPoints`: \n\n```\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n```\n\n**ZdravkoHr**\n\nWith the default values from the tests, pointsPerBlock = 25e18 and allocation of 50%.\naccPointsPerShare = 12.5e36\n\nUsers deposit and this value becomes > 12.5e36\n\nThen we go here\n```\n        uint256 accPointsPerShare = pool.accPointsPerShare * 1e18;\n         ...\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n```\nLet user amount be 10_000e18 = 1e22. Then we have\n`1e22 * 12.5e54` which is greater than `type(uint256.max)`\n![image](https://github.com/sherlock-audit/2024-05-sophon-judging/assets/42611094/dd0ca202-1803-4a26-9a2e-7207df18e3a6)\n\nHere are logs from the PoC:\n![image](https://github.com/sherlock-audit/2024-05-sophon-judging/assets/42611094/d1a2a34e-04a7-4a3d-8542-a1d135b3e749)\n\n\n\n\n**mystery0x**\n\nAh, ok. @RomanHiden you might want to look into this edge issue in `_pendingPoints()`. \n\n**WangSecurity**\n\nBased on the above discussion, I agree with the escalation.\n\nPlanning to accept it and validate with medium severity. Are there any duplicates of it?\n\n**ZdravkoHr**\n\n@WangSecurity, just searched for `getPendingPoints` and couldn't find a duplicate (there were 16 results). Maybe if @mystery0x knows of some\n\n**mystery0x**\n\nMany other reports touched on the topic but none of them identified the 1 wei culprit from the first and only depositor in the initial block(s).\n\nIt's noteworthy that the suggested mitigation, \"to set a floor that a user has to deposit\" will also solve the issues associated with #85 and #177. \n\n**WangSecurity**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ZdravkoHr](https://github.com/sherlock-audit/2024-05-sophon-judging/issues/36/#issuecomment-2145925136): accepted\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/sophon-org/farming-contracts/commit/f0b82fd83a5d85eb8dc7ba2bbce2d49fefb326a4",
      "summary": "\nIssue M-1: `accPointsPerShare` can reach a very large value causing integer overflows in the Sophon protocol.\n\nZdravkoHr found that the `accPointsPerShare` variable in each pool can become very large, leading to integer overflows. This is due to the code calculating `accPointsPerShare` using a variable with 36 decimals precision and then dividing it by `lpSupply`, which can be a small value. This can happen naturally or by a malicious depositor. The value can then be further multiplied, resulting in unexpected overflows. A proof of concept was provided showing how this can happen. This issue can put the protocol's functionality at risk. \n\nThe vulnerability was found through a manual review and there are no known duplicates. The suggested solution is to set a floor for user deposits. The escalation was accepted and the issue has been resolved in the protocol's code. ",
      "report_date": {},
      "contest_prize_txt": "13000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/376",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-05-sophon-judging/issues/36",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "376",
      "slug": "m-1-accpointspershare-can-reach-a-very-large-value-leading-to-overflows-sherlock-sophon-farming-contracts-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sophon Farming Contracts",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sophon Farming Contracts",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        },
        {
          "tags_tag": {
            "title": "Overflow/Underflow"
          }
        }
      ]
    },
    {
      "id": "30620",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 9,
      "protocol_id": "1314",
      "title": "M-2: User wrapped tokens get stuck in master router because of incorrect calculation",
      "content": "Source: https://github.com/sherlock-audit/2024-02-jala-swap-judging/issues/146 \n\n## Found by \nArabadzhiev, C1rdan, cawfree, den\\_sosnovskyi, jah, mahmud, merlinboii, recursiveEth, yotov721\n## Summary\nSwapping exact tokens for ETH swaps underlying token amount, not wrapped token amount and this causes wrapped tokens to get stuck in the contract.\n\n## Vulnerability Detail\nIn the protocol the `JalaMasterRouter` is used to swap tokens with less than 18 decimals. It is achieved by wrapping the underlying tokens and interacting with the `JalaRouter02`. **Wrapping** the token gives it decimals 18 (18 - token.decimals()). There are also functions that swap with native ETH. \n\nIn the `swapExactTokensForETH` function the tokens are transferred from the user to the Jala master router, **wrapped**, approved to `JalaRouter2` and then `IJalaRouter02::swapExactTokensForETH()` is called with **the amount of tokens to swap**, to address, deadline and path. \n\nThe amount of tokens to swap that is passed, is the amount before the wrap. Hence the wrappedAmount - underlyingAmount is stuck. \n\nAdd the following test to `JalaMasterRouter.t.sol` and run with `forge test --mt testswapExactTokensForETHStuckTokens -vvv`\n```javascript\n    function testswapExactTokensForETHStuckTokens() public {\n        address wrappedTokenA = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(address(tokenA));\n\n        tokenA.approve(address(wrapperFactory), type(uint256).max);\n        wrapperFactory.wrap(address(this), address(tokenA), 100);\n\n        IERC20(wrappedTokenA).approve(address(router), 100 ether);\n        router.addLiquidityETH{value: 100 ether}(wrappedTokenA, 100 ether, 0, 0, address(this), type(uint40).max);\n\n        address pairAddress = factory.getPair(address(WETH), wrapperFactory.wrappedTokenFor(address(tokenA)));\n\n        uint256 pairBalance = JalaPair(pairAddress).balanceOf(address(this));\n\n        address[] memory path = new address[](2);\n        path[0] = wrappedTokenA;\n        path[1] = address(WETH);\n\n        vm.startPrank(user0);\n        console.log(\"ETH user balance before:       \", user0.balance);\n        console.log(\"TokenA user balance before:    \", tokenA.balanceOf(user0));\n        console.log(\"WTokenA router balance before: \", IERC20(wrappedTokenA).balanceOf(address(masterRouter)));\n\n        tokenA.approve(address(masterRouter), 550);\n        masterRouter.swapExactTokensForETH(address(tokenA), 550, 0, path, user0, type(uint40).max);\n        vm.stopPrank();\n\n        console.log(\"ETH user balance after:       \", user0.balance);\n        console.log(\"TokenA user balance after:    \", tokenA.balanceOf(user0));\n        console.log(\"WTokenA router balance after: \", IERC20(wrappedTokenA).balanceOf(address(masterRouter)));\n    }\n```\n\n\n## Impact\nUser wrapped tokens get stuck in router contract. The can be stolen by someone performing a `swapExactTokensForTokens()` because it uses the whole balance of the contract when swapping: `IERC20(wrappedTokenIn).balanceOf(address(this))` \n```solidity\n        amounts = IJalaRouter02(router).swapExactTokensForTokens(\n            IERC20(wrappedTokenIn).balanceOf(address(this)),\n            amountOutMin,\n            path,\n            address(this),\n            deadline\n        );\n```\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-jala-swap/blob/main/jalaswap-dex-contract/contracts/JalaMasterRouter.sol#L284-L301\n\n## Tool used\nManual Review, foundry\n\n## Recommendation\nIn `JalaMasterRouter::swapExactTokensForETH()` multiply the `amountIn` by decimal off set of the token:\n```diff\n    function swapExactTokensForETH(\n        address originTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override returns (uint256[] memory amounts) {\n        address wrappedTokenIn = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(originTokenAddress);\n\n        require(path[0] == wrappedTokenIn, \"MS: !path\");\n\n        TransferHelper.safeTransferFrom(originTokenAddress, msg.sender, address(this), amountIn);\n        _approveAndWrap(originTokenAddress, amountIn);\n        IERC20(wrappedTokenIn).approve(router, IERC20(wrappedTokenIn).balanceOf(address(this)));\n\n+        uint256 decimalOffset = IChilizWrappedERC20(wrappedTokenIn).getDecimalsOffset();\n+        amounts = IJalaRouter02(router).swapExactTokensForETH(amountIn * decimalOffset, amountOutMin, path, to, deadline);\n-        amounts = IJalaRouter02(router).swapExactTokensForETH(amountIn , amountOutMin, path, to, deadline);\n    }\n```\n\n\n\n## Discussion\n\n**nevillehuang**\n\nIf a sufficient slippage (which is users responsibility) is set, this will at most cause a revert, so medium severity is more appropriate. (The PoC set slippage to zero)\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/jalaswap/jalaswap-dex-contract/commit/9ed6e8f4f6ad762ef7b747ca2d367f6cfd78973e.\n\n**spacegliderrrr**\n\nfix looks good, right amount is now passed to the router\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.",
      "summary": "\nThe report discusses a bug found in the JalaSwap protocol, where user wrapped tokens can get stuck in the master router due to an incorrect calculation. This happens when swapping exact tokens for ETH, as the amount of tokens passed is before the wrapping process, causing the wrapped amount to be stuck in the contract. This can potentially lead to the tokens being stolen by someone performing a swap. The bug was found through a manual review using the tool foundry. The recommendation is to fix the calculation by multiplying the amountIn by the decimal offset of the token. The protocol team has already fixed the issue.",
      "report_date": {},
      "contest_prize_txt": "15750 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/233",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-02-jala-swap-judging/issues/146",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "233",
      "slug": "m-2-user-wrapped-tokens-get-stuck-in-master-router-because-of-incorrect-calculation-sherlock-jala-swap-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Jala Swap",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Jala Swap",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "30675",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "LOW",
      "finders_count": 0,
      "protocol_id": "471",
      "title": "[01] `PrizeVault._tryGetAssetDecimals()` may return erroneous decimals",
      "content": "\nSome ERC20 assets do not have `decimals()` implemented. As such, when calling `PrizeVault._tryGetAssetDecimals()`, `success == false` when returned by `staticcall()` and `_tryGetAssetDecimals()` returns (false, 0):  \n\nhttps://github.com/code-423n4/2024-03-pooltogether/blob/main/pt-v5-vault/src/PrizeVault.sol#L772-L783\n\n```solidity\n    function _tryGetAssetDecimals(IERC20 asset_) internal view returns (bool, uint8) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n```\n\nAccording to the logic implemented in the constructor, `_underlyingDecimals` would default to 18:\n\nhttps://github.com/code-423n4/2024-03-pooltogether/blob/main/pt-v5-vault/src/PrizeVault.sol#L303-L305\n\n```solidity\n        IERC20 asset_ = IERC20(yieldVault_.asset());\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n```\n\nThis can lead to significant discrepancy if the non-standard asset decimals is different than 18. It can affect various contract functionalities, such as asset calculations and distributions, especially for tokens with non-standard decimal values when accessing `PrizeVault.decimals()`:\n\nhttps://github.com/code-423n4/2024-03-pooltogether/blob/main/pt-v5-vault/src/PrizeVault.sol#L320-L322\n\n```solidity\n    function decimals() public view override(ERC20, IERC20Metadata) returns (uint8) {\n        return _underlyingDecimals;\n    }\n```\n\nTo mitigate this, contracts should be designed with mechanisms to accurately determine and use the correct decimal value; either by requiring decimal specification upon initialization, implementing fallback mechanisms with predefined mappings, or including validation checks to ensure compatibility and accuracy in token-related operations. Addressing this challenge is crucial for maintaining the reliability and fairness of smart contract transactions involving a diverse range of ERC20 tokens. \n\n",
      "summary": "",
      "report_date": {},
      "contest_prize_txt": "37700",
      "contest_link": "https://code4rena.com/reports/2024-03-pooltogether",
      "sponsor_name": "PoolTogether",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-03-pooltogether",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "332",
      "slug": "01-prizevault_trygetassetdecimals-may-return-erroneous-decimals-code4rena-pooltogether-pooltogether-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "PoolTogether",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "PoolTogether",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC20"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "27293",
      "kind": "MARKDOWN",
      "auditfirm_id": "11",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "1161",
      "title": "`TokenSaleProposal::buy` implicitly assumes that buy token has 18 decimals resulting in a potential total loss scenario for Dao Pool",
      "content": "**Description:** `TokenSaleProposalBuy::buy` is called by users looking to buy the DAO token using a pre-approved token. The exchange rate for this sale is pre-assigned for the specific tier. This function internally calls `TokenSaleProposalBuy::_purchaseWithCommission` to transfer funds from the buyer to the gov pool. Part of the transferred funds are used to pay the DexeDAO commission and balance funds are transferred to the `GovPool` address. To do this, `TokenSaleProposalBuy::_sendFunds` is called.\n\n```solidity\n    function _sendFunds(address token, address to, uint256 amount) internal {\n        if (token == ETHEREUM_ADDRESS) {\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"TSP: failed to transfer ether\");\n        } else {\n  >>          IERC20(token).safeTransferFrom(msg.sender, to, amount.from18(token.decimals())); //@audit -> amount is assumed to be 18 decimals\n        }\n    }\n```\n\nNote that this function assumes that the `amount` of ERC20 token is always 18 decimals. The `DecimalsConverter::from18` function converts from a base decimal (18) to token decimals. Note that the amount is directly passed by the buyer and there is no prior normalisation done to ensure the token decimals are converted to 18 decimals before the `_sendFunds` is called.\n\n\n**Impact:** It is easy to see that for tokens with smaller decimals, eg. USDC with 6 decimals, will cause a total loss to the DAO. In such cases amount is presumed to be 18 decimals & on converting to token decimals(6), this number can round down to 0.\n\n**Proof of Concept:**\n- Tier 1 allows users to buy DAO token at exchange rate, 1 DAO token = 1 USDC.\n-  User intends to buy 1000 Dao Tokens and calls `TokenSaleProposal::buy` with `buy(1, USDC, 1000*10**6)\n- Dexe DAO Comission is assumed 0% for simplicity- > `sendFunds` is called with `sendFunds(USDC, govPool, 1000* 10**6)`\n- `DecimalConverter::from18` function is called on amount with base decimals 18, destination decimals 6:  `from18(1000*10**6, 18, 6)`\n- this gives `1000*10**6/10*(18-6) = 1000/ 10**6` which rounds to 0\n\nBuyer can claim 1000 DAO tokens for free. This is a total loss to the DAO.\n\nAdd PoC to `TokenSaleProposal.test.js`:\n\nFirst add a new line around [L76](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L76) to add new `purchaseToken3`:\n```javascript\n      let purchaseToken3;\n```\n\nThen add a new line around [L528](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L528):\n```javascript\n      purchaseToken3 = await ERC20Mock.new(\"PurchaseMockedToken3\", \"PMT3\", 6);\n```\n\nThen add a new tier around [L712](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L712):\n```javascript\n        {\n          metadata: {\n            name: \"tier 9\",\n            description: \"the ninth tier\",\n          },\n          totalTokenProvided: wei(1000),\n          saleStartTime: timeNow.toString(),\n          saleEndTime: (timeNow + 10000).toString(),\n          claimLockDuration: \"0\",\n          saleTokenAddress: saleToken.address,\n          purchaseTokenAddresses: [purchaseToken3.address],\n          exchangeRates: [PRECISION.times(1).toFixed()],\n          minAllocationPerUser: 0,\n          maxAllocationPerUser: 0,\n          vestingSettings: {\n            vestingPercentage: \"0\",\n            vestingDuration: \"0\",\n            cliffPeriod: \"0\",\n            unlockStep: \"0\",\n          },\n          participationDetails: [],\n        },\n```\n\nThen add the test itself under the section `describe(\"if added to whitelist\", () => {`:\n```javascript\n          it(\"audit buy implicitly assumes that buy token has 18 decimals resulting in loss to DAO\", async () => {\n            await purchaseToken3.approve(tsp.address, wei(1000));\n\n            // tier9 has the following parameters:\n            // totalTokenProvided   : wei(1000)\n            // minAllocationPerUser : 0 (no min)\n            // maxAllocationPerUser : 0 (no max)\n            // exchangeRate         : 1 sale token for every 1 purchaseToken\n            //\n            // purchaseToken3 has 6 decimal places\n            //\n            // mint purchase tokens to owner 1000 in 6 decimal places\n            //                        1000 000000\n            let buyerInitTokens6Dec = 1000000000;\n\n            await purchaseToken3.mint(OWNER, buyerInitTokens6Dec);\n            await purchaseToken3.approve(tsp.address, buyerInitTokens6Dec, { from: OWNER });\n\n            //\n            // start: buyer has bought no tokens\n            let TIER9 = 9;\n            let purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, wei(0));\n\n            // buyer attempts to purchase using 100 purchaseToken3 tokens\n            // purchaseToken3 has 6 decimals but all inputs to Dexe should be in\n            // 18 decimals, so buyer formats input amount to 18 decimals\n            // doing this first to verify it works correctly\n            let buyInput18Dec = wei(\"100\");\n            await tsp.buy(TIER9, purchaseToken3.address, buyInput18Dec);\n\n            // buyer has bought wei(100) sale tokens\n            purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, buyInput18Dec);\n\n            // buyer has 900 000000 remaining purchaseToken3 tokens\n            assert.equal((await purchaseToken3.balanceOf(OWNER)).toFixed(), \"900000000\");\n\n            // next buyer attempts to purchase using 100 purchaseToken3 tokens\n            // but sends input formatted into native 6 decimals\n            // sends 6 decimal input: 100 000000\n            let buyInput6Dec = 100000000;\n            await tsp.buy(TIER9, purchaseToken3.address, buyInput6Dec);\n\n            // buyer has bought an additional 100000000 sale tokens\n            purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;\n            assert.equal(purchaseView.claimTotalAmount, \"100000000000100000000\");\n\n            // but the buyer still has 900 000000 remaining purchasetoken3 tokens\n            assert.equal((await purchaseToken3.balanceOf(OWNER)).toFixed(), \"900000000\");\n\n            // by sending the input amount formatted to 6 decimal places,\n            // the buyer was able to buy small amounts of the token being sold\n            // for free!\n          });\n```\n\nFinally run the test with: `npx hardhat test --grep \"audit buy implicitly assumes that buy token has 18 decimals resulting in loss to DAO\"`\n\n**Recommended Mitigation:** There are at least 2 options for mitigating this issue:\n\nOption 1 - revise the design decision that all token amounts must be sent in 18 decimals even if the underlying token decimals are not 18, to instead that all token amounts should be sent in their native decimals and Dexe will convert everything.\n\nOption 2 - keep current design but revert if `amount.from18(token.decimals()) == 0` in [L90](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/token-sale-proposal/TokenSaleProposalBuy.sol#L90) or alternatively use the [`from18Safe()`](https://github.com/dl-solarity/solidity-lib/blob/master/contracts/libs/utils/DecimalsConverter.sol#L124) function which uses [`_convertSafe()`](https://github.com/dl-solarity/solidity-lib/blob/master/contracts/libs/utils/DecimalsConverter.sol#L248) that reverts if the conversion is 0.\n\nThe project team should also examine other areas where the same pattern occurs which may have the same vulnerability and where it may be required to revert if the conversion returns 0:\n\n* `GovUserKeeper` [L92](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L92), [L116](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L116), [L183](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L183)\n* `GovPool` [L248](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/GovPool.sol#L248)\n* `TokenSaleProposalWhitelist` [L50](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/token-sale-proposal/TokenSaleProposalWhitelist.sol#L50)\n* `ERC721Power` [L113](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L113), [L139](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L139)\n* `TokenBalance` [L35](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/utils/TokenBalance.sol#L35), [L62](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/utils/TokenBalance.sol#L62)\n\n**Dexe:**\nFixed in commit [c700d9f](https://github.com/dexe-network/DeXe-Protocol/commit/c700d9f9f328d1df853891b52fd3527b56a6f1df).\n\n**Cyfrin:** Verified. While other places have been changed, `TokenBalance::sendFunds()` still uses `from18()` instead of `from18Safe()` & other parts of the codebase which allow user input when calling `TokenBalance::sendFunds()` directly could be impacted by a similar issue.\n\nFor example `TokenSaleProposalWhitelist::unlockParticipationTokens()` - if users try to unlock a small enough amount of locked tokens which are in 6 decimal precision, state will be updated as if the unlock was successful but the resulting conversion in `TokenBalance::sendFunds()` will round down to 0. Execution will continue & zero tokens will be transferred to the user but since storage has been updated those tokens will remain forever locked.\n\nDexe should carefully consider if there exists any valid situations where the `from18()` conversion in `TokenBalance::sendFunds()` should round an input > 0 to 0, and the transaction should not revert but continue executing transferring 0 tokens? Cyfrin recommends that the \"default\" conversion to use is `from18Safe()` and that `from18()` should only be used where conversions to 0 are explicitly allowed.",
      "summary": "\nA bug report has been submitted for the `TokenSaleProposalBuy::buy` function in the Dexe Network Protocol. This function is called by users looking to buy the DAO token using a pre-approved token. The exchange rate for this sale is pre-assigned for the specific tier. This function internally calls `TokenSaleProposalBuy::_purchaseWithCommission` to transfer funds from the buyer to the gov pool. Part of the transferred funds are used to pay the DexeDAO commission and balance funds are transferred to the `GovPool` address. To do this, `TokenSaleProposalBuy::_sendFunds` is called.\n\nThis function assumes that the `amount` of ERC20 token is always 18 decimals. The `DecimalsConverter::from18` function converts from a base decimal (18) to token decimals. Note that the amount is directly passed by the buyer and there is no prior normalisation done to ensure the token decimals are converted to 18 decimals before the `_sendFunds` is called. This can lead to a total loss to the DAO when tokens with smaller decimals, such as USDC with 6 decimals, are used.\n\nThe impact of this bug is that a buyer can claim DAO tokens for free. A proof of concept has been included in the report.\n\nTwo options have been recommended for mitigation. Option 1 is to revise the design decision that all token amounts must be sent in 18 decimals even if the underlying token decimals are not 18, to instead that all token amounts should be sent in their native decimals and Dexe will convert everything. Option 2 is to keep the current design but revert if `amount.from18(token.decimals()) == 0` or alternatively use the `from18Safe()` function which uses `_convertSafe()` that reverts if the conversion is 0.\n\nThe project team should also examine other areas where the same pattern occurs which may have the same vulnerability and where it may be required to revert if the conversion returns 0.\n\nThe bug has been fixed in commit [c700d9f](https://github.com/dexe-network/DeXe-Protocol/commit/c700d9f9f328d1df853891b",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 1.007154661394276,
      "general_score": 3.0007154661394275,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "tokensaleproposalbuy-implicitly-assumes-that-buy-token-has-18-decimals-resulting-in-a-potential-total-loss-scenario-for-dao-pool-cyfrin-none-cyfrin-dexe-markdown",
      "firm_name": "Cyfrin",
      "firm_logo_square": "Cyfrin_square.jpg",
      "protocol_name": "Dexe",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
      },
      "protocols_protocol": {
        "name": "Dexe",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Algo-Stables"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        },
        {
          "tags_tag": {
            "title": "Precision Loss"
          }
        },
        {
          "tags_tag": {
            "title": "ERC20"
          }
        },
        {
          "tags_tag": {
            "title": "Weird ERC20"
          }
        }
      ]
    },
    {
      "id": "29353",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 15,
      "protocol_id": "1126",
      "title": "[M-05] Decimal Limitation in CamelotRelayer and UniV3Relayer Contract Deployment",
      "content": "\n<https://github.com/open-dollar/od-contracts/blob/v1.5.5-audit/src/contracts/oracles/CamelotRelayer.sol#L58> \n\n<https://github.com/open-dollar/od-contracts/blob/v1.5.5-audit/src/contracts/oracles/CamelotRelayer.sol#L103-L105> \n\n<https://github.com/open-dollar/od-contracts/blob/v1.5.5-audit/src/contracts/oracles/UniV3Relayer.sol#L64> \n\n<https://github.com/open-dollar/od-contracts/blob/v1.5.5-audit/src/contracts/oracles/UniV3Relayer.sol#L110-L112>\n\nThe current design of the CamelotRelayer and UniV3Relayer contracts limits its compatibility to only those `_quoteTokens` that have a decimal count of 18 or fewer. If an attempt is made to deploy the contract with a token having more than 18 decimals as the `_quoteToken`, the contract deployment will fail due to an underflow issue during the multiplier calculation. This poses no financial risk but restricts the contract's adaptability in the wider DeFi ecosystem, preventing its use with tokens that have more than 18 decimals.\n\n### Proof of Concept\n\nThe restriction emerges from the constructor, where the `multiplier` is deduced as `18 - IERC20Metadata(_quoteToken).decimals()`.\n\n<https://github.com/open-dollar/od-contracts/blob/v1.5.5-audit/src/contracts/oracles/CamelotRelayer.sol#L58> \n\n<https://github.com/open-dollar/od-contracts/blob/v1.5.5-audit/src/contracts/oracles/UniV3Relayer.sol#L64>\n\n```solidity\n    multiplier = 18 - IERC20Metadata(_quoteToken).decimals();\n```\n\nFor tokens like [`YAMv2`, which possess 24 decimals](https://etherscan.io/token/0xaba8cac6866b83ae4eec97dd07ed254282f6ad8a), the computation would attempt `18 - 24`, which results in an underflow, making the contract deployment unsuccessful.\n\n### Recommended Mitigation Steps\n\n1.  Alter the datatype of `multiplier` to `int256` to account for both positive and negative values.\n\n2.  Adjust the multiplier's computation in the constructor to handle situations where token decimals might be greater or less than 18.\n\n```solidity\n    int8 decimalsDifference = 18 - int8(IERC20Metadata(_quoteToken).decimals());\n    multiplier = int256(decimalsDifference);\n```\n\n3.  Revise the `_parseResult` function to either multiply or divide the `_quoteResult` depending on the `multiplier` value.\n\n```solidity\n    function _parseResult(uint256 _quoteResult) internal view returns (uint256 _result) {\n        if (multiplier > 0) {\n            return _quoteResult * (10 ** uint256(multiplier));\n        } else if (multiplier < 0) {\n            return _quoteResult / (10 ** uint256(-multiplier));\n        } else {\n            return _quoteResult;\n        }\n    }\n```\n\nNote: It will require additional code refactoring to make `baseAmount` and its value assignment as `int256` as well.\n\n**[pi0neerpat (OpenDollar) confirmed](https://github.com/code-423n4/2023-10-opendollar-findings/issues/323#issuecomment-1787830556)**\n\n**[MiloTruck (Judge) commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/323#issuecomment-1790123541):**\n > The warden has demonstrated how `CamelotRelayer.sol` and `UniV3Relayer.sol` cannot be deployed for tokens with more than 18 decimals, which limits the functionality of the protocol unnecessarily. As such, medium severity is appropriate. \n\n\n***\n\n",
      "summary": "\nThis bug report is about the current design of the CamelotRelayer and UniV3Relayer contracts which limits its compatibility to only those `_quoteTokens` that have a decimal count of 18 or fewer. If an attempt is made to deploy the contract with a token having more than 18 decimals as the `_quoteToken`, the contract deployment will fail due to an underflow issue during the multiplier calculation. \n\nThe restriction emerges from the constructor, where the `multiplier` is deduced as `18 - IERC20Metadata(_quoteToken).decimals()`. For tokens like `YAMv2`, which possess 24 decimals, the computation would attempt `18 - 24`, which results in an underflow, making the contract deployment unsuccessful.\n\nThe bug report suggests three mitigation steps to fix this issue. Firstly, alter the datatype of `multiplier` to `int256` to account for both positive and negative values. Secondly, adjust the multiplier's computation in the constructor to handle situations where token decimals might be greater or less than 18. Thirdly, revise the `_parseResult` function to either multiply or divide the `_quoteResult` depending on the `multiplier` value. It will also require additional code refactoring to make `baseAmount` and its value assignment as `int256` as well.\n\nThe bug was confirmed and given a medium severity rating by OpenDollar and Judge respectively.",
      "report_date": {},
      "contest_prize_txt": "36500",
      "contest_link": "https://code4rena.com/reports/2023-10-opendollar",
      "sponsor_name": "Open Dollar",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-10-opendollar",
      "github_link": "https://github.com/code-423n4/2023-10-opendollar-findings/issues/323",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "297",
      "slug": "m-05-decimal-limitation-in-camelotrelayer-and-univ3relayer-contract-deployment-code4rena-open-dollar-open-dollar-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Open Dollar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Open Dollar",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Overflow/Underflow"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "29460",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 27,
      "protocol_id": "1058",
      "title": "[H-07] Incorrect precision assumed from RdpxPriceOracle creates multiple issues related to value inflation/deflation",
      "content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L372> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L381> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L539> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1160>\n\nThe `RdpxEthPriceOracle`, available in the audit repo [here](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol), provides the `RdpxV2Core`, the `UniV2LiquidityAmo` and the `PerpetualAtlanticVault` contracts the necessary values for `rdpx` related price calculations.\n\nThe issue is that these contracts expect the returned values to be in `1e8` precision (as stated in the natspec [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1224), [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L378) and [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/IPerpetualAtlanticVault.sol#L20C1-L24C65)). But the returned precision [is actually `1e18`](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol#L243).\n\nThis difference creates multiple issues throughout the below contracts:\n\n| Contract                     | Function               | Effect                                                       |\n| ---------------------------- | ---------------------- | ------------------------------------------------------------ |\n| `rdpxV2Core.sol`             | `getRdpxPrice()`       | Returns an `1e18` value when `1e8` expected                  |\n|                              | `calculateBondCost()`  | Deflates the `rdpxRequired`                                  |\n|                              | `calculateAmounts()`   | Inflates the `rdpxRequiredInWeth`                            |\n|                              | `_transfer()`          | Inflates `rdpxAmountInWeth` and may cause possible underflow |\n| `UniV2LiquidityAmo`          | `getLpPriceInEth()`    | Overestimates the lp value                                   |\n| `ReLp.sol`                   | `reLP()`               | Inflates min token amounts                                   |\n| `PerpetualAtlanticVault.sol` | `getUnderlyingPrice()` | Returns `1e18` instead of `1e8`                              |\n|                              | `calculatePremium()`   | Inflates the premium calculation                             |\n\n### Proof of Concept\n\nThe `RdpxEthPriceOracle.sol` file can be found [here](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol)\n\nIt exposes the following functions used in the audit:\n\n*   [`getLpPriceInEth()`](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol#L200)\n*   [`getRdpxPriceInEth()`](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol#L243)\n\nThese two functions provide the current price denominated in `ETH`, with a precision in `1e18`, as confirmed by their respective natspec comments:\n\n```\n    /// @dev Returns the price of LP in ETH in 1e18 decimals\n    function getLpPriceInEth() external view override returns (uint) {\n    ...\n\n    /// @notice Returns the price of rDPX in ETH\n    /// @return price price of rDPX in ETH in 1e18 decimals\n    function getRdpxPriceInEth() external view override returns (uint price) {\n\n```\n\nBut, in the contracts from the audit repo, the business logic (and even the natspec) assumes the returned precision will be `1e8`. See below:\n\nIn the `RdpxV2Core` contract the assumption that the price returned from the oracle is clearly noted in the [natspec](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1227C1-L1227C1) of the `getRdpxPrice()` function:\n\n      /**\n       * @notice Returns the price of rDPX against ETH\n       * @dev    Price is in 1e8 Precision\n       * @return rdpxPriceInEth rDPX price in ETH\n       **/\n      function getRdpxPrice() public view returns (uint256) {\n        return\n          IRdpxEthOracle(pricingOracleAddresses.rdpxPriceOracle)\n            .getRdpxPriceInEth();\n      }\n\nIn `UniV2LiquidityAmo` the assumption is noted [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L378):\n\n      /**\n       * @notice Returns the price of a rDPX/ETH Lp token against the alpha token\n       * @dev    Price is in 1e8 Precision\n       * @return uint256 LP price\n       **/\n      function getLpPrice() public view returns (uint256) {\n\nAnd it has business logic implication here:\n\n      function getLpTokenBalanceInWeth() external view returns (uint256) {\n        return (lpTokenBalance * getLpPrice()) / 1e8;\n      }\n\nIn `PerpetualAtlanticVault` it is noted [here](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/IPerpetualAtlanticVault.sol#L21):\n\n      /**\n       * @notice Returns the price of the underlying in ETH in 1e8 precision\n       * @return uint256 the current underlying price\n       **/\n      function getUnderlyingPrice() external view returns (uint256);\n\nAnd the business logic implications in this contract are primarily found in the `calculatePremium` function, where the premium is divided by `1e8`:\n\n      function calculatePremium(\n        uint256 _strike,\n        uint256 _amount,\n        uint256 timeToExpiry,\n        uint256 _price\n      ) public view returns (uint256 premium) {\n        premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(\n          _strike,\n          _price > 0 ? _price : getUnderlyingPrice(),\n          getVolatility(_strike),\n          timeToExpiry\n        ) * _amount) / 1e8);\n      }\n\nFrom the audit files it's clear that the assumption was that the returned price would be in `1e8`, but this is Dopex's own `RdpxPriceOracle`, so was likely a simple oversight which slipped through testing as a `MockRdpxEthPriceOracle` was implemented to simplify testing, which mocked the values from the oracle, but only to a `1e8` precision.\n\n### Recommended Mitigation Steps\n\nFor price feeds where `WETH` will be token B, it is convention (although not a standard, as far as the reviewer is aware), that the precision returned will be `1e18`. See [here](https://ethereum.stackexchange.com/questions/92508/do-all-chainlink-feeds-return-prices-with-8-decimals-of-precision).\n\nAs the sponsor indicated that the team might move to Chainlink oracles, it is suggested to modify the `RdpxV2Core`, `PerpetualAtlanticVault`, `UniV2Liquidity` and the `ReLp` contracts to work with the returned `1e18` precision, assuming that the keep the token pair as rdpx/WETH.\n\n**[psytama (Dopex) confirmed and commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/549#issuecomment-1733729931):**\n > The issue is in the oracle contract which returns 1e18.\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/549#issuecomment-1759261378):**\n > Seems like the Warden grouped a bunch of consequences down to the root cause of the oracle precision.\n> \n> I'll need to determine how to group / ungroup findings as there seem to be multple impacts but a single root cause.\n\n***\n\n",
      "summary": "\nThis bug report is regarding the `RdpxEthPriceOracle`, a contract available on the audit repo which provides the `RdpxV2Core`, the `UniV2LiquidityAmo`, and the `PerpetualAtlanticVault` contracts with necessary values for `rdpx` related price calculations. The issue is that these contracts expect the returned values to be in `1e8` precision, but the returned precision is actually `1e18`. This difference creates multiple issues throughout the contracts such as inflating the `rdpxRequiredInWeth`, deflating the `rdpxRequired`, inflating the `rdpxAmountInWeth`, overestimating the lp value, inflating min token amounts and inflating the premium calculation.\n\nThe `RdpxEthPriceOracle.sol` file can be found [here](https://github.com/dopex-io/rdpx-eth-oracle/blob/5762c2339b1c45b87ff4db172e43cef4a0ff603a/src/RdpxEthOracle.sol) and it exposes the two functions `getLpPriceInEth()` and `getRdpxPriceInEth()` which provide the current price denominated in `ETH`, with a precision in `1e18`.\n\nIt is suggested to modify the `RdpxV2Core`, `PerpetualAtlanticVault`, `UniV2Liquidity` and the `ReLp` contracts to work with the returned `1e18` precision, assuming that the team keeps the token pair as rdpx/WETH.",
      "report_date": {},
      "contest_prize_txt": "125000",
      "contest_link": "https://code4rena.com/reports/2023-08-dopex",
      "sponsor_name": "Dopex",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-08-dopex",
      "github_link": "https://github.com/code-423n4/2023-08-dopex-findings/issues/549",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "278",
      "slug": "h-07-incorrect-precision-assumed-from-rdpxpriceoracle-creates-multiple-issues-related-to-value-inflationdeflation-code4rena-dopex-dopex-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Dopex",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Dopex",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "29454",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 22,
      "protocol_id": "1058",
      "title": "[H-01] Improper precision of strike price calculation can result in broken protocol",
      "content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L1189-L1190> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L576-L583>\n\nDue to a lack of adequate precision, the calculated strike price for a PUT option for rDPX is not guaranteed to be 25% OTM, which breaks core assumptions around (1) protecting downside price movement of the rDPX which makes up part of the collateral for dpxETH & (2) not overpaying for PUT option protection.\n\nMore specifically, the price of rDPX as used in the `calculateBondCost` function of the RdpxV2Core contract is represented as ETH / rDPX, and is given in 8 decimals of precision. To calculate the strike price which is 25% OTM based on the current price, the logic calls the `roundUp` function on what is effectively 75% of the current spot rDPX price. The issue is with the `roundUp` function of the PerpetualAtlanticVault contract, which effectively imposes a minimum value of 1e6.\n\nConsidering approximate recent market prices of `$`2000/ETH and `$`20/rDPX, the current price of rDPX in 8 decimals of precision would be exactly 1e6. Then to calculate the 25% OTM strike price, we would arrive at a strike price of `1e6 * 0.75 = 75e4`. The `roundUp` function will then round up this value to `1e6` as the strike price, and issue the PUT option using that invalid strike price. Obviously this strike price is not 25% OTM, and since its an ITM option, the premium imposed will be significantly higher. Additionally this does not match the implementation as outlined in the docs.\n\n### Proof of Concept\n\nWhen a user calls the `bond` function of the RdpxV2Core contract, it will calculate the `rdpxRequired` and `wethRequired` required by the user in order to mint a specific `_amount` of dpxETH, which is calculated using the `calculateBondCost` function:\n\n```solidity\nfunction bond(\n  uint256 _amount,\n  uint256 rdpxBondId,\n  address _to\n) public returns (uint256 receiptTokenAmount) {\n  _whenNotPaused();\n  // Validate amount\n  _validate(_amount > 0, 4);\n\n  // Compute the bond cost\n  (uint256 rdpxRequired, uint256 wethRequired) = calculateBondCost(\n    _amount,\n    rdpxBondId\n  );\n  ...\n}\n```\n\nAlong with the collateral requirements, the `wethRequired` will also include the ETH premium required to mint the PUT option. The amount of premium is calculated based on a strike price which represents 75% of the current price of rDPX (25% OTM PUT option). In the `calculateBondCost` function:\n\n```solidity\nfunction calculateBondCost(\n  uint256 _amount,\n  uint256 _rdpxBondId\n) public view returns (uint256 rdpxRequired, uint256 wethRequired) {\n  uint256 rdpxPrice = getRdpxPrice();\n\n  ...\n\n  uint256 strike = IPerpetualAtlanticVault(addresses.perpetualAtlanticVault)\n    .roundUp(rdpxPrice - (rdpxPrice / 4)); // 25% below the current price\n\n  uint256 timeToExpiry = IPerpetualAtlanticVault(\n    addresses.perpetualAtlanticVault\n  ).nextFundingPaymentTimestamp() - block.timestamp;\n  if (putOptionsRequired) {\n    wethRequired += IPerpetualAtlanticVault(addresses.perpetualAtlanticVault)\n      .calculatePremium(strike, rdpxRequired, timeToExpiry, 0);\n  }\n}\n```\n\nAs shown, the strike price is calculated as:\n\n```solidity\nuint256 strike = IPerpetualAtlanticVault(addresses.perpetualAtlanticVault).roundUp(rdpxPrice - (rdpxPrice / 4));\n```\n\nIt uses the `roundUp` function of the PerpetualAtlanticVault contract which is defined as follows:\n\n```solidity\nfunction roundUp(uint256 _strike) public view returns (uint256 strike) {\n  uint256 remainder = _strike % roundingPrecision;\n  if (remainder == 0) {\n    return _strike;\n  } else {\n    return _strike - remainder + roundingPrecision;\n  }\n}\n```\n\nIn this contract `roundingPrecision` is set to `1e6`, and this is where the problem arises. As I mentioned earlier, take the following approximate market prices: `$`2000/ETH and `$`20/rDPX. This means the `rdpxPrice`, which is represented as ETH/rDPX in 8 decimals of precision, will be `1e6`. To calculate the strike price, we get the following: `1e6 * 0.75 = 75e4`. However this value is fed into the `roundUp` function which will convert the `75e4` to `1e6`. This value of `1e6` is then used to calculate the premium, which is completely wrong. Not only is `1e6` not 25% OTM, but it is actually ITM, meaning the premium will be significantly higher than was intended by the protocol design.\n\n### Recommended Mitigation Steps\n\nThe value of the `roundingPrecision` is too high considering reasonable market prices of ETH and rDPX. Consider decreasing it.\n\n**[psytama (Dopex) confirmed](https://github.com/code-423n4/2023-08-dopex-findings/issues/2083#issuecomment-1734091528)**\n\n***\n\n",
      "summary": "\nA bug has been identified in the `RdpxV2Core` and `PerpetualAtlanticVault` contracts of the dpxETH protocol. This bug results in the calculated strike price for a PUT option for rDPX not being guaranteed to be 25% OTM, which breaks core assumptions around protecting downside price movement of the rDPX which makes up part of the collateral for dpxETH and not overpaying for PUT option protection.\n\nThe issue is due to the `roundUp` function of the `PerpetualAtlanticVault` contract, which effectively imposes a minimum value of `1e6`. This means that when the current price of rDPX is `1e6` (in 8 decimals of precision), the strike price calculated by the `calculateBondCost` function of the `RdpxV2Core` contract will be rounded up to `1e6` as well. This is not 25% OTM, and since it is an ITM option, the premium imposed will be significantly higher.\n\nTo mitigate this issue, the value of the `roundingPrecision` should be decreased. This has been confirmed by psytama (Dopex).",
      "report_date": {},
      "contest_prize_txt": "125000",
      "contest_link": "https://code4rena.com/reports/2023-08-dopex",
      "sponsor_name": "Dopex",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-08-dopex",
      "github_link": "https://github.com/code-423n4/2023-08-dopex-findings/issues/2083",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "278",
      "slug": "h-01-improper-precision-of-strike-price-calculation-can-result-in-broken-protocol-code4rena-dopex-dopex-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Dopex",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Dopex",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "24318",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "1049",
      "title": "H-3: CurveTricryptoOracle#getPrice contains math error that causes LP to be priced completely wrong",
      "content": "Source: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/100 \n\n## Found by \n0x52, Kow\n\nCurveTricryptoOracle#getPrice incorrectly divides the LP price by the price of ETH which causes it to return the price of LP in terms of ETH instead of USD\n\n## Vulnerability Detail\n\n[CurveTricryptoOracle.sol#L57-L62](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L57-L62)\n\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n\nAfter the LP price has been calculated in USD it is mistakenly divided by the price of ETH causing the contract to return the LP price in terms of ETH rather than USD. This leads to LP that is massively undervalued causing positions which are actually heavily over collateralized to be liquidated.\n\n## Impact\n\nHealthy positions are liquidated due to incorrect LP pricing\n\n## Code Snippet\n\n[CurveTricryptoOracle.sol#L48-L65](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L48-L65)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDon't divide the price by the price of ETH\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because lpPrice is considered in ETH so dividing by ETH/USD price returns the final result in USD\n\n**Kral01** commented:\n> there is a precision value\n\n\n\n**Gornutz**\n\nJudges accurately state why the division by ETH/USD is required to return the proper USD value.\n\n**Shogoki**\n\nClosing in regards to other judges and sponsors comments.\n\n**IAm0x52**\n\nThis is valid. The code being used here was borrowed from the Sentiment [CurveTriCryptoOracle](https://arbiscan.io/address/0x4e828a117ddc3e4dd919b46c90d4e04678a05504#code), which is specifically meant to return the price in terms of ETH. This oracle is meant to return the valuation in USD which means the division by the price of ETH needs to be dropped.\n\n**Shogoki**\n\n> This is valid. The code being used here was borrowed from the Sentiment [CurveTriCryptoOracle](https://arbiscan.io/address/0x4e828a117ddc3e4dd919b46c90d4e04678a05504#code), which is specifically meant to return the price in terms of ETH. This oracle is meant to return the valuation in USD which means the division by the price of ETH needs to be dropped.\n\nMaybe was a bit quick in closing. Will reopen it and we will take a deeper look at it.",
      "summary": "\nThis bug report is about an issue found in the CurveTricryptoOracle#getPrice function of the codebase. The bug causes the Liquidation Price (LP) to be priced completely wrong due to a math error. The code snippet in question is located at CurveTricryptoOracle.sol#L57-L62 and it incorrectly divides the LP price by the price of ETH which causes it to return the price of LP in terms of ETH instead of USD. This leads to healthy positions being liquidated due to incorrect LP pricing. \n\nThe issue was initially found by 0x52 and Kow and then discussed by other members of the Sherlock Audit team. The team concluded that the code was borrowed from the Sentiment CurveTriCryptoOracle which is meant to return the price in terms of ETH. As the oracle is meant to return the valuation in USD, the division by the price of ETH needs to be dropped. The issue was then reopened for further investigation.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/104",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/100",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "104",
      "slug": "h-3-curvetricryptooraclegetprice-contains-math-error-that-causes-lp-to-be-priced-completely-wrong-sherlock-none-blueberry-update-3-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update #3",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update #3",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "20908",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "981",
      "title": "M-5: Exponential and logarithmic price adapters will return incorrect pricing when moving from higher dp token to lower dp token",
      "content": "Source: https://github.com/sherlock-audit/2023-06-Index-judging/issues/42 \n\n## Found by \n0x52\n## Summary\n\nThe exponential and logarithmic price adapters do not work correctly when used with token pricing of different decimal places. This is because the resolution of the underlying expWad and lnWad functions is not fit for tokens that aren't 18 dp.\n\n## Vulnerability Detail\n\n[AuctionRebalanceModuleV1.sol#L856-L858](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L856-L858)\n\n    function _calculateQuoteAssetQuantity(bool isSellAuction, uint256 _componentQuantity, uint256 _componentPrice) private pure returns (uint256) {\n        return isSellAuction ? _componentQuantity.preciseMulCeil(_componentPrice) : _componentQuantity.preciseMul(_componentPrice);\n    }\n\nThe price returned by the adapter is used directly to call _calculateQuoteAssetQuantity which uses preciseMul/preciseMulCeil to convert from component amount to quote amount. Assume we wish to sell 1 WETH for 2,000 USDT. WETH is 18dp while USDT is 6dp giving us the following price:\n\n    1e18 * price / 1e18 = 2000e6\n\nSolving for price gives:\n\n    price = 2000e6\n\nThis establishes that the price must be scaled to:\n\n    price dp = 18 - component dp + quote dp\n\nPlugging in our values we see that our scaling of 6 dp makes sense.\n\n[BoundedStepwiseExponentialPriceAdapter.sol#L67-L80](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L67-L80)\n\n        uint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\n        // Protect against priceChange overflow\n        if (scalingFactor > type(uint256).max / expExpression) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 priceChange = scalingFactor * expExpression - WAD;\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\n\nGiven the pricing code and notably the simple scalingFactor it also means that priceChange must be in the same order of magnitude as the price which in this case is 6 dp. The issue is that on such small scales, both lnWad and expWad do not behave as expected and instead yield a linear behavior. This is problematic as the curve will produce unexpected behaviors under these circumstances selling the tokens at the wrong price. Since both functions are written in assembly it is very difficult to determine exactly what is going on or why this occurs but testing in remix gives the following values:\n\n    expWad(1e6) - WAD = 1e6\n    expWad(5e6) - WAD = 5e6\n    expWad(10e6) - WAD = 10e6\n    expWad(1000e6) - WAD = 1000e6\n\nAs seen above these value create a perfect linear scaling and don't exhibit any exponential qualities. Given the range of this linearity it means that these adapters can never work when selling from higher to lower dp tokens. \n\n## Impact\n\nExponential and logarithmic pricing is wrong when tokens have mismatched dp\n\n## Code Snippet\n\n[BoundedStepwiseExponentialPriceAdapter.sol#L28-L88](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L28-L88)\n\n[BoundedStepwiseLogarithmicPriceAdapter.sol#L28-L88](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseLogarithmicPriceAdapter.sol#L28-L88)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nscalingFactor should be scaled to 18 dp then applied via preciseMul instead of simple multiplication. This allows lnWad and expWad to execute in 18 dp then be scaled down to the correct dp.\n\n\n\n## Discussion\n\n**pblivin0x**\n\nAgree that scalingFactor should be 18 decimals and applied with preciseMul, will fix. \n\n**Oot2k**\n\nNot a duplicate \n\n**bizzyvinci**\n\nEscalate\n\nThis is invalid\n\n`FixedPointMathLib.expWad` and `FixedPointMathLib.lnWad` uses WAD as input and WAD as output. This is mentioned in [docs](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol#L120) and you can test it out on remix. Therefore, `exp(1) = FixedPointMathLib.expWad(WAD) / WAD` and `exp(5) = FixedPointMathLib.expWad(5*WAD) / WAD`.\n\n`expWad(1e6) - WAD = 1e6` is equal to `exp(1e-12) - 1 = 1e-12` which is absolutely correct.\n\nFor the formula to work, timeCoefficient has to be in WAD. @pblivin0x  should look at our DM around this time.\n\n<img width=\"840\" alt=\"Screenshot 2023-08-01 at 09 46 44\" src=\"https://github.com/sherlock-audit/2023-06-Index-judging/assets/22333930/1b224171-5a20-4836-95f6-3ed78078dda0\">\n\n\nHis comment: `scalingFactor should be 18 decimals and applied with preciseMul` is on a different matter. It's a plan for the future to allow decimal scalingFactor e.g 0.5, 2.5 rather than just integers like 1, 2, 3 etc.\n\nTo recap: \n`block.timestamp` is in seconds, therefore `timeBucket`, `_timeElapsed` and `bucketSize` are in seconds.\n`_componentPrice`, `initialPrice`, `minPrice`, `maxPrice`, `priceChange` and `FixedPointMathLib` are in WAD.\nTherefore, `expExpression`, `expArgument` and `timeCoefficient` has to also be in WAD.\n`scalingFactor` is just a scaler unit which the team plan to turn into WAD in the future for more precision with scaling.\n\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is invalid\n> \n> `FixedPointMathLib.expWad` and `FixedPointMathLib.lnWad` uses WAD as input and WAD as output. This is mentioned in [docs](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol#L120) and you can test it out on remix. Therefore, `exp(1) = FixedPointMathLib.expWad(WAD) / WAD` and `exp(5) = FixedPointMathLib.expWad(5*WAD) / WAD`.\n> \n> `expWad(1e6) - WAD = 1e6` is equal to `exp(1e-12) - 1 = 1e-12` which is absolutely correct.\n> \n> For the formula to work, timeCoefficient has to be in WAD. @pblivin0x  should look at our DM around this time.\n> \n> <img width=\"840\" alt=\"Screenshot 2023-08-01 at 09 46 44\" src=\"https://github.com/sherlock-audit/2023-06-Index-judging/assets/22333930/1b224171-5a20-4836-95f6-3ed78078dda0\">\n> \n> \n> His comment: `scalingFactor should be 18 decimals and applied with preciseMul` is on a different matter. It's a plan for the future to allow decimal scalingFactor e.g 0.5, 2.5 rather than just integers like 1, 2, 3 etc.\n> \n> To recap: \n> `block.timestamp` is in seconds, therefore `timeBucket`, `_timeElapsed` and `bucketSize` are in seconds.\n> `_componentPrice`, `initialPrice`, `minPrice`, `maxPrice`, `priceChange` and `FixedPointMathLib` are in WAD.\n> Therefore, `expExpression`, `expArgument` and `timeCoefficient` has to also be in WAD.\n> `scalingFactor` is just a scaler unit which the team plan to turn into WAD in the future for more precision with scaling.\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nSince scaling factor is not applied via precise mul in the current implementation, in order to work as the code is written it has to be have the same number of decimals as price and therefore can't be WAD, regardless of what sponsor has said in the discord comments. As I've shown in my issue these smaller values are not compatible with expWAD and lnWAD and will produce incorrect values, negatively affecting auction pricing. \n\n**bizzyvinci**\n\nThe [getPrice function](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L28-L88) can be broken down to the following after removing `boundary price` and type conversions.\n\n1. timeBucket = _timeElapsed / bucketSize\n2. expArgument = timeCoefficient * timeBucket\n3. expExpression = FixedPointMathLib.expWad(expArgument)\n4. priceChange = scalingFactor * expExpression - WAD\n5. price = initialPrice + priceChange (or minus)\n\nTo know what unit should be WAD or not, we need to look elsewhere.\n1. `_timeElapsed = block.timestamp - rebalanceInfo[_setToken].rebalanceStartTime` [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L806) and `rebalanceInfo[_setToken].rebalanceStartTime` is set to `block.timestamp` when startRebalance is called [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L275). Therefore `_timeElapsed`, `bucketSize` and `timeBucket` has to be seconds.\n2. `_componentPrice` is in precise unit or WAD based on calculation [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L857). Therefore `price`, `initialPrice` and `priceChange` have to also be in WAD.\n3. Formula 4 is wrong as pointed out in #39 therefore let's just focus on the multiplication part and assume `priceChange = scalingFactor * expExpression`. If `priceChange` is `WAD`, then `scalingFactor * expExpression` has to be WAD. Either `scalingFactor is WAD` or `expExpression` is WAD.\n4. FixedPointMathLib.expWad returns WAD, so `expExpression` is indeed WAD. So `scalingFactor` is basic unit.\n5. Furthermore, `FixedPointMathLib.expWad` takes WAD as input, and that input is `timeCoefficient * timeBucket`. We've established that `timeBucket` is seconds in 1, so therefore `timeCoefficient` has to be WAD.\n\nThe sponsor's message was referenced because \n* I was the one who decided that his initial statement `timeCoefficient and bucketSize are not in WAD` is wrong. So he might want to cross-check things again.\n* We had some discussions about scalingFactor and converting it to WAD around that time.\n\nIf scalingFactor is changed to WAD, then priceChange would be `WAD^2`. Therefore, we must use preciseMul to keep things balanced again. P.S: -WAD is ignored again.\n```solidity\n+ priceChange = scalingFactorWAD.preciseMul(expExpression)\n- priceChange = scalingFactorBasic * expExpression\n```\n\nThe 2 formula are the same thing because `preciseMul(a, b) = a * b / WAD` [code](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/lib/PreciseUnitMath.sol#L94-L96)\n```solidity\nfunction preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a.mul(b).div(PRECISE_UNIT);\n}\n```\n\n**IAm0x52**\n\n> _componentPrice is in precise unit or WAD based on calculation [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L857). Therefore price, initialPrice and priceChange have to also be in WAD.\n\nThis is incorrect. I've proven in my submission above that when going from an 18 dp token to 6 dp that price has to be 6 dp. Since scalingFactor is applied as a scaler and not via preciseMul then expArgument and expExpression have to also be in 6 dp as well. If you used a WAD expression for them the pricing would be completely wrong as it would return an 18 dp price. As I've shown expWAD returns incorrectly when inputting a 6 dp number.\n\n**IAm0x52**\n\nThe point of this issue is to prove that scaling factor must be applied via preciseMul or else the price cannot work as expect. To just say \"scaling factor should be applied via preciseMul\" is not a valid issue unless you can show why it's incorrect that it's not applied that way and the damages that it causes. \n\n**bizzyvinci**\n\nprecise unit is used for precision in calculation because the numbers could be very small and solidity does automatic rounding. When multiplying or dividing, preciseMul or preciseDiv is used to finally get rid of that precision. You can view the [PreciseUnitMath library](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/lib/PreciseUnitMath.sol) and the key take away are\n1. `PRECISE_UNIT = PRECISE_UNIT_INT = WAD = 1e18`\n2. `preciseMul(a, b) = a * b / WAD` and that only makes sense if a or b is WAD\n3. `preciseDiv(a, b) = a * WAD / b` and that only makes sense if b is WAD\n\nNow, why is `_componentPrice` in WAD? \nBecause `_componentQuantity` and the returned `quoteAssetQuantity` are not in WAD and preciseMul needs `b` to be WAD. `_componentQuantity` and `quoteAssetQuantity` are the raw quantity amount that would be transferred with `token.transfer`.\n\nhttps://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L856-858\n```solidity\nfunction _calculateQuoteAssetQuantity(bool isSellAuction, uint256 _componentQuantity, uint256 _componentPrice) private pure returns (uint256) {\n      return isSellAuction ? _componentQuantity.preciseMulCeil(_componentPrice) : _componentQuantity.preciseMul(_componentPrice);\n  }\n```\n\n\n**pblivin0x**\n\nI believe this is a valid medium\n\n**Oot2k**\n\nI agree that this is valid medium\n\n**bizzyvinci**\n\nI still stand by my escalation and I think my proof is sufficient cause it proves the following\n* _componentPrice in WAD\n* Right now, scalingFactor is not WAD cause that would be mathematically wrong. It must be a normal integer.\n* The unit of each parameters (e.g which one is seconds, WAD or int) to show that price does work correctly.\n* The team plans to make scalingFactor WAD and use preciseMul. They **must** use preciseMul to make sure priceChange remains a WAD (rather than WAD^2)\n* The migration of scalingFactor from integer scalar to WAD scalar **would not** change price nor priceChange because `preciseMul(a,b) = a * b / WAD`\n* The only effect the migration has is precision. scalingFactor could then be represented as decimals instead of just integers. \n\n\nIf anyone disagrees it would be nice if they state why. Or if there's a point that wasn't clear, I'm here to clarify.\n\n**bizzyvinci**\n\nI understand the proof might be daunting to comprehend so I'll recommend using pen and paper (and maybe remix with calculator) to make things easier.\n\n**bizzyvinci**\n\nI do agree that my escalation be rejected\n\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this a valid medium based on the above comments. \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [bizzyvinci](https://github.com/sherlock-audit/2023-06-Index-judging/issues/42/#issuecomment-1659888928): rejected\n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe changes are to update to 18 decimal `scalingFactor` in both the exponential and logarithmic adapter\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseLogarithmicPriceAdapter.sol#L73",
      "summary": "\nThis bug report is about the Exponential and Logarithmic Price Adapters which are used to convert token pricing of different decimal places. It was found by 0x52 and reported on GitHub. The issue is that when moving from higher dp token to lower dp token, the adapters do not work correctly due to the resolution of the underlying expWad and lnWad functions not being fit for tokens that aren't 18 dp. This is because the price returned by the adapter is used directly to call _calculateQuoteAssetQuantity which uses preciseMul/preciseMulCeil to convert from component amount to quote amount and the resolution of the functions is not suitable for smaller values.\n\nTesting in Remix showed that these functions produce a perfect linear scaling instead of an exponential one, meaning that the adapters can never work when selling from higher to lower dp tokens. As a result, exponential and logarithmic pricing is wrong when tokens have mismatched dp.\n\nThe team plan to turn scalingFactor into WAD in the future for more precision with scaling, and use preciseMul instead of simple multiplication. This would allow lnWad and expWad to execute in 18 dp then be scaled down to the correct dp.\n\nThe bug report was discussed and it was agreed that this is a valid medium issue. The team plan to fix it by turning scalingFactor into WAD in the future and using preciseMul instead of simple multiplication.",
      "report_date": {},
      "contest_prize_txt": "24000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/91",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-Index-judging/issues/42",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "91",
      "slug": "m-5-exponential-and-logarithmic-price-adapters-will-return-incorrect-pricing-when-moving-from-higher-dp-token-to-lower-dp-token-sherlock-none-index-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Index Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Index Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        },
        {
          "tags_tag": {
            "title": "Assembly"
          }
        }
      ]
    },
    {
      "id": "19120",
      "kind": "MARKDOWN",
      "auditfirm_id": "15",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "851",
      "title": "Rounding error in unstaking esMeta",
      "content": "**Severity:** Medium\n\n**Context:** [`MetaManager.sol#L84`](https://github.com/getmetafinance/meta/blob/00bbac1613fa69e4c180ff53515451df4df9f69e/contracts/meta/MetaManager.sol#L84)\n\n**Description:**\nUsers can start unstaking esMETA by calling `MetaManager::unstake` providing the amount and vesting period in days.\n\n[https://github.com/getmetafinance/meta/blob/00bbac1613fa69e4c180ff53515451df4df9f69e/contracts/meta/MetaManager.sol#L84](https://github.com/getmetafinance/meta/blob/00bbac1613fa69e4c180ff53515451df4df9f69e/contracts/meta/MetaManager.sol#L84 \"‌\")\n\nFor simplicity of discussion, let us see the first unstaking process.\nAccording to the provided vesting period, `nonSlashRate` is calculated and `unstakeRate` is calculated as `amount * nonSlashRate / 100 / timeToExit`.\n\nIn this calculation, `amount` is in 18 decimals, `nonSlashRate` ranges 50~100 and `timeToExit` ranges from `minExitCycle` ~ `maxExitCycle` (10~50 days by default but can be changed by admin).\n\nLet us say a user stakes 1000e18 GLP to get 1000e18 esMETA.\nLater he decides to unstake the whole amount for the next 50 days.\n\n```\nunstakeRatio = amount / timeToExit = 1000e18/(50 days) = 231481481481481\n```\n\nAfter 50 days, he calls `withdraw()` and the claimable amount after full vesting is :\n\n```\nunstakeRatio * 50 days = 231481481481481 * 50 days = 999999999999997920000\n```\n\nThe received amount is `2080000` wei lower than expected.\n\n```\n1000e18 - 999999999999996192000 = 2080000\n```\n\nAlthough this amount seems quite low cause the GLP is in 18 decimals but this will be happen across users for all unstaking process. As a result, this error will gradually increase and cause inaccuracy.\n\n**Impact**\nUsers will always get less amount than expected on full unstaking and the errors are accumulated to cause the imbalance of META and esMETA.\n\n**Recommendation:**\nExtend the accuracy of `unstakeRatio` by 1e18 and divide the claimable amount back by 1e18.\n\n```\nfunction unstake(uint256 _amount, uint8 _timeInDays) external updateReward(msg.sender) {\n// ...\nunstakeRate[caller] = total * 1e18 / timeToExit;\n//\n}\n\nfunction getClaimable(address _user) public view returns (uint256 amount) {//@audit-info time windowed rewards\nif (time2fullRedemption[_user] > lastWithdrawTime[_user]) {//@audit-info user already withdrawed after full redemption time, no rewards are available to claim\namount = block.timestamp > time2fullRedemption[_user]\n? unstakeRate[_user] *\n(time2fullRedemption[_user] - lastWithdrawTime[_user]) / 1e18\n: unstakeRate[_user] *\n(block.timestamp - lastWithdrawTime[_user]) / 1e18;\n}\n}\n```\n\n**Meta Team:**\n\nFixed. Precision losses are addressed.\n\n```diff\n\nfunction unstake(uint256 _amount, uint8 _timeInDays) external updateReward(msg.sender) {\naddress caller = msg.sender;\nrequire(_timeInDays >= minExitCycle/Constants.ONE_DAY && _timeInDays <= maxExitCycle/Constants.ONE_DAY, \"Fund: Invalid vesting days\");\n\nesMeta.burn(caller, _amount);\n_withdraw(caller);\nuint256 total = _amount;\nif (time2fullRedemption[caller] > block.timestamp) {\nuint256 scaled = ((unstakeRate[caller] * 100 ) * (time2fullRedemption[caller] - block.timestamp)) / (100 - lastSlashRate[caller]);\nscaled /= Constants.PINT;\ntotal += scaled ;\n}\nuint8 nonSlashRate = getNonSlashRate(_timeInDays);\ntotal = (total  * nonSlashRate)/100;\nuint256 timeToExit = _timeInDays * Constants.ONE_DAY;\nlastSlashRate[caller] = 100 - nonSlashRate;\n+        unstakeRate[caller] = (total * Constants.PINT) / timeToExit;\ntime2fullRedemption[caller] = block.timestamp + timeToExit;\n}\n\n\nfunction getClaimable(address _user) public view returns (uint256 amount) {\nif (time2fullRedemption[_user] > lastWithdrawTime[_user]) {\namount = block.timestamp > time2fullRedemption[_user]\n? unstakeRate[_user] *\n(time2fullRedemption[_user] - lastWithdrawTime[_user])\n: unstakeRate[_user] *\n(block.timestamp - lastWithdrawTime[_user]);\n+            amount /= Constants.PINT;\n}\n}\n```\n\n**Hans:**\nVerified.",
      "summary": "\nThis bug report is about an inaccuracy that occurs when a user calls the `MetaManager::unstake` function to start unstaking esMETA, which provides the amount and vesting period in days. According to the provided vesting period, `nonSlashRate` is calculated and `unstakeRate` is calculated as `amount * nonSlashRate / 100 / timeToExit`. This calculation causes a precision loss, resulting in the user receiving an amount lower than expected. \n\nThe impact of this bug is that users will always get less amount than expected on full unstaking and the errors are accumulated to cause the imbalance of META and esMETA. The recommendation to fix this bug is to extend the accuracy of `unstakeRatio` by 1e18 and divide the claimable amount back by 1e18. \n\nThe Meta Team has fixed the bug, and Hans has verified it.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hans/2023-07-13-Meta.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "rounding-error-in-unstaking-esmeta-hans-none-meta-markdown_",
      "firm_name": "Hans",
      "firm_logo_square": "hans_square.jpg",
      "protocol_name": "Meta",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Hans",
        "logo_square": "hans_square.jpg"
      },
      "protocols_protocol": {
        "name": "Meta",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "18737",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "822",
      "title": "Protocol fees are in WAD instead of token decimal units",
      "content": "## High Risk Report\n\n## Severity\n**High Risk**\n\n## Context\n`Portfolio.sol#L489`\n\n## Description\nWhen swapping, `deltaInput` is in WAD (not token decimals) units. Therefore, the `protocolFee` will also be in WAD as a percentage of `deltaInput`. This WAD amount is then credited to the REGISTRY:\n\n```solidity\niteration.feeAmount = (deltaInput * _state.fee) / PERCENTAGE;\nif (_protocolFee != 0) {\n    uint256 protocolFeeAmount = iteration.feeAmount / _protocolFee;\n    iteration.feeAmount -= protocolFeeAmount;\n    _applyCredit(REGISTRY, _state.tokenInput, protocolFeeAmount);\n}\n```\n\nThe privileged registry can claim these fees using a withdrawal (draw) and the WAD units are not scaled back to token decimal units, resulting in withdrawing more fees than they should have received if the token has less than 18 decimals. This will reduce the global reserve by the increased fee amount and break the accounting and functionality of all pools using the token.\n\n## Recommendation\nGenerally, some quantities are in WAD units and some in token decimals throughout the protocol. We recommend using WAD units everywhere and only converting from/to token decimal units at the \"token boundary\", directly at the point of interaction with the token contract through a `transfer` / `transferFrom` / `balanceOf` call.\n\n## Primitive\nResolved in PR 335.\n\n## Spearbit\nFixed.",
      "summary": "\nThis bug report is about a high risk issue found in the Portfolio.sol#L489 code. When swapping, the deltaInput is in WAD (not token decimals) units. This means that the protocolFee will also be in WAD as a percentage of deltaInput. This WAD amount is then credited to the REGISTRY. The privileged registry can claim these fees using a withdrawal (draw) and the WAD units are not scaled back to token decimal units, resulting in withdrawing more fees than they should have received if the token has less than 18 decimals. This will reduce the global reserve by the increased fee amount and break the accounting and functionality of all pools using the token.\n\nThe recommendation is to use WAD units everywhere and only convert from/to token decimal units at the \"token boundary\", directly at the point of interaction with the token contract through a transfer/transferFrom/balanceOf call. The issue was resolved in PR 335 and fixed.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Primitive-Spearbit-Security-Review.pdf",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Primitive-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Primitive-Spearbit-Security-Review.pdf",
      "pdf_page_from": 13,
      "contest_id": "",
      "slug": "protocol-fees-are-in-wad-instead-of-token-decimal-units-spearbit-none-primitive-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Primitive",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Primitive",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "19133",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 27,
      "protocol_id": "853",
      "title": "H-4: The price from `StableOracleDAI` is returned with the incorrect number of decimals",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/236 \n\n## Found by \n0xStalin, 0xeix, 0xlmanini, Bahurum, Brenzee, Dug, G-Security, PNS, Proxy, SanketKogekar, T1MOH, Vagner, WATCHPUG, ast3ros, ctf\\_sec, immeas, juancito, kutugu, n33k, peanuts, pengun, qbs, qpzm, saidam017, sam\\_gmk, sashik\\_eth, twicek\n## Summary\n\nThe price returned from the `getPriceUSD` function of the `StableOracleDAI` is scaled up by `1e10`, which results in 28 decimals instead of the intended 18.\n\n## Vulnerability Detail\n\nIn `StableOracleDAI` the `getPriceUSD` function is defined as follows...\n\n```solidity\n    function getPriceUSD() external view override returns (uint256) {\n        address[] memory pools = new address[](1);\n        pools[0] = 0x60594a405d53811d3BC4766596EFD80fd545A270;\n        uint256 DAIWethPrice = DAIEthOracle.quoteSpecificPoolsWithTimePeriod(\n            1000000000000000000, // 1 Eth\n            0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // WETH (base token)\n            0x6B175474E89094C44Da98b954EedeAC495271d0F, // DAI (quote token)\n            pools, // DAI/WETH pool uni v3\n            600 // period\n        );\n\n        uint256 wethPriceUSD = ethOracle.getPriceUSD();\n\n        // chainlink price data is 8 decimals for WETH/USD, so multiply by 10 decimals to get 18 decimal fractional\n        //(uint80 roundID, int256 price, uint256 startedAt, uint256 timeStamp, uint80 answeredInRound) = priceFeedDAIETH.latestRoundData();\n        (, int256 price,,,) = priceFeedDAIETH.latestRoundData();\n\n        return (wethPriceUSD * 1e18) / ((DAIWethPrice + uint256(price) * 1e10) / 2);\n    }\n```\n\nThe assumption is made that the `DAIWethPrice` is 8 decimals, and is therefore multiplied by `1e10` in the return statement to scale it up to 18 decimals. \n\nThe _other_ price feeds used in the protocol are indeed received with decimals, however, the Chainlink DAI/ETH price feed returns a value with 18 decimals as can be seen on their site.\n\nhttps://docs.chain.link/data-feeds/price-feeds/addresses\n\n## Impact\n\nThis means that the price returned from the `getPriceUSD` function is scaled up by `1e10`, which results in 28 decimals instead of the intended 18, drastically overvaluing the DAI/USD price.\n\nThis will result in the USSD token price being a tiny fraction of what it is intended to be. Instead of being pegged to $1, it will be pegged to $0.0000000001, completely defeating the purpose of the protocol.\n\nFor example, if a user calls `USSD.mintForToken`, supplying DAI, they'll be able to mint `1e10` times more USSD than intended.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L33-L53\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove the `* 1e10` from the return statement.\n\n```diff\n-   return (wethPriceUSD * 1e18) / ((DAIWethPrice + uint256(price) * 1e10) / 2);\n+   return (wethPriceUSD * 1e18) / (DAIWethPrice + uint256(price) / 2);\n```",
      "summary": "\nA bug has been found in the `StableOracleDAI` contract of the 2023-05-USSD protocol. It was identified by a group of auditors including 0xStalin, 0xeix, 0xlmanini, Bahurum, Brenzee, Dug, G-Security, PNS, Proxy, SanketKogekar, T1MOH, Vagner, WATCHPUG, ast3ros, ctf\\_sec, immeas, juancito, kutugu, n33k, peanuts, pengun, qbs, qpzm, saidam017, sam\\_gmk, sashik\\_eth, and twicek.\n\nThe `getPriceUSD` function of the `StableOracleDAI` is designed to return the price of DAI in USD. The function assumes that the `DAIWethPrice` is 8 decimals and multiplies it by `1e10` to scale it up to 18 decimals. However, the Chainlink DAI/ETH price feed returns a value with 18 decimals as can be seen on their site. This means that the price returned from the `getPriceUSD` function is scaled up by `1e10`, which results in 28 decimals instead of the intended 18, drastically overvaluing the DAI/USD price.\n\nThis will result in the USSD token price being a tiny fraction of what it is intended to be. Instead of being pegged to $1, it will be pegged to $0.0000000001, completely defeating the purpose of the protocol. For example, if a user calls `USSD.mintForToken`, supplying DAI, they'll be able to mint `1e10` times more USSD than intended.\n\nThe code snippet for the `getPriceUSD` function can be found at https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/oracles/StableOracleDAI.sol#L33-L53.\n\nThe recommendation to fix this issue is to remove the `* 1e10` from the return statement.\n\n```diff\n-   return (wethPriceUSD * 1e18) / ((DAIWethPrice + uint256(",
      "report_date": {},
      "contest_prize_txt": "12000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/82",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/236",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "82",
      "slug": "h-4-the-price-from-stableoracledai-is-returned-with-the-incorrect-number-of-decimals-sherlock-none-ussd-autonomous-secure-dollar-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "USSD - Autonomous Secure Dollar",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Algo-Stables"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "18510",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "618",
      "title": "M-1: BalancerPairOracle#getPrice will revert due to division by zero in some cases",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/25 \n\n## Found by \n0x52, nobody2018\n## Summary\n\n`BalancerPairOracle#getPrice` internally calls `computeFairReserves`, which returns fair reserve amounts given spot reserves, weights, and fair prices. When the parameter `resA` passed to `computeFairReserves` is smaller than `resB`, division by 0 will occur.\n\n## Vulnerability Detail\n\nIn `BalancerPairOracle#getPrice`, resA and resB passed to `computeFairReserves` are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n\n```solidity\nfunction computeFairReserves(\n        uint256 resA,\n        uint256 resB,\n        uint256 wA,\n        uint256 wB,\n        uint256 pxA,\n        uint256 pxB\n    ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n    \t...\n    \t//@audit r0 = 0 when resA < resB.\n->      uint256 r0 = resA / resB;\n        uint256 r1 = (wA * pxB) / (wB * pxA);\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = r1 / r0;\n            fairResA = resA * (ratio ** wB);\n            fairResB = resB / (ratio ** wA);\n        } else {\n->          uint256 ratio = r0 / r1;\t\t// radio = 0 when r0 = 0\n->          fairResA = resA / (ratio ** wB);   \t// revert divided by 0\n            fairResB = resB * (ratio ** wA);\n        }\n    }\n```\n\nAnother case is **when the decimals of tokenA is smaller than the decimals of tokenB**, such as usdc(e6)-weth(e18).\n\n## Impact\n\nAll functions that subcall `BalancerPairOracle#getPrice` will be affected.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L35-L66\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n--- a/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n+++ b/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n@@ -50,7 +50,7 @@ contract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n         // --> fairResA / r1^wB = constant product\n         // --> fairResA = resA^wA * resB^wB * r1^wB\n         // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n-        uint256 r0 = resA / resB;\n+        uint256 r0 = resA * 10**(decimalsB) / resB;\n         uint256 r1 = (wA * pxB) / (wB * pxA);\n         // fairResA = resA * (r1 / r0) ^ wB\n         // fairResB = resB * (r0 / r1) ^ wA\n```\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is a valid M/H. Please review **Vulnerability Detail** of this report, it describes 2 cases:\n1. resA and resB passed to computeFairReserves are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n2. when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18).\n\n**This issue is same root as #28**.\nThe impact described in #28 is only possible if the dp of the two tokens are different. But it is not completely correct, because when the dp of token0 is less than the dp of token1, a division by zero error occurs, such as token0(e6)-token1(e18).\nMerging the two reports is the best description.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is a valid M/H. Please review **Vulnerability Detail** of this report, it describes 2 cases:\n> 1. resA and resB passed to computeFairReserves are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n> 2. when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18).\n> \n> **This issue is same root as #28**.\n> The impact described in #28 is only possible if the dp of the two tokens are different. But it is not completely correct, because when the dp of token0 is less than the dp of token1, a division by zero error occurs, such as token0(e6)-token1(e18).\n> Merging the two reports is the best description.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with escalation. This and #28 are dupes and this does a better job of describing the issue so it should be the main issue. Additionally given that the contract would become nonfunctional rather than return an incorrect price, I agree with the watson's original severity of medium.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nMaking this issue the main one and #28 a duplicate of this issue. \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Making this issue the main one and #28 a duplicate of this issue. \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue in BalancerPairOracle#getPrice which can cause a transaction to revert due to division by zero in some cases. It was found by 0x52 and nobody2018. \n\nThe issue is caused by the `computeFairReserves` function, which is called by `BalancerPairOracle#getPrice`. When the parameter `resA` passed to `computeFairReserves` is smaller than `resB`, division by 0 will occur. This is common for the balance of TokenB to be greater than the balance of TokenA. Another case is when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18). \n\nAll functions that subcall `BalancerPairOracle#getPrice` will be affected. The code snippet can be found at https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L35-L66. The tool used to find this bug was Manual Review. \n\nThe recommendation is to modify the code as follows:\n\n```diff\n--- a/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n+++ b/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n@@ -50,7 +50,7 @@ contract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n         // --> fairResA / r1^wB = constant product\n         // --> fairResA = resA^wA * resB^wB * r1^wB\n         // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n-        uint256 r0 = resA / resB;\n+        uint256 r0 = resA * 10**(decimalsB) / resB;\n         uint256 r1 = (wA * pxB) / (wB * pxA);\n         // fairResA = resA * (r1 / r0) ^",
      "report_date": {},
      "contest_prize_txt": "24000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/77",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 3,
      "general_score": 1,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/25",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "77",
      "slug": "m-1-balancerpairoraclegetprice-will-revert-due-to-division-by-zero-in-some-cases-sherlock-none-blueberry-update-2-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update #2",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update #2",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Missing-Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "20567",
      "kind": "MARKDOWN",
      "auditfirm_id": "16",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "964",
      "title": "[M-02] The ERC4626 standard is not followed correctly",
      "content": "**Impact:**\nMedium, as functionality is not working as expected but without a value loss\n\n**Likelihood:**\nMedium, as multiple methods are not compliant with the standard\n\n**Description**\n\nAs per EIP-4626, the `maxDeposit` method \"MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0.\". This is not the case currently, as even if the contract is paused, the `maxDeposit` method will still return what it usually does.\n\nWhen it comes to the `decimals` method, the EIP says: \"Although the convertTo functions should eliminate the need for any use of an EIP-4626 Vault’s decimals variable, it is still strongly recommended to mirror the underlying token’s decimals if at all possible, to eliminate possible sources of confusion and simplify integration across front-ends and for other off-chain users.\"\nThe `LoanVault` contract has hardcoded the value of 18 to be returned when `decimals` are called, but it should be the decimals of the underlying token (it might not be 18 in some case maybe).\n\n**Recommendations**\n\nGo through [the standard](https://eips.ethereum.org/EIPS/eip-4626) and follow it for all methods that `override` methods from the inherited ERC4626 implementation.",
      "summary": "\nThis bug report concerns two methods of the LoanVault contract, `maxDeposit` and `decimals`, which are not compliant with the Ethereum Improvement Proposal (EIP) 4626 standard. The `maxDeposit` method should return 0 if deposits are disabled, but currently it will still return a value. The `decimals` method should mirror the underlying token’s decimals, but it is currently hardcoded to return 18. \n\nThe impact of this bug is medium, as the functionality is not working as expected but without a value loss. The likelihood is also medium, as multiple methods are not compliant with the standard. The recommendation is to go through the EIP-4626 standard and follow it for all methods that override methods from the inherited ERC4626 implementation.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 2,
      "general_score": 2,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-04-01-Florence Finance.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "m-02-the-erc4626-standard-is-not-followed-correctly-pashov-none-florence-finance-markdown",
      "firm_name": "Pashov Audit Group",
      "firm_logo_square": "Pashov_square.png",
      "protocol_name": "Florence Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
      },
      "protocols_protocol": {
        "name": "Florence Finance",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-4626"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "7114",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 5,
      "protocol_id": "16",
      "title": "Loss of Long-Term Swap Proceeds Likely in Pools With Decimal or Price Imbalances",
      "content": "## Severity: High Risk\n\n## Context\n`VirtualOrders.sol#L166`\n\n## Description\nThis TWAMM implementation tracks the proceeds of long-term swaps efficiently via accumulated values called \"scaled proceeds\" for each token. In every order block interval (OBI), the scaled proceeds for e.g. the sale of token 0 are incremented by:\n\n```\n(quantity of token 1 purchased during the OBI) * 264 = (sales rate of token 0 during the OBI)\n```\n\nThen the proceeds of any specific long-term swap can be computed as the product of the difference between the scaled proceeds at the current block (or the expiration block of the order if filled) and the last block for which proceeds were claimed for the order and the order's sales rate, divided by 264:\n\n```\nlast := min(currentBlock, orderExpiryBlock)\nprev := block of last proceeds collection, or block order was placed in if this is the first withdrawal\nLT swap proceeds = (scaledProceeds[last] - scaledProceeds[prev]) * (order.salesRate) / 264\n```\n\nThe value 264 is referred to as the \"scaling factor\" and is intended to reduce precision loss in the division to determine the increment to the scaled proceeds.\n\nThe addition to increment the scaled proceeds and the subtraction to compute its net change is both intentionally done with unchecked arithmetic—since only the difference matters, so long as at most one overflow occurs between claim-of-proceeds events for any given order, the computed proceeds will be correct (up to rounding errors). If two or more overflows occur, however, funds will be lost by the swapper (unclaimable and locked in the contract).\n\nAdditionally, to cut down on gas costs, the scaled proceeds for the two tokens are packed into a single storage slot, so that only 128 bits are available for each value. This makes multiple overflows within the lifetime of a single order more likely. The CronFi team was aware of this at the start of the audit and specifically requested it be investigated, though they expected a maximum order length of 5 years to be sufficient to avoid the issue in practice.\n\nThe scaling factor of 264 is approximately 1.8 * 10^19, close to the unit size of an 18-decimal token. It indeed works well if both pool tokens have similar decimals and relative prices that do not differ by too many orders of magnitude, as the quantity purchased and the sales rate will then be of similar magnitude, canceling to within a few powers of ten (2^128 * 3.4 * 10^38, leaving around 19 orders of magnitude after accounting for the scaling factor). However, in pools with large disparities in price, decimals, or both, numerical issues are easy to encounter.\n\nThe most extreme, realistic example would be a DAI-GUSD pool. DAI has 18 decimals while GUSD has only 2. We will treat the price of DAI and GUSD as equal for this analysis, as they are both stablecoins, and arbitrage of the TWAMM pool should prevent large deviations. Selling GUSD at a rate of 1000 per block, with an OBI of 64 (the stable pool order block interval in the audited commit) results in an increment of the scaled proceeds per OBI of:\n\n```\nincrement = (64 * 1000 * 10^18) / 264 = (1000 * 10^2) = 1.18 * 10^37\n```\n\nThis will overflow an unsigned 128-bit integer after 29 OBIs; at 12 seconds per block, this means the first overflow occurs after 12 * 64 * 29 = 22272 seconds or about 6.2 hours, and thus the first double overflow (and hence irrevocable loss of proceeds if a withdrawal is not executed in time) will occur within about 12.4 hours (slightly but not meaningfully longer if the price is pushed a bit below 1:1, assuming a deep enough pool or reasonably efficient arbitrage). Since the TWAMM is intended to support swaps that take days, weeks, months, or even years to fill, without requiring constant vigilance from every long-term swapper, this is a strong violation of safety.\n\nA less extreme but more market-relevant example would be a DAI-WBTC pool. WBTC has 8 instead of 2 decimals, but it is also more than four orders of magnitude more valuable per token than DAI, making it only about 2 orders of magnitude \"safer\" than a DAI-GUSD pool. Imitating the above calculation with 20,000 DAI = 1 WBTC and selling...",
      "summary": "\nThis bug report is about a potential issue with VirtualOrders.sol, a part of the TWAMM implementation. It is a high risk issue and is present at line 166. This implementation tracks the proceeds of long-term swaps efficiently. In order to reduce precision loss, a scaling factor of 264 is used in the division to determine the increment to the scaled proceeds. This is done with unchecked arithmetic, which could lead to funds being lost if two or more overflows occur between claim-of-proceeds events for any given order. Additionally, the scaled proceeds for the two tokens are packed into a single storage slot, making multiple overflows within the lifetime of a single order more likely. \n\nThe scaling factor of 264 works well if both pool tokens have similar decimals and relative prices that do not differ by too many orders of magnitude. However, in pools with large disparities in price, decimals, or both, numerical issues are easy to encounter. An example is a DAI-GUSD pool, which has 18 decimals for DAI and 2 for GUSD. In this case, selling GUSD at a rate of 1000 per block, with an order block interval of 64, results in an increment of the scaled proceeds per OBI that is too large for the unsigned 128 bit integer, leading to an overflow after 29 OBIs. This means that the first double overflow, and hence irrevocable loss of proceeds, will occur within about 12.4 hours. This is a strong violation of safety, as the TWAMM is intended to support swaps that take days, weeks, months, or even years to fill.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/CronFinance-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/CronFinance-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/CronFinance-Spearbit-Security-Review.pdf",
      "pdf_page_from": 8,
      "contest_id": "",
      "slug": "loss-of-long-term-swap-proceeds-likely-in-pools-with-decimal-or-price-imbalances-spearbit-cron-finance-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Cron Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Cron Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Overflow/Underflow"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "6638",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "32",
      "title": "H-1: Too few `ICHI` v2 farming reward tokens transferred to the user due to incorrect decimal precision",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/319 \n\n## Found by \nberndartmueller, 0x52\n\n## Summary\n\nThe `burn` function in the `WIchiFarm` contract transfers too few `ICHI` **v2** farming reward tokens to the caller due to using 9 decimals instead of 18 decimals for the `ICHI` **v2** token.\n\n## Vulnerability Detail\n\nClosing an ICHI vault spell farming position burns the wrapped ICHI vault LP tokens (`WIchiFarm` ERC-1155 tokens). Farming rewards are harvested from the ICHI farm ([see contract on Etherscan](https://etherscan.io/address/0x275dfe03bc036257cd0a713ee819dbd4529739c8)) and received as `ICHI` **v1** tokens.\n\nThe `ICHI` **v1** ERC-20 token uses **9 decimals** ([see token on Etherscan](https://etherscan.io/token/0x903bEF1736CDdf2A537176cf3C64579C3867A881)), whereas the `ICHI` **v2** ERC-20 token uses **18 decimals** ([see token on Etherscan](https://etherscan.io/token/0x111111517e4929D3dcbdfa7CCe55d30d4B6BC4d6)).\n\nThose received `ICHI` **v1** tokens are then converted to **v2** tokens in line 134.\n\nTo calculate the user's share of eligible `ICHI` **v2** reward tokens, the reward per share accumulator `stIchiPerShare` at the time of minting the `WIchiFarm` token and the current `enIchiPerShare` accumulator is used.\n\nHowever, those accumulator values are in **9 decimals** precision (please see the `ichiFarmV2.harvest` function for proof that `pool.accIchiPerShare` uses 9 decimals, otherwise the `ICHI` token transfer would fail due to inflated `_pendingIchi`). Given that `amount` is in **18 decimals**, the calculation of `stIchi` and `enIchi` in lines 143 and 144 will result in a value with **9 decimals** precision.\n\nAs previously mentioned, the `ICHI` **v2** token uses **18 decimals**. Therefore, too few `ICHI` **v2** tokens are transferred.\n\n## Impact\n\nUsers will receive substantially fewer `ICHI` v2 farming reward tokens than expected.\n\n## Code Snippet\n\n[wrapper/WIchiFarm.sol#L143-L144](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/wrapper/WIchiFarm.sol#L143-L144)\n\n```solidity\n116: function burn(uint256 id, uint256 amount)\n117:     external\n118:     nonReentrant\n119:     returns (uint256)\n120: {\n121:     if (amount == type(uint256).max) {\n122:         amount = balanceOf(msg.sender, id);\n123:     }\n124:     (uint256 pid, uint256 stIchiPerShare) = decodeId(id);\n125:     _burn(msg.sender, id, amount);\n126:\n127:     uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n128:     ichiFarm.harvest(pid, address(this));\n129:     ichiFarm.withdraw(pid, amount, address(this));\n130:\n131:     // Convert Legacy ICHI to ICHI v2\n132:     if (ichiRewards > 0) {\n133:         ICHIv1.safeApprove(address(ICHI), ichiRewards);\n134:         ICHI.convertToV2(ichiRewards);\n135:     }\n136:\n137:     // Transfer LP Tokens\n138:     address lpToken = ichiFarm.lpToken(pid);\n139:     IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n140:\n141:     // Transfer Reward Tokens\n142:     (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n143:     uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n144:     uint256 enIchi = (enIchiPerShare * amount) / 1e18; // @audit-info `enIchi` and `stIchi` are in 9 decimal precision\n145:\n146:     if (enIchi > stIchi) {\n147:         ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n148:     }\n149:     return pid;\n150: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider changing the denominator in lines 143 and 144 from `1e18` to `1e9` to use the required `18` decimals for the `ICHI` v2 token.",
      "summary": "\nThis bug report is regarding the `burn` function in the `WIchiFarm` contract, which transfers too few `ICHI` **v2** farming reward tokens to the caller due to using 9 decimals instead of 18 decimals for the `ICHI` **v2** token. The `burn` function is used when closing an ICHI vault spell farming position and burning the wrapped ICHI vault LP tokens (`WIchiFarm` ERC-1155 tokens). Farming rewards are harvested from the ICHI farm and received as `ICHI` **v1** tokens. \n\nThe `ICHI` **v1** ERC-20 token uses **9 decimals**, whereas the `ICHI` **v2** ERC-20 token uses **18 decimals**. Those received `ICHI` **v1** tokens are then converted to **v2** tokens in line 134. To calculate the user's share of eligible `ICHI` **v2** reward tokens, the reward per share accumulator `stIchiPerShare` at the time of minting the `WIchiFarm` token and the current `enIchiPerShare` accumulator is used.\n\nHowever, those accumulator values are in **9 decimals** precision and the `amount` is in **18 decimals**. This results in too few `ICHI` **v2** tokens being transferred. This means that users will receive substantially fewer `ICHI` v2 farming reward tokens than expected.\n\nThe recommendation is to change the denominator in lines 143 and 144 from `1e18` to `1e9` to use the required `18` decimals for the `ICHI` v2 token. The bug was found by berndartmueller, 0x52 and was reviewed manually.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/41",
      "sponsor_name": "Blueberry",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/319",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "41",
      "slug": "h-1-too-few-ichi-v2-farming-reward-tokens-transferred-to-the-user-due-to-incorrect-decimal-precision-sherlock-blueberry-blueberry-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        },
        {
          "tags_tag": {
            "title": "Configuration"
          }
        }
      ]
    },
    {
      "id": "7314",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 4,
      "protocol_id": "41",
      "title": "claim() will underflow and revert for all tokens without 18 decimals",
      "content": "## Severity\nMedium Risk\n\n## Context\nWithdrawProxy.sol#238-244\n\n## Description\nIn the `claim()` function, the amount to decrease the Y intercept of the vault is calculated as:\n\n```\n(s.expected - balance).mulWadDown(10**ERC20(asset()).decimals() - s.withdrawRatio)\n```\n\n`s.withdrawRatio` is represented as a WAD (18 decimals). As a result, using any token with a number of decimals under 17 (assuming the withdraw ratio is greater than 10%) will lead to an underflow and cause the function to revert.\n\nIn this situation, the token's decimals don't matter. They are captured in `s.expected` and `balance`, and are also the scale at which the vault's y-intercept is measured, so there's no need to adjust for them.\n\n**Note**: I know this isn't a risk in the current implementation, since it's WETH only, but since you are planning to generalize to accept all ERC20s, this is important.\n\n## Recommendation\n```solidity\nif (balance < s.expected) {\n    PublicVault(VAULT()).decreaseYIntercept(\n        (s.expected - balance).mulWadDown(\n            -10**ERC20(asset()).decimals() - s.withdrawRatio\n            + 1e18 - s.withdrawRatio\n        )\n    );\n}\n```",
      "summary": "\nThis bug report is about the \"claim()\" function in the WithdrawProxy.sol code. The issue is that if the number of decimals in the token is under 17 and the withdraw ratio is greater than 10%, it will lead to an underflow and cause the function to revert. The recommendation is to adjust the code to include a \"+ 1e18 - s.withdrawRatio\" to the calculation of the amount to decrease the Y intercept of the vault. This will ensure that the token's decimals don't matter and the vault's y-intercept is measured correctly. This bug report is important because the code is planned to be generalized to accept all ERC20s.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Astaria-Spearbit-Security-Review.pdf",
      "pdf_page_from": 35,
      "contest_id": "",
      "slug": "claim-will-underflow-and-revert-for-all-tokens-without-18-decimals-spearbit-astaria-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Astaria",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Astaria",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "6262",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 7,
      "protocol_id": "58",
      "title": "M-4: Deposit and withdraw to the vault with the wrong decimals of amount in contract `PerpDepository`",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/402 \n\n## Found by \nberndartmueller, yixxas, HollaDieWaldfee, Bahurum, rvierdiiev, duc, peanuts\n\n## Summary\nFunction `vault.deposit` and `vault.withdraw` of vault in contract `PerpDepository` need to be passed with the amount in raw decimal of tokens (is different from 18 in case using USDC, WBTC, ... as base and quote tokens). But some calls miss the conversion of decimals from 18 to token's decimal, and pass wrong decimals into them.\n## Vulnerability Detail\n* Function `vault.deposit` need to be passed the param amount in token's decimal (as same as `vault.withdraw`). You can see at function `_depositAsset` in contract PerpDepository.\n```solidity=\nfunction _depositAsset(uint256 amount) private {\n    netAssetDeposits += amount;\n    \n    IERC20(assetToken).approve(address(vault), amount);\n    vault.deposit(assetToken, amount);\n}\n```\n* But there are some calls of `vault.deposit` and `vault.withdraw` that passed the amount in the wrong decimal (18 decimal).\nLet's see function `_rebalanceNegativePnlWithSwap` in contract PerpDepository:\n```solidity=\nfunction _rebalanceNegativePnlWithSwap(\n    uint256 amount,\n    uint256 amountOutMinimum,\n    uint160 sqrtPriceLimitX96,\n    uint24 swapPoolFee,\n    address account\n) private returns (uint256, uint256) {\n    ...\n    (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n        normalizedAmount,\n        isShort,\n        amountIsInput,\n        sqrtPriceLimitX96\n    );\n    vault.withdraw(assetToken, baseAmount); \n    \n    ...\n    \n    vault.deposit(quoteToken, quoteAmount);\n\n    emit Rebalanced(baseAmount, quoteAmount, shortFall);\n    return (baseAmount, quoteAmount);\n}\n```\nBecause function `_placePerpOrder` returns in decimal 18 (confirmed with sponsor WarTech), this calls pass `baseAmount` and `quoteAmount` in decimal 18, inconsistent with the above call. It leads to vault using the wrong decimal when depositing and withdrawing tokens.\n* There is  another case that use `vault.withdraw` with the wrong decimal (same as this case) in function `_rebalanceNegativePnlLite`:\n```solidity=\n//function _rebalanceNegativePnlLite, contract PerpDepository\n...\n\n(uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n    normalizedAmount,\n    isShort,\n    amountIsInput,\n    sqrtPriceLimitX96\n);\nvault.withdraw(assetToken, baseAmount);\n\n...\n```\n## Impact\nBecause of calling `vault.deposit` and `vault.withdraw` with the wrong decimal of the param amount, the protocol can lose a lot of funds. And some functionalities of the protocol can be broken cause it can revert by not enough allowance when calling these functions.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L498\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L524\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L638\n## Tool used\n\nManual Review\n\n## Recommendation\nShould convert the param `amount` from token's decimal to decimal 18 before `vault.deposit` and `vault.withdraw`.\n\n## Discussion\n\n**WarTech9**\n\n~~`amount` is always in the unit of the token being deposited so no normalization required.~~\n\n**hrishibhat**\n\n@WarTech9 just confirming that your comment is applicable to all the duplicates  tagged here. Right?\n\n**WarTech9**\n\nAfter further review this issue is valid. `quoteAmount` should be converted to `quoteDecimals` before `vault.deposit()` in `_rebalanceNegativePnlWithSwap()`\n\n**WarTech9**\n\nIssue exists in `_rebalanceNegativePnlWithSwap()` before `vault.deposit()`. Need to convert from 18 decimals to 6 for USDC.\nIssue does not exist in `_rebalanceNegativePnlLite` where amount returned by `_placePerpOrder()` is already in 18 decimals. So no conversion required before `vault.withdraw()`.",
      "summary": "\nThis bug report is about the function `vault.deposit` and `vault.withdraw` of vault in contract `PerpDepository` which need to be passed with the amount in raw decimal of tokens (which is different from 18 in case using USDC, WBTC, ... as base and quote tokens). However, some calls miss the conversion of decimals from 18 to token's decimal, and pass wrong decimals into them. This results in the protocol losing a lot of funds and some functionalities of the protocol being broken due to not enough allowance when calling these functions.\n\nThe issue has been found by berndartmueller, yixxas, HollaDieWaldfee, Bahurum, rvierdiiev, duc, and peanuts. It exists in `_rebalanceNegativePnlWithSwap()` before `vault.deposit()` and needs to be converted from 18 decimals to 6 for USDC. The issue does not exist in `_rebalanceNegativePnlLite` where amount returned by `_placePerpOrder()` is already in 18 decimals. So no conversion required before `vault.withdraw()`.\n\nThe code snippets for the issue can be found at https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L498, https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L524, and https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L638. The tool used to identify the issue is Manual Review.\n\nThe recommendation to fix the issue is to convert the param `amount` from token's decimal to decimal 18 before `vault.deposit` and `vault.withdraw`.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/33",
      "sponsor_name": "UXD",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/402",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "33",
      "slug": "m-4-deposit-and-withdraw-to-the-vault-with-the-wrong-decimals-of-amount-in-contract-perpdepository-sherlock-uxd-uxd-protocol-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "UXD Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "UXD Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Derivatives"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "18846",
      "kind": "MARKDOWN",
      "auditfirm_id": "13",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "840",
      "title": "TRST-M-1 multiplication overflow in getPoolPrice() likely",
      "content": "**Description:**\n`getPoolPrice()` is used in hedgeDelta to get the price directly from Uniswap v3 pool:\n```solidity \n    function getPoolPrice() public view returns (uint256 price, uint256 \n         inversed){\n            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        uint256 p = uint256(sqrtPriceX96) * uint256(sqrtPriceX96) * (10 \n        ** token0.decimals());\n     // token0/token1 in 1e18 format\n          price = p / (2 ** 192);\n              inversed = 1e36 / price;\n         }\n\n```\nThe issue is that calculation of p is likely to overflow. sqrtPriceX96 has 96 bits for decimals, \n10** `token0.decimals()` will have 60 bits when decimals is 18, therefore there is only \n(256 – 2 * 96 – 60) / 2 = 2 bits for non-decimal part of sqrtPriceX96. \n\n**Recommended Mitigation:**\nConsider converting the sqrtPrice to a 60x18 format and performing arithmetic operations \nusing the PRBMathUD60x18 library.\n\n**Team Response:**\nFixed\n\n**Mitigation Review**\nCalculations are now performed safely using the standard FullMath library",
      "summary": "\nThis bug report is regarding the `getPoolPrice()` function used in hedgeDelta. The issue is that calculation of p is likely to overflow, as sqrtPriceX96 has 96 bits for decimals, and 10** `token0.decimals()` will have 60 bits when decimals is 18, leaving only 2 bits for non-decimal part of sqrtPriceX96. \n\nThe recommended mitigation was to consider converting the sqrtPrice to a 60x18 format and performing arithmetic operations using the PRBMathUD60x18 library. The team response was that the issue was fixed and calculations are now performed safely using the standard FullMath library.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2022-12-23-rysk UniswapV3RangeOrderReactor.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "trst-m-1-multiplication-overflow-in-getpoolprice-likely-trust-security-none-rysk-uniswapv3rangeorderreactor-markdown_",
      "firm_name": "Trust Security",
      "firm_logo_square": "Trust_Security_square.png",
      "protocol_name": "Rysk Uniswapv3Rangeorderreactor",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Trust Security",
        "logo_square": "Trust_Security_square.png"
      },
      "protocols_protocol": {
        "name": "Rysk Uniswapv3Rangeorderreactor",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Uniswap"
          }
        },
        {
          "tags_tag": {
            "title": "Overflow/Underflow"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "6100",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 11,
      "protocol_id": "76",
      "title": "[M-02] Price will not always be 18 decimals, as expected and outlined in the comments",
      "content": "\nThe `price()` function is expected to return the price of one fractional tokens, represented in base tokens, to 18 decimals of precision. This is laid out clearly in the comments:\n\n`/// @notice The current price of one fractional token in base tokens with 18 decimals of precision.`<br>\n`/// @dev Calculated by dividing the base token reserves by the fractional token reserves.`<br>\n`/// @return price The price of one fractional token in base tokens * 1e18.`<br>\n\n\nHowever, the formula incorrectly calculates the price to be represented in whatever number of decimals the base token is in. Since there are many common base tokens (such as USDC) that will have fewer than 18 decimals, this will create a large mismatch between expected prices and the prices that result from the function.\n\n### Proof of Concept\n\nPrices are calculated with the following formula, where `ONE = 1e18`:\n\n```solidity\nreturn (_baseTokenReserves() * ONE) / fractionalTokenReserves();\n```\n\nWe know that `fractionalTokenReserves` will always be represented in 18 decimals. This means that the `ONE` and the\n`fractionalTokenReserves` will cancel each other out, and we are left with the `baseTokenReserves` number of decimals for the final price.\n\nAs an example:\n\n*   We have `$1000` USDC in reserves, which at 6 decimals is 1e9\n*   We have 1000 fractional tokens in reserve, which at 18 decimals is 1e21\n*   The price calculation is `1e9 * 1e18 / 1e21 = 1e6`\n*   While the value should be 1 token, the 1e6 will be interpreted as just 1/1e12 tokens if we expect the price to be in 1e18\n\n### Recommended Mitigation Steps\n\nThe formula should use the decimals value of the `baseToken` to ensure that the decimals of the resulting price ends up with 18 decimals as expected:\n\n```solidity\nreturn (_baseTokenReserves() * 10 ** (36 - ERC20(baseToken).decimals()) / fractionalTokenReserves();\n```\n\nThis will multiple `baseTokenReserves` by 1e18, and then additionally by the gap between 1e18 and its own decimals count, which will result in the correct decimals value for the outputted price.\n\n**[outdoteth (Caviar) confirmed and commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/141#issuecomment-1373910029):**\n > Fixed in: https://github.com/outdoteth/caviar/pull/5\n> \n> Always ensure that the exponent is 18 greater than the denominator. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an incorrect calculation of the price in the `price()` function of the Pair.sol source code. The function is expected to return the price of one fractional token in base tokens with 18 decimals of precision, but instead it returns a price with the number of decimals of the base token, which is usually fewer than 18. This creates a mismatch between expected prices and the prices that result from the function.\n\nThe incorrect formula used in the code is `return (_baseTokenReserves() * ONE) / fractionalTokenReserves();`, where `ONE = 1e18`. Since `fractionalTokenReserves` is always represented in 18 decimals, the `ONE` and the `fractionalTokenReserves` cancel each other out, and the final price is represented in the number of decimals of the `baseTokenReserves`. As an example, if the `baseTokenReserves` is $1000 USDC (1e9) and the `fractionalTokenReserves` is 1000 tokens (1e21), the price calculation is `1e9 * 1e18 / 1e21 = 1e6`, while the value should be 1 token. \n\nThe recommended mitigation step is to use the decimals value of the `baseToken` in the formula to ensure that the decimals of the resulting price ends up with 18 decimals as expected: `return (_baseTokenReserves() * 10 ** (36 - ERC20(baseToken).decimals()) / fractionalTokenReserves();`. This will multiple `baseTokenReserves` by 1e18, and then additionally by the gap between 1e18 and its own decimals count, which will result in the correct decimals value for the outputted price.",
      "report_date": {},
      "contest_prize_txt": "$36,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-12-caviar-contest",
      "sponsor_name": "Caviar",
      "sponsor_link": "https://twitter.com/caviarAMM",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/141",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "193",
      "slug": "m-02-price-will-not-always-be-18-decimals-as-expected-and-outlined-in-the-comments-code4rena-caviar-caviar-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Caviar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Caviar",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "6349",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 17,
      "protocol_id": "78",
      "title": "[M-19] _handleDeposit and _handleWithdraw do not account for tokens with decimals higher than 18",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L650\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L675\n\n\n## Vulnerability details\n\n## Impact \n\nIn `Trading.sol` a [deposit](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L675) or [withdrawal](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L700) of tokens with decimals higher than 18 will always revert. \n\nThis is the case e.g. for `NEAR` which is divisible into 10e24 `yocto` \n\n## Proof of Concept\n\nChange [00.Mocks.js#L33](https://github.com/code-423n4/2022-12-tigris/blob/main/deploy/test/00.Mocks.js#L33) to:\n\n```\nargs: [\"USDC\", \"USDC\", 24, deployer, ethers.utils.parseUnits(\"1000\", 24)]\n```\n\nThen in [07.Trading.js](https://github.com/code-423n4/2022-12-tigris/blob/main/test/07.Trading.js):\n\n```\nOpening and closing a position with tigUSD output\nOpening and closing a position with <18 decimal token output\n```\n\nare going to fail with:\n```\nError: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)\n```\n\n## Tools Used\n\nVisual Studio Code\n\n## Recommended Mitigation Steps\n\nUpdate calculations in the contract to account for tokens with decimals higher than 18.",
      "summary": "\nThis bug report is about a vulnerability in the Trading.sol contract. This vulnerability can cause a deposit or withdrawal of tokens with decimals higher than 18 to always revert. This can be demonstrated by changing the 00.Mocks.js file and running the 07.Trading.js test. This will result in an error that says \"Arithmetic operation underflowed or overflowed outside of an unchecked block\". To fix this vulnerability, calculations in the contract should be updated to account for tokens with decimals higher than 18.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
      "sponsor_name": "Tigris Trade",
      "sponsor_link": "https://twitter.com/TigrisTrades",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/533",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "192",
      "slug": "m-19-_handledeposit-and-_handlewithdraw-do-not-account-for-tokens-with-decimals-higher-than-18-code4rena-tigris-trade-tigris-trade-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Tigris Trade",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Tigris Trade",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Derivatives"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Algo-Stables"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "5692",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "81",
      "title": "H-9: Swapping 100 tokens in DepositReceipt_ETH and DepositReciept_USDC breaks usage of WBTC LP and other high value tokens",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/46 \n\n## Found by \nclems4ever, 0x52\n\n## Summary\n\nDepositReceipt_ETH and DepositReciept_USDC checks the value of liquidity by swapping 100 tokens through the swap router. WBTC is a good example of a token that will likely never work as LP due to the massive value of swapping 100 WBTC. This makes DepositReceipt_ETH and DepositReciept_USDC revert during slippage checks after calculating amount out. As of the time of writing this, WETH also experiences a 11% slippage when trading 100 tokens. Since DepositReceipt_ETH only supports 18 decimal tokens, WETH/USDC would have to use DepositReciept_USDC, resulting in WETH/USDC being incompatible. The fluctuating liquidity could also make this a big issue as well. If liquidity reduces after deposits are made, user deposits could be permanently trapped. \n\n## Vulnerability Detail\n\n        //check swap value of 100tokens to USDC to protect against flash loan attacks\n        uint256 amountOut; //amount received by trade\n        bool stablePool; //if the traded pool is stable or volatile.\n        (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n\nThe above lines try to swap 100 tokens from token1 to USDC. In the case of WBTC 100 tokens is a monstrous amount to swap. Given the low liquidity on the network, it simply won't function due to slippage requirements.\n\n    function _priceCollateral(IDepositReceipt depositReceipt, uint256 _NFTId) internal view returns(uint256){  \n        uint256 pooledTokens = depositReceipt.pooledTokens(_NFTId);      \n        return( depositReceipt.priceLiquidity(pooledTokens));\n    }\n\n    function totalCollateralValue(address _collateralAddress, address _owner) public view returns(uint256){\n        NFTids memory userNFTs = loanNFTids[_collateralAddress][_owner];\n        IDepositReceipt depositReceipt = IDepositReceipt(_collateralAddress);\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 totalPooledTokens;\n        for(uint256 i =0; i < NFT_LIMIT; i++){\n            //check if each slot contains an NFT\n            if (userNFTs.ids[i] != 0){\n                totalPooledTokens += depositReceipt.pooledTokens(userNFTs.ids[i]);\n            }\n        }\n        return(depositReceipt.priceLiquidity(totalPooledTokens));\n    }\n\nOne of the two functions above are used to price LP for every vault action on Vault_Velo. If liquidity is sufficient when user deposits but then drys up after, the users deposit would be permanently trapped in the in the vault. In addition to this liquidation would also become impossible causing the protocol to assume bad debt.\n\nThis could also be exploited by a malicious user. First they deposit a large amount of collateral into the Velodrome WBTC/USDC pair. They take a portion of their LP and take a loan against it. Now they withdraw the rest of their LP. Since there is no longer enough liquidity to swap 100 tokens with 5% slippage, they are now safe from liquidation, allowing a risk free loan.\n\n## Impact\n\nLPs that contain high value tokens will be unusable at best and freeze user funds or be abused at the worst case\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol#L93-L152\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L75-L130\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the number of tokens to an immutable, so that it can be set individually for each token. Optionally you can add checks (shown below) to make sure that the number of tokens being swapped will result in at least some minimum value of USDC is received. Similar changes should be made for DepositReceipt_ETH:\n\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                uint256 _tokensToSwap,\n                bool _stable,\n                address _priceFeed) \n                ERC721(_name, _symbol){\n\n        ...\n\n        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n\n    +       (amountOut,) = _router.getAmountOut(_tokensToSwap, token1, USDC);\n\n    +       //swapping tokens must yield at least 100 USDC\n    +       require( amountOut >= 1e8);\n    +       tokensToSwap = _tokensToSwap;\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            require( keccak256(token1Symbol) == keccak256(USDCSymbol), \"One token must be USDC\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n    +       (amountOut, ) = _router.getAmountOut(_tokensToSwap, token0, USDC);\n\n    +       //swapping tokens must yield at least 100 USDC\n    +       require( amountOut >= 1e8);\n    +       tokensToSwap = _tokensToSwap;\n        }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/76bb63d885759825d93e95925364806168d02e51\n\nBoth DepositReceipts have had the swap quantity changed to an immutable. DepositReceipt_USDC contains further checks to ensure the swap quantity would receive between 100 and 105 USDC on deployment so we know it is the right scale. This check could also be done with DepositReceipt_ETH but because the value of ETH is dynamic it would be a little more complex so instead we just included a non-zero value check. \n\nSorry, corrected a mistake with still using the `HUNDRED` constant for scaling this trade\nhttps://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/d8e7651f44a4cee07d23c00aa6ee612e25879771",
      "summary": "\nThis bug report is about DepositReceipt_ETH and DepositReciept_USDC, which are smart contracts used to check the value of liquidity. These contracts check the value by swapping 100 tokens through the swap router. However, for tokens with high value such as WBTC, swapping 100 tokens is a monstrous amount and may not be possible due to slippage requirements. This could lead to user deposits being trapped and liquidation becoming impossible, causing the protocol to assume bad debt. It can also be exploited by malicious users to take a risk free loan. \n\nThe code snippets provided in the report show the functions used to price LP for every vault action on Vault_Velo. The recommendation section suggests changing the number of tokens to an immutable, so that it can be set individually for each token. Additionally, checks can be added to make sure that the number of tokens being swapped will result in at least some minimum value of USDC is received. \n\nThe sponsor confirmed the bug and has since fixed it. The fixes include changing the swap quantity to an immutable and adding checks to ensure the swap quantity would receive between 100 and 105 USDC on deployment.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/22",
      "sponsor_name": "Isomorph",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 2,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/46",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "22",
      "slug": "h-9-swapping-100-tokens-in-depositreceipt_eth-and-depositreciept_usdc-breaks-usage-of-wbtc-lp-and-other-high-value-tokens-sherlock-isomorph-isomorph-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Isomorph",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Isomorph",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Privacy"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        },
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        }
      ]
    },
    {
      "id": "5663",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "83",
      "title": "M-3: The rather harsh requirement of `tokenAmount` makes it inapplicable for certain tokens",
      "content": "Source: https://github.com/sherlock-audit/2022-11-nounsdao-judging/issues/63 \n\n## Found by \nWATCHPUG, rvierdiiev\n\n## Summary\n\nThe requirements for `tokenAmount >= stopTime - startTime` will not be suitable for all tokens and therefore need to be made less applicable for certain tokens like WBTC and EURS.\n\n## Vulnerability Detail\n\nRequiring the `tokenAmount >= stopTime - startTime` is suitable for USDC and WETH.\n\nHowever, such requirements will be a bit too harsh for other popular tokens, eg, WBTC (`decimals: 8`) and EURS (`decimals: 2`). Therefore, make the system less applicable for those tokens.\n\nFor WBTC, it must be `0.31536 WBTC` per year (worth about $5,400) to meet this requirement, and for EURS, it must be at least `315,360 EURS` per year (worth about $315,000).\n\n## Impact\n\nThe system will be inapplicable for certain tokens with higher per wei value, eg, WBTC and EURS.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-nounsdao/blob/main/src/StreamFactory.sol#L200\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider changing to `tokenAmount * RATE_DECIMALS_MULTIPLIER >= stopTime - startTime`.\n\n## Discussion\n\n**eladmallel**\n\nFix PR: https://github.com/nounsDAO/streamer/pull/12",
      "summary": "\nThis bug report is about the requirement of `tokenAmount` which makes it inapplicable for certain tokens like WBTC and EURS. The requirement of `tokenAmount >= stopTime - startTime` is suitable for USDC and WETH, but it is too harsh for tokens with higher per wei value, such as WBTC and EURS. To meet this requirement, it must be `0.31536 WBTC` per year (worth about $5,400) and `315,360 EURS` per year (worth about $315,000). This will make the system inapplicable for certain tokens with higher per wei value. The recommendation is to change to `tokenAmount * RATE_DECIMALS_MULTIPLIER >= stopTime - startTime`. A fix PR has been submitted and is available at https://github.com/nounsDAO/streamer/pull/12.",
      "report_date": {},
      "contest_prize_txt": "10000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/27",
      "sponsor_name": "Nouns",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-nounsdao-judging/issues/63",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "27",
      "slug": "m-3-the-rather-harsh-requirement-of-tokenamount-makes-it-inapplicable-for-certain-tokens-sherlock-nouns-nounsdao-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "NounsDAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "NounsDAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "5646",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "92",
      "title": "H-1: debtToMint incorrectly treats feeAdjustment decimals",
      "content": "Source: https://github.com/sherlock-audit/2022-11-opyn-judging/issues/236 \n\n## Found by \nkeccak123, hyh\n\n## Summary\n\n_debtToMint() will return `0` decimals amounts and `sqthToSell` in depositAuction() will be insignificant, leading to ignoring the market orders used and depositing auction to be void as no external funding will be brought in.\n\n## Vulnerability Detail\n\n`feeAdjustment = _calcFeeAdjustment()` is `(squeethEthPrice * feeRate) / 10000` and have `18` decimals.\n\n`wSqueethToMint = (_amount * debt) / (collateral + (debt * feeAdjustment))` will have `36` decimals in numerator and the same `36` in denominator, yielding `0` decimals figure. That figure is `sqthToSell`, so no market buying orders will be ever filled.\n\n## Impact\n\ndepositAuction() will malfunction all the time, either reverting or producing less WETH and less CRAB than desired, i.e. there will be no deposit auction as market order part is needed to bring in the liquidity to be distributed.\n\nSetting the severity to be high as this is system malfunction with material impact and no prerequisites.\n\n## Code Snippet\n\nfeeAdjustment is treated as if it has no decimals:\n\nhttps://github.com/sherlock-audit/2022-11-opyn/blob/main/crab-netting/src/CrabNetting.sol#L476-L485\n\n```solidity\n    /**\n     * @dev calculates wSqueeth minted when amount is deposited\n     * @param _amount to deposit into crab\n     */\n    function _debtToMint(uint256 _amount) internal view returns (uint256) {\n        uint256 feeAdjustment = _calcFeeAdjustment();\n        (,, uint256 collateral, uint256 debt) = ICrabStrategyV2(crab).getVaultDetails();\n        uint256 wSqueethToMint = (_amount * debt) / (collateral + (debt * feeAdjustment));\n        return wSqueethToMint;\n    }\n```\n\nwhile it has 18 decimals:\n\nhttps://github.com/sherlock-audit/2022-11-opyn/blob/main/crab-netting/src/CrabNetting.sol#L795-L800\n\n```solidity\n    function _calcFeeAdjustment() internal view returns (uint256) {\n        uint256 feeRate = IController(sqthController).feeRate();\n        if (feeRate == 0) return 0;\n        uint256 squeethEthPrice = IOracle(oracle).getTwap(ethSqueethPool, sqth, weth, sqthTwapPeriod, true);\n        return (squeethEthPrice * feeRate) / 10000;\n    }\n```\n\nAs `sqthToSell` to be insignificant, there will be no Squeeth selling at all:\n\nhttps://github.com/sherlock-audit/2022-11-opyn/blob/main/crab-netting/src/CrabNetting.sol#L491-L504\n\n```solidity\n    function depositAuction(DepositAuctionParams calldata _p) external onlyOwner {\n        _checkOTCPrice(_p.clearingPrice, false);\n        /**\n         * step 1: get eth from mm\n         *     step 2: get eth from deposit usdc\n         *     step 3: crab deposit\n         *     step 4: flash deposit\n         *     step 5: send sqth to mms\n         *     step 6: send crab to depositors\n         */\n        uint256 initCrabBalance = IERC20(crab).balanceOf(address(this));\n        uint256 initEthBalance = address(this).balance;\n\n        uint256 sqthToSell = _debtToMint(_p.totalDeposit);\n```\n\nThis renders sqth buying orders block void, i.e. it will be always `_p.orders[0].quantity >= remainingToSell`:\n\nhttps://github.com/sherlock-audit/2022-11-opyn/blob/main/crab-netting/src/CrabNetting.sol#L504-L524\n\n```solidity\n        uint256 sqthToSell = _debtToMint(_p.totalDeposit);\n        // step 1 get all the eth in\n        uint256 remainingToSell = sqthToSell;\n        for (uint256 i = 0; i < _p.orders.length; i++) {\n            require(_p.orders[i].isBuying, \"auction order not buying sqth\");\n            require(_p.orders[i].price >= _p.clearingPrice, \"buy order price less than clearing\");\n            _checkOrder(_p.orders[i]);\n            if (_p.orders[i].quantity >= remainingToSell) {\n                IWETH(weth).transferFrom(\n                    _p.orders[i].trader, address(this), (remainingToSell * _p.clearingPrice) / 1e18\n                );\n                remainingToSell = 0;\n                break;\n            } else {\n                IWETH(weth).transferFrom(\n                    _p.orders[i].trader, address(this), (_p.orders[i].quantity * _p.clearingPrice) / 1e18\n                );\n                remainingToSell -= _p.orders[i].quantity;\n            }\n        }\n        require(remainingToSell == 0, \"not enough buy orders for sqth\");\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding decimals treatment, for example:\n\nhttps://github.com/sherlock-audit/2022-11-opyn/blob/main/crab-netting/src/CrabNetting.sol#L476-L485\n\n```solidity\n    /**\n     * @dev calculates wSqueeth minted when amount is deposited\n     * @param _amount to deposit into crab\n     */\n    function _debtToMint(uint256 _amount) internal view returns (uint256) {\n        uint256 feeAdjustment = _calcFeeAdjustment();\n        (,, uint256 collateral, uint256 debt) = ICrabStrategyV2(crab).getVaultDetails();\n-       uint256 wSqueethToMint = (_amount * debt) / (collateral + (debt * feeAdjustment));\n+       uint256 wSqueethToMint = (_amount * debt) / (collateral + (debt * feeAdjustment) / 1e18);\n        return wSqueethToMint;\n    }\n```\n\n## Discussion\n\n**thec00n**\n\nNice find. Fix lgtm.",
      "summary": "\nIssue H-1 is a bug in the debtToMint() function in the CrabNetting.sol contract which is part of the Opyn protocol. It was discovered by keccak123 and hyh. The bug is caused by the fact that feeAdjustment is not treated correctly and has 18 decimals, causing the calculation of wSqueethToMint to return a 0 decimals figure. This will lead to the depositAuction() function malfunctioning, either reverting or producing less WETH and less CRAB than desired. This will result in no deposit auction as the market order part is needed to bring in the liquidity to be distributed.\n\nThe severity of this bug is set to high as it is a system malfunction with a material impact and no prerequisites. The code snippet which is causing the bug is as follows: \n\n```solidity\n    /**\n     * @dev calculates wSqueeth minted when amount is deposited\n     * @param _amount to deposit into crab\n     */\n    function _debtToMint(uint256 _amount) internal view returns (uint256) {\n        uint256 feeAdjustment = _calcFeeAdjustment();\n        (,, uint256 collateral, uint256 debt) = ICrabStrategyV2(crab).getVaultDetails();\n        uint256 wSqueethToMint = (_amount * debt) / (collateral + (debt * feeAdjustment));\n        return wSqueethToMint;\n    }\n```\n\nThe recommended fix for this bug is to add decimals treatment, as follows: \n\n```solidity\n    /**\n     * @dev calculates wSqueeth minted when amount is deposited\n     * @param _amount to deposit into crab\n     */\n    function _debtToMint(uint256 _amount) internal view returns (uint256) {\n        uint256 feeAdjustment = _calcFeeAdjustment();\n        (,, uint256 collateral, uint256 debt) = ICrabStrategyV2(crab).getVaultDetails();\n-       uint256 wSqueethToMint = (_amount * debt) / (collateral + (debt * feeAdjustment));\n+       uint256 wSqueethToMint =",
      "report_date": {},
      "contest_prize_txt": "25000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/26",
      "sponsor_name": "Opyn",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-opyn-judging/issues/236",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "26",
      "slug": "h-1-debttomint-incorrectly-treats-feeadjustment-decimals-sherlock-opyn-opyn-crab-netting-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Opyn Crab Netting",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Opyn Crab Netting",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "3515",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "104",
      "title": "M-3: WithdrawPeriphery#_convertToToken slippage control is broken for any token other than USDC",
      "content": "Source: https://github.com/sherlock-audit/2022-10-rage-trade-judging/issues/55 \n\n## Found by \n0x52\n\n## Summary\n\nWithdrawPeriphery allows the user to redeem junior share vaults to any token available on GMX, applying a fixed slippage threshold to all redeems. The slippage calculation always returns the number of tokens to 6 decimals. This works fine for USDC but for other tokens like WETH or WBTC that are 18 decimals the slippage protection is completely ineffective and can lead to loss of funds for users that are withdrawing.\n\n## Vulnerability Detail\n\n    function _convertToToken(address token, address receiver) internal returns (uint256 amountOut) {\n        // this value should be whatever glp is received by calling withdraw/redeem to junior vault\n        uint256 outputGlp = fsGlp.balanceOf(address(this));\n\n        // using min price of glp because giving in glp\n        uint256 glpPrice = _getGlpPrice(false);\n\n        // using max price of token because taking token out of gmx\n        uint256 tokenPrice = gmxVault.getMaxPrice(token);\n\n        // apply slippage threshold on top of estimated output amount\n        uint256 minTokenOut = outputGlp.mulDiv(glpPrice * (MAX_BPS - slippageThreshold), tokenPrice * MAX_BPS);\n\n        // will revert if atleast minTokenOut is not received\n        amountOut = rewardRouter.unstakeAndRedeemGlp(address(token), outputGlp, minTokenOut, receiver);\n    }\n\nWithdrawPeriphery allows the user to redeem junior share vaults to any token available on GMX. To prevent users from losing large amounts of value to MEV the contract applies a fixed percentage slippage. minToken out is returned to 6 decimals regardless of the token being requested. This works for tokens with 6 decimals like USDC, but is completely ineffective for the majority of tokens that aren't.  \n\n## Impact\n\nUsers withdrawing tokens other than USDC can suffer huge loss of funds due to virtually no slippage protection\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-rage-trade/blob/main/dn-gmx-vaults/contracts/periphery/WithdrawPeriphery.sol#L147-L161\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdjust minTokenOut to match the decimals of the token:\n\n        uint256 minTokenOut = outputGlp.mulDiv(glpPrice * (MAX_BPS - slippageThreshold), tokenPrice * MAX_BPS);\n    +   minTokenOut = minTokenOut * 10 ** (token.decimals() - 6);\n\n## Discussion\n\n**0xDosa**\n\nAgreed on the issue but the severity level should be medium since loss of funds is not possible. While swapping on GMX, there is min-max spread and fees but no slippage due to them using chainlink oracles for pricing the tokens, so a direct sandwich attack would not work.\n\n**Evert0x**\n\nDowngrading to medium",
      "summary": "\nThis bug report is about an issue found in WithdrawPeriphery, a contract that allows users to redeem junior share vaults to any token available on GMX. A fixed percentage slippage is applied to prevent users from losing large amounts of value to MEV, but this slippage calculation always returns the number of tokens to 6 decimals regardless of the token being requested. This works for tokens with 6 decimals like USDC, but is ineffective for tokens with more than 6 decimals. This means users withdrawing tokens other than USDC can suffer huge loss of funds due to virtually no slippage protection.\n\nThe recommended solution is to adjust minTokenOut to match the decimals of the token, by adding a line of code to the existing code snippet. The severity level of this issue was discussed and ultimately downgraded from high to medium, since loss of funds is not possible due to chainlink oracles being used for pricing the tokens.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/16",
      "sponsor_name": "Rage Trade",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-rage-trade-judging/issues/55",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "16",
      "slug": "m-3-withdrawperiphery_converttotoken-slippage-control-is-broken-for-any-token-other-than-usdc-sherlock-rage-trade-rage-trade-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Rage Trade",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Rage Trade",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "USDC"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "5228",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 4,
      "protocol_id": "110",
      "title": "M-4: Protocol won't work with `USDC` even though it is a token specifically mentioned in the docs",
      "content": "Source: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/21 \n\n## Found by \npashov, ctf\\_sec, 0x52\n\n## Summary\nThe protocol has requirements for values (for example 1e18) that would be too big if used with a 6 decimals token like `USDC` - `USDC` is mentioned as a token that will be used in the docs\n## Vulnerability Detail\nFor the mint functionality, a user has to transfer at least 1e18 tokens so that he can mint pool tokens - `if (amount < 1e18) revert InvalidActionAmount(amount);`. If the `paymentToken` used was `USDC` (as pointed out in docs), this would mean he would have to contribute at least 1e12 USDC tokens (more than a billion) which would be pretty much impossible to do. There is also another such check in `MarketExtended::addPoolToExistingMarket` with `require(initialActualLiquidityForNewPool >= 1e12, \"Insufficient market seed\");` - both need huge amounts when using a low decimals token like USDC that has 6 decimals.\n\n## Impact\nThe protocol just wouldn't work at all in its current state when using a lower decimals token. Since such a token was mentioned in the docs I set this as a High severity issue.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketExtended.sol#L125\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L265\n## Tool used\n\nManual Review\n\n## Recommendation\nDrastically lower  the `require` checks so they can work with tokens with a low decimals count like `USDC`\n\n## Discussion\n\n**JasoonS**\n\nI feel really silly that I didn't think of that when I wrote the readme - we have spoken about it came up many times in the alpha version audit that we did last year. We have no intention of using USDC anytime soon. We have been using DAI exclusively. My mistake - I thought why not just have the option for insurance sake and mention USDC (since it is the only other token remotely likely that we might use).\n\nThis most certainly isn't `high` - it is in the constructor that we'd immediately notice that (of course as I mentioned we have been aware of this for a long time). The rest of the mechanism works with USDC - just those minimums will need to be adjusted.\n\nSo, \"_Bug in the readme?_\" I'd say this isn't a vulnerability at all!\n\nWe could fetch the `decimals` from the payment token on initialization, but honestly don't think the extra complexity is justified in our situation.\n\n\n**Evert0x**\n\nAs USDC was explicitly mentioned by the protocol we would like to reward this finding.",
      "summary": "\nThis bug report is about the protocol not working with USDC, a token specifically mentioned in the docs. It was found by pashov, ctf\\_sec, and 0x52. The issue is that the protocol requires values (such as 1e18) that are too large when used with a 6 decimals token like USDC, making it impossible to use. This issue was given a high severity as USDC was mentioned in the docs. The code snippets that were used to identify this issue can be found in the GitHub repository. The recommendation is to lower the require checks so they can work with tokens with a low decimals count like USDC. After discussion, it was decided that this was not a vulnerability and that the complexity of fetching the decimals from the payment token on initialization was not necessary. The finding was rewarded as USDC was explicitly mentioned by the protocol.",
      "report_date": {},
      "contest_prize_txt": "25000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/15",
      "sponsor_name": "Float Capital",
      "sponsor_link": "",
      "quality_score": 4.333333333333333,
      "general_score": 3,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/21",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "15",
      "slug": "m-4-protocol-wont-work-with-usdc-even-though-it-is-a-token-specifically-mentioned-in-the-docs-sherlock-float-capital-float-capital-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Float Capital",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Float Capital",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Derivatives"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "USDC"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "3721",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "114",
      "title": "H-9: Lender#lend for Sense has mismatched decimals",
      "content": "Source: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/164 \n\n## Found by \n0x52\n\n## Summary\n\nThe decimals of the Sense principal token don't match the decimals of the ERC5095 vault it mints shares to. This can be abused on the USDC market to mint a large number of shares to steal yield from all other users.\n\n## Vulnerability Detail\n\n        uint256 received;\n        {\n            // Get the starting balance of the principal token\n            uint256 starting = token.balanceOf(address(this));\n\n            // Swap those tokens for the principal tokens\n            ISensePeriphery(x).swapUnderlyingForPTs(adapter, s, lent, r);\n\n            // Calculate number of principal tokens received in the swap\n            received = token.balanceOf(address(this)) - starting;\n\n            // Verify that we received the principal tokens\n            if (received < r) {\n                revert Exception(11, 0, 0, address(0), address(0));\n            }\n        }\n\n        // Mint the Illuminate tokens based on the returned amount\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\nSense principal tokens for [DIA](https://etherscan.io/token/0x9c5edebb6fe50c9447828a30a2414c061c74cd77) and [USDC](https://etherscan.io/token/0xA5240A4a27817135E2aB30c8f1996a2d460C9Db4) are 8 decimals to match the decimals of the underlying cTokens, cUSDC and cDAI. The decimals of the ERC5095 vault matches the underlying of the vault. This creates a disparity in decimals that aren't adjusted for in Lender#lend for Sense, which assumes that the vault and Sense principal tokens match in decimals. In the example of USDC the ERC5095 will be 6 decimals but the sense token will be 8 decimals. Each 1e6 USDC token will result in ~1e8 Sense tokens being received. Since the contract mints based on the difference in the number of sense tokens before and after the call, it will mint ~100x the number of vault shares than it should. Since the final yield is distributed pro-rata to the number of shares, the user who minted with sense will be entitled to much more yield than they should be and everyone else will get substantially less.\n\n## Impact\n\nUser can mint large number of shares to steal funds from other users\n\n## Code Snippet\n\n[Lender.sol#L693-L741](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L693-L741)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nQuery the decimals of the Sense principal and use that to adjust the decimals to match the decimals of the vault.",
      "summary": "\nThis bug report is about the decimals mismatch of Sense principal token and the ERC5095 vault it mints shares to. It is found by 0x52 and can be exploited on the USDC market to mint a large number of shares and steal yield from other users. The code snippet responsible for this issue is present in Lender.sol#L693-L741. The tool used to find this issue is manual review. The recommendation to solve this issue is to query the decimals of the Sense principal and use that to adjust the decimals to match the decimals of the vault.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/12",
      "sponsor_name": "Swivel",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 2,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/164",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "12",
      "slug": "h-9-lenderlend-for-sense-has-mismatched-decimals-sherlock-swivel-illuminate-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Illuminate",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Illuminate",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "3715",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "114",
      "title": "H-3: Sense redeem is unavailable and funds are frozen for underlyings whose decimals are smaller than the corresponding IBT decimals",
      "content": "Source: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/228 \n\n## Found by \nhyh, 0x52\n\n## Summary\n\nSense version of Redeemer's redeem() compares `amount` of Sense principal token Lender had on its balance vs `redeemed` amount of underlying as a slippage check, requiring that the latter be equal or greater than the former.\n\nAs these numbers have different decimals this check blocks the redeem altogether for the tokens whose decimals are smaller than decimals of the corresponding interest bearing token, freezing the funds.\n\n## Vulnerability Detail\n\nSense version of redeem() assumes that Sense PT has the same decimals as underlying, performing slippage check by directly comparing the amounts.\n\nSense principal has decimals of the corresponding interest bearing tokens, not the decimals of the underlying. In the compound case IBT decimals are `8` and can be greater or less than underlying's.\n\nFor example, `1st July 2023 cUSDC Sense Principal Token` has `8` decimals, as cUSDC does (instead of 6 as USDC):\n\nhttps://etherscan.io/token/0x869a70c198c937801b26d2701dc8e4e8c4de354a\n\nIn this case the slippage check reverts the operation. Sense PT cannot be turned to underlying and will remain on Lender's balance this way.\n\nOn the other hand, when underlying decimals are greater than IBT decimals the slippage check becomes a noop.\n\n## Impact\n\nProtocol users can be subject to market manipulations as Sense AMM result isn't checked for the underlyings whose decimals are higher than decimals of the corresponding IBT, say in the cDAI (8) and DAI (18) case. I.e. sandwich attacks have high possibility in this case whenever amounts are big enough.\n\nSense redeem will be unavailable and funds frozen for the underlyings whose decimals are smaller than decimals of the corresponding IBT, say in the cUSDC (8) and USDC (6) case. \n\nAs without working redeem() the whole Sense PT funds be frozen for all the users as it deals with the cumulative holdings of the protocol, setting the severity to be high.\n\n## Code Snippet\n\nSense redeem() compares `amount` of Sense PT to `redeemed` amount of underlying in order to `Verify that underlying are received 1:1`:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L335-L394\n\n```solidity\n    /// @notice redeem method signature for Sense\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param s Sense's maturity is needed to extract the pt address\n    /// @param a Sense's adapter for this market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 s,\n        address a\n    ) external returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Get Sense's principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Cache the lender to save on SLOAD operations\n        address cachedLender = lender;\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(cachedLender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, cachedLender, address(this), amount);\n\n        // Get the starting balance to verify the amount received afterwards\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        ...\n\n        // Redeem the compounding token back to the underlying\n        IConverter(converter).convert(\n            compounding,\n            u,\n            IERC20(compounding).balanceOf(address(this))\n        );\n\n        // Get the amount received\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Verify that underlying are received 1:1 - cannot trust the adapter\n        if (redeemed < amount) {\n            revert Exception(13, 0, 0, address(0), address(0));\n        }\n\n        // Update the holdings for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n```\n\nThis way, for example, 8 decimals amount of `1st July 2023 cUSDC Sense Principal Token`, say `1e3*1e8` for `1000 PT`, is checked to be greater than `1e3*1e6` for `1000 USDC`, which basically is never true. Same holds for any Sense USDC PT.\n\nOn the other hand, for example DAI, having 18 decimals, will always pass this check as Sense cDAI PT has cDAI decimals of 8, for example (from https://docs.sense.finance/developers/deployed-contracts/):\n\nhttps://etherscan.io/token/0xcfA7B126c680007D0367d0286D995c6aEE53e087\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn order to verify `redeemed = IERC20(u).balanceOf(address(this)) - starting` vs initial `IERC20(IMarketPlace(marketPlace).token(u, m, p))`'s balance of Lender, consider introducing the decimals adjustment multiplier, i.e. read Sense PT decimals, underlying decimals, and multiply the smaller decimals amount to match the bigger decimals one in order to compare.",
      "summary": "\nThis bug report is about an issue in Sense's version of Redeemer's redeem() function. The issue is that the function compares the amount of Sense principal token Lender had on its balance with the amount of underlying asset as a slippage check, requiring that the latter be equal or greater than the former. This check, however, fails when the decimals of the underlying asset is smaller than the decimals of the corresponding interest bearing token. As a result, the redeem operation reverts and the funds are frozen for the users.\n\nThe vulnerability exists because Sense version of redeem() assumes that Sense PT has the same decimals as underlying and performs the slippage check by directly comparing the amounts. This is not true in cases where the decimals of the interest bearing token is greater than the decimals of the underlying asset, as is the case with cUSDC and USDC.\n\nThe impact of this issue is that protocol users can be subject to market manipulations as Sense AMM result isn't checked for the underlyings whose decimals are higher than decimals of the corresponding IBT, such as in the cDAI (8) and DAI (18) case. Furthermore, Sense redeem will be unavailable and funds frozen for the underlyings whose decimals are smaller than decimals of the corresponding IBT, such as in the cUSDC (8) and USDC (6) case. As without working redeem() the whole Sense PT funds be frozen for all the users, the severity of this issue is high.\n\nTo fix this issue, the developers should consider introducing the decimals adjustment multiplier. This would involve reading the Sense PT decimals, underlying decimals, and multiplying the smaller decimals amount to match the bigger decimals one in order to compare.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/12",
      "sponsor_name": "Swivel",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/228",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "12",
      "slug": "h-3-sense-redeem-is-unavailable-and-funds-are-frozen-for-underlyings-whose-decimals-are-smaller-than-the-corresponding-ibt-decimals-sherlock-swivel-illuminate-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Illuminate",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Illuminate",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "5744",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 15,
      "protocol_id": "126",
      "title": "[M-15] Oracle assumes token and feed decimals will be limited to 18 decimals",
      "content": "\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L87><br>\n<https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L121><br>\n\nThe `Oracle` contract normalizes prices in both `viewPrices` and `getPrices` functions to adjust for potential decimal differences between feed and token decimals and the expected return value.\n\nHowever these functions assume that `feedDecimals` and `tokenDecimals` won't exceed 18 since the normalization calculation is `36 - feedDecimals - tokenDecimals`, or that at worst case the sum of both won't exceed 36.\n\nThis assumption should be safe for certain cases, for example WETH is 18 decimals and the ETH/USD chainlink is 8 decimals, but may cause an overflow (and a revert) for the general case, rendering the Oracle useless in these cases.\n\n### Proof of Concept\n\nIf `feedDecimals + tokenDecimals > 36` then the expression `36 - feedDecimals - tokenDecimals` will be negative and (due to Solidity 0.8 default checked math) will cause a revert.\n\n### Recommended Mitigation Steps\n\nIn case `feedDecimals + tokenDecimals` exceeds 36, then the proper normalization procedure would be to **divide** the price by `10 ** decimals`. Something like this:\n\n    uint normalizedPrice;\n\n    if (feedDecimals + tokenDecimals > 36) {\n        uint decimals = feedDecimals + tokenDecimals - 36;\n        normalizedPrice = price / (10 ** decimals)\n    } else {\n        uint8 decimals = 36 - feedDecimals - tokenDecimals;\n        normalizedPrice = price * (10 ** decimals);\n    }\n\n**[08xmt (Inverse) confirmed and commented](https://github.com/code-423n4/2022-10-inverse-findings/issues/533#issuecomment-1351469171):**\n > Fixed in https://github.com/InverseFinance/FrontierV2/pull/25<br>\n> Also pretty sure this is a dupe\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the Oracle contract of the code-423n4/2022-10-inverse repository. The `viewPrices` and `getPrices` functions are used to normalize prices to adjust for potential decimal differences between feed and token decimals and the expected return value. \n\nThe bug is caused by an assumption that `feedDecimals` and `tokenDecimals` won't exceed 18, as the normalization calculation is `36 - feedDecimals - tokenDecimals`. This assumption is not safe for the general case, as it may cause an overflow (and a revert) if the sum of both is greater than 36, rendering the Oracle useless.\n\nA proof of concept has been provided to demonstrate the vulnerability. If `feedDecimals + tokenDecimals > 36` then the expression `36 - feedDecimals - tokenDecimals` will be negative and will cause a revert.\n\nThe recommended mitigation step is to divide the price by `10 ** decimals` if `feedDecimals + tokenDecimals` exceeds 36. This should be done in place of the current normalization procedure.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
      "sponsor_name": "Inverse Finance",
      "sponsor_link": "https://twitter.com/InverseFinance",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-inverse",
      "github_link": "https://github.com/code-423n4/2022-10-inverse-findings/issues/533",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "175",
      "slug": "m-15-oracle-assumes-token-and-feed-decimals-will-be-limited-to-18-decimals-code4rena-inverse-finance-inverse-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Inverse Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Inverse Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "5607",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "131",
      "title": "[M-14] PA1D#bidSharesForToken returns incorrect `bidShares.creator.value`",
      "content": "\n[PA1D.sol#L665-L675](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L665-L675)<br>\n\n`bidShares` returned are incorrect leading to incorrect royalties.\n\n### Proof of Concept\n\n[Zora Market](https://etherscan.io/address/0xe5bfab544eca83849c53464f85b7164375bdaac1#code#F1#L113)\n\n    function isValidBidShares(BidShares memory bidShares)\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return\n            bidShares.creator.value.add(bidShares.owner.value).add(\n                bidShares.prevOwner.value\n            ) == uint256(100).mul(Decimal.BASE);\n    }\n\nAbove you can see the Zora market lines that validate bidShares, which shows that Zora market bidShare.values should be percentages written out to 18 decimals. However PA1D#bidSharesForToken sets the bidShares.creator.value to the raw basis points set by the owner, which is many order of magnitudes different than expected.\n\n### Recommended Mitigation Steps\n\nTo return the proper value, basis points returned need to be adjusted. Convert from basis points to percentage by dividing by 10 &ast;&ast; 2 (100) then scale to 18 decimals. The final result it to multiple the basis point by 10 &ast;&ast; (18 - 2) or 10 &ast;&ast; 16:\n\n    function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {\n        // this information is outside of the scope of our\n        bidShares.prevOwner.value = 0;\n        bidShares.owner.value = 0;\n        if (_getReceiver(tokenId) == address(0)) {\n    -       bidShares.creator.value = _getDefaultBp();\n    +       bidShares.creator.value = _getDefaultBp() * (10 ** 16);\n        } else {\n    -       bidShares.creator.value = _getBp(tokenId);\n    +       bidShares.creator.value = _getBp(tokenId) * (10 ** 16);\n        }\n        return bidShares;\n    }\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/180#issuecomment-1307823222):**\n > Good catch! We'll implement the suggested solution.\n\n**[alexanderattar (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/180#ref-pullrequest-1469977783):**\n > [Feature/holo 612 royalty smart contract improvements](https://github.com/holographxyz/holograph-protocol/pull/93)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about incorrect royalties being returned due to incorrect bidShares in the PA1D contract. The proof of concept is the Zora Market, which has lines of code that validate bidShares. The issue is that the PA1D#bidSharesForToken sets the bidShares.creator.value to the raw basis points set by the owner, which is many order of magnitudes different than expected. This is because the basis points should be converted to percentages written out to 18 decimals. The recommended mitigation step is to multiple the basis point by 10 ** (18 - 2) or 10 ** 16. This should fix the issue and return the proper value.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-holograph-contest",
      "sponsor_name": "Holograph",
      "sponsor_link": "https://twitter.com/holographxyz",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/180",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "170",
      "slug": "m-14-pa1dbidsharesfortoken-returns-incorrect-bidsharescreatorvalue-code4rena-holograph-holograph-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Holograph",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Holograph",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "3331",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 4,
      "protocol_id": "137",
      "title": "M-6: No Validation Check Against Decimal Of Secondary Token",
      "content": "Source: https://github.com/sherlock-audit/2022-09-notional-judging/issues/88 \n\n## Found by \nak1, xiaoming90, 0x52, Jeiwan\n\n## Summary\n\nThere is no validation check against the decimal of the secondary token due to a typo. Thus, this will cause the vault to be broken entirely or the value of the shares to be stuck if a secondary token with more than 18 decimals is added.\n\n## Vulnerability Detail\n\nThere is a typo in Line 65 within the `TwoTokenPoolMixin` contract. The validation at Line 65 should perform a check against the `secondaryDecimals` instead of the `primaryDecimals`. As such, no validation was performed against the secondary token.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/TwoTokenPoolMixin.sol#L65\n\n```solidity\nFile: TwoTokenPoolMixin.sol\n23:     constructor(\n24:         NotionalProxy notional_, \n25:         AuraVaultDeploymentParams memory params\n26:     ) PoolMixin(notional_, params) {\n..SNIP..\n55:         // If the underlying is ETH, primaryBorrowToken will be rewritten as WETH\n56:         uint256 primaryDecimals = IERC20(primaryAddress).decimals();\n57:         // Do not allow decimal places greater than 18\n58:         require(primaryDecimals <= 18);\n59:         PRIMARY_DECIMALS = uint8(primaryDecimals);\n60: \n61:         uint256 secondaryDecimals = address(SECONDARY_TOKEN) ==\n62:             Deployments.ETH_ADDRESS\n63:             ? 18\n64:             : SECONDARY_TOKEN.decimals();\n65:         require(primaryDecimals <= 18);\n66:         SECONDARY_DECIMALS = uint8(secondaryDecimals);\n67:     }\n```\n\nIf the decimal of the secondary tokens is more than 18, the `Stable2TokenOracleMath._getSpotPrice` will stop working as the code will revert in Line 24 below because the decimal of secondary tokens is more than 18.\n\nWhen the `Stable2TokenOracleMath._getSpotPrice` function stop working, the vaults will be broken entirely because the settle vault and reinvest rewards functions will stop working too. This is because the settle vault and reinvest rewards functions will call the `Stable2TokenOracleMath._getSpotPrice` function internally, resulting in a revert.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L16\n\n```solidity\nFile: Stable2TokenOracleMath.sol\n16:     function _getSpotPrice(\n17:         StableOracleContext memory oracleContext, \n18:         TwoTokenPoolContext memory poolContext, \n19:         uint256 tokenIndex\n20:     ) internal view returns (uint256 spotPrice) {\n21:         // Prevents overflows, we don't expect tokens to be greater than 18 decimals, don't use\n22:         // equal sign for minor gas optimization\n23:         require(poolContext.primaryDecimals < 19); /// @dev primaryDecimals overflow\n24:         require(poolContext.secondaryDecimals < 19); /// @dev secondaryDecimals overflow\n25:         require(tokenIndex < 2); /// @dev invalid token index\n```\n\n## Impact\n\nThe `Stable2TokenOracleMath._getSpotPrice` will stop working, which will in turn cause the settle vault and reinvest rewards functions to stop working too. Since a vault cannot be settled, the vault is considered broken. If the reinvest rewards function cannot work, the value of users' shares will be stuck as the vault relies on reinvesting rewards to buy more BPT tokens from the market.\n\nIn addition, there might be some issues when calculating the price of the tokens since the vault assumes that both primary and secondary tokens have a decimal equal to or less than 18 OR some overflow might occur when processing the token value.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/TwoTokenPoolMixin.sol#L65\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L16\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the code to perform the validation against the `secondaryDecimals` state variable.\n\n```diff\nconstructor(\n    NotionalProxy notional_, \n    AuraVaultDeploymentParams memory params\n) PoolMixin(notional_, params) {\n    ..SNIP..\n    // If the underlying is ETH, primaryBorrowToken will be rewritten as WETH\n    uint256 primaryDecimals = IERC20(primaryAddress).decimals();\n    // Do not allow decimal places greater than 18\n    require(primaryDecimals <= 18);\n    PRIMARY_DECIMALS = uint8(primaryDecimals);\n\n    uint256 secondaryDecimals = address(SECONDARY_TOKEN) ==\n        Deployments.ETH_ADDRESS\n        ? 18\n        : SECONDARY_TOKEN.decimals();\n-   require(primaryDecimals <= 18);\n+   require(secondaryDecimals <= 18);\n    SECONDARY_DECIMALS = uint8(secondaryDecimals);\n}\n```\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000\n\nValid issue, although I'm struggling to think of a token with more than 18 decimals.\n\n**jeffywu**\n\nConfirmed, although I would disagree with the severity here to Low. While in theory this would be an issue there are no TwoTokenPools we would really consider with 18+ decimals and these vaults get white listed on a case by case basis.",
      "summary": "\nA bug was found in the `TwoTokenPoolMixin` contract which causes no validation check against the decimal of the secondary token. This typo in Line 65 within the contract should perform a check against the `secondaryDecimals` instead of the `primaryDecimals`. If the decimal of the secondary token is more than 18, the `Stable2TokenOracleMath._getSpotPrice` will stop working, resulting in the vault being broken or the value of users' shares being stuck. This is because the settle vault and reinvest rewards functions will call the `Stable2TokenOracleMath._getSpotPrice` function internally, resulting in a revert. The code should be updated to perform the validation against the `secondaryDecimals` state variable. It was confirmed that while this would be an issue in theory, there are no TwoTokenPools with 18+ decimals and these vaults get white listed on a case by case basis.",
      "report_date": {},
      "contest_prize_txt": "100000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/2",
      "sponsor_name": "Notional",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-notional-judging/issues/88",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "2",
      "slug": "m-6-no-validation-check-against-decimal-of-secondary-token-sherlock-notional-notional-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Notional",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Notional",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "3777",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "148",
      "title": "[M-05] Tokens with lower number of decimals can result in postponed linear vesting for user",
      "content": "_Submitted by pashov_\n\n[VTVLVesting.sol#L174](https://github.com/code-423n4/2022-09-vtvl/blob/69da6e96f94ff3e02b9bb6175e6de2b3e71d3eb0/contracts/VTVLVesting.sol#L174)<br>\n\nIn the `_baseVestedAmount` of `VTVLVesting.sol` we see the following code\n\n```solidity\nuint40 finalVestingDurationSecs = _claim.endTimestamp - _claim.startTimestamp; // length of the interval\nuint112 linearVestAmount = _claim.linearVestAmount * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs;\n```\n\nLet’s look at `truncatedCurrentVestingDurationSecs` as just the duration passed from the start of the vesting period for the PoC (this doesn’t omit important data in this context).\n\nNow think of the following scenario:\n\nWe have a token `$TKN` that has 6 decimals (those are the decimals of both USDT & USDC). We want to distribute 10,000 of those tokens to a user vested over a 10 year period.\n\n10 years in seconds is 315360000 &ast;&ast;&ast;&ast;(this is `finalVestingDurationSecs`)\n\nThis means that we will distribute 10,000 &ast; 10^6 = 10 000 000 000 fractions of a token for 315360000 seconds, meaning we will distribute 310 fractions of a token each second - this is `linearVestAmount`\n\nNow, since `finalVestingDurationSecs` is so big (315360000) it will almost always round `linearVestAmount` to zero when dividing by it, up until\n\n`_claim.linearVestAmount * truncatedCurrentVestingDurationSecs` becomes a bigger number than 315360000, but since `_claim.linearVestAmount` is 310 we will need the current vesting duration to be at least 1 017 290 seconds which is **12** days postponed vesting. 12 days in a moving market can make a big difference if the user was expecting the tokens to start vesting from the first day.\n\n### Impact\n\nUnexpected postponing of vesting can result in waiting times for users to receive their must-be-vested tokens. This period can be used by other token holders to dump the token and decrease the price of it, resulting in a loss of capital for the vesting receiver.\n\n### Recommended Mitigation Steps\n\nEnforce the contract to work with only 18 decimal tokens with a `require` statement in the constructor.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-09-vtvl-findings/issues/191#issuecomment-1257051653):**\n > Downgrading to Medium, there are a lot of external factors presented here by the warden to line up to a loss of funds.  \n\n**[lawrencehui (VTVL) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-09-vtvl-findings/issues/191#issuecomment-1270955314):**\n > I acknowledge the warden's concern of the rounding, but I think the result of loss of funds is one of the extreme edge cases. I would suggest instead of restricting only to 18 decimal tokens (which is impractical as we would also want to include USDC and USDT for vesting too!), I would implement the rounding checking in the frontend UI and prompt user of potential delay caused by rounding / truncation as described in this issue.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-vtvl-findings/issues/191#issuecomment-1272146188):**\n > Given that smart contracts can be interacted with in any number of ways (etherscan, programmatically, etc), I don't think the mitigation negates the risk entirely and am going to stick with the Medium severity here.  The wardens demonstrates clearly the way in which this can happen. While it may be a bit outside of the normal vesting schedule expected, I do think it's valuable to understand the bounds of the math you have employed here.\n\n\n\n***\n\n",
      "summary": "\nA bug report was filed for the code in the VTVLVesting.sol contract. The code has a vulnerability that can cause unexpected delays in vesting of tokens. This can result in a loss of capital for the vesting receiver. \n\nThe bug report explains that the `_baseVestedAmount` of the VTVLVesting.sol contract contains code which can cause a delay in vesting of tokens. For example, if a token with 6 decimals is being distributed to a user over a 10 year period, the code will round the linearVestAmount to zero until the current vesting duration reaches 12 days. This means that the user will have to wait 12 days before receiving their tokens. \n\nThe impact of this vulnerability is that other token holders can take advantage of the delay and dump the token, causing a decrease in the price of the token and resulting in a loss of capital for the vesting receiver. \n\nThe recommendation to fix this issue is to enforce the contract to work with only 18 decimal tokens with a `require` statement in the constructor.",
      "report_date": {},
      "contest_prize_txt": "$30,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-09-vtvl-contest",
      "sponsor_name": "VTVL",
      "sponsor_link": "https://twitter.com/vtvlco",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-09-vtvl",
      "github_link": "https://github.com/code-423n4/2022-09-vtvl-findings/issues/191",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "164",
      "slug": "m-05-tokens-with-lower-number-of-decimals-can-result-in-postponed-linear-vesting-for-user-code4rena-vtvl-vtvl-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "VTVL",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "VTVL",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "3353",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "150",
      "title": "H-5: `UniV2LPOracle` will malfunction if token0 or token1's `decimals != 18`",
      "content": "Source: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/026-H \n## Found by \nLambda, WATCHPUG, 0x52, hyh\n\n## Summary\n\nWhen one of the LP token's underlying tokens `decimals` is not 18, the price of the LP token calculated by `UniV2LPOracle` will be wrong. \n\n## Vulnerability Detail\n\n`UniV2LPOracle` is an implementation of Alpha Homora v2's Fair Uniswap's LP Token Pricing Formula:\n\n> The Formula ... of combining fair asset prices and fair asset reserves:\n\n> $$\nP = 2\\cdot \\frac{\\sqrt{r_0 \\cdot r_1} \\cdot \\sqrt{p_0\\cdot p_1}}{totalSupply},\n$$\n\n> where $r_i$ is the asset ii's pool balance and $p_i$ is the asset $i$'s fair price.\n\nHowever, the current implementation wrongful assumes $r_0$ and $r_1$ are always in 18 decimals.\n\nhttps://github.com/sentimentxyz/oracle/blob/59b26a3d8c295208437aad36c470386c9729a4bc/src/uniswap/UniV2LPOracle.sol#L39-L50\n\n```solidity\nfunction getPrice(address pair) external view returns (uint) {\n    (uint r0, uint r1,) = IUniswapV2Pair(pair).getReserves();\n\n    // 2 * sqrt(r0 * r1 * p0 * p1) / totalSupply\n    return FixedPointMathLib.sqrt(\n        r0\n        .mulWadDown(r1)\n        .mulWadDown(oracle.getPrice(IUniswapV2Pair(pair).token0()))\n        .mulWadDown(oracle.getPrice(IUniswapV2Pair(pair).token1()))\n    )\n    .mulDivDown(2e27, IUniswapV2Pair(pair).totalSupply());\n}\n```\n\nhttps://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\n\n```solidity\nuint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\nfunction mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n    return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n}\n```\n\nhttps://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\n\n```solidity\nfunction mulDivDown(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n) internal pure returns (uint256 z) {\n    assembly {\n        // Store x * y in z for now.\n        z := mul(x, y)\n\n        // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n        if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n            revert(0, 0)\n        }\n\n        // Divide z by the denominator.\n        z := div(z, denominator)\n    }\n}\n```\n\n## Impact\n\nWhen the decimals of one or both tokens in the pair is not 18, the price will be way off.\n\n## Code Snippet\n\nWe've created a test script to demonstrate `UniV2LPOracle` is malfunctioning with USDC/WETH, in which USDC's decimals is 6 instead of 18.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/console.sol\";\nimport {Test} from \"forge-std/Test.sol\";\n\nimport {IOracle} from \"../core/IOracle.sol\";\nimport {UniV2LpOracle} from \"../uniswap/UniV2LPOracle.sol\";\n\nimport {OracleFacade} from \"../core/OracleFacade.sol\";\nimport {ChainlinkOracle} from \"../chainlink/ChainlinkOracle.sol\";\nimport {WETHOracle} from \"../weth/WETHOracle.sol\";\nimport {AggregatorV3Interface} from \"../chainlink/AggregatorV3Interface.sol\";\nimport \"forge-std/console.sol\";\n\ncontract UniV2LPOracleTest is Test {\n    address constant usdc = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    address constant pair = address(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n\n    address constant ethUsdFeed =\n        address(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    address constant usdcUsdFeed =\n        address(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\n\n    ChainlinkOracle chainlinkOracle;\n    WETHOracle wETHOracle;\n    UniV2LpOracle uniV2LpOracle;\n    OracleFacade oracleFacade;\n\n    function setUp() public {\n        // core oracle\n        oracleFacade = new OracleFacade();\n\n        chainlinkOracle = new ChainlinkOracle(\n            AggregatorV3Interface(ethUsdFeed)\n        );\n        chainlinkOracle.setFeed(usdc, AggregatorV3Interface(usdcUsdFeed));\n\n        WETHOracle wethOracle = new WETHOracle();\n        oracleFacade.setOracle(weth, wethOracle);\n        oracleFacade.setOracle(usdc, chainlinkOracle);\n\n        uniV2LpOracle = new UniV2LpOracle(oracleFacade);\n    }\n\n    function testUniV2Price() public {\n        console.log(uniV2LpOracle.getPrice(pair));\n    }\n}\n\n```\n\n#### `reserves` and `totalSupply` of UniswapV2 USDC/ETH Pair `0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc` on Mainnet at the time of writing\n\nResult of `getReserves()`\n```js\n_reserve0   uint112 :  45456843739761\n_reserve1   uint112 :  28342500764440756425363\n_blockTimestampLast   uint32 :  1663233599\n```\n\n`totalSupply()`: `550760227054391377`\n\n#### Expected and actual result\n\n```js\n// real time price\n28342500764440756425363 * 2   / 550760227054391377 = 102921\n\n// normalized r0 and r1 ✅\n102728696484607347546879 / 1e18 = 102728\n\n// current result\n102728772378134052 / 1e18 = 0.10272877237813405\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider normalizing r0 and r1 to 18 decimals before using them in the formula.\n\n## Sentiment Team\nFixed as recommended. PRs [here](https://github.com/sentimentxyz/oracle/pull/35) and [here](https://github.com/sentimentxyz/oracle/pull/41).\n\n## Lead Senior Watson\nConfirmed fix.",
      "summary": "\nThis bug report is about an issue found in `UniV2LPOracle`, an implementation of Alpha Homora v2's Fair Uniswap's LP Token Pricing Formula. The issue is that if one of the LP token's underlying tokens `decimals` is not 18, the price of the LP token calculated by `UniV2LPOracle` will be wrong. This was found by Lambda, WATCHPUG, 0x52, and hyh. \n\nThe issue is caused by the current implementation wrongful assuming $r_0$ and $r_1$ are always in 18 decimals. A test script was created to demonstrate `UniV2LPOracle` is malfunctioning with USDC/WETH, in which USDC's decimals is 6 instead of 18. When the decimals of one or both tokens in the pair is not 18, the price will be way off.\n\nThe recommendation is to consider normalizing r0 and r1 to 18 decimals before using them in the formula. This has been fixed as recommended, with the PRs available here and here. The fix was confirmed by the Lead Senior Watson.",
      "report_date": {},
      "contest_prize_txt": "75000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/1",
      "sponsor_name": "Sentiment",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/026-H",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "1",
      "slug": "h-5-univ2lporacle-will-malfunction-if-token0-or-token1s-decimals-18-sherlock-sentiment-sentiment-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sentiment",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sentiment",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "3352",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 6,
      "protocol_id": "150",
      "title": "H-4: `ERC4626Oracle` Price will be wrong when the ERC4626's `decimals` is different from the underlying token’s decimals",
      "content": "Source: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/025-H \n## Found by \nLambda, JohnSmith, WATCHPUG, 0x52, berndartmueller, Bahurum\n\n## Summary\n\nEIP-4626 does not require the decimals must be the same as the underlying tokens' decimals, and when it's not, `ERC4626Oracle` will malfunction.\n\n## Vulnerability Detail\n\nIn the current implementation, `IERC4626(token).decimals()` is used as the `IERC4626(token).asset()`'s decimals to calculate the ERC4626's price.\n\nHowever, while most ERC4626s are using the underlying token’s decimals as `decimals`, there are some ERC4626s use a different decimals from underlying token’s decimals since EIP-4626 does not require the decimals must be the same as the underlying token’s decimals:\n\n> Although the convertTo functions should eliminate the need for any use of an EIP-4626 Vault’s decimals variable, it is still strongly recommended to mirror the underlying token’s decimals if at all possible, to eliminate possible sources of confusion and simplify integration across front-ends and for other off-chain users.\n\nRef: https://eips.ethereum.org/EIPS/eip-4626\n\n## Impact\n\nThe price of ERC4626 will be significantly underestimated when the underlying token's decimals > ERC4626's decimals, and be significantly overestimated when the underlying token's decimals < ERC4626's decimals.\n\n## Code Snippet\n\nhttps://github.com/sentimentxyz/oracle/blob/59b26a3d8c295208437aad36c470386c9729a4bc/src/erc4626/ERC4626Oracle.sol#L35-L43\n\n```solidity\n    function getPrice(address token) external view returns (uint) {\n        uint decimals = IERC4626(token).decimals();\n        return IERC4626(token).previewRedeem(\n            10 ** decimals\n        ).mulDivDown(\n            oracleFacade.getPrice(IERC4626(token).asset()),\n            10 ** decimals\n        );\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`getPrice()` can be changed to:\n\n```solidity\n    function getPrice(address token) external view returns (uint) {\n        uint decimals = IERC4626(token).decimals();\n        address underlyingToken = IERC4626(token).asset();\n        return IERC4626(token).previewRedeem(\n            10 ** decimals\n        ).mulDivDown(\n            oracleFacade.getPrice(underlyingToken),\n            10 ** IERC20Metadata(underlyingToken).decimals()\n        );\n    }\n```\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/oracle/pull/34).\n\n## Lead Senior Watson\nConfirmed fix.",
      "summary": "\nThis bug report concerns a malfunction in the `ERC4626Oracle` when the decimals of the ERC4626 is different from the underlying token's decimals. This issue was found by Lambda, JohnSmith, WATCHPUG, 0x52, berndartmueller, and Bahurum. The current implementation uses `IERC4626(token).decimals()` as the `IERC4626(token).asset()`'s decimals to calculate the ERC4626's price, however, EIP-4626 does not require the decimals must be the same as the underlying token’s decimals. This causes the price of ERC4626 to be significantly underestimated when the underlying token's decimals > ERC4626's decimals, and be significantly overestimated when the underlying token's decimals < ERC4626's decimals. The Sentiment Team fixed the issue as recommended and Lead Senior Watson confirmed the fix.",
      "report_date": {},
      "contest_prize_txt": "75000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/1",
      "sponsor_name": "Sentiment",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/025-H",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "1",
      "slug": "h-4-erc4626oracle-price-will-be-wrong-when-the-erc4626s-decimals-is-different-from-the-underlying-tokens-decimals-sherlock-sentiment-sentiment-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sentiment",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sentiment",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "3351",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "150",
      "title": "H-3: CTokenOracle.sol#getCErc20Price contains critical math error",
      "content": "Source: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/021-H \n## Found by \n0x52\n\n## Summary\n\nCTokenOracle.sol#getCErc20Price contains a math error that immensely overvalues CTokens\n\n## Vulnerability Detail\n\n[CTokenOracle.sol#L66-L76](https://github.com/sentimentxyz/oracle/blob/59b26a3d8c295208437aad36c470386c9729a4bc/src/compound/CTokenOracle.sol#L66-L76)\n\n    function getCErc20Price(ICToken cToken, address underlying) internal view returns (uint) {\n        /*\n            cToken Exchange rates are scaled by 10^(18 - 8 + underlying token decimals) so to scale\n            the exchange rate to 18 decimals we must multiply it by 1e8 and then divide it by the\n            number of decimals in the underlying token. Finally to find the price of the cToken we\n            must multiply this value with the current price of the underlying token\n        */\n        return cToken.exchangeRateStored()\n        .mulDivDown(1e8 , IERC20(underlying).decimals())\n        .mulWadDown(oracle.getPrice(underlying));\n    }\n\nIn L74, IERC20(underlying).decimals() is not raised to the power of 10. The results in the price of the LP being overvalued by many order of magnitudes. A user could deposit one CToken and drain the reserves of every liquidity pool.\n\n## Impact\n\nAll lenders could be drained of all their funds due to excessive over valuation of CTokens cause by this error\n\n## Code Snippet\n\n[CTokenOracle.sol#L66-L76](https://github.com/sentimentxyz/oracle/blob/59b26a3d8c295208437aad36c470386c9729a4bc/src/compound/CTokenOracle.sol#L66-L76)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFix the math error by changing L74:\n\n    return cToken.exchangeRateStored()\n    .mulDivDown(1e8 , 10 ** IERC20(underlying).decimals())\n    .mulWadDown(oracle.getPrice(underlying));\n       \n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/oracle/pull/43).\n\n## Lead Senior Watson\nConfirmed fix.",
      "summary": "\nThis bug report is about an issue found in the CTokenOracle.sol#getCErc20Price contract. The issue is a math error that immensely overvalues CTokens, which could lead to all lenders being drained of all their funds due to excessive over valuation of CTokens. The math error is in line 74, where IERC20(underlying).decimals() is not raised to the power of 10. The Sentiment Team fixed the issue as recommended by changing line 74 to return cToken.exchangeRateStored().mulDivDown(1e8 , 10 ** IERC20(underlying).decimals()).mulWadDown(oracle.getPrice(underlying)); and Lead Senior Watson confirmed the fix.",
      "report_date": {},
      "contest_prize_txt": "75000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/1",
      "sponsor_name": "Sentiment",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 2,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/021-H",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "1",
      "slug": "h-3-ctokenoraclesolgetcerc20price-contains-critical-math-error-sherlock-sentiment-sentiment-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sentiment",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sentiment",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "5773",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 18,
      "protocol_id": "152",
      "title": "[H-01] Incorrect handling of `pricefeed.decimals()`",
      "content": "\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/oracles/PegOracle.sol#L46-L83>\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L299-L300>\n\n### Impact\n\nWrong math for handling pricefeed decimals. This code will only work for pricefeeds of 8 decimals, any others give wrong/incorrect data. The maths used can be shown in three lines:\n\n```solidity\nnowPrice = (price1 * 10000) / price2;\nnowPrice = nowPrice * int256(10**(18 - priceFeed1.decimals()));\nreturn nowPrice / 1000000;\n```\n\nLine1: adds 4 decimals\nLine2: adds (18 - d) decimals, (where d = pricefeed.decimals())\nLine3:  removes 6 decimals\n\nTotal: adds (16 - d) decimals\n\nwhen d=8, the contract correctly returns an 8 decimal number. However, when d = 6, the function will return a 10 decimal number. This is further raised by (18-d = 12) decimals when checking for depeg event, leading to a 22 decimal number which is 4 orders of magnitude incorrect.\n\nif d=18, (like usd-eth pricefeeds) contract fails / returns 0.\n\nAll chainlink contracts which give price in eth, operate with 18 decimals. So this can cripple the system if added later.\n\n### Proof of Concept\n\nRunning the test  AssertTest.t.sol:testPegOracleMarketCreation and changing the line on\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/test/AssertTest.t.sol#L30>\n\nto\n\n```solidity\nPegOracle pegOracle3 = new PegOracle(\n            0xB1552C5e96B312d0Bf8b554186F846C40614a540,  //usd-eth contract address\n            btcEthOracle\n        );\n```\n\ngives this output\n\n    oracle3price1: 1085903802394919427                                                                                                                                                                               \n    oracle3price2: 13753840915281064000                                                                                                                                                                              \n    oracle3price1 / oracle3price2: 0\n\nreturning an oracle value of 0. Simulating with a mock price feed of 6 decimals gives results 4 orders of magnitude off.\n\n### Tools Used\n\nFoundry, VS-Code\n\n### Recommended Mitigation Steps\n\nSince only the price ratio is calculated, there is no point in increasing the decimal by (18-d) in the second line. Proposed solution:\n\n```solidity\nnowPrice = (price1 * 10000) / price2;\nnowPrice = nowPrice * int256(10**(priceFeed1.decimals())) * 100;\nreturn nowPrice / 1000000;\n```\n\nThis returns results in d decimals, no matter the value of d.\n\n**[MiguelBits (Y2K Finance) confirmed](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/195)** \n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the PegOracle.sol file of the 2022-09-y2k-finance Github repository. The vulnerability is caused by incorrect maths for handling pricefeed decimals. The code only works for pricefeeds of 8 decimals, any others give wrong/incorrect data. This can lead to a contract failure or incorrect data when the pricefeed is set to 6 or 18 decimals. To test the vulnerability, the AssertTest.t.sol:testPegOracleMarketCreation was run and the results showed an oracle value of 0. Simulating with a mock price feed of 6 decimals gave results 4 orders of magnitude off. The recommended mitigation step is to change the second line of the code to return results in d decimals, no matter the value of d.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-09-y2k-finance-contest",
      "sponsor_name": "Y2k Finance",
      "sponsor_link": "https://twitter.com/Y2kFinance",
      "quality_score": 5,
      "general_score": 2,
      "source_link": "https://code4rena.com/reports/2022-09-y2k-finance",
      "github_link": "https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/195",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "162",
      "slug": "h-01-incorrect-handling-of-pricefeeddecimals-code4rena-y2k-finance-y2k-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Y2k Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Y2k Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "7237",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "72",
      "title": "_slippageTol does not adjust for decimal differences",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\nAssetLogic.sol#L273\n\n## Description\nUsers set the slippage tolerance in percentage. The `assetLogic` calculates:\n\n```\nminReceived = (_amount * _slippageTol) / s.LIQUIDITY_FEE_DENOMINATOR\n```\n\nThen `assetLogic` uses `minReceived` in the swap functions. However, the `minReceived` does not adjust for the decimal differences between `assetIn` and `assetOut`. Users will either always hit the slippage or suffer huge slippage when `assetIn` and `assetOut` have a different number of decimals.\n\nAssume the number of decimals of `assetIn` is 6 and the number of decimals of `assetOut` is 18. The `minReceived` will be set to `10^-12` smaller than the correct value. Users would be vulnerable to sandwich attacks in this case. \n\nAlternatively, if the number of decimals of `assetIn` is 18 and the number of decimals of `assetOut` is 6, the `minReceived` will be set to `10^12` larger than the correct value. Users would always hit the slippage, and the cross-chain transfer will get stuck.\n\n### Code Snippet\n```solidity\nlibrary AssetLogic {\n    function _swapAsset(... ) ... {\n        // Swap the asset to the proper local asset\n        uint256 minReceived = (_amount * _slippageTol) / s.LIQUIDITY_FEE_DENOMINATOR;\n        ...\n        return (pool.swapExact(_amount, _assetIn, _assetOut, minReceived), _assetOut);\n        ...\n    }\n}\n```\n\n## Recommendation\nRecommend to adjust the value with `swapStorage.tokenPrecisionMultipliers` for internal swap. For the external swap, the value should be adjusted according to `token.decimals`.\n\n## Connext\nSolved in PR 1574.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is about an issue with the AssetLogic.sol#L273 in the AssetLogic library. It states that when users set the slippage tolerance in percentage, the assetLogic calculates a minReceived value with the wrong amount. This leads to users either always hitting the slippage or suffering huge slippage when the assetIn and assetOut have different number of decimals. For example, if the number of decimals of assetIn is 6 and the decimal of assetOut is 18, the minReceived value will be set to 10ˆ-12 smaller than the correct value, making users vulnerable to sandwich attacks. On the other hand, if the number of decimals of assetIn is 18 and the number of decimals of assetOut is 6, the minReceived will be set to 10ˆ12 larger than the correct value, causing the cross-chain transfer to get stuck.\n\nThe recommendation is to adjust the value with swapStorage.tokenPrecisionMultipliers for internal swap and according to token.decimals for external swap. This issue has been solved in PR 1574 and has been verified by Spearbit.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Connext-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Connext-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Connext-Spearbit-Security-Review.pdf",
      "pdf_page_from": 26,
      "contest_id": "",
      "slug": "slippagetol-does-not-adjust-for-decimal-differences-spearbit-connext-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Connext",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Connext",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "2338",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "219",
      "title": "[M-05] Withdrawing ETH collateral with max uint256 amount value reverts transaction",
      "content": "_Submitted by berndartmueller, also found by WatchPug_\n\nWithdrawing ETH collateral via the `withdrawCollateral` function using `type(uint256).max` for the `_amount` parameter reverts the transaction due to `_asset` being the zero-address and `IERC20Detailed(_asset).decimals()` not working for native ETH.\n\n#### Proof of Concept\n\n[GeneralVault.sol#L121-L124](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L121-L124)\n\n```solidity\nif (_amount == type(uint256).max) {\n    uint256 decimal = IERC20Detailed(_asset).decimals(); // @audit-info does not work for native ETH. Transaction reverts\n    _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal);\n}\n```\n\n### Recommended mitigation steps\n\nCheck `_asset` and use hard coded decimal value (`18`) for native ETH.\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/85)**\n\n**[atozICT20 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/85):**\n > [Fix the issue of transaction fails due to calculate ETH's decimals sturdyfi/code4rena-may-2022#7](https://github.com/sturdyfi/code4rena-may-2022/pull/7)\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/85#issuecomment-1145575544):**\n > Good find! Stated in `_asset` description that null address is interpreted as ETH, which isn't a token, and therefore reverts when attempting to fetch its decimals.\n\n\n\n***\n\n",
      "summary": "\nThis bug report focuses on a vulnerability found in the `withdrawCollateral` function of the GeneralVault smart contract. The vulnerability occurs when `type(uint256).max` is used for the `_amount` parameter and `_asset` is the zero-address. This causes the transaction to revert because `IERC20Detailed(_asset).decimals()` does not work for native ETH. Manual review was used to identify this vulnerability. The recommended mitigation step is to check `_asset` and use a hard coded decimal value of 18 for native ETH.",
      "report_date": {},
      "contest_prize_txt": "$30,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-05-sturdy-contest",
      "sponsor_name": "Sturdy",
      "sponsor_link": "https://twitter.com/SturdyFinance",
      "quality_score": 3,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/85",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "125",
      "slug": "m-05-withdrawing-eth-collateral-with-max-uint256-amount-value-reverts-transaction-code4rena-sturdy-sturdy-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Sturdy",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Sturdy",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "1922",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "250",
      "title": "[M-07] Wrong calculation for `yVault` price per share if decimals != 18",
      "content": "_Submitted by berndartmueller_\n\nThe [yVault.getPricePerFullShare()](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L196) function calculates the price per share by multiplying with `1e18` token decimals with the assumption that the underlying token always has 18 decimals. `yVault` has the same amount of decimals as it's underlying token see ([yVault.decimals()](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L70))\n\nBut tokens don't always have `1e18` decimals (e.g. USDC).\n\n### Impact\n\nThe price per share calculation does not return the correct price for underlying tokens that do not have 18 decimals. This could lead to paying out too little or too much and therefore to a loss for either the protocol or the user.\n\n### Proof of Concept\n\nFollowing test will fail with the current implementation when the underlying vault token has 6 decimals:\n\n*NOTE: `units()` helper function was adapted to accept the desired decimals.*\n\n```typescript\nit.only(\"should mint the correct amount of tokens for tokens with 6 decimals\", async () => {\n  const DECIMALS = 6;\n\n  await token.setDecimals(DECIMALS);\n  expect(await yVault.decimals()).to.equal(DECIMALS);\n\n  expect(await yVault.getPricePerFullShare()).to.equal(0);\n  await token.mint(user1.address, units(1000, DECIMALS));\n  await token.connect(user1).approve(yVault.address, units(1000, DECIMALS));\n\n  await yVault.connect(user1).deposit(units(500, DECIMALS));\n  expect(await yVault.balanceOf(user1.address)).to.equal(units(500, DECIMALS));\n\n  await token.mint(strategy.address, units(500, DECIMALS));\n  expect(await yVault.getPricePerFullShare()).to.equal(units(2, DECIMALS));\n});\n```\n\nFails with following error: `AssertionError: Expected \"2000000000000000000\" to be equal 2000000`\n\n### Recommended mitigation steps\n\nUse vault `decimals()` instead of hardcoded `1e18` decimals.\n\n```solidity\nfunction getPricePerFullShare() external view returns (uint256) {\n    uint256 supply = totalSupply();\n    if (supply == 0) return 0;\n    return (balance() * (10**decimals())) / supply; // @audit-info use `decimals()` instead of hardcoded `1e18`\n}\n```\n\n**[spaghettieth (JPEG'd) disputed and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/117#issuecomment-1097985902):**\n > The `yVault` contract has been designed to work with Curve LPs, which have 18 decimals\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/117#issuecomment-1109895569):**\n > I'm downgrading this to a medium risk but leaving it as valid. Any number of external factors could conspire to result in a non-18 decimal token being used in the future, at which point this code may have been forgotten. A better choice would be to do a decimal check.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the function getPricePerFullShare() in the yVault contract. The function calculates the price per share by multiplying with `1e18` token decimals with the assumption that the underlying token always has 18 decimals. However, tokens don't always have `1e18` decimals (e.g. USDC). This could lead to paying out too little or too much and therefore to a loss for either the protocol or the user. A proof of concept is provided to demonstrate the issue. The recommended mitigation step is to use the vault `decimals()` instead of hardcoded `1e18` decimals.",
      "report_date": {},
      "contest_prize_txt": "$100,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-04-jpegd-contest",
      "sponsor_name": "JPEG'd",
      "sponsor_link": "https://twitter.com/jpegd_69",
      "quality_score": 3,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/117",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "107",
      "slug": "m-07-wrong-calculation-for-yvault-price-per-share-if-decimals-18-code4rena-jpegd-jpegd-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "JPEG'd",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "JPEG'd",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "1333",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "304",
      "title": "[H-02] Wrong token allocation computation for token decimals != 18 if floor price not reached",
      "content": "_Submitted by cmichel_\n\nIn `LaunchEvent.createPair`, when the floor price is not reached (`floorPrice > wavaxReserve * 1e18 / tokenAllocated`), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.\n\nNote that the `floorPrice` is supposed to have a precision of 18:\n\n> /// @param \\_floorPrice Price of each token in AVAX, scaled to 1e18\n\nThe `floorPrice > (wavaxReserve * 1e18) / tokenAllocated` check is correct but the `tokenAllocated` computation involves the `token` decimals:\n\n```solidity\n// @audit should be wavaxReserve * 1e18 / floorPrice\ntokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;\n```\n\nThis computation does not work for `token`s that don't have 18 decimals.\n\n#### Example\n\nAssume I want to sell `1.0 wBTC = 1e8 wBTC` (8 decimals) at `2,000.0 AVAX = 2,000 * 1e18 AVAX`.\nThe `floorPrice` is `2000e18 * 1e18 / 1e8 = 2e31`\n\nAssume the Launch event only raised `1,000.0 AVAX` - half of the floor price for the issued token amount of `1.0 WBTC` (it should therefore allocate only half a WBTC) - and the token amount will be reduced as: `floorPrice = 2e31 > 1000e18 * 1e18 / 1e8 = 1e31 = actualPrice`.\nThen, `tokenAllocated = 1000e18 * 1e8 / 2e31 = 1e29 / 2e31 = 0` and no tokens would be allocated, instead of `0.5 WBTC = 0.5e8 WBTC`.\n\nThe computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice = 1000e18 * 1e18 / 2e31 = 1e39 / 2e31 = 10e38 / 2e31 = 5e7 = 0.5e8`.\n\n#### Recommendation\n\nThe new `tokenAllocated` computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice;`.\n\n**[cryptofish7 (Trader Joe) confirmed and commented](https://github.com/code-423n4/2022-01-trader-joe-findings/issues/193#issuecomment-1035433466):**\n > Fix: https://github.com/traderjoe-xyz/rocket-joe/pull/76\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the `LaunchEvent.createPair` function of a software program. The bug occurs when the floor price is not reached, and the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price. The problem is that the computation involved with determining the amount of tokens allocated uses the token decimals, which does not work for tokens that do not have 18 decimals. An example is provided to illustrate the issue. The recommendation is that the new token allocation computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice;`.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDT",
      "contest_link": "https://code4rena.com/contests/2022-01-trader-joe-contest",
      "sponsor_name": "Trader Joe",
      "sponsor_link": "https://twitter.com/traderjoe_xyz",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-01-trader-joe",
      "github_link": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/193",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "79",
      "slug": "h-02-wrong-token-allocation-computation-for-token-decimals-18-if-floor-price-not-reached-code4rena-trader-joe-trader-joe-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Trader Joe",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Trader Joe",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "1187",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "261",
      "title": "[H-04] Yearn token <> shares conversion decimal issue",
      "content": "_Submitted by cmichel_\n\nThe yearn strategy `YearnYield` converts shares to tokens by doing `pricePerFullShare * shares / 1e18`:\n\n    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {\n        if (shares == 0) return 0;\n        // @audit should divided by vaultDecimals \n        amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);\n    }\n\nBut Yearn's `getPricePerFullShare` seems to be [in `vault.decimals()` precision](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L1147), i.e., it should convert it as `pricePerFullShare * shares / (10 ** vault.decimals())`.\nThe vault decimals are the same [as the underlying token decimals](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L295-L296)\n\n#### Impact\n\nThe token and shares conversions do not work correctly for underlying tokens that do not have 18 decimals.\nToo much or too little might be paid out leading to a loss for either the protocol or user.\n\n#### Recommended Mitigation Steps\n\nDivide by `10**vault.decimals()` instead of `1e18` in `getTokensForShares`.\nApply a similar fix in `getSharesForTokens`.\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/134)** \n\n",
      "summary": "\nA bug has been reported in the Yearn strategy \"YearnYield\". This bug affects the token and shares conversion, resulting in the incorrect amount of tokens or shares being paid out. This could lead to a loss for either the protocol or user. The bug is caused by the use of `1e18` in the `getTokensForShares` function, when it should be divided by `10**vault.decimals()` instead. The same fix should also be applied to the `getSharesForTokens` function. The recommended mitigation steps are to divide by `10**vault.decimals()` instead of `1e18` in `getTokensForShares` and to apply the same fix in `getSharesForTokens`.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-12-sublime-contest",
      "sponsor_name": "Sublime",
      "sponsor_link": "https://twitter.com/sublimefinance",
      "quality_score": 3,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2021-12-sublime",
      "github_link": "https://github.com/code-423n4/2021-12-sublime-findings/issues/134",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "61",
      "slug": "h-04-yearn-token-shares-conversion-decimal-issue-code4rena-sublime-sublime-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Sublime",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Sublime",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        },
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        }
      ]
    },
    {
      "id": "769",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "346",
      "title": "[H-08] Vault.withdraw mixes normalized and standard amounts",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `Vault.balance` function uses the `balanceOfThis` function which scales (\"normalizes\") all balances to 18 decimals.\n\n```\nfor (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}\n```\n\nNote that `balance()`'s second term `IController(manager.controllers(address(this))).balanceOf()` is not normalized, but it must be.\n\nThis leads to many issues through the contracts that use `balance` but don't treat these values as normalized values.\nFor example, in `Vault.withdraw`, the computed `_amount` value is normalized (in 18 decimals).\nBut the `uint256 _balance = IERC20(_output).balanceOf(address(this));` value is not normalized but compared to the normalized `_amount` and even subtracted:\n\n```solidity\n// @audit compares unnormalzied output to normalized output\nif (_balance < _amount) {\n    IController _controller = IController(manager.controllers(address(this)));\n    // @audit cannot directly subtract unnormalized\n    uint256 _toWithdraw = _amount.sub(_balance);\n    if (_controller.strategies() > 0) {\n        _controller.withdraw(_output, _toWithdraw);\n    }\n    uint256 _after = IERC20(_output).balanceOf(address(this));\n    uint256 _diff = _after.sub(_balance);\n    if (_diff < _toWithdraw) {\n        _amount = _balance.add(_diff);\n    }\n}\n```\n\n## Impact\nImagine in `withdraw`, the `output` is USDC with 6 decimals, then the normalized `_toWithdraw` with 18 decimals (due to using `_amount`) will be a huge number and attempt to withdraw an inflated amount.\nAn attacker can steal tokens this way by withdrawing a tiny amount of shares and receive an inflated USDC or USDT amount (or any `_output` token with less than 18 decimals).\n\n## Recommended Mitigation Steps\nWhenever using anything involving `vault.balanceOfThis()` or `vault.balance()` one needs to be sure that any derived token amount needs to be denormalized again before using them.",
      "summary": "\nThis bug report is about the `Vault.balance` function in a smart contract. This function uses the `balanceOfThis` function which normalizes all balances to 18 decimals. However, the second term `IController(manager.controllers(address(this))).balanceOf()` is not normalized, leading to issues in the contracts that use `balance` but don't treat these values as normalized values. This can lead to an attacker stealing tokens by withdrawing a tiny amount of shares and receiving an inflated amount of a token with less than 18 decimals.\n\nThe recommended mitigation steps for this issue are to make sure any derived token amount is denormalized again before using them.",
      "report_date": {},
      "contest_prize_txt": "$30,000 USDC (plus $30,000 in tokens)",
      "contest_link": "https://code4rena.com/contests/2021-09-yaxis-contest",
      "sponsor_name": "yAxis",
      "sponsor_link": "https://twitter.com/yaxis_project",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2021-09-yaxis",
      "github_link": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/131",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "30",
      "slug": "h-08-vaultwithdraw-mixes-normalized-and-standard-amounts-code4rena-yaxis-yaxis-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "yAxis",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "yAxis",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        },
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        }
      ]
    },
    {
      "id": "768",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "346",
      "title": "[H-07] Vault.balance() mixes normalized and standard amounts",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `Vault.balance` function uses the `balanceOfThis` function which scales (\"normalizes\") all balances to 18 decimals.\n\n```\nfor (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}\n```\n\nNote that `balance()`'s second term `IController(manager.controllers(address(this))).balanceOf()` is not normalized.\nThe code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).\n\n## Impact\nThe result is that the `balance()` will be under-reported.\nThis leads to receiving wrong shares when `deposit`ing tokens, and a wrong amount when redeeming `tokens`.\n\n## Recommended Mitigation Steps\nThe second term `IController(manager.controllers(address(this))).balanceOf()` must also be normalized before adding it.\n`IController(manager.controllers(address(this))).balanceOf()` uses `_vaultDetails[msg.sender].balance` which directly uses the raw token amounts which are not normalized.",
      "summary": "\nThis bug report is about the `Vault.balance` function in the code. The function uses the `balanceOfThis` function which normalizes all balances to 18 decimals. However, the second term `IController(manager.controllers(address(this))).balanceOf()` is not normalized, which means that the `balance()` will be under-reported. This leads to receiving wrong shares when `deposit`ing tokens, and a wrong amount when redeeming `tokens`. The recommended mitigation steps are to normalize the second term before adding it, and to use `_vaultDetails[msg.sender].balance` which directly uses the raw token amounts which are not normalized.",
      "report_date": {},
      "contest_prize_txt": "$30,000 USDC (plus $30,000 in tokens)",
      "contest_link": "https://code4rena.com/contests/2021-09-yaxis-contest",
      "sponsor_name": "yAxis",
      "sponsor_link": "https://twitter.com/yaxis_project",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2021-09-yaxis",
      "github_link": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/132",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "30",
      "slug": "h-07-vaultbalance-mixes-normalized-and-standard-amounts-code4rena-yaxis-yaxis-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "yAxis",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "yAxis",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "630",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "423",
      "title": "[H-01] CompositeMultiOracle returns wrong decimals for prices?",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `CompositeMultiOracle.peek/get` functions seem to return wrong prices.\nIt's unclear what decimals `source.decimals` refers to in this case. Does it refer to `source.source` token decimals?\n\nIt chains the price arguments through `_peek` function calls and a single price is computed as:\n\n```solidity\n(priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);   // Get price for one unit\n// @audit shouldn't this divide by 10 ** IOracle(source.source).decimals() instead?\npriceOut = priceIn * priceOut / (10 ** source.decimals);\n```\n\nAssume all oracles use 18 decimals (`oracle.decimals()` returns 18) and `source.decimals` refers to the _token decimals_ of `source.source`.\n\nThen going from `USDC -> DAI -> USDT` (`path = [DAI]`) starts with a price of `1e18` in `peek`:\n- `_peek(USDC, DAI, 1e18)`: Gets the price of `1e6 USDC` (as USDC has 6 decimals) in DAI with 18 decimals precision (because all oracle precision is set to 18): `priceOut = priceIn * 1e18 / 1e6 = 1e18 * 1e18 / 1e6 = 1e30`\n- `_peek(DAI, USDT, 1e30)`: Gets the price of `1e18 DAI` (DAI has 18 decimals) with 18 decimals precision: `priceOut = priceIn * 1e18 / 1e18 = priceIn = 1e30`\n\nIt then uses `1e30` as the price to go from `USDC` to `USDT`: `value = price * amount / 1e18 = 1e30 * (1.0 USDC) / 1e18 = 1e30 * 1e6 / 1e18 = 1e18 = 1e12 * 1e6 = 1_000_000_000_000.0 USDT`. Inflating the actual `USDT` amount.\n\n## Recommended Mitigation Steps\nThe issue is that `peek` assumes that the final price is in 18 decimals in the `value = price * amount / 1e18` division by `1e18`.\nBut `_peek` (and `_get`) don't enforce this.\n\n`_peek` should scale the prices to `1e18` by doing:\n\n```solidity\n(priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);\n// priceOut will have same decimals as priceIn if we divide by oracle decimals\npriceOut = priceIn * priceOut / (10 ** IOracle(source.source).decimals());\n```\n\nIt does not need to divide by the `source.source` _token precision_ (`source.decimals`), but by the oracle precision (`IOracle(source.source).decimals()`).",
      "summary": "\nA bug has been reported in the `CompositeMultiOracle.peek/get` functions which are returning incorrect prices. It is not clear what the decimals in `source.decimals` refer to. The bug is related to the price arguments being passed through `_peek` function calls and the single price being computed as `priceOut = priceIn * priceOut / (10 ** source.decimals)`. \n\nAssuming all oracles use 18 decimals and `source.decimals` refers to the token decimals of `source.source`, then when going from `USDC -> DAI -> USDT` the price starts with `1e18` in `peek` and the final price is `1e18` which inflates the actual `USDT` amount.\n\nThe recommended mitigation steps are that `_peek` should scale the prices to `1e18` by doing `priceOut = priceIn * priceOut / (10 ** IOracle(source.source).decimals())` and not dividing by the `source.source` token precision (`source.decimals`).",
      "report_date": {},
      "contest_prize_txt": "$30,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-08-yield-micro-contest-1",
      "sponsor_name": "Yield",
      "sponsor_link": "https://twitter.com/yield",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2021-08-yield",
      "github_link": "https://github.com/code-423n4/2021-08-yield-findings/issues/26",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "25",
      "slug": "h-01-compositemultioracle-returns-wrong-decimals-for-prices-code4rena-yield-yield-micro-contest-1-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Yield",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Yield",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    },
    {
      "id": "412",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "889",
      "title": "[M-03] BaseVaultAdaptor assumes sharePrice is always in underlying decimals",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\n## Vulnerability Details\nThe two `BaseVaultAdaptor.calculateShare` functions computes `share = amount.mul(uint256(10)**decimals).div(sharePrice)`\n\n```solidity\nuint256 sharePrice = _getVaultSharePrice();\n// amount is in \"token\" decimals, share should be in \"vault\" decimals\nshare = amount.mul(uint256(10)**decimals).div(sharePrice);\n```\n\nThis assumes that the `sharePrice` is always in _token_ decimals and that _token_ decimals is the same as _vault_ decimals.\n\nThis both happens to be the case for Yearn vaults, but will not necessarily be the case for other protocols.\nAs this functionality is in the `BaseVaultAdaptor` and not in the specific `VaultAdaptorYearnV2_032`, consider generalizing the conversion.\n\n## Impact\nIntegrating a token where the token or price is reported in a different precision will lead to potential losses as more shares are computed.\n\n## Recommended Mitigation Steps\nThe conversion seems highly protocol specific, `calculateShare` should be an abstract function like `_getVaultSharePrice`, that is implemented in the specific adaptors.",
      "summary": "\nThis bug report is about the two BaseVaultAdaptor.calculateShare functions, which are used to compute the amount of shares a user can purchase. Currently, this calculation assumes that the sharePrice is always in token decimals and that token decimals is the same as vault decimals. This is true for Yearn vaults, but not necessarily for other protocols. As a result, integrating a token where the token or price is reported in a different precision can lead to potential losses as more shares are computed. To mitigate this issue, the conversion should be made more general, and the calculateShare function should be an abstract function that is implemented in the specific adaptors.",
      "report_date": {},
      "contest_prize_txt": "$100,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-07-gro-protocol-contest",
      "sponsor_name": "Gro Protocol",
      "sponsor_link": "https://twitter.com/groprotocol",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2021-06-gro",
      "github_link": "https://github.com/code-423n4/2021-06-gro-findings/issues/114",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "17",
      "slug": "m-03-basevaultadaptor-assumes-shareprice-is-always-in-underlying-decimals-code4rena-gro-protocol-gro-protocol-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Gro Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Gro Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        }
      ]
    }
  ]
}