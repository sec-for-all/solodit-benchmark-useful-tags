{
  "tag": "Deposit/Reward tokens",
  "count": 18,
  "metadata": {
    "totalResults": 18,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 17,
    "reset": 1771761000
  },
  "findings": [
    {
      "id": "63648",
      "kind": "MARKDOWN",
      "auditfirm_id": "16",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "3577",
      "title": "[M-01] Minting of `fToken` and `xToken` allowed during stability mode",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium  \n\n**Likelihood:** Medium  \n\n## Description\n\nThe `Market.mint()` function mints both fToken and xToken [based on the current collateral ratio](https://github.com/RegnumAurumAcquisitionCorp/fx-contracts/blob/main/contracts/f(x)/math/FxLowVolatilityMath.sol#L293-L307).  \nIn the original Aladdin implementation, this function could be called only once. However, RegnumFx [removed this restriction](https://github.com/RegnumAurumAcquisitionCorp/fx-contracts/compare/bbb461cba879349c24c02d87872e93ec0a1a1975...f6e865df2dd46d67a49391d94e54b26e6a8af43c#diff-2c8d19ba3d13b72d110c2a9536e5e9915118ad919b38848357200e91afb683faL252), allowing it to be called multiple times.\n\nWhen the system enters stability mode, the collateral ratio has fallen below the defined safe threshold. This indicates that additional base tokens need to be deposited to restore the ratio.\n\nAllowing `mint()` during stability mode worsens the problem: each new mint increases the number of fTokens in circulation, which in turn raises the amount of base tokens required to bring the system back to a healthy state. As a result, recovery becomes more difficult, and the system may remain undercollateralized for longer.\n\nThe severity chosen for this issue is medium, because only whitelisted managers can use the function, and they are trusted entities that are not interested in making stablecoin depeg.\n\n## Recommendations\n\nRestrict `mint()` from being called when the system is in stability mode to prevent further dilution of collateralization and to simplify recovery.\n\n\n",
      "summary": "\nThe bug report discusses an issue with the `Market.mint()` function, which creates both fTokens and xTokens based on the current collateral ratio. The original implementation only allowed this function to be called once, but a recent change has removed this restriction. This means that the function can now be called multiple times, even during stability mode when the collateral ratio has fallen below a safe threshold. This makes it more difficult for the system to recover, as each new mint increases the amount of base tokens needed to restore the ratio. The report recommends restricting the function from being called during stability mode to prevent further problems. The severity of this issue is considered medium, as only trusted entities are able to use the function and they are not likely to intentionally harm the stability of the system.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 3,
      "general_score": 2,
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/RWf(x)-security-review_2025-08-20.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "m-01-minting-of-ftoken-and-xtoken-allowed-during-stability-mode-pashov-audit-group-none-rwfx_2025-08-20-markdown",
      "firm_name": "Pashov Audit Group",
      "firm_logo_square": "Pashov_square.png",
      "protocol_name": "RWf(x)_2025-08-20",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
      },
      "protocols_protocol": {
        "name": "RWf(x)_2025-08-20",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Precision Loss"
          }
        },
        {
          "tags_tag": {
            "title": "Protocol Reserve"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "MinOut/MaxIn Validation"
          }
        },
        {
          "tags_tag": {
            "title": "Pre/Post Balance"
          }
        }
      ]
    },
    {
      "id": "30745",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 58,
      "protocol_id": "1286",
      "title": "[H-01] Holders array can be manipulated by transferring or burning with amount 0, stealing rewards or bricking certain functions",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/main/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L214-L231>\n\n### Impact\n\n`LiquidInfrastructureERC20._beforeTokenTransfer()` checks if the `to` address has a balance of `0`, and if so, adds the address to the holders array.\n\n[LiquidInfrastructureERC20#L142-145](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/main/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L142-L145)\n\n```solidity\nbool exists = (this.balanceOf(to) != 0);\nif (!exists) {\n    holders.push(to);\n}\n```\n\nHowever, the ERC20 contract allows for transferring and burning with `amount = 0`, enabling users to manipulate the holders array.\n\nAn approved user that has yet to receive tokens can initiate a transfer from another address to themself with an amount of `0`. This enables them to add their address to the holders array multiple times. Then, `LiquidInfrastructureERC20.distribute()` will loop through the user multiple times and give the user more rewards than it should.\n\n```solidity\nfor (i = nextDistributionRecipient; i < limit; i++) {\n    address recipient = holders[i];\n    if (isApprovedHolder(recipient)) {\n        uint256[] memory receipts = new uint256[](\n            distributableERC20s.length\n        );\n        for (uint j = 0; j < distributableERC20s.length; j++) {\n            IERC20 toDistribute = IERC20(distributableERC20s[j]);\n            uint256 entitlement = erc20EntitlementPerUnit[j] *\n                this.balanceOf(recipient);\n            if (toDistribute.transfer(recipient, entitlement)) {\n                receipts[j] = entitlement;\n            }\n        }\n\n        emit Distribution(recipient, distributableERC20s, receipts);\n    }\n}\n```\n\nThis also enables any user to call burn with an amount of `0`, which will push the zero address to the holders array causing it to become very large and prevent `LiquidInfrastructureERC20.distributeToAllHolders()` from executing.\n\n### Proof of Concept\n\n```typescript\nit(\"malicious user can add himself to holders array multiple times and steal rewards\", async function () {\n    const { infraERC20, erc20Owner, nftAccount1, holder1, holder2 } = await liquidErc20Fixture();\n    const nft = await deployLiquidNFT(nftAccount1);\n    const erc20 = await deployERC20A(erc20Owner);\n\n    await nft.setThresholds([await erc20.getAddress()], [parseEther('100')]);\n    await nft.transferFrom(nftAccount1.address, await infraERC20.getAddress(), await nft.AccountId());\n    await infraERC20.addManagedNFT(await nft.getAddress());\n    await infraERC20.setDistributableERC20s([await erc20.getAddress()]);\n\n    const OTHER_ADDRESS = '0x1111111111111111111111111111111111111111'\n\n    await infraERC20.approveHolder(holder1.address);\n    await infraERC20.approveHolder(holder2.address);\n\n    // Malicious user transfers 0 to himself to add himself to the holders array\n    await infraERC20.transferFrom(OTHER_ADDRESS, holder1.address, 0);\n\n    // Setup balances\n    await infraERC20.mint(holder1.address, parseEther('1'));\n    await infraERC20.mint(holder2.address, parseEther('1'));\n    await erc20.mint(await nft.getAddress(), parseEther('2'));\n    await infraERC20.withdrawFromAllManagedNFTs();\n\n    // Distribute to all holders fails because holder1 is in the holders array twice\n    // Calling distribute with 2 sends all funds to holder1\n    await mine(500);\n    await expect(infraERC20.distributeToAllHolders()).to.be.reverted;\n    await expect(() => infraERC20.distribute(2))\n        .to.changeTokenBalances(erc20, [holder1, holder2], [parseEther('2'), parseEther('0')]);\n    expect(await erc20.balanceOf(await infraERC20.getAddress())).to.eq(parseEther('0'));\n});\n\nit(\"malicious user can add zero address to holders array\", async function () {\n    const { infraERC20, erc20Owner, nftAccount1, holder1 } = await liquidErc20Fixture();\n\n    for (let i = 0; i < 10; i++) {\n        await infraERC20.burn(0);\n    }\n    // I added a getHolders view function to better see this vulnerability\n    expect((await infraERC20.getHolders()).length).to.eq(10);\n});\n```\n\n### Recommended Mitigation Steps\n\nAdjust the logic in `_beforeTokenTransfer` to ignore burns, transfers where the amount is `0`, and transfers where the recipient already has a positive balance.\n\n```diff\nfunction _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n) internal virtual override {\n    require(!LockedForDistribution, \"distribution in progress\");\n    if (!(to == address(0))) {\n        require(\n            isApprovedHolder(to),\n            \"receiver not approved to hold the token\"\n        );\n    }\n    if (from == address(0) || to == address(0)) {\n        _beforeMintOrBurn();\n    }\n-   bool exists = (this.balanceOf(to) != 0);\n-   if (!exists) {\n+   if (to != address(0) && balanceOf(to) == 0 && amount > 0)\n       holders.push(to);\n   }\n}\n```\n\n### Assessed type\n\nToken Transfer\n\n**[ChristianBorst (Althea) confirmed and commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/77#issuecomment-1973729369):**\n > This is a significant issue since it is a DoS attack vector and can cause miscalculation of entitlements. I also think the report is very clear in outlining the issue.\n\n***\n \n",
      "summary": "\nThis bug report addresses a vulnerability in the LiquidInfrastructureERC20 contract. The contract checks if the recipient of a token transfer has a balance of 0 and if so, adds them to the holders array. However, the ERC20 standard allows for transfers and burns with an amount of 0, enabling users to manipulate the holders array. This can lead to a DoS attack and miscalculation of rewards. The recommended mitigation step is to adjust the logic in the `_beforeTokenTransfer` function to ignore transfers with an amount of 0 and transfers to recipients with a positive balance. This bug is classified as a Token Transfer type and has been confirmed by ChristianBorst (Althea). ",
      "report_date": {},
      "contest_prize_txt": "24500",
      "contest_link": "https://code4rena.com/reports/2024-02-althea-liquid-infrastructure",
      "sponsor_name": "Althea Liquid Infrastructure",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-02-althea-liquid-infrastructure",
      "github_link": "https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/77",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "331",
      "slug": "h-01-holders-array-can-be-manipulated-by-transferring-or-burning-with-amount-0-stealing-rewards-or-bricking-certain-functions-code4rena-althea-liquid-infrastructure-althea-liquid-infrastructure-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Althea Liquid Infrastructure",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Althea Liquid Infrastructure",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Denial-Of-Service"
          }
        }
      ]
    },
    {
      "id": "21961",
      "kind": "MARKDOWN",
      "auditfirm_id": "11",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "1045",
      "title": "Non-standard ERC20 tokens are not supported",
      "content": "**Severity:** Medium\n\n**Description:** The protocol implemented a function `deposit()` to allow users to deposit.\n```solidity\nDepositVault.sol\n37:     function deposit(uint256 amount, address tokenAddress) public payable {\n38:         require(amount > 0 || msg.value > 0, \"Deposit amount must be greater than 0\");\n39:         if(msg.value > 0) {\n40:             require(tokenAddress == address(0), \"Token address must be 0x0 for ETH deposits\");\n41:             uint256 depositIndex = deposits.length;\n42:             deposits.push(Deposit(payable(msg.sender), msg.value, tokenAddress));\n43:             emit DepositMade(msg.sender, depositIndex, msg.value, tokenAddress);\n44:         } else {\n45:             require(tokenAddress != address(0), \"Token address must not be 0x0 for token deposits\");\n46:             IERC20 token = IERC20(tokenAddress);\n47:             token.safeTransferFrom(msg.sender, address(this), amount);\n48:             uint256 depositIndex = deposits.length;\n49:             deposits.push(Deposit(payable(msg.sender), amount, tokenAddress));//@audit-issue fee-on-transfer, rebalancing tokens will cause problems\n50:             emit DepositMade(msg.sender, depositIndex, amount, tokenAddress);\n51:\n52:         }\n53:     }\n```\nLooking at the line L49, we can see that the protocol assumes `amount` of tokens were transferred.\nBut this does not hold true for some non-standard ERC20 tokens like fee-on-transfer tokens or rebalancing tokens.\n(Refer to [here](https://github.com/d-xo/weird-erc20) about the non-standard weird ERC20 tokens)\n\nFor example, if token incurs fee on transfer, the actually transferred amount will be less than the provided parameter `amount` and the `deposits` will have a wrong state value. Because the current implementation only allows full withdrawal, this means the tokens will be locked in the contract permanently.\n\n**Impact:** If non-standard ERC20 tokens are used, the tokens could be locked in the contract permanently.\n\n**Recommended Mitigation:**\n- We recommend adding another field in the `Deposit` structure, say `balance`\n- We recommend allow users to withdraw partially and decrease the `balance` field appropriately for successful withdrawals.\nIf these changes are going to be made, we note that there are other parts that need changes. For example, the withdraw function would need to be updated so that it does not require the withdrawal amount is same to the original deposit amount.\n\n**Protocol:**\nContract updated to support non-standard ERC-20 tokens. We've decided to not allow users to partially withdraw since it would complicate the logic of the signatures, as of now only full withdraws can be executed.\n\n**Cyfrin:** Verified in commit [405fa78](https://github.com/HyperGood/woosh-contracts/commit/405fa78a2c0cf8b8ab8943484cb95b5c8807cbfb).",
      "summary": "\nA bug was found in the protocol implemented with the function `deposit()` that allows users to deposit. If non-standard ERC20 tokens are used, the tokens could be locked in the contract permanently. This is because the protocol assumes a certain amount of tokens were transferred, but this does not hold true for some non-standard ERC20 tokens like fee-on-transfer tokens or rebalancing tokens. To mitigate this, the protocol was updated to support non-standard ERC-20 tokens. The `Deposit` structure was updated with a new field called `balance` and full withdrawals can be executed. This update was verified in commit 405fa78.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-06-Woosh Deposit Vault.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "non-standard-erc20-tokens-are-not-supported-cyfrin-none-woosh-deposit-vault-markdown",
      "firm_name": "Cyfrin",
      "firm_logo_square": "Cyfrin_square.jpg",
      "protocol_name": "Woosh Deposit Vault",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
      },
      "protocols_protocol": {
        "name": "Woosh Deposit Vault",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Fee On Transfer"
          }
        },
        {
          "tags_tag": {
            "title": "Rebasing Tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Pre/Post Balance"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Weird ERC20"
          }
        }
      ]
    },
    {
      "id": "27086",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 22,
      "protocol_id": "1077",
      "title": "H-10: Immediately start getting rewards belonging to others after staking",
      "content": "Source: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/603 \n\n## Found by \n0x73696d616f, 0xGoodess, 0xJuda, 0xTheC0der, 0xdeadbeef, 0xvj, Ch\\_301, Kalyan-Singh, MrjoryStewartBaxter, VAD37, berndartmueller, bin2chen, caelumimperium, carrotsmuggler, jecikpo, l3r0ux, lemonmon, pengun, saidam017, talfao, wangxx2026, xiaoming90\n\nMalicious users could abuse the accounting error to immediately start getting rewards belonging to others after staking, leading to a loss of reward tokens.\n\n## Vulnerability Detail\n\n> **Note**\n> This issue affects both LMPVault and DV since they use the same underlying reward contract.\n\nAssume a new user called Bob mints 100 LMPVault or DV shares. The ERC20's `_mint` function will be called, which will first increase Bob's balance at Line 267 and then trigger the `_afterTokenTransfer` hook at Line 271.\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/0457042d93d9dfd760dbaa06a4d2f1216fdbe297/contracts/token/ERC20/ERC20.sol#L259\n\n```solidity\nFile: ERC20.sol\n259:     function _mint(address account, uint256 amount) internal virtual {\n..SNIP..\n262:         _beforeTokenTransfer(address(0), account, amount);\n263: \n264:         _totalSupply += amount;\n265:         unchecked {\n266:             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n267:             _balances[account] += amount;\n268:         }\n..SNIP..\n271:         _afterTokenTransfer(address(0), account, amount);\n272:     }\n```\n\nThe `_afterTokenTransfer` hook will automatically stake the newly minted shares to the rewarder contracts on behalf of Bob.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L854\n\n```solidity\nFile: LMPVault.sol\n854:     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n..SNIP..\n862:         if (to != address(0)) {\n863:             rewarder.stake(to, amount);\n864:         }\n865:     }\n```\n\nWithin the `MainRewarder.stake` function, it will first call the `_updateReward` function at Line 87 to take a snapshot of accumulated rewards. Since Bob is a new user, his accumulated rewards should be zero. However, this turned out to be false due to the bug described in this report.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/MainRewarder.sol#L86\n\n```solidity\nFile: MainRewarder.sol\n86:     function stake(address account, uint256 amount) public onlyStakeTracker {\n87:         _updateReward(account);\n88:         _stake(account, amount);\n89: \n90:         for (uint256 i = 0; i < extraRewards.length; ++i) {\n91:             IExtraRewarder(extraRewards[i]).stake(account, amount);\n92:         }\n93:     }\n```\n\nWhen the `_updateReward` function is executed, it will compute Bob's earned rewards.  It is important to note that at this point, Bob's balance has already been updated to 100 shares in the `stakeTracker` contract, and `userRewardPerTokenPaid[Bob]` is zero.\n\nBob's earned reward will be as follows, where $r$ is the `rewardPerToken()`:\n\n$$\nearned(Bob) = 100\\ {shares \\times (r - 0)} = 100r\n$$\n\nBob immediately accumulated a reward of $100r$ upon staking into the rewarder contract, which is incorrect. Bob could withdraw $100r$ reward tokens that do not belong to him.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol#L128\n\n```solidity\nFile: AbstractRewarder.sol\n128:     function _updateReward(address account) internal {\n129:         uint256 earnedRewards = 0;\n130:         rewardPerTokenStored = rewardPerToken();\n131:         lastUpdateBlock = lastBlockRewardApplicable();\n132: \n133:         if (account != address(0)) {\n134:             earnedRewards = earned(account);\n135:             rewards[account] = earnedRewards;\n136:             userRewardPerTokenPaid[account] = rewardPerTokenStored;\n137:         }\n138: \n139:         emit UserRewardUpdated(account, earnedRewards, rewardPerTokenStored, lastUpdateBlock);\n140:     }\n..SNIP..\n155:     function balanceOf(address account) public view returns (uint256) {\n156:         return stakeTracker.balanceOf(account);\n157:     }\n..SNIP..\n204:     function earned(address account) public view returns (uint256) {\n205:         return (balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18) + rewards[account];\n206:     }\n```\n\n## Impact\n\nLoss of reward tokens for the vault shareholders.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L854\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/MainRewarder.sol#L86\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol#L128\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the balance of the users in the rewarder contract is only incremented after the `_updateReward` function is executed.\n\nOne option is to track the balance of the staker and total supply internally within the rewarder contract and avoid reading the states in the `stakeTracker` contract, commonly seen in many reward contracts.\n\n```diff\nFile: AbstractRewarder.sol\nfunction balanceOf(address account) public view returns (uint256) {\n-   return stakeTracker.balanceOf(account);\n+\treturn _balances[account];\n}\n```\n\n```diff\nFile: AbstractRewarder.sol\nfunction _stake(address account, uint256 amount) internal {\n    Errors.verifyNotZero(account, \"account\");\n    Errors.verifyNotZero(amount, \"amount\");\n    \n+    _totalSupply += amount\n+    _balances[account] += amount\n\n    emit Staked(account, amount);\n}\n```",
      "summary": "\nThis bug report is about an accounting error in the rewarder contract that allows malicious users to immediately start getting rewards belonging to others after staking, leading to a loss of reward tokens. The bug is caused by the `_updateReward` function being called after the user's balance is updated in the `stakeTracker` contract, resulting in the user accumulating rewards that do not belong to them. This issue affects both LMPVault and DV since they use the same underlying reward contract. \n\nTo fix this issue, it is recommended to track the balance of the staker and total supply internally within the rewarder contract and avoid reading the states in the `stakeTracker` contract. This can be done by replacing the `stakeTracker.balanceOf(account)` with `_balances[account]` in the `balanceOf` function and by adding the `_totalSupply += amount` and `_balances[account] += amount` in the `_stake` function.",
      "report_date": {},
      "contest_prize_txt": "144000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/101",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/603",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "101",
      "slug": "h-10-immediately-start-getting-rewards-belonging-to-others-after-staking-sherlock-tokemak-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Tokemak",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Tokemak",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        }
      ]
    },
    {
      "id": "18508",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "618",
      "title": "H-1: AuraSpell#openPositionFarm fails to return all rewards to user",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29 \n\n## Found by \n0x52, nobody2018\n## Summary\n\nWhen a user adds to an existing position on AuraSpell, the contract burns their current position and remints them a new one. The issues is that WAuraPool will send all reward tokens to the contract but it only sends Aura back to the user, causing all other rewards to be lost.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L256-L261\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n\nInside WAuraPools#burn reward tokens are sent to the user.\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L130-L140\n\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wAuraPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(AURA);\n        }\n\nWe see above that the contract only refunds Aura to the user causing all other extra reward tokens received by the contract to be lost to the user.\n\n## Impact\n\nUser will lose all extra reward tokens from their original position\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWAuraPool returns the reward tokens it sends. Use this list to refund all tokens to the user\n\n\n\n## Discussion\n\n**sleepriverfish**\n\nEscalate for 10 USDC.\nThe issue was  excluded from #Blueberry Update, it appears to have been rewarded in #Blueberry Update 2.\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> The issue was  excluded from #Blueberry Update, it appears to have been rewarded in #Blueberry Update 2.\n> https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nEscalate for 10 USDC\nvalid H. Nobody escalated [it](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42) \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> valid H. Nobody escalated [it](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42) \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with second escalation\n\n**sleepriverfish**\n\nSo, the issue https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42 considered invalid? I believe it should be categorized and rewarded in some way.\n\n**hrishibhat**\n\nEscalation rejected\n\nValid high\nThe issue mentioned above has been resolved accordingly in the respective contest. \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid high\n> The issue mentioned above has been resolved accordingly in the respective contest. \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nA bug report has been raised in the Sherlock Audit repository about an issue with the AuraSpell#openPositionFarm contract. It was found by 0x52 and nobody2018 and is related to the WAuraPool contract. The issue is that when a user adds to an existing position on AuraSpell, the contract burns their current position and remints them a new one. However, the WAuraPool contract only sends the Aura token back to the user, causing all other rewards to be lost. \n\nThe vulnerability detail is that inside the WAuraPools#burn function, reward tokens are sent to the user. However, in the AuraSpell#openPositionFarm function, the contract only refunds Aura to the user, causing all other extra reward tokens received by the contract to be lost to the user. \n\nThe impact of this bug is that users will lose all extra reward tokens from their original position.\n\nThe tool used to identify this bug was manual review. The recommendation is that WAuraPool should be modified to return the reward tokens it sends. This list should then be used to refund all tokens to the user.\n\nThe issue was discussed and it was decided that the issue mentioned previously had been resolved accordingly in the respective contest, so the escalation was rejected. Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "report_date": {},
      "contest_prize_txt": "24000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/77",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 3,
      "general_score": 2,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "77",
      "slug": "h-1-auraspellopenpositionfarm-fails-to-return-all-rewards-to-user-sherlock-none-blueberry-update-2-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update #2",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update #2",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Check Return Value"
          }
        },
        {
          "tags_tag": {
            "title": "Missing-Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Fund Lock"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        }
      ]
    },
    {
      "id": "18506",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "617",
      "title": "M-12: rewardTokens removed from WAuraPool/WConvexPools will be lost forever",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/128 \n\n## Found by \n0x52\n## Summary\n\npendingRewards pulls a fresh count of reward tokens each time it is called. This is problematic if reward tokens are ever removed from the the underlying Aura/Convex pools because it means that they will no longer be distributed and will be locked in the contract forever.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L166-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L166-L189)\n\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n\nIn the lines above we can see that only tokens that are currently available on the pool. This means that if tokens are removed then they are no longer claimable and will be lost to those entitled to shares.\n\n## Impact\n\nUsers will lose reward tokens if they are removed\n\n## Code Snippet\n\n[WAuraPools.sol#L152-L190](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L152-L190)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReward tokens should be stored with the tokenID so that it can still be paid out even if it the extra rewardToken is removed.",
      "summary": "\nThis bug report is about an issue with reward tokens being removed from the WAuraPool/WConvexPools contract in the Sherlock Audit 2023-04-blueberry-judging project. The bug was found by 0x52 and it was identified through manual review. \n\nThe code snippet shows that only tokens that are currently available in the pool are taken into consideration when the pendingRewards function is called. This means that if tokens are removed from the pool, they will not be distributed to the users and will be locked in the contract forever. As a result, users will lose reward tokens if they are removed.\n\nThe recommendation is to store the reward tokens with the tokenID so that it can still be paid out even if the extra rewardToken is removed.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/69",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/128",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "m-12-rewardtokens-removed-from-waurapoolwconvexpools-will-be-lost-forever-sherlock-none-blueberry-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Lending Pool"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Configuration"
          }
        },
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        }
      ]
    },
    {
      "id": "18497",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "617",
      "title": "M-3: The protocol  will not be able to add liquidity on the curve with another token with a balance.",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47 \n\n## Found by \nBauer, nobody2018\n## Summary\nThe `CurveSpell` protocol only ensure approve curve pool to spend its borrow token. Hence, it will not be able to add liquidity on the curve with another token with a balance.\n\n## Vulnerability Detail\nThe  `openPositionFarm()` function enables user to open a leveraged position in a yield farming strategy by borrowing funds and using them to add liquidity to a Curve pool, while also taking into account certain risk management parameters such as maximum LTV and position size. When add liquidity on curve ,the protocol use the borrowed token and the collateral token, it checks the number of tokens in the pool and creates an array of the supplied token amounts to be passed to the add_liquidity function. Then the curve will transfer the tokens from the protocol and mint lp tokens to the protocol. However, the protocol only ensure approve curve pool to spend its borrow token. Hence, it will not be able to add liquidity on the curve with another token with a balance.\n```solidity\n // 3. Add liquidity on curve\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n```\n\n## Impact\nThe protocol  will not be able to add liquidity on the curve with another token with a balance.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L90-L115\n## Tool used\n\nManual Review\n\n## Recommendation\nAllow the curve pool to spend tokens that have a balance in the protocol to add liquidity",
      "summary": "\nThis bug report is about the `CurveSpell` protocol, which is used to open leveraged positions in a yield farming strategy. The protocol only ensures approve curve pool to spend its borrow token, and hence it will not be able to add liquidity on the curve with another token with a balance. This is because the `openPositionFarm()` function creates an array of the supplied token amounts to be passed to the add_liquidity function, but it only checks the number of tokens in the pool and not the balance of the tokens.\n\nThe impact of this bug is that the protocol will not be able to add liquidity on the curve with another token with a balance. The code snippet for this bug can be found at https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L90-L115. This bug was found by Bauer and nobody2018 using manual review.\n\nThe recommendation to fix this bug is to allow the curve pool to spend tokens that have a balance in the protocol to add liquidity.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/69",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "m-3-the-protocol-will-not-be-able-to-add-liquidity-on-the-curve-with-another-token-with-a-balance-sherlock-none-blueberry-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Missing-Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Coding-Bug"
          }
        }
      ]
    },
    {
      "id": "18483",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 7,
      "protocol_id": "617",
      "title": "H-3: Users are forced to swap all reward tokens with no slippage protection",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/121 \n\n## Found by \n0x52, Bauer, Breeje, J4de, ctf\\_sec, n1punp, nobody2018\n## Summary\n\nAuraSpell forces users to swap their reward tokens to debt token but doesn't allow them to specify any slippage values.\n\n## Vulnerability Detail\n\n[AuraSpell.sol#L193-L203\n](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L193-L203)\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\nAbove all reward tokens are swapped and always use 0 for min out meaning that deposits will be sandwiched and stolen.\n\n## Impact\n\nAll reward tokens can be sandwiched and stolen\n\n## Code Snippet\n\n[AuraSpell.sol#L149-L224](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow user to specify slippage parameters for all reward tokens",
      "summary": "\nThis bug report is about an issue found in the AuraSpell.sol contract, which is part of the Sherlock Audit project. The issue is that users are forced to swap all reward tokens with no slippage protection. This was found through manual review by 0x52, Bauer, Breeje, J4de, ctf_sec, n1punp, and nobody2018.\n\nThe vulnerability detail is that the code snippet for the swap function does not allow users to specify any slippage values, meaning that deposits can be sandwiched and stolen. This can result in all reward tokens being sandwiched and stolen. The code snippet for the vulnerability can be found in AuraSpell.sol#L193-L203 and the full code snippet can be found in AuraSpell.sol#L149-L224.\n\nThe impact of this vulnerability is that all reward tokens can be sandwiched and stolen. The recommendation for this issue is to allow users to specify slippage parameters for all reward tokens.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/69",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/121",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "h-3-users-are-forced-to-swap-all-reward-tokens-with-no-slippage-protection-sherlock-none-blueberry-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Slippage"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        }
      ]
    },
    {
      "id": "18481",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "617",
      "title": "H-1: attackers will keep stealing the `rewards` from Convex SPELL",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/101 \n\n## Found by \nBauer, Ch\\_301\n## Summary\nOn [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) transfer [CRV + CVX + the extra rewards](https://docs.convexfinance.com/convexfinance/general-information/why-convex/convex-for-liquidity-providers) to Convex SPELL \n\n\n## Vulnerability Detail\nBut [ConvexSpell.openPositionFarm()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L67-L138) only refund CVX to the user.\nSo the rest rewards will stay in the SPELL intel if someone (could be an attacker) invokes `_doRefund()` within `closePositionFarm()` with the same address tokens \n\n## Impact\n- Convex SPELL steals the user rewards \n- the protocol will lose some fees \n- attackers will keep stealing the rewards from Convex SPELL\n\n## Code Snippet\n`WConvexPools.burn()` transfer CRV + CVX + the extra rewards\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235\n```solidity\n        // Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n```\n\nonly refund CVX to the user\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#LL127C1-L138C10\n```solidity\n        // 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wConvexPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CVX);\n        }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nyou should Refund all Rewards (CRV + CVX + the extra rewards)\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nConvex docs are confirming this point \n\n```diff\nConvex allows liquidity providers to earn trading fees and claim boosted CRV without locking CRV themselves. Liquidity providers can receive boosted CRV and liquidity mining rewards with minimal effort:\nEarn claimable CRV with a high boost without locking any CRV\nEarn CVX rewards\nZero deposit and withdraw fees\nZero fees on extra incentive tokens (SNX, etc)\n```\nand [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) handle this properly\n\nso Convex SPELL should refund all the rewards\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Convex docs are confirming this point \n> \n> ```diff\n> Convex allows liquidity providers to earn trading fees and claim boosted CRV without locking CRV themselves. Liquidity providers can receive boosted CRV and liquidity mining rewards with minimal effort:\n> Earn claimable CRV with a high boost without locking any CRV\n> Earn CVX rewards\n> Zero deposit and withdraw fees\n> Zero fees on extra incentive tokens (SNX, etc)\n> ```\n> and [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) handle this properly\n> \n> so Convex SPELL should refund all the rewards\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nSenior watson's comment:\n\nsame as\nhttps://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29 \n\n**hrishibhat**\n\nEscalation accepted\n\nValid high \nThis issue is a valid high along with another duplicate #42\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid high \n> This issue is a valid high along with another duplicate #42\n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the Convex SPELL code. The code allows users to transfer CRV, CVX, and extra rewards to the SPELL, but only refunds CVX to the user when the position is closed. This means that the extra rewards remain in the SPELL, and can be stolen by attackers if they invoke the same address tokens with the _doRefund() function. This vulnerability can cause the Convex SPELL to steal user rewards, leading to the protocol losing fees, and attackers being able to keep stealing rewards from the SPELL. The code snippet provided in the report shows the WConvexPools.burn() function, which transfers CRV, CVX, and extra rewards, and the ConvexSpell.openPositionFarm() function, which only refunds CVX to the user. The tool used to identify this bug was manual review. The recommendation is to refund all rewards (CRV + CVX + the extra rewards). The discussion that followed included a comment from Ch-301, who suggested escalating the bug for 10 USDC, and Convex docs to confirm the point. Senior Watson's comment pointed to a duplicate issue, and Hrishibhat accepted the escalation. Finally, Sherlock-Admin confirmed that the issue's escalation had been accepted, and that contestants' payouts and scores would be updated accordingly.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/69",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 1,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/101",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "h-1-attackers-will-keep-stealing-the-rewards-from-convex-spell-sherlock-none-blueberry-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Coding-Bug"
          }
        },
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        }
      ]
    },
    {
      "id": "6913",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "1",
      "title": "claimToTreasury(COMP) steals users' COMP rewards",
      "content": "## Security Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`compound/MorphoGovernance.sol#L414`\n\n## Description\nThe `claimToTreasury` function can send a market's underlying tokens that have been accumulated in the contract to the treasury. This is intended to be used for the reserve amounts that accumulate in the contract from P2P matches. However, Compound also pays out rewards in COMP, and COMP is a valid Compound market. \n\nSending the COMP reserves will also send the COMP rewards. This is especially concerning as anyone can claim COMP rewards on behalf of Morpho at any time, and the rewards will be sent to the contract. An attacker could even frontrun a `claimToTreasury(cCOMP)` call with a `Comptroller.claimComp(morpho, [cComp])` call to sabotage the reward system, resulting in users being unable to claim their rewards.\n\n## Recommendation\nIf Morpho wants to support the COMP market, consider separating the COMP reserve from the COMP rewards.\n\n## Morpho Response\nGiven the changes required and the small likelihood of setting a reserve factor for the COMP asset, and our awareness of this issue, we have decided not to implement it.\n\n## Spearbit Response\nAcknowledged.",
      "summary": "\nThis bug report is about the claimToTreasury function in the MorphoGovernance.sol#L414 contract. This function sends a market's underlying tokens that have been accumulated in the contract to the treasury. This is intended to be used for the reserve amounts that accumulate in the contract from P2P matches. However, Compound also pays out rewards in COMP and COMP is a valid Compound market. Sending the COMP reserves will also send the COMP rewards, which is bad because anyone can claim COMP rewards on the behalf of Morpho at any time and the rewards will be sent to the contract. An attacker could even frontrun a claimToTreasury(cCOMP) call with a Comptroller.claimComp(morpho, [cComp]) call to sabotage the reward system.\n\nThe recommendation is that if Morpho wants to support the COMP market, they should consider separating the COMP reserve from the COMP rewards. Morpho decided not to implement this due to the changes to do and the small likelihood to set a reserve factor for the COMP asset and the awareness on their side about this. Spearbit acknowledged this.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/MorphoV1-Spearbit-Security-Review.pdf",
      "pdf_page_from": 13,
      "contest_id": "",
      "slug": "claimtotreasurycomp-steals-users-comp-rewards-spearbit-morpho-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Morpho",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Morpho",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 1.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Derivatives"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        }
      ]
    },
    {
      "id": "6641",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "32",
      "title": "H-4: Fail to accrue interests on multiple token positions",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/140 \n\n## Found by \ncducrest-brainbot, rvierdiiev, Jeiwan\n\n## Summary\n\nIn `BlueBerryBank.sol` the functions `borrow`, `repay`, `lend`, or `withdrawLend` call `poke(token)` to trigger interest accrual on concerned token, but fail to do so for other token debts of the concerned position.  This could lead to wrong calculation of position's debt and whether the position is liquidatable.\n\n## Vulnerability Detail\n\nWhether a position is liquidatable or not is checked at the end of the `execute` function, the execution should revert if the position is liquidatable. \n\nThe calculation of whether a position is liquidatable takes into account all the different debt tokens within the position. However, the debt accrual has been triggered only for one of these tokens, the one concerned by the executed action. For other tokens, the value of `bank.totalDebt` will be lower than what it should be. This results in the debt value of the position being lower than what it should be and a position seen as not liquidatable while it should be liquidatable. \n\n## Impact\n\nUsers may be able to operate on their position leading them in a virtually liquidatable state while not reverting as interests were not applied. This will worsen the debt situation of the bank and lead to overall more liquidatable positions.\n\n## Code Snippet\n\nexecute checking isLiquidatable without triggering interests:\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L607\n\nactions only poke one token (here for borrow): \n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L709-L715\n\nbank.totalDebt is used to calculate a position's debt while looping over every tokens: \n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L451-L475\n\nThe position's debt is used to calculate the risk:\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L477-L495\n\nThe risk is used to calculate whether a debt is liquidatable:\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L497-L505\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReview how token interests are triggered. Probably need to accrue interests on every debt token of a position at the beginning of execute.",
      "summary": "\nThis bug report is about an issue in the BlueBerryBank.sol smart contract. The functions `borrow`, `repay`, `lend`, or `withdrawLend` call `poke(token)` to trigger interest accrual on the concerned token, but fail to do so for other token debts of the concerned position. This could lead to wrong calculation of position's debt and whether the position is liquidatable. \n\nThe calculation of whether a position is liquidatable takes into account all the different debt tokens within the position, but the debt accrual has been triggered only for one of these tokens. This results in the debt value of the position being lower than what it should be and a position seen as not liquidatable while it should be liquidatable. \n\nThe impact of this bug is that users may be able to operate on their position leading them in a virtually liquidatable state while not reverting as interests were not applied. This will worsen the debt situation of the bank and lead to overall more liquidatable positions.\n\nThe bug was found by cducrest-brainbot, rvierdiiev, and Jeiwan, and was identified using manual review. The recommendation is to review how token interests are triggered and to accrue interests on every debt token of a position at the beginning of execute.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/41",
      "sponsor_name": "Blueberry",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/140",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "41",
      "slug": "h-4-fail-to-accrue-interests-on-multiple-token-positions-sherlock-blueberry-blueberry-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Missing-Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        }
      ]
    },
    {
      "id": "6640",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 14,
      "protocol_id": "32",
      "title": "H-3: LP tokens are not sent back to withdrawing user",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/151 \n\n## Found by \nrvierdiiev, minhtrng, Dug, Jeiwan, obront, chaduke, koxuan, sinarette, Ch\\_301, cergyk, evan, berndartmueller, 0x52, Bauer\n\n## Summary\n\nWhen users withdraw their assets from `IchiVaultSpell.sol`, the function unwinds their position and sends them back their assets, but it never sends them back the amount they requested to withdraw, leaving the tokens stuck in the Spell contract.\n\n## Vulnerability Detail\n\nWhen a user withdraws from `IchiVaultSpell.sol`, they either call `closePosition()` or `closePositionFarm()`, both of which make an internal call to `withdrawInternal()`.\n\nThe following arguments are passed to the function:\n- strategyId: an index into the `strategies` array, which specifies the Ichi vault in question\n- collToken: the underlying token, which is withdrawn from Compound\n- amountShareWithdraw: the number of underlying tokens to withdraw from Compound\n- borrowToken: the token that was borrowed from Compound to create the position, one of the underlying tokens of the vault\n- amountRepay: the amount of the borrow token to repay to Compound\n- amountLpWithdraw: the amount of the LP token to withdraw, rather than trade back into borrow tokens\n\nIn order to accomplish these goals, the contract does the following...\n\n1) Removes the LP tokens from the ERC1155 holding them for collateral.\n```solidity\ndoTakeCollateral(strategies[strategyId].vault, lpTakeAmt);\n```\n2) Calculates the number of LP tokens to withdraw from the vault.\n```solidity\nuint256 amtLPToRemove = vault.balanceOf(address(this)) - amountLpWithdraw;\nvault.withdraw(amtLPToRemove, address(this));\n```\n\n3) Converts the non-borrowed token that was withdrawn in the borrowed token (not copying the code in, as it's not relevant to this issue).\n\n4) Withdraw the underlying token from Compound.\n```solidity\ndoWithdraw(collToken, amountShareWithdraw);\n```\n\n5) Pay back the borrowed token to Compound.\n```solidity\ndoRepay(borrowToken, amountRepay);\n```\n\n6) Validate that this situation does not put us above the maxLTV for our loans.\n```solidity\n_validateMaxLTV(strategyId);\n```\n\n7) Sends the remaining borrow token that weren't paid back and withdrawn underlying tokens to the user.\n```solidity\ndoRefund(borrowToken);\ndoRefund(collToken);\n```\n\nCrucially, the step of sending the remaining LP tokens to the user is skipped, even though the function specifically does the calculations to ensure that `amountLpWithdraw` is held back from being taken out of the vault.\n\n## Impact\n\nUsers who close their positions and choose to keep LP tokens (rather than unwinding the position for the constituent tokens) will have their LP tokens stuck permanently in the IchiVaultSpell contract.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L276-L330\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd an additional line to the `withdrawInternal()` function to refund all LP tokens as well:\n\n```diff\n  doRefund(borrowToken);\n  doRefund(collToken);\n+ doRefund(address(vault));\n```\n\n## Discussion\n\n**Gornutz**\n\nduplicate of 34",
      "summary": "\nThis bug report is about an issue where LP tokens are not sent back to withdrawing users when assets are withdrawn from the `IchiVaultSpell.sol` function. This issue was found by a group of people and the vulnerability detail was found by manually reviewing the code. The impact of the issue is that users who close their positions and choose to keep LP tokens will have their LP tokens stuck permanently in the IchiVaultSpell contract.\n\nThe code snippet that is relevant to this issue is located at https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L276-L330. The recommendation to resolve this issue is to add an additional line to the `withdrawInternal()` function to refund all LP tokens as well.\n\nThe discussion section mentions that this issue is a duplicate of issue 34. This means that the same issue has been reported before and the same solution can be used.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/41",
      "sponsor_name": "Blueberry",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/151",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "41",
      "slug": "h-3-lp-tokens-are-not-sent-back-to-withdrawing-user-sherlock-blueberry-blueberry-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Missing-Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        }
      ]
    },
    {
      "id": "6639",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 8,
      "protocol_id": "32",
      "title": "H-2: Users who deposit extra funds into their Ichi farming positions will lose all their ICHI rewards",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/158 \n\n## Found by \ncarrot, rvierdiiev, minhtrng, obront, sinarette, tives, berndartmueller, 0x52\n\n## Summary\n\nWhen a user deposits extra funds into their Ichi farming position using `openPositionFarm()`, the old farming position will be closed down and a new one will be opened. Part of this process is that their ICHI rewards will be sent to the `IchiVaultSpell.sol` contract, but they will not be distributed. They will sit in the contract until the next user (or MEV bot) calls `closePositionFarm()`, at which point they will be stolen by that user.\n\n## Vulnerability Detail\n\nWhen Ichi farming positions are opened via the `IchiVaultSpell.sol` contract, `openPositionFarm()` is called. It goes through the usual deposit function, but rather than staking the LP tokens directly, it calls `wIchiFarm.mint()`. This function deposits the token into the `ichiFarm`, encodes the deposit as an ERC1155, and sends that token back to the Spell:\n```solidity\nfunction mint(uint256 pid, uint256 amount)\n    external\n    nonReentrant\n    returns (uint256)\n{\n    address lpToken = ichiFarm.lpToken(pid);\n    IERC20Upgradeable(lpToken).safeTransferFrom(\n        msg.sender,\n        address(this),\n        amount\n    );\n    if (\n        IERC20Upgradeable(lpToken).allowance(\n            address(this),\n            address(ichiFarm)\n        ) != type(uint256).max\n    ) {\n        // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n        IERC20Upgradeable(lpToken).safeApprove(\n            address(ichiFarm),\n            type(uint256).max\n        );\n    }\n    ichiFarm.deposit(pid, amount, address(this));\n    // @ok if accIchiPerShare is always changing, so how does this work?\n    // it's basically just saving the accIchiPerShare at staking time, so when you unstake, it can calculate the difference\n    // really fucking smart actually\n    (uint256 ichiPerShare, , ) = ichiFarm.poolInfo(pid);\n    uint256 id = encodeId(pid, ichiPerShare);\n    _mint(msg.sender, id, amount, \"\");\n    return id;\n}\n```\nThe resulting ERC1155 is posted as collateral in the Blueberry Bank.\n\nIf the user decides to add more funds to this position, they simply call `openPositionFarm()` again. The function has logic to check if there is already existing collateral of this LP token in the Blueberry Bank. If there is, it removes the collateral and calls `wIchiFarm.burn()` (which harvests the Ichi rewards and withdraws the LP tokens) before repeating the deposit process.\n```solidity\nfunction burn(uint256 id, uint256 amount)\n    external\n    nonReentrant\n    returns (uint256)\n{\n    if (amount == type(uint256).max) {\n        amount = balanceOf(msg.sender, id);\n    }\n    (uint256 pid, uint256 stIchiPerShare) = decodeId(id);\n    _burn(msg.sender, id, amount);\n\n    uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n    ichiFarm.harvest(pid, address(this));\n    ichiFarm.withdraw(pid, amount, address(this));\n\n    // Convert Legacy ICHI to ICHI v2\n    if (ichiRewards > 0) {\n        ICHIv1.safeApprove(address(ICHI), ichiRewards);\n        ICHI.convertToV2(ichiRewards);\n    }\n\n    // Transfer LP Tokens\n    address lpToken = ichiFarm.lpToken(pid);\n    IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n    // Transfer Reward Tokens\n    (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n    uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n    uint256 enIchi = (enIchiPerShare * amount) / 1e18;\n\n    if (enIchi > stIchi) {\n        ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n    }\n    return pid;\n}\n```\nHowever, this deposit process has no logic for distributing the ICHI rewards. Therefore, these rewards will remain sitting in the `IchiVaultSpell.sol` contract and will not reach the user.\n\nFor an example of how this is handled properly, we can look at the opposite function, `closePositionFarm()`. In this case, the same `wIchiFarm.burn()` function is called. But in this case, it's followed up with an explicit call to withdraw the ICHI from the contract to the user.\n```solidity\ndoRefund(ICHI);\n```\nThis `doRefund()` function refunds the contract's full balance of ICHI to the `msg.sender`, so the result is that the next user to call `closePositionFarm()` will steal the ICHI tokens from the original user who added to their farming position.\n\n## Impact\n\nUsers who farm their Ichi LP tokens for ICHI rewards can permanently lose their rewards.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L199-L249\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/wrapper/WIchiFarm.sol#L116-L150\n\nHere is a link to the `harvest()` function  on the IchiFarmV2.sol contract, which is called by `wIchiFarm.sol` and contains the logic for distributing ICHI rewards: https://github.com/ichifarm/ichi-farming/blob/206c44b790fbb2a1e3a655685eb3ab8d793c9f00/contracts/ichiFarmV2.sol#L238-L257\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn the `openPositionFarm()` function, in the section that deals with withdrawing existing collateral, add a line that claims the ICHI rewards for the calling user.\n\n```diff\nif (collSize > 0) {\n    (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n    if (farmingPid != decodedPid) revert INCORRECT_PID(farmingPid);\n    if (posCollToken != address(wIchiFarm))\n        revert INCORRECT_COLTOKEN(posCollToken);\n    bank.takeCollateral(collSize);\n    wIchiFarm.burn(collId, collSize);\n+   doRefund(ICHI);\n}\n```",
      "summary": "\nThis bug report details an issue with the Ichi farming positions in the IchiVaultSpell.sol contract. When a user deposits extra funds into their Ichi farming position using `openPositionFarm()`, the old farming position will be closed down and a new one will be opened. Part of this process is that their ICHI rewards will be sent to the `IchiVaultSpell.sol` contract, but they will not be distributed. They will sit in the contract until the next user (or MEV bot) calls `closePositionFarm()`, at which point they will be stolen by that user.\n\nThis means that users who farm their Ichi LP tokens for ICHI rewards can permanently lose their rewards. The bug was found by carrot, rvierdiiev, minhtrng, obront, sinarette, tives, berndartmueller, and 0x52. It was found through manual review.\n\nThe recommendation is to add a line to the `openPositionFarm()` function that claims the ICHI rewards for the calling user. This would ensure that users get the rewards they are expecting.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/41",
      "sponsor_name": "Blueberry",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/158",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "41",
      "slug": "h-2-users-who-deposit-extra-funds-into-their-ichi-farming-positions-will-lose-all-their-ichi-rewards-sherlock-blueberry-blueberry-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Missing-Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Configuration"
          }
        }
      ]
    },
    {
      "id": "6638",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "32",
      "title": "H-1: Too few `ICHI` v2 farming reward tokens transferred to the user due to incorrect decimal precision",
      "content": "Source: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/319 \n\n## Found by \nberndartmueller, 0x52\n\n## Summary\n\nThe `burn` function in the `WIchiFarm` contract transfers too few `ICHI` **v2** farming reward tokens to the caller due to using 9 decimals instead of 18 decimals for the `ICHI` **v2** token.\n\n## Vulnerability Detail\n\nClosing an ICHI vault spell farming position burns the wrapped ICHI vault LP tokens (`WIchiFarm` ERC-1155 tokens). Farming rewards are harvested from the ICHI farm ([see contract on Etherscan](https://etherscan.io/address/0x275dfe03bc036257cd0a713ee819dbd4529739c8)) and received as `ICHI` **v1** tokens.\n\nThe `ICHI` **v1** ERC-20 token uses **9 decimals** ([see token on Etherscan](https://etherscan.io/token/0x903bEF1736CDdf2A537176cf3C64579C3867A881)), whereas the `ICHI` **v2** ERC-20 token uses **18 decimals** ([see token on Etherscan](https://etherscan.io/token/0x111111517e4929D3dcbdfa7CCe55d30d4B6BC4d6)).\n\nThose received `ICHI` **v1** tokens are then converted to **v2** tokens in line 134.\n\nTo calculate the user's share of eligible `ICHI` **v2** reward tokens, the reward per share accumulator `stIchiPerShare` at the time of minting the `WIchiFarm` token and the current `enIchiPerShare` accumulator is used.\n\nHowever, those accumulator values are in **9 decimals** precision (please see the `ichiFarmV2.harvest` function for proof that `pool.accIchiPerShare` uses 9 decimals, otherwise the `ICHI` token transfer would fail due to inflated `_pendingIchi`). Given that `amount` is in **18 decimals**, the calculation of `stIchi` and `enIchi` in lines 143 and 144 will result in a value with **9 decimals** precision.\n\nAs previously mentioned, the `ICHI` **v2** token uses **18 decimals**. Therefore, too few `ICHI` **v2** tokens are transferred.\n\n## Impact\n\nUsers will receive substantially fewer `ICHI` v2 farming reward tokens than expected.\n\n## Code Snippet\n\n[wrapper/WIchiFarm.sol#L143-L144](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/wrapper/WIchiFarm.sol#L143-L144)\n\n```solidity\n116: function burn(uint256 id, uint256 amount)\n117:     external\n118:     nonReentrant\n119:     returns (uint256)\n120: {\n121:     if (amount == type(uint256).max) {\n122:         amount = balanceOf(msg.sender, id);\n123:     }\n124:     (uint256 pid, uint256 stIchiPerShare) = decodeId(id);\n125:     _burn(msg.sender, id, amount);\n126:\n127:     uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n128:     ichiFarm.harvest(pid, address(this));\n129:     ichiFarm.withdraw(pid, amount, address(this));\n130:\n131:     // Convert Legacy ICHI to ICHI v2\n132:     if (ichiRewards > 0) {\n133:         ICHIv1.safeApprove(address(ICHI), ichiRewards);\n134:         ICHI.convertToV2(ichiRewards);\n135:     }\n136:\n137:     // Transfer LP Tokens\n138:     address lpToken = ichiFarm.lpToken(pid);\n139:     IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n140:\n141:     // Transfer Reward Tokens\n142:     (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n143:     uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n144:     uint256 enIchi = (enIchiPerShare * amount) / 1e18; // @audit-info `enIchi` and `stIchi` are in 9 decimal precision\n145:\n146:     if (enIchi > stIchi) {\n147:         ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n148:     }\n149:     return pid;\n150: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider changing the denominator in lines 143 and 144 from `1e18` to `1e9` to use the required `18` decimals for the `ICHI` v2 token.",
      "summary": "\nThis bug report is regarding the `burn` function in the `WIchiFarm` contract, which transfers too few `ICHI` **v2** farming reward tokens to the caller due to using 9 decimals instead of 18 decimals for the `ICHI` **v2** token. The `burn` function is used when closing an ICHI vault spell farming position and burning the wrapped ICHI vault LP tokens (`WIchiFarm` ERC-1155 tokens). Farming rewards are harvested from the ICHI farm and received as `ICHI` **v1** tokens. \n\nThe `ICHI` **v1** ERC-20 token uses **9 decimals**, whereas the `ICHI` **v2** ERC-20 token uses **18 decimals**. Those received `ICHI` **v1** tokens are then converted to **v2** tokens in line 134. To calculate the user's share of eligible `ICHI` **v2** reward tokens, the reward per share accumulator `stIchiPerShare` at the time of minting the `WIchiFarm` token and the current `enIchiPerShare` accumulator is used.\n\nHowever, those accumulator values are in **9 decimals** precision and the `amount` is in **18 decimals**. This results in too few `ICHI` **v2** tokens being transferred. This means that users will receive substantially fewer `ICHI` v2 farming reward tokens than expected.\n\nThe recommendation is to change the denominator in lines 143 and 144 from `1e18` to `1e9` to use the required `18` decimals for the `ICHI` v2 token. The bug was found by berndartmueller, 0x52 and was reviewed manually.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/41",
      "sponsor_name": "Blueberry",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/319",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "41",
      "slug": "h-1-too-few-ichi-v2-farming-reward-tokens-transferred-to-the-user-due-to-incorrect-decimal-precision-sherlock-blueberry-blueberry-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Decimals"
          }
        },
        {
          "tags_tag": {
            "title": "Configuration"
          }
        }
      ]
    },
    {
      "id": "21994",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "900",
      "title": "[H-09] Attacker can steal 99% of total balance from any reward token in any Staking contract",
      "content": "\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L108-L110>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L483-L503> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L296-L315>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L351-L360> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L377-L378>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L390-L399>\n\n### Impact\n\nAttacker can steal 99% of the balance of a reward token of any Staking contract in the blockchain. An attacker can do this by modifying the reward speed of the target reward token.\n\nSo an attacker gets access to `changeRewardSpeed`, he will need to deploy a vault using the target Staking contract as its Staking contract. Since the Staking contract is now attached to the attacker's created vault, he can now successfully `changeRewardSpeed`. Now with `changeRewardSpeed`, attacker can set the `rewardSpeed` to any absurdly large amount that allows them to drain 99% of the balance (dust usually remains due to rounding issues) after some seconds (12 seconds in the PoC.)\n\n### Proof of Concept\n\nThis attack is made possible by the following issues:\n\n1.  Any user can deploy a Vault that uses any existing Staking contract - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L106-L108>\n2.  As long as attacker is creator of a Vault that has the target Staking contract attached to it, attacker can call `changeStakingRewardSpeeds` to modify the rewardSpeeds of any reward tokens in the target Staking contract - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L495-L501>\n3.  There are no checks for limits on the `rewardsPerSecond` value in `changeRewardSpeed` so attacker can set any amount they want - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L299-L314>\n4.  `changeRewardSpeed` also uses `_calcRewardsEnd` to get the new `rewardsEndTimestamp` but that calculation is faulty and the new timestamp is always longer than it's supposed to be leading to people being able to claim more rewards than they should get - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L351-L360>\n\nBelow is the PoC using a Foundry test:\n\n```solidity\n  function test__steal_rewards_from_any_staking_contract() public {\n    addTemplate(\"Adapter\", templateId, adapterImpl, true, true);\n    addTemplate(\"Strategy\", \"MockStrategy\", strategyImpl, false, true);\n    addTemplate(\"Vault\", \"V1\", vaultImpl, true, true);\n\n    // 1. deploy regular legit vault owned by this\n    address vault = deployVault();\n    address staking = vaultRegistry.getVault(vault).staking;\n\n    rewardToken.mint(staking, 1_000_000 ether);\n\n    vm.startPrank(bob);\n    asset.mint(bob, 10000 ether);\n    asset.approve(vault, 10000 ether);\n    IVault(vault).deposit(10000 ether, bob);\n    IVault(vault).approve(staking, 10000 ether);\n    IMultiRewardStaking(staking).deposit(9900 ether, bob);\n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    // 2. deploy attacker-owned vault using the same Staking contract as legit vault\n    // alice is the attacker\n    address attackerVault = controller.deployVault(\n      VaultInitParams({\n        asset: iAsset,\n        adapter: IERC4626(address(0)),\n        fees: VaultFees({\n          deposit: 100,\n          withdrawal: 200,\n          management: 300,\n          performance: 400\n        }),\n        feeRecipient: feeRecipient,\n        owner: address(this)\n      }),\n      DeploymentArgs({ id: templateId, data: abi.encode(uint256(100)) }),\n      DeploymentArgs({ id: 0, data: \"\" }),\n      staking,\n      \"\",\n      VaultMetadata({\n        vault: address(0),\n        staking: staking,\n        creator: alice,\n        metadataCID: metadataCid,\n        swapTokenAddresses: swapTokenAddresses,\n        swapAddress: address(0x5555),\n        exchange: uint256(1)\n      }),\n      0\n    );\n\n    asset.mint(alice, 10 ether);\n    asset.approve(vault, 10 ether);\n    IVault(vault).deposit(10 ether, alice);\n    IVault(vault).approve(staking, 10 ether);\n    IMultiRewardStaking(staking).deposit(1 ether, alice);\n\n    address[] memory targets = new address[](1);\n    targets[0] = attackerVault;\n    IERC20[] memory rewardTokens = new IERC20[](1);\n    rewardTokens[0] = iRewardToken;\n    uint160[] memory rewardsSpeeds = new uint160[](1);\n    rewardsSpeeds[0] = 990_099_990 ether;\n    controller.changeStakingRewardsSpeeds(targets, rewardTokens, rewardsSpeeds);\n\n    assertGt(rewardToken.balanceOf(staking), 1_000_000 ether);\n\n    vm.warp(block.timestamp + 12);\n    MultiRewardStaking(staking).claimRewards(alice, rewardTokens);\n\n    assertGt(rewardToken.balanceOf(alice), 999_999 ether);\n    assertLt(1 ether, rewardToken.balanceOf(staking));\n    vm.stopPrank();\n  }\n```\n\nThe PoC shows that the attacker, Alice, can drain any reward token of a Staking contract deployed by a different vault owner. In this test case, Alice does the attack described above stealing a total 999,999 worth of reward tokens (99% of reward tokens owned by the Staking contract.)\nNote that the attacker can tweak the amount they stake in the contract, the reward speed they'll use, and the seconds to wait before, before claiming rewards. All of those things have an effect on the cost of the attack and how much can be drained.\n\nThe test can be run with:\n`forge test --no-match-contract 'Abstract' --match-test test__steal_rewards_from_any_staking_contract`\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\n1.  Don't allow any Vault creator to use and modify just ANY Staking contract - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L106-L108>\n2.  Add checks to limit how high `rewardsPerSecond` can be when changing rewardSpeed. Maybe make it so that it takes a minimum of 1 month (or some other configurable period) for rewards to be distributed. - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L299-L314>\n3.  Fix calcRewardsEnd to compute the correct rewardsEndTimestamp by taking into account total accrued rewards until that point in time - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L351-L360>\n\n**[RedVeil (Popcorn) confirmed](https://github.com/code-423n4/2023-01-popcorn-findings/issues/263)** \n\n***\n\n",
      "summary": "\nThis bug report is about an attack that allows an attacker to steal 99% of the balance of a reward token of any Staking contract in the blockchain. The attack is made possible by four issues: any user can deploy a Vault that uses any existing Staking contract, the attacker can call `changeStakingRewardSpeeds` to modify the reward speeds of any reward tokens in the target Staking contract, there are no checks for limits on the `rewardsPerSecond` value in `changeRewardSpeed`, and `changeRewardSpeed` uses `_calcRewardsEnd` to get the new `rewardsEndTimestamp` but that calculation is faulty and the new timestamp is always longer than it's supposed to be leading to people being able to claim more rewards than they should get. \n\nThe bug report includes a Proof of Concept (PoC) using Foundry test. The PoC shows that the attacker, Alice, can drain any reward token of a Staking contract deployed by a different vault owner. In this test case, Alice does the attack described above stealing a total 999,999 worth of reward tokens (99% of reward tokens owned by the Staking contract).\n\nThe recommended mitigation steps are to not allow any Vault creator to use and modify just ANY Staking contract, add checks to limit how high `rewardsPerSecond` can be when changing rewardSpeed, and fix calcRewardsEnd to compute the correct rewardsEndTimestamp by taking into account total accrued rewards until that point in time. RedVeil (Popcorn) has confirmed the bug report.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-01-popcorn",
      "sponsor_name": "Popcorn",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2023-01-popcorn",
      "github_link": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/263",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "211",
      "slug": "h-09-attacker-can-steal-99-of-total-balance-from-any-reward-token-in-any-staking-contract-code4rena-popcorn-popcorn-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Popcorn",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Popcorn",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "1350",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "423",
      "title": "[H-02] Malicious Users Can Transfer Vault Collateral To Other Accounts To Extract Additional Yield From The Protocol",
      "content": "_Submitted by leastwood_\n\n`ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which:\n\n*   Approves Ladle to move the tokens.\n*   Transfers the tokens to `ConvexYieldWrapper.sol`.\n*   Wraps/stakes these tokens.\n*   Updates accounting and produces debt tokens within `Ladle.sol`.\n\n`_getDepositedBalance()` takes into consideration the user's total collateral stored in all of their owned vaults. However, as a vault owner, you are allowed to give the vault to another user, move collateral between vaults and add/remove collateral. Therefore, it is possible to manipulate the result of this function by checkpointing one user's balance at a given time, transferring ownership to another user and then create a new checkpoint with this user.\n\nAs a result, a user is able to generate protocol yield multiple times over on a single collateral amount. This can be abused to effectively extract all protocol yield.\n\n#### Proof of Concept\n\nConsider the following exploit scenario:\n\n*   Alice owns a vault which has 100 tokens worth of collateral.\n*   At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards.\n*   Alice then calls `Ladle.give()`, transferring the ownership of the vault to Bob and calls `ConvexYieldWrapper.addVault()`.\n*   Bob is able to call `user_checkpoint()` and effectively update their checkpointed balance.\n*   At this point in time, both Alice and Bob have claim to any yield generated by the protocol, however, there is only one vault instance that holds the underlying collateral.\n\n<https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexYieldWrapper.sol#L100-L120>\n```solidity\nfunction _getDepositedBalance(address account_) internal view override returns (uint256) {\n    if (account_ == address(0) || account_ == collateralVault) {\n        return 0;\n    }\n\n    bytes12[] memory userVault = vaults[account_];\n\n    //add up all balances of all vaults registered in the wrapper and owned by the account\n    uint256 collateral;\n    DataTypes.Balances memory balance;\n    uint256 userVaultLength = userVault.length;\n    for (uint256 i = 0; i < userVaultLength; i++) {\n        if (cauldron.vaults(userVault[i]).owner == account_) {\n            balance = cauldron.balances(userVault[i]);\n            collateral = collateral + balance.ink;\n        }\n    }\n\n    //add to balance of this token\n    return _balanceOf[account_] + collateral;\n}\n```\n\n#### Tools Used\n\nManual code review.\nDiscussion/confirmation with the Yield Protocol team.\n\n#### Recommended Mitigation Steps\n\nEnsure that any change to a vault will correctly checkpoint the previous and new vault owner. The affected actions include but are not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault.\n\n**[iamsahu (Yield) confirmed](https://github.com/code-423n4/2022-01-yield-findings/issues/89)**\n\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-01-yield-findings/issues/89#issuecomment-1044656259):**\n > The warden identified a way to sidestep the accounting in the `ConvexYieldWrapper`.\n> \n> Because `ConvexYieldWrapper` takes lazy accounting, transferring vaults at the `Ladle` level allows to effectively register the same vault under multiple accounts, which ultimately allow to steal more yield than expected.\n> \n> While the loss of yield can be classified as a medium severity, the fact that the warden was able to break the accounting invariants of the `ConvexYieldWrapper` leads me to raise the severity to high\n> \n> Ultimately mitigation will require to `_checkpoint` also when vault operations happen (especially transfer), this may require a rethinking at the Ladle level as the reason why the warden was able to sidestep the checkpoint is because the `Ladle` doesn't notify the `Wrapper` of any vault transfers\n\n**[alcueca (Yield) commented](https://github.com/code-423n4/2022-01-yield-findings/issues/89#issuecomment-1046642319):**\n > Yes, that's right. To fix this issue we will deploy a separate Ladle to deal specifically with convex tokens. The fix will probably involve removing `stir` and `give` instead of notifying the wrapper, but we'll see.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in ConvexYieldWrapper.sol, a wrapper contract for staking convex tokens. It allows users to earn rewards on their deposits by interacting with the Ladle.sol contract's batch() function. The vulnerability is in the _getDepositedBalance() function which takes into account the user's total collateral stored in all of their owned vaults. It is possible to manipulate the result of this function by checkpointing one user's balance at a given time, transferring ownership to another user and then creating a new checkpoint with this user. This can be abused to effectively extract all protocol yield.\n\nTo demonstrate, consider the following example. Alice owns a vault which has 100 tokens worth of collateral. At this point, the _getDepositedBalance() function returns 100 as its result. Alice then calls Ladle.give() to transfer the ownership of the vault to Bob and calls ConvexYieldWrapper.addVault(). Bob is then able to call user_checkpoint() and effectively update their checkpointed balance. As a result, both Alice and Bob have claim to any yield generated by the protocol, however, there is only one vault instance that holds the underlying collateral.\n\nTo mitigate this vulnerability, it is important to ensure that any change to a vault will correctly checkpoint the previous and new vault owner. This includes but is not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault.",
      "report_date": {},
      "contest_prize_txt": "$30,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-01-yield-convex-contest",
      "sponsor_name": "Yield",
      "sponsor_link": "https://twitter.com/yield",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-01-yield",
      "github_link": "https://github.com/code-423n4/2022-01-yield-findings/issues/89",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "80",
      "slug": "h-02-malicious-users-can-transfer-vault-collateral-to-other-accounts-to-extract-additional-yield-from-the-protocol-code4rena-yield-yield-convex-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Yield",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Yield",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        }
      ]
    },
    {
      "id": "1349",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "423",
      "title": "[H-01] Malicious Users Can Duplicate Protocol Earned Yield By Transferring wCVX Tokens To Another Account",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\n`ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which:\n- Approves Ladle to move the tokens.\n- Transfers the tokens to `ConvexYieldWrapper.sol`.\n- Wraps/stakes these tokens.\n- Updates accounting and produces debt tokens within `Ladle.sol`.\n\nDuring `wrap()` and `unwrap()` actions, `_checkpoint()` is used to update the rewards for the `from_` and `to_` accounts. However, the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract implements a `_beforeTokenTransfer()` function which has been removed from Yield Protocol's custom implementation.\n\nAs a result, it is possible to transfer `wCVX` tokens to another account after an initial checkpoint has been made. By manually calling `user_checkpoint()` on the new account, this user is able to update its deposited balance of the new account while the sender's balance is not updated. This can be repeated to effectively replicate a user's deposited balance over any number of accounts. To claim yield generated by the protocol, the user must only make sure that the account calling `getReward()` holds the tokens for the duration of the call.\n\n## Proof of Concept\n\nThe exploit can be outlined through the following steps:\n- Alice receives 100 `wCVX` tokens from the protocol after wrapping their convex tokens.\n- At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards.\n- Alice transfers her tokens to her friend Bob who then manually calls `user_checkpoint()` to update his balance.\n- Now from the perspective of the protocol, both Alice and Bob have 100 `wCVX` tokens as calculated by the `_getDepositedBalance()` function.\n- If either Alice or Bob wants to claim rewards, all they need to do is make sure the 100 `wCVX` tokens are in their account upon calling `getReward()`. Afterwards, the tokens can be transferred out.\n\n## Tools Used\n\nManual code review.\nDiscussion/confirmation with the Yield Protocol team.\n\n## Recommended Mitigation Steps\n\nConsider implementing the `_beforeTokenTransfer()` function as shown in the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract. However, it is important to ensure the wrapper contract and collateral vaults are excluded from the checkpointing so they are not considered in the rewards calculations.",
      "summary": "\nThis bug report details a vulnerability in the `ConvexYieldWrapper.sol` contract, which is a wrapper contract for staking convex tokens on the user's behalf. The `batch()` function of the `Ladle.sol` contract is used to approve Ladle to move tokens, transfer tokens to `ConvexYieldWrapper.sol`, wrap/stake the tokens and update accounting and produce debt tokens within `Ladle.sol`. The `_checkpoint()` function is used to update the rewards for the `from_` and `to_` accounts, however the `_beforeTokenTransfer()` function has been removed from Yield Protocol's custom implementation.\n\nThis allows a user to transfer `wCVX` tokens to another account after an initial checkpoint has been made. By manually calling `user_checkpoint()` on the new account, the user is able to update its deposited balance of the new account while the sender's balance is not updated. This can be repeated to effectively replicate a user's deposited balance over any number of accounts and claim yield generated by the protocol.\n\nThe bug was found through manual code review and confirmed with the Yield Protocol team. The recommended mitigation step is to implement the `_beforeTokenTransfer()` function as shown in the reference contract, while making sure the wrapper contract and collateral vaults are excluded from the checkpointing so they are not considered in the rewards calculations.",
      "report_date": {},
      "contest_prize_txt": "$30,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-01-yield-convex-contest",
      "sponsor_name": "Yield",
      "sponsor_link": "https://twitter.com/yield",
      "quality_score": 3,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-01-yield",
      "github_link": "https://github.com/code-423n4/2022-01-yield-findings/issues/86",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "80",
      "slug": "h-01-malicious-users-can-duplicate-protocol-earned-yield-by-transferring-wcvx-tokens-to-another-account-code4rena-yield-yield-convex-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Yield",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Yield",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        }
      ]
    },
    {
      "id": "1127",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 7,
      "protocol_id": "337",
      "title": "[H-02] Tokens can be stolen when depositToken == rewardToken",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `Streaming` contract allows the `deposit` and `reward` tokens to be the same token.\n\n> I believe this is intended, think Sushi reward on Sushi as is the case with `xSushi`.\n\nThe reward and deposit balances are also correctly tracked independently in `depositTokenAmount` and `rewardTokenAmount`.\nHowever, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:\n\n```solidity\nfunction recoverTokens(address token, address recipient) public lock {\n    // NOTE: it is the stream creators responsibility to save\n    // tokens on behalf of their users.\n    require(msg.sender == streamCreator, \"!creator\");\n    if (token == depositToken) {\n        require(block.timestamp > endDepositLock, \"time\");\n        // get the balance of this contract\n        // check what isnt claimable by either party\n        // @audit-info depositTokenAmount updated on stake/withdraw/exit, redeemedDepositTokens increased on claimDepositTokens\n        uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n        // allow saving of the token\n        ERC20(token).safeTransfer(recipient, excess);\n\n        emit RecoveredTokens(token, recipient, excess);\n        return;\n    }\n    \n    if (token == rewardToken) {\n        require(block.timestamp > endRewardLock, \"time\");\n        // check current balance vs internal balance\n        //\n        // NOTE: if a token rebases, i.e. changes balance out from under us,\n        // most of this contract breaks and rugs depositors. this isn't exclusive\n        // to this function but this function would in theory allow someone to rug\n        // and recover the excess (if it is worth anything)\n\n        // check what isnt claimable by depositors and governance\n        // @audit-info rewardTokenAmount increased on fundStream\n        uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n        ERC20(token).safeTransfer(recipient, excess);\n\n        emit RecoveredTokens(token, recipient, excess);\n        return;\n    }\n    // ...\n```\n\n#### POC\nGiven `recoverTokens == depositToken`, `Stream` creator calls `recoverTokens(token = depositToken, creator)`.\n\n- The `token` balance is the sum of deposited tokens (minus reclaimed) plus the reward token amount. `ERC20(token).balanceOf(address(this)) >= (depositTokenAmount - redeemedDepositTokens) + (rewardTokenAmount + rewardTokenFeeAmount)`\n- `if (token == depositToken)` executes, the `excess` from the deposit amount will be the reward amount (`excess >= rewardTokenAmount + rewardTokenFeeAmount`). This will be transferred.\n- `if (token == rewardToken)` executes, the new token balance is just the deposit token amount now (because the reward token amount has been transferred out in the step before). Therefore, `ERC20(token).balanceOf(address(this)) >= depositTokenAmount - redeemedDepositTokens`. If this is non-negative, the transaction does not revert and the creator makes a profit.\n\nExample:\n- outstanding redeemable deposit token amount: `depositTokenAmount - redeemedDepositTokens = 1000`\n- funded `rewardTokenAmount` (plus `rewardTokenFeeAmount` fees): `rewardTokenAmount + rewardTokenFeeAmount = 500`\n\nCreator receives `1500 - 1000 = 500` excess deposit and `1000 - 500 = 500` excess reward.\n\n## Impact\nWhen using the same deposit and reward token, the stream creator can steal tokens from the users who will be unable to withdraw their profit or claim their rewards.\n\n## Recommended Mitigation Steps\nOne needs to be careful with using `.balanceOf` in this special case as it includes both deposit and reward balances.\n\nAdd a special case for `recoverTokens` when `token == depositToken == rewardToken` and then the excess should be `ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - (rewardTokenAmount + rewardTokenFeeAmount);`",
      "summary": "\nThis bug report describes an issue with the contract 'Streaming' which allows the same token to be used for both deposits and rewards. The problem is that when the token is recovered, it is recovered twice, once for deposits and another time for rewards. This allows the stream creator to steal tokens from users who will not be able to withdraw their profits or claim their rewards. The recommended mitigation step is to add a special case for 'recoverTokens' when 'token == depositToken == rewardToken' and then the excess should be calculated as 'ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - (rewardTokenAmount + rewardTokenFeeAmount)'.",
      "report_date": {},
      "contest_prize_txt": "$100,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-11-streaming-protocol-contest",
      "sponsor_name": "Streaming Protocol",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2021-11-streaming",
      "github_link": "https://github.com/code-423n4/2021-11-streaming-findings/issues/215",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "62",
      "slug": "h-02-tokens-can-be-stolen-when-deposittoken-rewardtoken-code4rena-streaming-protocol-streaming-protocol-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Streaming Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Streaming Protocol",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        }
      ]
    }
  ]
}