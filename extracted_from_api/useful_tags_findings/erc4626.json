{
  "tag": "ERC4626",
  "count": 28,
  "metadata": {
    "totalResults": 28,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 1,
    "reset": 1771761060
  },
  "findings": [
    {
      "id": "63523",
      "kind": "MARKDOWN",
      "auditfirm_id": "16",
      "impact": "LOW",
      "finders_count": 1,
      "protocol_id": "3569",
      "title": "[L-04] Frontrunnable Initialization",
      "content": "\n_Acknowledged_\n\nThe `initialize` instruction creates the global `fund_pool` PDA (`seed = b\"fund_pool\"`) and sets `initial_admin` to an arbitrary public key supplied by the caller. There is no access control restricting who may invoke this first-use initializer. An attacker can front-run deployment, initialize the pool, and seize control over all admin- and signer-gated operations for the lifetime of the program (until redeploy).\n\n**Recommendations**\n\nImplement a robust access control mechanism that ensures only a trusted entity, such as the program's deployer or a predefined address, can call the `initialize` function. This restriction can be enforced by verifying the caller's identity or using a specific signature during initialization.\n\n\n",
      "summary": "",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Enclave-security-review_2025-10-25.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "l-04-frontrunnable-initialization-pashov-audit-group-none-enclave_2025-10-25-markdown",
      "firm_name": "Pashov Audit Group",
      "firm_logo_square": "Pashov_square.png",
      "protocol_name": "Enclave_2025-10-25",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
      },
      "protocols_protocol": {
        "name": "Enclave_2025-10-25",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Algo-Stables"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Decentralized Stablecoin"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Gas Limit"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Initial Deposit"
          }
        },
        {
          "tags_tag": {
            "title": "Sense"
          }
        },
        {
          "tags_tag": {
            "title": "Auction"
          }
        }
      ]
    },
    {
      "id": "30624",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "1290",
      "title": "M-1: Vault Inflation Attack",
      "content": "Source: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/22 \n\n## Found by \nkfx, santipu\\_\n\n## Summary\n\nAn attacker can be the first and only depositor on the vault during the first epoch in order to execute an inflation attack that will steal the deposited funds of all depositors in the next epoch. \n\n## Vulnerability Detail\n\nA malicious user can perform a donation to execute a classic first depositor/ERC4626 inflation Attack against the new Smilee vaults. The general process of this attack is well-known, and a detailed explanation of this attack can be found in many of the resources such as the following:\n\n- https://blog.openzeppelin.com/a-novel-defense-against-erc4626-inflation-attacks\n- https://mixbytes.io/blog/overview-of-the-inflation-attack\n\nIn short, to kick-start the attack, the malicious user will often usually mint the smallest possible amount of shares (e.g., 1 wei) and then donate significant assets to the vault to inflate the number of assets per share. Subsequently, it will cause a rounding error when other users deposit.\n\nHowever, in Smilee there's the problem that the deposits are not processed until the epoch is finished. Therefore, the attacker would need to be the only depositor on the first epoch of the vault; after the second epoch starts, all new depositors will lose all the deposited funds due to a rounding error. \n\nThis scenario may happen for newly deployed vaults with a short maturity period (e.g., 1 day) and/or for vaults with not very popular tokens. \n\n## Impact\n\nAn attacker will steal all funds deposited by the depositors of the next epoch. \n\n## PoC\n\nThe following test can be pasted in `IGVault.t.sol` and be run with the following command: `forge test --match-test testInflationAttack`.\n\n```solidity\nfunction testInflationAttack() public {\n    // Attacker deposits 1 wei to the vault\n    VaultUtils.addVaultDeposit(bob, 1, admin, address(vault), vm);\n\n    // Next epoch...\n    Utils.skipDay(true, vm);\n    vm.prank(admin);\n    ig.rollEpoch();\n\n    // Attacker has 1 wei of shares\n    vm.prank(bob);\n    vault.redeem(1);\n    assertEq(1, vault.balanceOf(bob));\n\n    // Other users deposit liquidity (15e18)\n    VaultUtils.addVaultDeposit(alice, 10e18, admin, address(vault), vm);\n    VaultUtils.addVaultDeposit(alice, 5e18, admin, address(vault), vm);\n\n    Utils.skipDay(true, vm);\n\n    // Before rolling an epoch, the attacker donates funds to the vault to trigger rounding\n    vm.prank(admin);\n    baseToken.mint(bob, 15e18);\n    vm.prank(bob);\n    baseToken.transfer(address(vault), 15e18);\n\n    // Next epoch...\n    vm.prank(admin);\n    ig.rollEpoch();\n\n    // No new shares have been minted\n    assertEq(1, vault.totalSupply()); \n\n    // Now, attacker can withdraw all funds from the vault\n    vm.prank(bob);\n    vault.initiateWithdraw(1);\n\n    // Next epoch...\n    Utils.skipDay(true, vm);\n    vm.prank(admin);\n    ig.rollEpoch();\n\n    // The attacker withdraws all the funds (donated + stolen)\n    vm.prank(bob);\n    vault.completeWithdraw();\n    assertEq(baseToken.balanceOf(bob), 30e18 + 1);\n}\n```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/Vault.sol#L324-L349\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo mitigate this issue it's recommended to enforce a minimum liquidity requirement on the deposit and withdraw functions. This way, it won't be possible to round down the new deposits. \n\n```diff\n    function deposit(uint256 amount, address receiver, uint256 accessTokenId) external isNotDead whenNotPaused {\n        // ...\n\n        _state.liquidity.pendingDeposits += amount;\n        _state.liquidity.totalDeposit += amount;\n        _emitUpdatedDepositReceipt(receiver, amount);\n        \n+       require(_state.liquidity.totalDeposit > 1e6);\n\n        // ...\n    }\n    \n    function _initiateWithdraw(uint256 shares, bool isMax) internal {\n        // ...\n\n        _state.liquidity.totalDeposit -= withdrawDepositEquivalent;\n        depositReceipt.cumulativeAmount -= withdrawDepositEquivalent;\n\n+       require(_state.liquidity.totalDeposit > 1e6 || _state.liquidity.totalDeposit == 0);\n\n        // ...\n    }\n```\n\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> low, because it is highly unlikely that there will be just 1 wei deposit in the first epoch. If it is, something is wrong with the vault in the first place and might be considered admin mistake.\n\n**takarez** commented:\n>  valid; first deposit attack; medium(7)\n\n\n\n**metadato-eth**\n\nSAME AS 137 and 142\nLOW\nWe agree vault inflation attack can mathematically be possible but Smilee vaults are not standard ones. \nFor this attack to happen there must be a single depositor in the very first epoch.\nFirst epoch has a custom lenght and it is used by the team simply to set up the vault and launch it with some initial capital (otherwise the IG side would have 0 notional to trade). Therefore the exploit is basically not possible.\nIn any case we implemented the fix.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dverso/smilee-v2-contracts/commit/da38dba1ec14e7888c0e374dd325dd94339a5b5a.\n\n**panprog**\n\nFix review: Fixed\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n**santipu03**\n\nEscalate\n\nI think that this issue should be medium severity as it fits with the description on the [Sherlock rules](https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue):\n> - Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n> - Breaks core contract functionality, rendering the contract useless or leading to loss of funds.\n\nThis issue will cause a **loss of funds**, breaking a core functionality of the protocol, as the attacker will steal the deposits of users depositing on the next epochs after the attack. Also, it **requires certain external conditions or specific states** because an attacker must be the only depositor on the first epoch (or on an epoch with 0 current liquidity). \n\nAlso, regarding the sponsor comments, there is no evidence provided to Watsons on the public domain during the audit contest period (14 Feb to 6 Mar) that states that the protocol team will perform an initial deposit on the first epoch when deploying the vault.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I think that this issue should be medium severity as it fits with the description on the [Sherlock rules](https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue):\n> > - Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n> > - Breaks core contract functionality, rendering the contract useless or leading to loss of funds.\n> \n> This issue will cause a **loss of funds**, breaking a core functionality of the protocol, as the attacker will steal the deposits of users depositing on the next epochs after the attack. Also, it **requires certain external conditions or specific states** because an attacker must be the only depositor on the first epoch (or on an epoch with 0 current liquidity). \n> \n> Also, regarding the sponsor comments, there is no evidence provided to Watsons on the public domain during the audit contest period (14 Feb to 6 Mar) that states that the protocol team will perform an initial deposit on the first epoch when deploying the vault.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nThis issue should remain low/invalid. As the sponsor said the first epoch is completely under admin control and will not be used by the user. \nYou're right that it's not written in the readme, but how is it possible that the protocol describes all possible edge cases every time? By design, this epoch will only be used by the protocol, not by users.\n\n**santipu03**\n\n@cvetanovv \n\nI may be wrong, but what I get from reading Sherlock's rules is that only the contest README has more importance than the general rules for valid issues:\n\n> Hierarchy of truth: Contest README > Sherlock rules for valid issues > protocol documentation (including code comments) > protocol answers on the contest public Discord channel.\nWhile considering the validity of an issue in case of any conflict the sources of truth are prioritized in the above order.\n\nTherefore, if I'm not missing something, this issue should be considered valid because the sponsor's mitigation wasn't mentioned on the README. \n\n\n\n**nevillehuang**\n\nAgree with @santipu03 unless such mitigations is explicitly mentioned in the known issue section, any possible mitigation would be an assumption, and so this issue should remain as valid medium, of course unless there is sufficient information to back up the intended mitigation mentioned by sponsor.\n\n**Czar102**\n\nUnless the sponsor has communicated these plans during the time of the audit, I'm planning to accept the escalation and make this a valid Medium.\n\n@cvetanovv @nevillehuang @santipu03 Is only #137 a duplicate of this issue? I can see that the duplication status on #142  is disputed, it will be considered separately.\n\n**nevillehuang**\n\n@Czar102 Yes to my knowledge, only #137 qualifies as an duplicate. #142 should be a separate issue to be considered\n\n**0xjuaan**\n\nHmm, isn't this low severity since it requires that throughout the first epoch, nobody deposits other than the attacker?\n\nA normal vault inflation attack can be considered H/M since the attacker would simply need to be the first depositor and this can be achieved through front-running.\n\nHowever this attack would require them to be the only depositor within the first epoch, which has can last 1 day, or even 1 month in some cases- so to me it seems like the likelihood would bring it to low severity, but of course I will respect the judge's decision.\n\n**Czar102**\n\n> However this attack would require them to be the only depositor within the first epoch, which has can last 1 day, or even 1 month in some cases- so to me it seems like the likelihood would bring it to low severity, but of course I will respect the judge's decision.\n\nIndeed, but there are cases when the attacker being the only depositor is plausible. Because of that, I think Medium severity is appropriate.\n\nPlanning to accept the escalation and make this issue a valid Medium. #137 will be a duplicate, status of #142 is TBD.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\nOnly #137 is a duplicate.\n\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [santipu03](https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/22/#issuecomment-2004201315): accepted\n\n**0xMR0**\n\n> Result: Medium Has duplicates\n> \n> Only #137 is a duplicate.\n\n@Czar102 `Has Duplicates` label is missed for this issue",
      "summary": "\n#Issue M-1: Vault Inflation Attack\n\nThis bug report discusses a potential attack on the Smilee Finance vaults, which could result in the theft of all deposited funds. The vulnerability allows an attacker to be the first and only depositor in the first epoch, causing a rounding error that steals the funds of all subsequent depositors. This attack is similar to a well-known inflation attack and can be executed by minting a small amount of shares and donating a large amount of assets to the vault. The impact of this attack is significant as it results in the loss of all deposited funds. A proof of concept has been provided and a code snippet showing the vulnerable code has been identified. The recommended fix is to enforce a minimum liquidity requirement on deposits and withdrawals. This issue was found through manual review and has been escalated to medium severity due to the potential for loss of funds. It has been determined that #137 is a duplicate of this issue. ",
      "report_date": {},
      "contest_prize_txt": "50500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/180",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/22",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "180",
      "slug": "m-1-vault-inflation-attack-sherlock-smilee-finance-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Smilee Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Smilee Finance",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "First Depositor Issue"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "30676",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "LOW",
      "finders_count": 0,
      "protocol_id": "471",
      "title": "[02] Streamlining token approvals in `PrizeVault._depositAndMint()` with `forceApprove()`",
      "content": "\nIncorporating `forceApprove()`, such as in `PrizeVault._depositAndMint()`, could offer a more streamlined approach to managing ERC20 token allowances; particularly in complex interactions involving asset transfers to yield vaults. By enabling the contract to set precise allowances in a single step, this method could eliminate the need for conditional checks and subsequent resetting of allowances, thus simplifying the logic and potentially enhancing contract efficiency. \n\nhttps://github.com/code-423n4/2024-03-pooltogether/blob/main/pt-v5-vault/src/PrizeVault.sol#L860-L872\n\n```diff\n        // Previously accumulated dust is swept into the yield vault along with the deposit.\n        uint256 _assetsWithDust = _asset.balanceOf(address(this));\n-        _asset.approve(address(yieldVault), _assetsWithDust);\n+        _asset.forceApprove(address(yieldVault), _assetsWithDust);\n\n        // The shares are calculated and then minted directly to mitigate rounding error loss.\n        uint256 _yieldVaultShares = yieldVault.previewDeposit(_assetsWithDust);\n        uint256 _assetsUsed = yieldVault.mint(_yieldVaultShares, address(this));\n-        if (_assetsUsed != _assetsWithDust) {\n-            // If some latent balance remains, the approval is set back to zero for weird tokens like USDT.\n-            _asset.approve(address(yieldVault), 0);\n-        }\n\n        _mint(_receiver, _shares);\n```\n\n",
      "summary": "",
      "report_date": {},
      "contest_prize_txt": "37700",
      "contest_link": "https://code4rena.com/reports/2024-03-pooltogether",
      "sponsor_name": "PoolTogether",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-03-pooltogether",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "332",
      "slug": "02-streamlining-token-approvals-in-prizevault_depositandmint-with-forceapprove-code4rena-pooltogether-pooltogether-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "PoolTogether",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "PoolTogether",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "30673",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "471",
      "title": "[M-07] `PrizeVault.maxDeposit()` doesn't take into account produced fees",
      "content": "\n<https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L368-L392><br>\n<https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L685><br>\n<https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L619>\n\n### Summary\n\nCurrently, `PrizeVault.maxDeposit()` calculates the maximum possible amount of deposit without taking into account produced fees. That means if there is already maxed deposited amount of asset that is calculated by the current implementation in `PrizeVault.maxDeposit()`, `yieldFeeRecipient` can't withdraw shares with `PrizeVault.claimYieldFeeShares()` because in that case `_mint()` will revert because of overflow. A lot of low-price tokens can exceed the limit of `type(uint96).max` with ease. For example, to make a deposit with `maxDeposit()` value with LADYS token it's needed only `$13568` (as of 08-03-2024).\n\n### Impact\n\nIf a user makes a maximum allowed deposit that is calculated by the current implementation of `PrizeVault.maxDeposit()`, `yieldFeeRecipient` can't withdraw fees if they are available.\n\n### Proof of Concept\n\nAdd this test to `PrizeVault.t.sol` and run with:\n\n```\n    forge test --match-contract PrizeVaultTest --match-test testMaxDeposit_CalculatesWithoutTakingIntoAccountGeneratedFees\n```\n\n```solidity\n    function _deposit(address account, uint256 amount) private {\n        underlyingAsset.mint(account, amount);\n        vm.startPrank(account);\n        underlyingAsset.approve(address(vault), amount);\n        vault.deposit(amount, account);\n        vm.stopPrank();\n    }\n\n    function testMaxDeposit_CalculatesWithoutTakingIntoAccountGeneratedFees() public {\n        vault.setYieldFeePercentage(1e8); // 10%\n        vault.setYieldFeeRecipient(bob);\n\n        // alice make initial deposit\n        _deposit(alice, 1e18);\n\n        // mint yield to the vault and liquidate\n        underlyingAsset.mint(address(vault), 1e18);\n        vault.setLiquidationPair(address(this));\n        uint256 maxLiquidation = vault.liquidatableBalanceOf(address(underlyingAsset));\n        uint256 amountOut = maxLiquidation / 2;\n        uint256 yieldFee = (1e18 - vault.yieldBuffer()) / (2 * 10); // 10% yield fee + 90% amountOut = 100%\n\n        // bob transfers tokens out and increase fee\n        vault.transferTokensOut(address(0), bob, address(underlyingAsset), amountOut);\n\n        // alice make deposit with maximum available value for deposit\n        uint256 maxDeposit = vault.maxDeposit(address(this));\n        _deposit(alice, maxDeposit);\n\n        // then bob want to withdraw earned fee but he can't do that\n        vm.prank(bob);\n        vm.expectRevert();\n        vault.claimYieldFeeShares(yieldFee);\n    }\n```\n\n### Recommended Mitigation Steps\n\nAdd function to withdraw fees in `asset` or change function `PrizeVault.maxDeposit()` to calculate max deposit with taking into account produced fees:\n\n```diff\n    function maxDeposit(address) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        uint256 totalDebt_ = _totalDebt(_totalSupply);\n        if (totalAssets() < totalDebt_) return 0;\n\n        // the vault will never mint more than 1 share per asset, so no need to convert supply limit to assets\n        uint256 twabSupplyLimit_ = _twabSupplyLimit(_totalSupply);\n        uint256 _maxDeposit;\n        uint256 _latentBalance = _asset.balanceOf(address(this));\n        uint256 _maxYieldVaultDeposit = yieldVault.maxDeposit(address(this));\n        if (_latentBalance >= _maxYieldVaultDeposit) {\n            return 0;\n        } else {\n            unchecked {\n                _maxDeposit = _maxYieldVaultDeposit - _latentBalance;\n            }\n-           return twabSupplyLimit_ < _maxDeposit ? twabSupplyLimit_ : _maxDeposit;\n+           return twabSupplyLimit_ < _maxDeposit ? twabSupplyLimit_ - yieldFeeBalance : _maxDeposit - yieldFeeBalance;\n        }\n    }\n```\n\n### Assessed type\n\nMath\n\n**[trmid (PoolTogether) confirmed and commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/91#issuecomment-2004124563):**\n > The TWAB max supply limit is a known issue with the prize vault and the deployer is expected to evaluate the possibility of the limit being exceeded before deploying a new prize vault. This issue has demonstrated that any yield fees accrued in this state may end up locked in the prize vault until enough withdrawals occur to free up the TWAB supply limit. This is undesirable behaviour, since all funds that have entered the prize vault through deposits or yield should be able to be taken out in these unexpected circumstances.\n>\n> Mitigation [here](https://github.com/GenerationSoftware/pt-v5-vault/pull/93).\n\n***\n\n",
      "summary": "This bug report discusses an issue with the `PrizeVault.maxDeposit()` function in the PoolTogether project's code. Currently, the function does not take into account any fees that may have been generated, which can lead to an overflow error and prevent the withdrawal of shares by the `yieldFeeRecipient`. This can affect users who make the maximum allowed deposit, as the fees generated may exceed the maximum amount allowed by the function. A test has been included to demonstrate this issue, and a mitigation solution has been proposed. The bug has been confirmed by the project team and a fix is being implemented. ",
      "report_date": {},
      "contest_prize_txt": "37700",
      "contest_link": "https://code4rena.com/reports/2024-03-pooltogether",
      "sponsor_name": "PoolTogether",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-03-pooltogether",
      "github_link": "https://github.com/code-423n4/2024-03-pooltogether-findings/issues/91",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "332",
      "slug": "m-07-prizevaultmaxdeposit-doesnt-take-into-account-produced-fees-code4rena-pooltogether-pooltogether-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "PoolTogether",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "PoolTogether",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Overflow/Underflow"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "30672",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "471",
      "title": "[M-06] Funds locked due to missing transfer check",
      "content": "\nAll of the user's funds are unretrievably locked in the `PrizeVault` contract.\n\nA combination of issues allows for the following scenario:\n\n1. Alice invokes [`_withdraw(receiver, assets)`](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L925-L941) (via `burn()` or `withdraw()`).\n2. The contract [computes the number of shares to redeem](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L933-L934), via `previewWithdraw(assets)`.\n3. The contract [redeems as many shares](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L935-L936), but the ERC 4626-compliant vault returns fewer shares than expected. At this point, the contract holds fewer than `assets` tokens.\n4. The contract [attempts to `transfer` assets to the receiver](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L939). This fails due to insufficient funds, but the ERC 20-compliant token does not revert (only returns `false`).\n5. At this point, Alice's assets are locked in the `PrizeVault` contract. They cannot be withdrawn at a later point, because the corresponding prize vault and yield vault shares have been burned.\n\nThe exploit relies on insufficient handling of two corner cases of [ERC-20](https://eips.ethereum.org/EIPS/eip-20) and [ERC-4246](https://eips.ethereum.org/EIPS/eip-4626):\n\n- [ERC-20](https://eips.ethereum.org/EIPS/eip-20) does not stipulate that `transfer` must throw if the message sender holds insufficient balance. Instead, returning `false` is compliant with ERC-20 and implemented by many tokens, including [BAT](https://etherscan.io/token/0x0d8775f648430679a709e98d2b0cb6250d2887ef), [cUSDC](https://etherscan.io/token/0x39aa39c021dfbae8fac545936693ac917d5e7563), [EURS](https://etherscan.io/token/0xdb25f211ab05b1c97d595516f45794528a807ad8), [HuobiToken](https://etherscan.io/token/0x6f259637dcd74c767781e37bc6133cd6a68aa161), [ZRX](https://etherscan.io/token/0xe41d2489571d322189246dafa5ebde1f4699f498) and many more.\n- [ERC-4626](https://eips.ethereum.org/EIPS/eip-4626) does not stipulate that `redeem(previewWithdraw(assets))` transfers at least `assets`. In particular, [`redeem(shares, ...)`](https://eips.ethereum.org/EIPS/eip-4626#redeem) only guarantees that exactly `shares` are burned. The only guaranteed way to gain a certain amount of assets is by calling [`withdraw(assets, ...)`](https://eips.ethereum.org/EIPS/eip-4626#withdraw).\\\n\nWhile this is the most standards-compliant scenario, a malicious vault could simply not transfer the required tokens on purpose, and still trigger the same effect as described above.\n\n### Proof of Concept\n\nWe provide a proof of concept that results in all of Alice's assets locked in the `PrizeVault` contract and all her shares burned.\n\nPlace the file below in `test/unit/PrizeVault/PoCLockedFunds.t.sol` and run the test with:\n\n```\n    $ forge test --mt test_poc_lockedFundsOnLossyWithdrawal\n```\n\n<details>\n\n```solidity\n// Place in test/unit/PrizeVault/PoCLockedFunds.t.sol\npragma solidity ^0.8.24;\n\nimport { UnitBaseSetup } from \"./UnitBaseSetup.t.sol\";\n\nimport { IERC20, IERC4626 } from \"openzeppelin/token/ERC20/extensions/ERC4626.sol\";\nimport { ERC20PermitMock } from \"../../contracts/mock/ERC20PermitMock.sol\";\nimport { ERC4626Mock } from \"openzeppelin/mocks/ERC4626Mock.sol\";\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\n\n// An ERC20-compliant token that does not throw on insufficient balance.\ncontract NoRevertToken is IERC20 {\n    uint8   public decimals = 18;\n    uint256 public totalSupply;\n\n    mapping (address => uint)                      public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n\n    constructor(uint _totalSupply) {\n        totalSupply = _totalSupply;\n        balanceOf[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function transfer(address dst, uint wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n        if (balanceOf[src] < wad) return false;                        // insufficient src bal\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n            if (allowance[src][msg.sender] < wad) return false;        // insufficient allowance\n            allowance[src][msg.sender] = allowance[src][msg.sender] - wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n    function approve(address usr, uint wad) virtual external returns (bool) {\n        allowance[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n}\n\n\n// An ERC4626-compliant (yield) vault.\n// `withdraw(assets)` burns `assets * totalSupply / (totalAssets + 1)` shares.\n// `redeem(shares)` transfers `shares * (totalAssets + 1) / (totalSupply + 1)` assets.\ncontract YieldVault is ERC4626Mock {\n    using Math for uint256;\n    constructor(address _asset) ERC4626Mock(_asset) {}\n\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets.mulDiv(totalSupply(), totalAssets() + 1);\n    }\n}\n\n// Demonstrate that all of Alice's funds are locked in the PrizeVault,\n// with all corresponding shares burned.\ncontract PoCLockedFunds is UnitBaseSetup {\n    NoRevertToken asset;\n\n    function setUpUnderlyingAsset() public view override returns (ERC20PermitMock) {\n        return ERC20PermitMock(address(asset));\n    }\n\n    function setUpYieldVault() public override returns (IERC4626) {\n        return new YieldVault(address(underlyingAsset));\n    }\n\n    function setUp() public override {\n        return;\n    }\n\n    function test_poc_lockedFundsOnLossyWithdrawal() public {\n        uint256 deposited = 1e18;\n\n        // Mint 10^18 tokens and transfer them to Alice.\n        asset = new NoRevertToken(deposited);\n        super.setUp();\n        asset.transfer(alice, deposited);\n\n        // Alice holds all tokens, the yield vault and the price vaults are empty.\n        assertEq(underlyingAsset.balanceOf(alice), deposited);\n        assertEq(underlyingAsset.balanceOf(address(vault)), 0);\n        assertEq(underlyingAsset.balanceOf(address(yieldVault)), 0);\n        assertEq(yieldVault.totalSupply(), 0);\n        assertEq(yieldVault.balanceOf(address(vault)), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n\n        // Alice enters the vault.\n        vm.startPrank(alice);\n        underlyingAsset.approve(address(vault), deposited);\n        vault.deposit(deposited, alice);\n\n        // All assets were transferred into the yield vault,\n        // as many yield vault shares were minted to the prize vault, and\n        // as many prize vault shares were minted to Alice.\n        assertEq(underlyingAsset.balanceOf(alice), 0);\n        assertEq(underlyingAsset.balanceOf(address(vault)), 0);\n        assertEq(underlyingAsset.balanceOf(address(yieldVault)), deposited);\n        assertEq(yieldVault.totalSupply(), deposited);\n        assertEq(yieldVault.balanceOf(address(vault)), deposited);\n        assertEq(vault.totalSupply(), deposited);\n        assertEq(vault.balanceOf(alice), deposited);\n\n        // Perform the lossy withdraw.\n        vault.withdraw(deposited, alice, alice);\n\n        // At this point Alice should've received all her assets back,\n        // and all prize/yield vault shares should've been burned.\n        // In contrast, no assets were transferred to Alice,\n        // but (almost) all shares have been burned.\n        assertEq(underlyingAsset.balanceOf(alice), 0);\n        assertEq(underlyingAsset.balanceOf(address(vault)), 999999999999999999);\n        assertEq(underlyingAsset.balanceOf(address(yieldVault)), 1);\n        assertEq(yieldVault.totalSupply(), 1);\n        assertEq(yieldVault.balanceOf(address(vault)), 1);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n\n        // As a result, Alice's funds are locked in the vault;\n        // she cannot even withdraw a single asset.\n        vm.expectRevert();\n        vault.withdraw(1, alice, alice);\n        vm.expectRevert();\n        vault.redeem(1, alice, alice);\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nWe recommend to fix both the ERC-20 transfer and ERC-4626 withdrawal.\n\nFor the first, it is easiest to rely on OpenZeppelin's [SafeERC20 `safeTransfer`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8cc7f2dcbf368f2a7ea491389dae41f01c16e352/contracts/token/ERC20/utils/SafeERC20.sol#L32-L38) function:\n\n```diff\ndiff --git a/pt-v5-vault/src/PrizeVault.sol b/pt-v5-vault/src/PrizeVault.sol\nindex fafcff3..de69915 100644\n--- a/pt-v5-vault/src/PrizeVault.sol\n+++ b/pt-v5-vault/src/PrizeVault.sol\n@@ -936,7 +936,7 @@ contract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownab\n             yieldVault.redeem(_yieldVaultShares, address(this), address(this));\n         }\n         if (_receiver != address(this)) {\n-            _asset.transfer(_receiver, _assets);\n+            _asset.safeTransfer(_receiver, _assets);\n         }\n     }\n```\n\nThis already mitigates the erroneous locking of assets.\n\nIn addition, we recommend to ensure that at least the necessary amount of shares is withdrawn from the yield vault.\nIn the simplest form, this can be ensured by invoking `withdraw` directly:\n\n```diff\ndiff --git a/pt-v5-vault/src/PrizeVault.sol b/pt-v5-vault/src/PrizeVault.sol\nindex fafcff3..9bb0653 100644\n--- a/pt-v5-vault/src/PrizeVault.sol\n+++ b/pt-v5-vault/src/PrizeVault.sol\n@@ -930,10 +930,7 @@ contract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownab\n         // latent balance, we don't need to redeem any yield vault shares.\n         uint256 _latentAssets = _asset.balanceOf(address(this));\n         if (_assets > _latentAssets) {\n-            // The latent balance is subtracted from the withdrawal so we don't withdraw more than we need.\n-            uint256 _yieldVaultShares = yieldVault.previewWithdraw(_assets - _latentAssets);\n-            // Assets are sent to this contract so any leftover dust can be redeposited later.\n-            yieldVault.redeem(_yieldVaultShares, address(this), address(this));\n+            yieldVault.withdraw(_assets - _latentAssets, address(this), address(this));\n         }\n         if (_receiver != address(this)) {\n             _asset.transfer(_receiver, _assets);\n```\n\nIf a tighter bound on redeemed shares is desired, the call to `previewWithdraw`/`redeem` should be followed by a `withdraw` of the outstanding assets:\n\n```diff\ndiff --git a/pt-v5-vault/src/PrizeVault.sol b/pt-v5-vault/src/PrizeVault.sol\nindex fafcff3..622a7a6 100644\n--- a/pt-v5-vault/src/PrizeVault.sol\n+++ b/pt-v5-vault/src/PrizeVault.sol\n@@ -934,6 +934,13 @@ contract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownab\n             uint256 _yieldVaultShares = yieldVault.previewWithdraw(_assets - _latentAssets);\n             // Assets are sent to this contract so any leftover dust can be redeposited later.\n             yieldVault.redeem(_yieldVaultShares, address(this), address(this));\n+            \n+            // Redeeming `_yieldVaultShares` may have transferred fewer than the required assets.\n+            // Ask for the outstanding assets directly.\n+            _latentAssets = _asset.balanceOf(address(this));\n+            if (_assets > _latentAssets) {\n+                yieldVault.withdraw(_assets - _latentAssets);\n+            }\n         }\n         if (_receiver != address(this)) {\n             _asset.transfer(_receiver, _assets);\n```\n\n### Assessed type\n\nERC20\n\n**[trmid (PoolTogether) confirmed and commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/235#issuecomment-1996001801):**\n > I would like to add that if a \"compatible ERC4626 yield vault returns less assets than expected\", then it is not actually ERC4626 compatible as these behaviors are required in the spec. That being said, there are likely to be some yield vaults that have errors like this and it is a good thing if we can protect against it without inhibiting the default experience!\n> \n> The `safeTransfer` addition seems sufficient, while the other recommended mitigations are unnecessary and would break the \"dust collector\" strategy that the prize vault employs.\n>\n> Mitigation [here](https://github.com/GenerationSoftware/pt-v5-vault/pull/86).\n\n**[hansfriese (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/235#issuecomment-2002771823):**\n > The impact is critical if `_asset.transfer()` fails silently and it will be mitigated from [this known issue](https://github.com/code-423n4/2024-03-pooltogether/blob/main/bot-report.md#m-02-erc-20-transfertransferfrom-return-values-should-be-checked).\n> So according to [this criteria](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-similar-exploits-under-a-single-issue), this issue might be OOS if it's fully mitigated by adding `safeTransfer`.\n> \n> But another impact is `withdraw()` might revert when `yieldVault.redeem()` returns fewer assets than requested and Medium is appropriate.\n\n***\n\n",
      "summary": "\nThe bug report describes a scenario where a user's funds are locked in a contract called `PrizeVault`. This happens due to a combination of issues where the contract does not handle certain cases properly. The bug can be triggered when a user tries to withdraw their funds using a function called `_withdraw()`, which calculates the number of shares to redeem and then tries to transfer the assets to the user. However, due to errors in the contract's code and the way some tokens work, the transfer fails but does not revert, leaving the user's funds locked in the contract. This exploit relies on the fact that some tokens do not throw an error when the user does not have enough funds, and that the contract does not always transfer the correct amount of shares. A proof of concept is provided to demonstrate the bug, and mitigation steps are recommended to fix the issue. The bug is assessed as Medium severity, as it can cause the user's funds to be locked and the contract to revert in certain situations. ",
      "report_date": {},
      "contest_prize_txt": "37700",
      "contest_link": "https://code4rena.com/reports/2024-03-pooltogether",
      "sponsor_name": "PoolTogether",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-03-pooltogether",
      "github_link": "https://github.com/code-423n4/2024-03-pooltogether-findings/issues/235",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "332",
      "slug": "m-06-funds-locked-due-to-missing-transfer-check-code4rena-pooltogether-pooltogether-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "PoolTogether",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "PoolTogether",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Transfer Result Check"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "ERC20"
          }
        }
      ]
    },
    {
      "id": "30578",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 6,
      "protocol_id": "1263",
      "title": "H-4: Victim's fund can be stolen due to rounding error and exchange rate manipulation",
      "content": "Source: https://github.com/sherlock-audit/2024-01-napier-judging/issues/94 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nBandit, LTDingZhen, cawfree, jennifer37, xAlismx, xiaoming90\n## Summary\n\nVictim's funds can be stolen by malicious users by exploiting the rounding error and through exchange rate manipulation.\n\n## Vulnerability Detail\n\nThe LST Adaptor attempts to guard against the well-known vault inflation attack by reverting the TX when the amount of shares minted is rounded down to zero in Line 78 below.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L71\n\n```solidity\nFile: BaseLSTAdapter.sol\n71:     function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n72:         uint256 bufferEthCache = bufferEth; // cache storage reads\n73:         uint256 queueEthCache = withdrawalQueueEth; // cache storage reads\n74:         uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n75:         uint256 shares = previewDeposit(assets);\n76: \n77:         if (assets == 0) return (0, 0);\n78:         if (shares == 0) revert ZeroShares();\n```\n\nHowever, this control alone is not sufficient to guard against vault inflation attacks. \n\nLet's assume the following scenario (ignoring fee for simplicity's sake):\n\n1. The victim initiates a transaction that deposits 10 ETH as the underlying asset when there are no issued estETH shares.\n2. The attacker observes the victim’s transaction and deposits 1 wei of ETH (issuing 1 wei of estETH share) before the victim’s transaction. 1 wei of estETH share worth of PT and TY will be minted to the attacker.\n3. Then, the attacker executes a transaction to directly transfer 5 stETH to the adaptor. The exchange rate at this point is `1 wei / (5 ETH + 1 wei)`. Note that the [`totalAssets`](https://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/lido/StEtherAdapter.sol#L115) function uses the `balanceOf` function to compute the total underlying assets owned by the adaptor. Thus, this direct transfer will increase the total assets amount.\n4. When the victim’s transaction is executed, the number of estETH shares issued is calculated as `10 ETH * 1 wei / (5 ETH + 1 wei)`, resulting in 1 wei being issued due to round-down.\n5. The attacker will combine the PT + YT obtained earlier to redeem 1 wei of estETH share from the adaptor.\n6. The attacker, holding 50% of the issued estETH shares (indirectly via the PT+YT he owned), receives `(15 ETH + 1 wei) / 2` as the underlying asset. \n7. The attacker seizes 25% of the underlying asset (2.5 ETH) deposited by the victim.\n\nThis scenario demonstrates that even when a revert is triggered due to the number of issued estETH share being 0, it does not prevent the attacker from capturing the user’s funds through exchange rate manipulation.\n\n## Impact\n\nLoss of assets for the victim.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L71\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFollowing are some of the measures that could help to prevent such an attack:\n\n- Mint a certain amount of shares to zero address (dead address) during contract deployment (similar to what has been implemented in Uniswap V2)\n- Avoid using the `balanceOf` so that malicious users cannot transfer directly to the contract to increase the assets per share. Track the total assets internally via a variable.\n\n\n\n## Discussion\n\n**massun-onibakuchi**\n\nOpenzeppelin's ERC4626 with a decimalsOffset=0 in the virtual share mitigates the issue, but it is recognized that it does not completely resolve it. We plan to deposit a small amount of tokens after deployment.\n\n**ydspa**\n\nEscalate\nThis finding is not high.\nThis attack would be success only if the protocol team doesn't provide and keep any initial liquidity for the vault. However, in practical, we merely find protocol teams don't provide any fund to bootstrap projects. The likelihood of this attack is very low.\n\n**sherlock-admin2**\n\n> Escalate\n> This finding is not high.\n> This attack would be success only if the protocol team doesn't provide and keep any initial liquidity for the vault. However, in practical, we merely find protocol teams don't provide any fund to bootstrap projects. The likelihood of this attack is very low.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**massun-onibakuchi**\n\n> Escalate This finding is not high. This attack would be success only if the protocol team doesn't provide and keep any initial liquidity for the vault. However, in practical, we merely find protocol teams don't provide any fund to bootstrap projects. The likelihood of this attack is very low.\n\nAgree. This kind of inflation attack is not listed as a finding in the Mixbytes audit, which is still unpublished.\n\n**MehdiKarimi81**\n\nIf the protocol team doesn't provide initial liquidity it would be high, since it's not listed as a known issue and the protocol team didn't clear that they plan to provide initial liquidity, it can be considered as a high severity. \n\n**xiaoming9090**\n\nThe mitigation of minting some shares in advance to prevent this issue was not documented in the contest’s README. Thus, the issue remains valid and as it is, as mitigation cannot be applied retrospectively after the contest. Otherwise, it would be unfair to the Watsons to raise an issue that only gets invalid by a mitigation shared after the contest/audit.\n\n**cvetanovv**\n\nI disagree with the escalation and this report should remain a valid High. Nowhere in the Readme or Documentation is it described that the protocol knows and can prevent this attack.\n\n**Czar102**\n\nUncommunicated plans for issue mitigation don't constitute a reason for invalidation. I believe this was correctly judged – planning to reject the escalation and leave the issue as is.\n\n**Czar102**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ydspa](https://github.com/sherlock-audit/2024-01-napier-judging/issues/94/#issuecomment-1985343164): rejected",
      "summary": "\nThis bug report discusses a vulnerability in the protocol that allows malicious users to steal funds from victims. The issue is caused by a rounding error and exchange rate manipulation. The protocol has acknowledged the issue, but their current control is not enough to prevent such attacks. The impact of this bug is the loss of assets for the victim. The report suggests some measures to prevent this attack, such as minting shares to a dead address during contract deployment and avoiding the use of the `balanceOf` function. The tool used for this report is a manual review. There is a discussion among the team members regarding the severity of this issue, but it has been ultimately classified as High. ",
      "report_date": {},
      "contest_prize_txt": "29500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/171",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 1.5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-01-napier-judging/issues/94",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "171",
      "slug": "h-4-victims-fund-can-be-stolen-due-to-rounding-error-and-exchange-rate-manipulation-sherlock-napier-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Napier",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Napier",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1954.351532908873
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Vault"
          }
        },
        {
          "tags_tag": {
            "title": "First Depositor Issue"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "27035",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 21,
      "protocol_id": "1061",
      "title": "[M-07] ```trancheTokenAmount``` should be rounded UP when proceeding to a withdrawal or previewing a withdrawal",
      "content": "\nThis is good practice when implementing the EIP-4626 vault standard as it is more secure to favour the vault than its users in that case.<br>\nThis can also lead to issues down the line for other protocol integrating Centrifuge, that may assume that rounding was handled according to EIP-4626 best practices.\n\n### Proof of Concept\n\nWhen calling the [`processWithdraw`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L515) function, the `trancheTokenAmount` is computed through the [`_calculateTrancheTokenAmount`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L591) function, which rounds DOWN the number of shares required to be burnt to receive the `currencyAmount` payout/withdrawal.\n\n```solidity\n/// @dev Processes user's tranche token redemption after the epoch has been executed on Centrifuge.\n/// In case user's redempion order was fullfilled on Centrifuge during epoch execution MaxRedeem and MaxWithdraw\n/// are increased and LiquidityPool currency can be transferred to user's wallet on calling processRedeem or processWithdraw.\n/// Note: The trancheTokenAmount required to fullfill the redemption order was already locked in escrow upon calling requestRedeem and burned upon collectRedeem.\n/// @notice trancheTokenAmount return value is type of uint256 to be compliant with EIP4626 LiquidityPool interface\n/// @return trancheTokenAmount the amount of trancheTokens redeemed/burned required to receive the currencyAmount payout/withdrawel.\nfunction processWithdraw(uint256 currencyAmount, address receiver, address user)\npublic\nauth\nreturns (uint256 trancheTokenAmount)\n{\naddress liquidityPool = msg.sender;\nuint128 _currencyAmount = _toUint128(currencyAmount);\nrequire(\n(_currencyAmount <= orderbook[user][liquidityPool].maxWithdraw && _currencyAmount != 0),\n\"InvestmentManager/amount-exceeds-withdraw-limits\"\n);\n\nuint256 redeemPrice = calculateRedeemPrice(user, liquidityPool);\nrequire(redeemPrice != 0, \"LiquidityPool/redeem-token-price-0\");\n\nuint128 _trancheTokenAmount = _calculateTrancheTokenAmount(_currencyAmount, liquidityPool, redeemPrice);\n_redeem(_trancheTokenAmount, _currencyAmount, liquidityPool, receiver, user);\ntrancheTokenAmount = uint256(_trancheTokenAmount);\n}\n```\n\n```solidity\nfunction _calculateTrancheTokenAmount(uint128 currencyAmount, address liquidityPool, uint256 price)\ninternal\nview\nreturns (uint128 trancheTokenAmount)\n{\n(uint8 currencyDecimals, uint8 trancheTokenDecimals) = _getPoolDecimals(liquidityPool);\n\nuint256 currencyAmountInPriceDecimals = _toPriceDecimals(currencyAmount, currencyDecimals, liquidityPool).mulDiv(\n10 ** PRICE_DECIMALS, price, MathLib.Rounding.Down\n);\n\ntrancheTokenAmount = _fromPriceDecimals(currencyAmountInPriceDecimals, trancheTokenDecimals, liquidityPool);\n}\n```\n\nAs an additional reason the round UP the amount, the computed amount of shares is also used to [`_decreaseRedemptionLimits`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L635C14-L635C39), which could potentially lead to a rounded UP remaining redemption limit post withdrawal (note that for the same reason it would we wise to round UP the `_currency` amount as well when calling `_decreaseRedemptionLimits`).\n\nThe same function is used in the [`previewWithdraw`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L396) function, where is should be rounded UP for the same reasons.\n\n```solidity\n/// @return trancheTokenAmount is type of uin256 to support the EIP4626 Liquidity Pool interface\nfunction previewWithdraw(address user, address liquidityPool, uint256 _currencyAmount)\npublic\nview\nreturns (uint256 trancheTokenAmount)\n{\nuint128 currencyAmount = _toUint128(_currencyAmount);\nuint256 redeemPrice = calculateRedeemPrice(user, liquidityPool);\nif (redeemPrice == 0) return 0;\n\ntrancheTokenAmount = uint256(_calculateTrancheTokenAmount(currencyAmount, liquidityPool, redeemPrice));\n}\n```\n\n### Tools Used\n\nVisual Studio / Manual Review\n\n### Recommended Mitigation Steps\n\nAs the we do not always want to round the amount of shares UP in [`_calculateTrancheTokenAmount`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L591) (e.g. when used in [`previewDeposit`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L370) or [`processDeposit`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L427) the shares amount is correctly rounded DOWN), the function would actually require an extra argument like below:\n\n```solidity\nfunction _calculateTrancheTokenAmount(uint128 currencyAmount, address liquidityPool, uint256 price, Math.Rounding rounding)\ninternal\nview\nreturns (uint128 trancheTokenAmount)\n{\n(uint8 currencyDecimals, uint8 trancheTokenDecimals) = _getPoolDecimals(liquidityPool);\n\nuint256 currencyAmountInPriceDecimals = _toPriceDecimals(currencyAmount, currencyDecimals, liquidityPool).mulDiv(\n10 ** PRICE_DECIMALS, price, MathLib.Rounding.Down\n);\n\ntrancheTokenAmount = _fromPriceDecimals(currencyAmountInPriceDecimals, trancheTokenDecimals, liquidityPool);\n}\n```\n\nAnd be used as\n\n```solidity\n_calculateTrancheTokenAmount(currencyAmount, liquidityPool, redeemPrice, Math.Rounding.Ceil)\n```\n\nIn [`previewWithdraw`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L396) and [`processWithdraw`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L515)\n\nAnd\n\n```solidity\n_calculateTrancheTokenAmount(_currencyAmount, liquidityPool, depositPrice, Math.Rounding.Floor)\n```\n\nIn [`previewDeposit`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L370) and [`processDeposit`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L427).\n\n### Assessed type\n\nMath\n\n**[hieronx (Centrifuge) confirmed and commented](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/34#issuecomment-1745030227):**\n > Mitigated in https://github.com/centrifuge/liquidity-pools/pull/166\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the EIP-4626 vault standard implementation in Centrifuge. When calling the `processWithdraw` function, the `trancheTokenAmount` is computed through the `_calculateTrancheTokenAmount` function, which rounds DOWN the number of shares required to be burnt to receive the `currencyAmount` payout/withdrawal. This can lead to issues down the line for other protocols integrating Centrifuge, that may assume that rounding was handled according to EIP-4626 best practices. Additionally, the same function is used in the `previewWithdraw` function, where is should be rounded UP for the same reasons.\n\nThe tools used to identify this bug were Visual Studio and manual review. The recommended mitigation steps are to add an extra argument, like `Math.Rounding.Ceil` in `previewWithdraw` and `processWithdraw`, and `Math.Rounding.Floor` in `previewDeposit` and `processDeposit` to the `_calculateTrancheTokenAmount` function. This bug was assessed as a Math bug. The bug has been mitigated in the Centrifuge Liquidity Pool pull request #166.",
      "report_date": {},
      "contest_prize_txt": "70000",
      "contest_link": "https://code4rena.com/reports/2023-09-centrifuge",
      "sponsor_name": "Centrifuge",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-09-centrifuge",
      "github_link": "https://github.com/code-423n4/2023-09-centrifuge-findings/issues/34",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "285",
      "slug": "m-07-tranchetokenamount-should-be-rounded-up-when-proceeding-to-a-withdrawal-or-previewing-a-withdrawal-code4rena-centrifuge-centrifuge-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Centrifuge",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Centrifuge",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "26370",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "471",
      "title": "[M-01] If the underlying asset is a fee on transfer token, it could break the internal accounting of the vault",
      "content": "\nThe `Vault._deposit` function is used by the users to deposit `_assets` to the vault and mint vault shares to the `recipient` address. The amount of `_assets` are transferred to the `Vault` as follows:\n\n      SafeERC20.safeTransferFrom(\n        _asset,\n        _caller,\n        address(this),\n        _assetsDeposit != 0 ? _assetsDeposit : _assets\n      );\n\nThe `Vault.deposit` function uses this `_assets` amount to calculate the number of `shares` to be minted to the `_recipient` address.\n\nThe issue here is if the underlying `_asset` is a fee on transfer token then the actual received amount to the vault will be less than what is referred in the `Vault.deposit` function `_assets` input parameter. But the shares to mint is calculated using the entire `_assets` amount.\n\nThis issue could be further aggravated since the `_asset` is again `deposited` to the `_yieldVault` and when needing to be redeemed, will be `withdrawn` from the `_yieldVault` as well. These operations will again charge a fee if the `_asset` is a fee on transfer token. Hence, the actual `_asset` amount left for a particular user will be less than the amount they initially transferred in.\n\nHence, when the user `redeems` the minted shares back to the `_assets`, the contract will not have enough assets to transfer to the `redeemer`, thus reverting the transaction.\n\n### Proof of Concept\n\n```solidity\n      SafeERC20.safeTransferFrom(\n        _asset,\n        _caller,\n        address(this),\n        _assetsDeposit != 0 ? _assetsDeposit : _assets\n      );\n```\n\n<https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L951-L956>\n\n```solidity\n    _yieldVault.deposit(_assets, address(this));\n```\n\n<https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L959>\n\n```solidity\n    _yieldVault.withdraw(_assets, address(this), address(this));\n    SafeERC20.safeTransfer(IERC20(asset()), _receiver, _assets);\n```\n\n<https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/Vault.sol#L1026-L1027>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIt is recommended to compute the `_assets` amount balance of the contract before and after the `safeTransferFrom` call to get the difference between the two for the \"actually transferred\" amount to the `Vault`. Then, the \"actually transferred\" amount can be converted to shares and mint the correct amount of shares to the `recipient`.\n\n```solidity\n  uint256 balanceBefore = _asset.balanceOf(address(this));\n\n      SafeERC20.safeTransferFrom(\n        _asset,\n        _caller,\n        address(this),\n        _assetsDeposit != 0 ? _assetsDeposit : _assets\n      );\n\n  uint256 balanceAfter = _asset.balanceOf(address(this));  \n\n  uint256 transferredAmount = balanceAfter - balanceBefore;\n```\n\n**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/470#issuecomment-1644789820)**\n\n***\n\n",
      "summary": "\nA bug has been reported in the `Vault._deposit` function of the PoolTogether protocol. This function is used to deposit `_assets` to the vault and mint vault shares to the `recipient` address. The amount of `_assets` are transferred to the `Vault` using `SafeERC20.safeTransferFrom`. The issue is that if the underlying `_asset` is a fee on transfer token then the actual received amount to the vault will be less than what is referred in the `Vault.deposit` function `_assets` input parameter. This could be further aggravated since the `_asset` is again `deposited` to the `_yieldVault` and when needing to be redeemed, will be `withdrawn` from the `_yieldVault` as well. These operations will again charge a fee if the `_asset` is a fee on transfer token. Hence, the actual `_asset` amount left for a particular user will be less than the amount they initially transferred in, resulting in the transaction reverting when the user `redeems` the minted shares back to the `_assets`.\n\nThe recommended mitigation step to this bug is to compute the `_assets` amount balance of the contract before and after the `safeTransferFrom` call to get the difference between the two for the \"actually transferred\" amount to the `Vault`. Then, the \"actually transferred\" amount can be converted to shares and mint the correct amount of shares to the `recipient`. This mitigation step has been confirmed by asselstine (PoolTogether).",
      "report_date": {},
      "contest_prize_txt": "$121,650 USDC",
      "contest_link": "https://code4rena.com/reports/2023-07-pooltogether",
      "sponsor_name": "PoolTogether",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-07-pooltogether",
      "github_link": "https://github.com/code-423n4/2023-07-pooltogether-findings/issues/470",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "258",
      "slug": "m-01-if-the-underlying-asset-is-a-fee-on-transfer-token-it-could-break-the-internal-accounting-of-the-vault-code4rena-pooltogether-pooltogether-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "PoolTogether",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "PoolTogether",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Fee On Transfer"
          }
        },
        {
          "tags_tag": {
            "title": "Weird ERC20"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "26085",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "922",
      "title": "[M-16] `vMaia` is ERC-4626 compliant, but the `maxWithdraw` & `maxRedeem` functions are not fully up to EIP-4626's specification",
      "content": "\nThe `maxWithdraw` & `maxRedeem` functions should return the `0` when the withdrawal is paused. But here, it's returning `balanceOf[user]`.\n\n### Proof of Concept\n\n`vMaia Withdrawal` is only allowed once per month during the 1st Tuesday (UTC+0) of the month.\n\nIt's checked by the below function:\n\n```\n\n     102       function beforeWithdraw(uint256, uint256) internal override {\n                /// @dev Check if unstake period has not ended yet, continue if it is the case.\n                if (unstakePeriodEnd >= block.timestamp) return;\n        \n                uint256 _currentMonth = DateTimeLib.getMonth(block.timestamp);\n                if (_currentMonth == currentMonth) revert UnstakePeriodNotLive();\n        \n                (bool isTuesday, uint256 _unstakePeriodStart) = DateTimeLib.isTuesday(block.timestamp);\n                if (!isTuesday) revert UnstakePeriodNotLive();\n        \n                currentMonth = _currentMonth;\n                unstakePeriodEnd = _unstakePeriodStart + 1 days;\n    114        }\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/vMaia.sol#L102C1-L114C6>\n\n```\n\n    173            function maxWithdraw(address user) public view virtual override returns (uint256) {\n                      return balanceOf[user];\n                  }\n              \n                  /// @notice Returns the maximum amount of assets that can be redeemed by a user.\n                  /// @dev Assumes that the user has already forfeited all utility tokens.\n                  function maxRedeem(address user) public view virtual override returns (uint256) {\n                      return balanceOf[user];\n    181              }\n```\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/tokens/ERC4626PartnerManager.sol#L173C3-L181C6>\n\nOther than that period (during the 1st Tuesday (UTC+0) of the month ), the `maxWithdraw` & `maxRedeem` functions should return the `0`.\n\nAccording to [EIP-4626 specifications](<https://eips.ethereum.org/EIPS/eip-4626>):\n\n`maxWithdraw`\n\n     MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST\n     return 0.\n\n`maxRedeem`\n\n     MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST\n     return 0.\n\n### Recommended Mitigation Steps\n\nUse an if-else block and if the time period is within the 1st Tuesday (UTC+0) of the month, return `balanceOf[user]` and `else` return `0`.\n\nFor more information, reference [here](<https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#non-standard-erc-4626-vault-functionality>).\n\n### Assessed type\n\nERC4626\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/585#issuecomment-1655656724)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/585#issuecomment-1709162142):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/585).\n\n***\n\n",
      "summary": "\nThis bug report is about the `maxWithdraw` & `maxRedeem` functions in the ERC4626 contract. The functions should return `0` when the withdrawal is paused, according to the EIP-4626 specifications. However, it was returning the `balanceOf[user]`.\n\nThe `vMaia Withdrawal` is only allowed once per month during the 1st Tuesday (UTC+0) of the month. This is checked by the function beforeWithdraw which checks if the unstake period has not ended yet and if it is the 1st Tuesday of the month. If not, it reverts the UnstakePeriodNotLive.\n\nThe recommended mitigation steps are to use an if-else block and if the time period is within the 1st Tuesday (UTC+0) of the month, return `balanceOf[user]` and `else` return `0`. This was confirmed and addressed by 0xLightt (Maia).",
      "report_date": {},
      "contest_prize_txt": "$300,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-05-maia",
      "sponsor_name": "Maia DAO Ecosystem",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-05-maia",
      "github_link": "https://github.com/code-423n4/2023-05-maia-findings/issues/585",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "242",
      "slug": "m-16-vmaia-is-erc-4626-compliant-but-the-maxwithdraw-maxredeem-functions-are-not-fully-up-to-eip-4626s-specification-code4rena-maia-dao-ecosystem-maia-dao-ecosystem-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Maia DAO Ecosystem",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Maia DAO Ecosystem",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 202630.75
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 202630.75
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 202630.75
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 202630.75
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "EIP-4626"
          }
        }
      ]
    },
    {
      "id": "26071",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "922",
      "title": "[M-02] Slippage controls for calling `bHermes` contract's `ERC4626DepositOnly.deposit` and `ERC4626DepositOnly.mint` functions are missing",
      "content": "\n[EIPS](<https://eips.ethereum.org/EIPS/eip-4626#security-considerations>) mentions that \"if implementors intend to support EOA account access directly, they should consider adding an additional function call for `deposit`/`mint`/`withdraw`/`redeem` with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.\"\n\nUsing the `bHermes` contract that inherits the `ERC4626DepositOnly` contract, EOAs can call the `ERC4626DepositOnly.deposit` and `ERC4626DepositOnly.mint` functions directly. However, because no slippage controls can be specified when calling these functions, these function's `shares` and `assets` outputs can be less than expected to these EOAs.\n\n<https://github.com/code-423n4/2023-05-maia/blob/53c7fe9d5e55754960eafe936b6cb592773d614c/src/erc-4626/ERC4626DepositOnly.sol#L32-L44>\n\n```solidity\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/53c7fe9d5e55754960eafe936b6cb592773d614c/src/erc-4626/ERC4626DepositOnly.sol#L47-L58>\n\n```solidity\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n```\n\nIn contrast, the `UlyssesRouter.addLiquidity` function does control the slippage by including the `minOutput` input and executing `amount = ulysses.deposit(amount, msg.sender)` and `if (amount < minOutput) revert OutputTooLow()`. Although such slippage control for an ERC-4626 vault exists in this protocol's other contract, it does not exist in the `bHermes` contract. As a result, EOAs can mint less `bHermes` shares than expected when calling the `bHermes` contract's `ERC4626DepositOnly.deposit` function and send and burn more `HERMES` tokens than expected when calling the `bHermes` contract's `ERC4626DepositOnly.mint` function.\n\n<https://github.com/code-423n4/2023-05-maia/blob/53c7fe9d5e55754960eafe936b6cb592773d614c/src/ulysses-amm/UlyssesRouter.sol#L49-L56>\n\n```solidity\n    function addLiquidity(uint256 amount, uint256 minOutput, uint256 poolId) external returns (uint256) {\n        UlyssesPool ulysses = getUlyssesLP(poolId);\n\n        amount = ulysses.deposit(amount, msg.sender);\n\n        if (amount < minOutput) revert OutputTooLow();\n        return amount;\n    }\n```\n\n### Proof of Concept\n\nThe following steps can occur for the described scenario involving the `bHermes` contract's `ERC4626DepositOnly.mint` function. The case involving the `bHermes` contract's `ERC4626DepositOnly.deposit` function is similar to this:\n\n1. Alice wants to mint 1e18 `bHermes` shares in exchange for sending and burning 1e18 `HERMES` tokens.\n2. Alice calls the `bHermes` contract's `ERC4626DepositOnly.mint` function with the `shares` input being 1e18.\n3. Yet, such `ERC4626DepositOnly.mint` function call causes 1.2e18 `HERMES` tokens to be transferred from Alice.\n4. Alice unexpectedly sends, burns, and loses 0.2e18 more `HERMES` tokens than expected for minting 1e18 `bHermes` shares.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe `bHermes` contract can be updated to include a `deposit` function that allows `msg.sender` to specify the minimum `bHermes` shares to be minted for calling the corresponding `ERC4626DepositOnly.deposit` function; calling such `bHermes.deposit` function should revert if the corresponding `ERC4626DepositOnly.deposit` function's `shares` output is less than the specified minimum `bHermes` shares to be minted. Similarly, the `bHermes` contract can also include a `mint` function that allows `msg.sender` to specify the maximum `HERMES` tokens to be sent for calling the corresponding `ERC4626DepositOnly.mint` function; calling such `bHermes.mint` function should revert if the corresponding `ERC4626DepositOnly.mint` function's `assets` output is more than the specified maximum `HERMES` tokens to be sent.\n\n**[0xLightt (Maia) acknowledged](https://github.com/code-423n4/2023-05-maia-findings/issues/901#issuecomment-1633189718)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/901#issuecomment-1655667861):**\n > The reason this is not being addressed directly in this contract is we prefer to use a periphery contract like a generalized ERC4626 router to account for slippage and deadlines.\n\n***\n\n",
      "summary": "\nThis bug report is about the `bHermes` contract that inherits the `ERC4626DepositOnly` contract. When `msg.sender` calls the `ERC4626DepositOnly.deposit` and `ERC4626DepositOnly.mint` functions directly, there are no slippage controls, meaning that the `shares` and `assets` outputs can be less than expected. For example, when Alice calls the `bHermes` contract's `ERC4626DepositOnly.mint` function with the `shares` input being 1e18, 1.2e18 `HERMES` tokens are transferred from Alice, meaning Alice unexpectedly sends, burns, and loses 0.2e18 more `HERMES` tokens than expected for minting 1e18 `bHermes` shares.\n\nTo mitigate this issue, the `bHermes` contract can be updated to include a `deposit` function that allows `msg.sender` to specify the minimum `bHermes` shares to be minted for calling the corresponding `ERC4626DepositOnly.deposit` function, and a `mint` function that allows `msg.sender` to specify the maximum `HERMES` tokens to be sent for calling the corresponding `ERC4626DepositOnly.mint` function. Both of these functions should revert if the corresponding `ERC4626DepositOnly.deposit` or `ERC4626DepositOnly.mint` function's `shares` or `assets` output is less than the specified minimum `bHermes` shares or more than the specified maximum `HERMES` tokens.",
      "report_date": {},
      "contest_prize_txt": "$300,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-05-maia",
      "sponsor_name": "Maia DAO Ecosystem",
      "sponsor_link": "",
      "quality_score": 2,
      "general_score": 1,
      "source_link": "https://code4rena.com/reports/2023-05-maia",
      "github_link": "https://github.com/code-423n4/2023-05-maia-findings/issues/901",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "242",
      "slug": "m-02-slippage-controls-for-calling-bhermes-contracts-erc4626depositonlydeposit-and-erc4626depositonlymint-functions-are-missing-code4rena-maia-dao-ecosystem-maia-dao-ecosystem-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Maia DAO Ecosystem",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Maia DAO Ecosystem",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 202630.75
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 202630.75
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 202630.75
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 202630.75
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Slippage"
          }
        },
        {
          "tags_tag": {
            "title": "EIP-4626"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "7311",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 4,
      "protocol_id": "41",
      "title": "Multiple ERC4626Router and ERC4626RouterBase functions will always revert",
      "content": "## Severity: Medium Risk\n\n## Context\n- `ERC4626Router.sol#L49-58`\n- `ERC4626RouterBase.sol#L47`\n- `ERC4626RouterBase.sol#L60`\n\n## Description\nThe intention of the `ERC4626Router.sol` functions is that they are approval-less ways to deposit and redeem:\n\n> For the below, no approval needed, assumes vault is already max approved.\n\nAs long as the user has approved the `TRANSFER_PROXY` for WETH, this works for the `depositToVault` function:\n- WETH is transferred from the user to the router with `pullTokens`.\n- The router approves the vault for the correct amount of WETH.\n- `vault.deposit()` is called, which uses `safeTransferFrom` to transfer WETH from the router into the vault.\n\nHowever, for the `redeemMax` function, it doesn't work:\n- Approves the vault to spend the router's WETH.\n- `vault.redeem()` is called, which tries to transfer vault tokens from the router to the vault, and then mints withdraw proxy tokens to the receiver.\n\nThis error occurs assuming that the vault tokens would be burned, in which case the logic would work. But since they are transferred into the vault until the end of the epoch, we require approvals.\n\nThe same issue also exists in these two functions in `ERC4626RouterBase.sol`:\n- `redeem()`: this is where the incorrect approval lives, so the same issue occurs when it is called directly.\n- `withdraw()`: the same faulty approval exists in this function.\n\n## Recommendation\n`redeemMax` should follow the same flow as `deposit` to make this work:\n- `redeemMax` should `pullTokens` to pull the vault tokens from the user.\n- The router should approve the vault to spend its own tokens, not WETH.\n- Then we can call `vault.redeem()` and it will work as intended.\n\nBoth the `ERC4626RouterBase` functions should change the approval to be vault tokens rather than WETH:\n```diff\n- ERC20(vault.asset()).safeApprove(address(vault), amount);\n+ vault.safeApprove(address(vault), amount);\n```",
      "summary": "\nThis bug report is about the ERC4626Router.sol and ERC4626RouterBase.sol functions not working as intended. The intention of the functions is to allow deposit and redemption of funds without needing an approval, but this is not working as expected.\n\nThe depositToVault function works as intended, with WETH being transferred from the user to the router, then the router approving the vault for the correct amount of WETH, and finally vault.deposit() being called to transfer the WETH from the router into the vault.\n\nHowever, the redeemMax function does not work as expected. The router approves the vault to spend its WETH, then vault.redeem() is called, which tries to transfer vault tokens from the router to the vault, and then mints the withdraw proxy tokens to the receiver. This does not work because the vault tokens need to be approved for transfer.\n\nThe same issue exists in the redeem() and withdraw() functions in ERC4626RouterBase.sol.\n\nThe recommendation is that the redeemMax function should follow the same flow as depositToVault, and that the ERC4626RouterBase functions should change the approval to be vault tokens rather than WETH.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Astaria-Spearbit-Security-Review.pdf",
      "pdf_page_from": 34,
      "contest_id": "",
      "slug": "multiple-erc4626router-and-erc4626routerbase-functions-will-always-revert-spearbit-astaria-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Astaria",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Astaria",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "WETH"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Approve"
          }
        }
      ]
    },
    {
      "id": "7308",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "41",
      "title": "WithdrawProxy allows redemptions before PublicVault callstransferWithdrawReserve",
      "content": "## Severity: High Risk\n\n## Context\n`WithdrawProxy.sol#L172-L175`\n\n## Description\nAnytime there is a withdrawal pending (i.e., someone holds WithdrawProxy shares), shares may be redeemed as long as `totalAssets() > 0` and `s.finalAuctionEnd == 0`. Under normal operating conditions, `totalAssets()` becomes greater than 0 when the `PublicVault` calls `transferWithdrawReserve`. \n\n`totalAssets()` can also be increased to a non-zero value by anyone transferring WETH to the contract. If this occurs and a user attempts to redeem, they will receive a smaller share than they are owed.\n\n### Exploit Scenario\n- Depositor redeems from `PublicVault` and receives WithdrawProxy shares.\n- Malicious actor deposits a small amount of WETH into the WithdrawProxy.\n- Depositor accidentally redeems, or is tricked into redeeming, from the WithdrawProxy while `totalAssets()` is smaller than it should be.\n- `PublicVault` properly processes epoch and full `withdrawReserve` is sent to the WithdrawProxy.\n- All remaining holders of WithdrawProxy shares receive an outsized share as the previous shares were redeemed for the incorrect value.\n\n## Recommendation\n\n### Option 1\nConsider being explicit in opening the WithdrawProxy for redemptions (`redeem/withdraw`) by requiring `s.withdrawReserveReceived` to be a non-zero value:\n\n```solidity\nif (s.finalAuctionEnd != 0) {\n    // Updated condition\n    if (s.finalAuctionEnd != 0 || s.withdrawReserveReceived == 0) {\n        // if finalAuctionEnd is 0, no auctions were added\n        revert InvalidState(InvalidStates.NOT_CLAIMED);\n    }\n}\n```\nAstaria notes there is a second scenario where funds are sent to the WithdrawProxy: auction payouts. For the above recommendation to be complete, auction payouts or claiming MUST also set `withdrawReserveReceived`.\n\n### Option 2\nInstead of inferring when it is safe to withdraw based on `finalAuctionEnd` and `withdrawReserveReceived`, consider explicitly marking the withdrawals as open when it is both safe to withdraw (i.e., expected funds deposited) and the vault has claimed its share.",
      "summary": "\nThis bug report is about the WithdrawProxy.sol#L172-L175. It states that if anyone transfers WETH to the contract, totalAssets() will become greater than 0, and if someone attempts to redeem their shares then they will receive a smaller share than they are owed. It then explains the exploit scenario and provides two recommendations. \n\nThe first recommendation is to consider being explicit in opening the WithdrawProxy for redemptions by requiring s.withdrawReserveReceived to be a non-zero value. The second recommendation is to explicitly mark the withdraws as open when it is both safe to withdraw and the vault has claimed its share. \n\nIn conclusion, this bug report is about a vulnerability in the WithdrawProxy.sol#L172-L175 that can lead to a malicious actor manipulating the totalAssets() and resulting in users receiving a smaller share than they are owed. It provides two recommendations to fix the issue.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Astaria-Spearbit-Security-Review.pdf",
      "pdf_page_from": 32,
      "contest_id": "",
      "slug": "withdrawproxy-allows-redemptions-before-publicvault-callstransferwithdrawreserve-spearbit-astaria-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Astaria",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Astaria",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Validation"
          }
        },
        {
          "tags_tag": {
            "title": "EIP-4626"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "22014",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 10,
      "protocol_id": "900",
      "title": "[M-17] Malicious Users Can Drain The Assets Of Vault. (Due to not being ERC4626 Complaint)",
      "content": "\nMalicious users can drain the assets of the vault.\n\n### Proof of Concept\n\nThe `withdraw` function users `convertToShares` to convert the assets to the amount of shares. These shares are burned from the users account and the assets are returned to the user.\n\nThe function `withdraw` is shown below:\n\n```solidity\nfunction withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public nonReentrant syncFeeCheckpoint returns (uint256 shares) {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        shares = convertToShares(assets);\n/// .... [skipped the code]\n```\n\nThe function `convertToShares` is shown below:\n\n```solidity\nfunction convertToShares(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return\n            supply == 0\n                ? assets\n                : assets.mulDiv(supply, totalAssets(), Math.Rounding.Down);\n    }\n```\n\nIt uses `Math.Rounding.Down` , but it should use `Math.Rounding.Up`\n\nAssume that the vault with the following state:\n\n*   Total Asset = 1000 WETH\n*   Total Supply = 10 shares\n\nAssume that Alice wants to withdraw 99 WETH from the vault. Thus, she calls the **`Vault.withdraw(99 WETH)`** function.\n\nThe calculation would go like this:\n\n```solidity\nassets = 99\nreturn value = assets * supply / totalAssets()\nreturn value = 99 * 10 / 1000\nreturn value = 0\n```\n\nThe value would be rounded round to zero. This will be the amount of shares burned from users account, which is zero.\n\nHence user can drain the assets from the vault without burning their shares.\n\n> Note : A similar issue also exists in `mint` functionality where `Math.Rounding.Down` is used and `Math.Rounding.Up` should be used.\n\n### Recommended Mitigation Steps\n\nUse `Math.Rounding.Up` instead of `Math.Rounding.Down`.\n\nAs per OZ implementation here is the rounding method that should be used:\n\n`deposit` : `convertToShares` → `Math.Rounding.Down`\n\n`mint` : `converttoAssets` → `Math.Rounding.Up`\n\n`withdraw` : `convertToShares` → `Math.Rounding.Up`\n\n`redeem` : `convertToAssets` →  `Math.Rounding.Down`\n\n**[RedVeil (Popcorn) confirmed, but disagreed with severity](https://github.com/code-423n4/2023-01-popcorn-findings/issues/471)** \n\n**[LSDan (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-popcorn-findings/issues/471)** \n\n\n***\n\n",
      "summary": "\nA bug has been found in the `withdraw` function of a vault, which allows malicious users to drain the assets of the vault without burning their shares. The bug is caused by the use of `Math.Rounding.Down` instead of `Math.Rounding.Up` in the `convertToShares` function. \n\nTo illustrate the issue, assume the vault has 1000 WETH in total assets and 10 shares in total supply. If Alice wants to withdraw 99 WETH from the vault by calling the `Vault.withdraw(99 WETH)` function, the calculation would be: `99 * 10 / 1000 = 0`, and the value would be rounded down to zero. This means that the amount of shares burned from Alice's account would be zero, allowing her to drain the assets from the vault without burning her shares.\n\nA similar issue also exists in the `mint` functionality, where `Math.Rounding.Down` is used and `Math.Rounding.Up` should be used. To fix this issue, the following rounding methods should be used: `deposit` → `convertToShares` → `Math.Rounding.Down`; `mint` → `converttoAssets` → `Math.Rounding.Up`; `withdraw` → `convertToShares` → `Math.Rounding.Up`; `redeem` → `convertToAssets` →  `Math.Rounding.Down`. The bug has been confirmed by RedVeil (Popcorn) and the severity has been decreased to Medium by LSDan (judge).",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-01-popcorn",
      "sponsor_name": "Popcorn",
      "sponsor_link": "",
      "quality_score": 2,
      "general_score": 2,
      "source_link": "https://code4rena.com/reports/2023-01-popcorn",
      "github_link": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/471",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "211",
      "slug": "m-17-malicious-users-can-drain-the-assets-of-vault-due-to-not-being-erc4626-complaint-code4rena-popcorn-popcorn-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Popcorn",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Popcorn",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-4626"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "25839",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "41",
      "title": "[M-23] Function `withdraw()` and `redeem()` in ERC4626RouterBase would revert always because they have unnecessary allowance setting",
      "content": "\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626RouterBase.sol#L48><br>\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626RouterBase.sol#L62>\n\nFunctions withdraw() and redeem()  in ERC4626RouterBase  are used to withdraw user funds from vaults and they call `vault.withdraw()` and `vault.redeem()` and logics in vault transfer user shares and user required to give spending allowance for vault and there is no need for ERC4626RouterBase to set approval for vault and because those approved tokens won't be used and code uses `safeApprove()` so next calls to `withdraw()` and `redeem()` would revert because code would tries to change allowance amount while it's not zero. those functions would revert always and AstariaRouter uses them and user won't be able to use those function and any other protocol integrating with Astaria calling those function would have broken logic. also if UI interact with protocol with router functions then UI would have broken parts too. and functions in router support users to set slippage allowance and without them users have to interact with vault directly and they may lose funds because of the slippage.\n\n### Proof of Concept\n\nThis is `withdraw()` and `redeem()` code in ERC4626RouterBase:\n\n      function withdraw(\n        IERC4626 vault,\n        address to,\n        uint256 amount,\n        uint256 maxSharesOut\n      ) public payable virtual override returns (uint256 sharesOut) {\n\n        ERC20(address(vault)).safeApprove(address(vault), amount);\n        if ((sharesOut = vault.withdraw(amount, to, msg.sender)) > maxSharesOut) {\n          revert MaxSharesError();\n        }\n      }\n\n      function redeem(\n        IERC4626 vault,\n        address to,\n        uint256 shares,\n        uint256 minAmountOut\n      ) public payable virtual override returns (uint256 amountOut) {\n\n        ERC20(address(vault)).safeApprove(address(vault), shares);\n        if ((amountOut = vault.redeem(shares, to, msg.sender)) < minAmountOut) {\n          revert MinAmountError();\n        }\n      }\n\nAs you can see the code sets approval for vault to spend routers vault tokens and then call vault function. This is `_redeemFutureEpoch()` code in the vault which handles withdraw and redeem:\n\n      function _redeemFutureEpoch(\n        VaultData storage s,\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint64 epoch\n      ) internal virtual returns (uint256 assets) {\n        // check to ensure that the requested epoch is not in the past\n\n        ERC20Data storage es = _loadERC20Slot();\n\n        if (msg.sender != owner) {\n          uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n          if (allowed != type(uint256).max) {\n            es.allowance[owner][msg.sender] = allowed - shares;\n          }\n        }\n\n        if (epoch < s.currentEpoch) {\n          revert InvalidState(InvalidStates.EPOCH_TOO_LOW);\n        }\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n        // check for rounding error since we round down in previewRedeem.\n\n        //this will underflow if not enough balance\n        es.balanceOf[owner] -= shares;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n          es.balanceOf[address(this)] += shares;\n        }\n\n        emit Transfer(owner, address(this), shares);\n        // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n        _deployWithdrawProxyIfNotDeployed(s, epoch);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        // WithdrawProxy shares are minted 1:1 with PublicVault shares\n        WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);\n      }\n\nAs you can see this code only checks spending allowance that real owner of shares gives to the `msg.sender` and there is no check or updating spending allowance of the router vaulttokens for vault. so those approvals in the `withdraw()` and `redeem()` are unnecessary and they would cause code to revert always because code tries to set approval with `safeApprove()` while the current allowance is not zero.\n\nThis issue would cause calls to withdraw() and redeem() function to revert. any other protocol integrating with Astaria using those functions would have broken logic and also users would lose gas if they use those functions. contract AstariaRouter inherits ERC4626RouterBase and uses its `withdraw()` and `redeem()` function so users can't call `AstariaRouter.withdraw()` or `AstariaRouter.redeem()`which supports slippage allowance and they have to call vault's functions directly and they may lose funds because of the slippage.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nRemove unnecessary code.\n\n**[androolloyd (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/175)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the functions `withdraw()` and `redeem()` in the ERC4626RouterBase contract. These functions are used to withdraw user funds from vaults and they call `vault.withdraw()` and `vault.redeem()` and logics in the vault transfer user shares. The code uses `safeApprove()` which sets an approval for the vault to spend router vault tokens. The problem is that there is no need for ERC4626RouterBase to set approval for the vault and because those approved tokens won't be used, the code tries to change allowance amount while it's not zero, causing calls to `withdraw()` and `redeem()` to revert. This issue would cause any other protocol integrating with Astaria using those functions to have broken logic and users would lose gas if they use those functions. Furthermore, users would have to call vault's functions directly, which may lead to lost funds due to slippage.\n\nThe recommended mitigation steps for this issue are to remove the unnecessary code. Androolloyd (Astaria) has confirmed the bug report.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-01-astaria",
      "sponsor_name": "Astaria",
      "sponsor_link": "",
      "quality_score": 1,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/175",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "202",
      "slug": "m-23-function-withdraw-and-redeem-in-erc4626routerbase-would-revert-always-because-they-have-unnecessary-allowance-setting-code4rena-astaria-astaria-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Astaria",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Astaria",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Allowance"
          }
        },
        {
          "tags_tag": {
            "title": "Approve"
          }
        },
        {
          "tags_tag": {
            "title": "EIP-4626"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "SafeApprove"
          }
        }
      ]
    },
    {
      "id": "25838",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "41",
      "title": "[M-22] `ERC4626RouterBase.withdraw` can only be called once",
      "content": "\nERC4626RouterBase.withdraw will approve an amount of vault tokens to the vault, but the amount represents the number of asset tokens taken out by vault.withdraw, not the required number of vault tokens, and since it normally requires less than 1 vault token to take out 1 asset token, it will prevent ERC4626RouterBase.withdraw from using all approved vault tokens.\n\n```solidity\n  function withdraw(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 maxSharesOut\n  ) public payable virtual override returns (uint256 sharesOut) {\n\n    ERC20(address(vault)).safeApprove(address(vault), amount);\n    if ((sharesOut = vault.withdraw(amount, to, msg.sender)) > maxSharesOut) {\n      revert MaxSharesError();\n    }\n  }\n```\n\nand since safeApprove cannot approve a non-zero value to a non-zero value, the second call to ERC4626RouterBase.withdraw will fails in safeApprove.\n\n```solidity\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n```\n\n### Proof of Concept\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626RouterBase.sol#L41-L52>\n\n### Recommended Mitigation Steps\n\nChange to\n\n```diff\n  function withdraw(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n-   uint256 maxSharesOut\n+  uint256 maxSharesIn\n  ) public payable virtual override returns (uint256 sharesOut) {\n+   ERC20(address(vault)).safeApprove(address(vault), maxSharesIn);\n+   if ((sharesIn = vault.withdraw(amount, to, msg.sender)) > maxSharesIn) {\n-   ERC20(address(vault)).safeApprove(address(vault), amount);\n-   if ((sharesOut = vault.withdraw(amount, to, msg.sender)) > maxSharesOut) {\n      revert MaxSharesError();\n    }\n+   ERC20(address(vault)).safeApprove(address(vault), 0);\n\n  }\n```\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#467`](https://github.com/code-423n4/2023-01-astaria-findings/issues/467#event-8415375984)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the ERC4626RouterBase.withdraw function, which is used to approve an amount of vault tokens to the vault. The amount represents the number of asset tokens taken out by vault.withdraw, not the required number of vault tokens, and since it normally requires less than 1 vault token to take out 1 asset token, it will prevent ERC4626RouterBase.withdraw from using all approved vault tokens. This is because the safeApprove function cannot approve a non-zero value to a non-zero value, and the second call to ERC4626RouterBase.withdraw will fail in safeApprove.\n\nTo mitigate this issue, the code should be changed to include a maxSharesIn parameter and an associated safeApprove call, and a call to reset the allowance to 0. A proof of concept is available on Github, and SantiagoGregory (Astaria) has confirmed the issue via duplicate issue #467.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-01-astaria",
      "sponsor_name": "Astaria",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/228",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "202",
      "slug": "m-22-erc4626routerbasewithdraw-can-only-be-called-once-code4rena-astaria-astaria-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Astaria",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Astaria",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "EIP-4626"
          }
        }
      ]
    },
    {
      "id": "25822",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 8,
      "protocol_id": "41",
      "title": "[M-06] For a public vault, minimum deposit requirement that is enforced by `ERC4626Cloned.deposit` function can be bypassed by `ERC4626Cloned.mint` function or vice versa when share price does not equal one",
      "content": "\nThe following `ERC4626Cloned.deposit` function has `require(shares > minDepositAmount(), \"VALUE_TOO_SMALL\")` as the minimum deposit requirement, and the `ERC4626Cloned.mint` function below has `require(assets > minDepositAmount(), \"VALUE_TOO_SMALL\")` as the minimum deposit requirement. For a public vault, when the share price becomes different than 1, these functions' minimum deposit requirements are no longer the same. For example, given `S` is the `shares` input value for the `ERC4626Cloned.mint` function and `A` equals `ERC4626Cloned.previewMint(S)`, when the share price is bigger than 1 and `A` equals `minDepositAmount() + 1`, such `A` will violate the `ERC4626Cloned.deposit` function's minimum deposit requirement but the corresponding `S` will not violate the `ERC4626Cloned.mint` function's minimum deposit requirement; in this case, the user can just ignore the `ERC4626Cloned.deposit` function and call `ERC4626Cloned.mint` function to become a liquidity provider. Thus, when the public vault's share price is different than 1, the liquidity provider can call the less restrictive function out of the two so the minimum deposit requirement enforced by one of the two functions is not effective at all; this can result in unexpected deposit amounts and degraded filtering of who can participate as a liquidity provider.\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626-Cloned.sol#L19-L36>\n\n```solidity\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    returns (uint256 shares)\n  {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    require(shares > minDepositAmount(), \"VALUE_TOO_SMALL\");\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    ...\n  }\n```\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626-Cloned.sol#L38-L52>\n\n```solidity\n  function mint(\n    uint256 shares,\n    address receiver\n  ) public virtual returns (uint256 assets) {\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n    require(assets > minDepositAmount(), \"VALUE_TOO_SMALL\");\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    ...\n  }\n```\n\n### Proof of Concept\n\nPlease add the following test in `src\\test\\AstariaTest.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n  function testMinimumDepositRequirementForPublicVaultThatIsEnforcedByDepositFunctionCanBeBypassedByMintFunctionOfERC4626ClonedContractWhenSharePriceIsNotOne() public {\n    uint256 budget = 50 ether;\n    address alice = address(1);\n    address bob = address(2);\n    vm.deal(bob, budget);\n\n    TestNFT nft = new TestNFT(2);\n    _mintNoDepositApproveRouter(address(nft), 5);\n    address tokenContract = address(nft);\n    uint256 tokenId = uint256(0);\n\n    address publicVault = _createPublicVault({\n      strategist: strategistOne,\n      delegate: strategistTwo,\n      epochLength: 14 days\n    });\n\n    // after alice deposits 50 ether WETH in publicVault, publicVault's share price becomes 1\n    _lendToVault(Lender({addr: alice, amountToLend: budget}), publicVault);\n\n    // the borrower borrows 10 ether WETH from publicVault\n    (, ILienToken.Stack[] memory stack1) = _commitToLien({\n      vault: publicVault,\n      strategist: strategistOne,\n      strategistPK: strategistOnePK,\n      tokenContract: tokenContract,\n      tokenId: tokenId,\n      lienDetails: standardLienDetails,\n      amount: 10 ether,\n      isFirstLien: true\n    });\n    uint256 collateralId = tokenContract.computeId(tokenId);\n\n    // the borrower repays for the lien after 9 days, and publicVault's share price becomes bigger than 1\n    vm.warp(block.timestamp + 9 days);\n    _repay(stack1, 0, 100 ether, address(this));\n\n    vm.startPrank(bob);\n\n    // bob owns 50 ether WETH\n    WETH9.deposit{value: budget}();\n    WETH9.approve(publicVault, budget);\n\n    uint256 assetsIn = 100 gwei + 1;\n\n    // for publicVault at this moment, 99265705739 shares are equivalent to (100 gwei + 1) WETH according to previewMint function\n    uint256 sharesIn = IERC4626(publicVault).convertToShares(assetsIn);\n    assertEq(sharesIn, 99265705739);\n    assertEq(IERC4626(publicVault).previewMint(sharesIn), assetsIn);\n    \n    // bob is unable to call publicVault's deposit function for depositing (100 gwei + 1) WETH\n    vm.expectRevert(bytes(\"VALUE_TOO_SMALL\"));\n    IERC4626(publicVault).deposit(assetsIn, bob);\n\n    // bob is also unable to call publicVault's deposit function for depositing a little more than (100 gwei + 1) WETH\n    vm.expectRevert(bytes(\"VALUE_TOO_SMALL\"));\n    IERC4626(publicVault).deposit(assetsIn + 100, bob);\n\n    // however, bob is able to call publicVault's mint function for minting 99265705739 shares while transferring (100 gwei + 1) WETH to publicVault\n    IERC4626(publicVault).mint(sharesIn, bob);\n\n    vm.stopPrank();\n  }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe `ERC4626Cloned.deposit` function can be updated to directly compare the `assets` input to `minDepositAmount()` for the minimum deposit requirement while keeping the `ERC4626Cloned.mint` function as is. Alternatively, the `ERC4626Cloned.mint` function can be updated to directly compare the `shares` input to `minDepositAmount()` for the minimum deposit requirement while keeping the `ERC4626Cloned.deposit` function as is.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/486)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the `ERC4626Cloned.deposit` and `ERC4626Cloned.mint` functions of the Astaria project. These functions have `require(shares > minDepositAmount(), \"VALUE_TOO_SMALL\")` and `require(assets > minDepositAmount(), \"VALUE_TOO_SMALL\")` as the minimum deposit requirement, respectively. For a public vault, when the share price becomes different than 1, these functions' minimum deposit requirements are no longer the same. This can result in unexpected deposit amounts and degraded filtering of who can participate as a liquidity provider.\n\nTo test this bug, a test was added to `src\\test\\AstariaTest.t.sol` which passes to demonstrate the described scenario. To mitigate this issue, the `ERC4626Cloned.deposit` function can be updated to directly compare the `assets` input to `minDepositAmount()` for the minimum deposit requirement while keeping the `ERC4626Cloned.mint` function as is. Alternatively, the `ERC4626Cloned.mint` function can be updated to directly compare the `shares` input to `minDepositAmount()` for the minimum deposit requirement while keeping the `ERC4626Cloned.deposit` function as is. This was confirmed by SantiagoGregory (Astaria).",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-01-astaria",
      "sponsor_name": "Astaria",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/486",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "202",
      "slug": "m-06-for-a-public-vault-minimum-deposit-requirement-that-is-enforced-by-erc4626cloneddeposit-function-can-be-bypassed-by-erc4626clonedmint-function-or-vice-versa-when-share-price-does-not-equal-one-code4rena-astaria-astaria-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Astaria",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Astaria",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-4626"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "7008",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 5,
      "protocol_id": "53",
      "title": "An attacker can freeze all incoming deposits and brick the oracle members' reporting system with only 1 wei",
      "content": "## Severity: Critical Risk\n\n**Context:** SharesManager.1.sol#L195-L206\n\n**Description:** An attacker can brick or lock all deposited user funds and also prevent oracle members from reaching a quorum when there are earnings to be distributed as rewards. Consider the following scenario:\n\n1. The attacker forcefully sends 1 wei to the River contract using, e.g., `selfdestruct`. The attacker must ensure this transaction occurs before any other users deposit their funds in the contract. The attacker can observe the mempool and front-run the initial user deposit. Now, `b = _assetBalance() > 0` is at least 1 wei.\n   \n2. An allowed user tries to deposit funds into the River protocol. The call eventually ends up in `_mintShares(o, x)` and in the first line, `oldTotalAssetBalance = _assetBalance() - x`. Here, `_assetBalance()` represents the updated River balance after accounting for the user deposit `x`. So, `_assetBalance()` is now `b + x + ...` and `oldTotalAssetBalance = b + ...` where the `...` includes the beacon balance sum, deposited amounts for validators in the queue, etc. (which is probably 0 by this point). Therefore, `oldTotalAssetBalance > 0` means that the following if block is skipped:\n\n   ```javascript\n   if (oldTotalAssetBalance == 0) {\n       _mintRawShares(_owner, _underlyingAssetValue);\n       return _underlyingAssetValue;\n   }\n   ```\n\n   It goes directly to the else block for the first allowed user deposit:\n\n   ```javascript\n   else {\n       uint256 sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;\n       _mintRawShares(_owner, sharesToMint);\n       return sharesToMint;\n   }\n   ```\n\n   But since shares have not been minted yet, `_totalSupply() == 0`, leading to `sharesToMint == 0`. Thus, we mint 0 shares for the user and return 0. Note that `_assetBalance()` keeps increasing, but `_totalSupply()` or `Shares.get()` remains 0.\n\n3. When the next allowed users deposit funds, similar to step 2, River mints them 0 shares, while `_assetBalance()` increases but `_totalSupply()` or `Shares.get()` remains 0.\n\n   Note that `_totalSupply()` or `Shares.get()` remains 0 until the oracle members reach a quorum for the beacon balance sum and the number of validators for a voting frame. The last oracle member who calls `reportBeacon` to trigger the quorum causes a call to `_pushToRiver`, which in turn calls `river.setBeaconData`. In `setBeaconData`, if we have accumulated interest, then `_onEarnings` is called. The first few lines of `_onEarnings` are:\n\n   ```javascript\n   uint256 currentTotalSupply = _totalSupply();\n   if (currentTotalSupply == 0) {\n       revert ZeroMintedShares();\n   }\n   ```\n\n   However, `_totalSupply()` is still 0, resulting in `revert ZeroMintedShares()` being called, and the revert bubbles up the stack of the call to `reportBeacon`, causing the last oracle member that can trigger a quorum to have their call to `reportBeacon` reverted. Consequently, no quorums will ever be made that have earnings, and the River protocol will remain unaware of its deposited validators on the beacon change. Any possible path to `_mintRawShares` (which could cause `Shares.get()` to increase) is also blocked, keeping `_totalSupply()` at 0.\n\n   Even after validators, oracle members, etc., become active, when an allowed user deposits, they would receive 0 shares. \n\n   Note that an attacker can turn this into a DoS attack on the River Protocol, as redeployment alone would not solve this issue. The attacker can monitor the mempool and always aim to be the first person to force deposit 1 wei into the River deployed contract.\n\n**Alluvial:** If we change the condition that checks if the old underlying asset balance is zero to check if the total shares is under a minimum amount (so we would mint 1:1 as long as we haven't reached that value), would it solve the issue? This minimum value can be `DEPOSIT_SIZE`, as the price per share should be 1:1 anyway since no revenue was generated.\n\n**Spearbit:** Yes, this would solve the issue. Alluvial can also, as part of an atomic deployment, send 1 wei and mint the corresponding share using a call to the internal function `_mintRawShares`.\n\nAlso, note that we should remove the check for `oldTotalAssetBalance == 0`, as `oldTotalAssetBalance` is used as the denominator for `sharesToMint`. There could be edge scenarios where `_totalSupply()` is positive but `oldTotalAssetBalance` is 0. Thus, if extra checks are introduced for `_totalSupply()`, we should still keep the check or a modified version for `oldTotalAssetBalance`.\n\n**Spearbit:** In PR:\n- **[SPEARBIT/4]** Add an `ethToDeposit` storage variable that accounts for incoming ETH.\n\nAlluvial introduces a `BalanceToDeposit` storage variable. This variable is essentially replacing `address(this).balance` for River in multiple places, including the `_assetBalance()` function. The `BalanceToDeposit` can only be modified when:\n\n1. An allowed user deposits into River, which will increase `BalanceToDeposit` and also total minted shares.\n2. An entity (in later commits, only the admin can call this endpoint) calls `depositToConsensusLayer`, which might reduce the `BalanceToDeposit` amount, but the net effect on `_assetBalance()` would be zero. This implies that `BalanceToDeposit` should have been non-zero to begin with.\n3. A call to `setConsensusLayerData` by the Oracle (originating from a call to `reportConsensusLayerData` by an oracle member) pulls fees from `ELFeeRecipientAddress` (in later commits, it will only pull fees if needed and up to a max amount) and would increase `BalanceToDeposit`.\n\nNote that the attack in this issue works by ensuring `_assetBalance()` is non-zero while `_totalSupply()` is zero. This means we cannot afford a call to end up at `_onEarnings` for this scheme to work. Since if `_totalSupply() == 0`, `_onEarnings` would revert. Hence, even with a malicious group of oracle members reporting wrong data, if a call ends up at `setConsensusLayerData` with `_validatorCount = 0` and `_validatorTotalBalance > 0`, `_onEarnings` would trip. Moreover, if the oracle members are not malicious and simply report `_validatorCount = 0` and `_validatorTotalBalance = 0`, but an attacker force sends 1 wei to `ELFeeRecipientAddress`, `_onEarnings` would revert again because no shares are minted yet. \n\nThis means all possible ways to have a net positive effect on `BalanceToDeposit` (and thus `_assetBalance()`) while keeping `_totalSupply()` at zero are blocked. \n\nThe relationship can be summarized as:\n\n```\n_assetBalance() = (\n    BalanceToDeposit.get() +\n    CLValidatorTotalBalance.get() +\n    (DepositedValidatorCount.get() - CLValidatorCount.get()) * ConsensusLayerDepositManagerV1.DEPOSIT_SIZE\n);\n```\n\nor \n\n```\nB = D + Bv + 32 * (Cd - Cv)\n```\n\nwhere:\n\n- **B** is `_assetBalance()`\n- **D** is `BalanceToDeposit.get()`\n- **Bv** is `CLValidatorTotalBalance.get()`\n- **Cd** is `DepositedValidatorCount.get()`\n- **Cv** is `CLValidatorCount.get()`\n\nAlso, **Cv** - **Cd** is an invariant. **Bv** and **Cv** are only set in `setConsensusLayerData` and thus can only be changed by a quorum of oracle members. **Cd** only increases and is only set in `depositToConsensusLayer`, which requires a positive **D**. After a call to `depositToConsensusLayer`, we have:\n\n```\nD = 32 * (Cd(B = 0))\n```\n\nThus, putting all this information together means that all possible points of attack to ensure **B** remains positive while keeping `_totalSupply()` at zero are blocked.\n\nA note for the future: When users are able to withdraw their investment and burn their shares, if all users withdraw and due to some rounding errors or other causes, **B** stays positive, then the next user to deposit and mint a share would receive zero shares.",
      "summary": "\nA critical risk bug was discovered in the SharesManager.1.sol#L195-L206 code. An attacker can brick/lock all deposited user funds and prevent oracle members from coming to a quorum when there is an earning to be distributed as rewards. The attacker would force send 1 wei to the River contract before any other users deposit their funds. This would cause the _assetBalance() to be at least 1 wei and the oldTotalAssetBalance to be greater than 0. This would cause the following if block to be skipped and the else block would be executed, causing the user to receive 0 shares. This would cause the _totalSupply() or Shares.get() to remain 0 until the oracle members come to a quorum. When the last oracle member calls the reportBeacon, the _onEarnings would be called and the revert ZeroMintedShares() would be called and the revert would bubble up the stack of call to reportBeacon. This would cause no quorums to be made and the River protocol would stay unaware of its deposited validators on the beacon change. Alluvial suggested to change the condition that checks if the old underlying asset balance is 0 to checking if the total shares is under a minimum amount, which would solve the issue. Spearbit agreed and suggested to add a ethToDeposit storage var that accounts for incoming ETH. They also suggested to remove the check for oldTotalAssetBalance == 0 as oldTotalAssetBalance is used as the denominator for sharesToMint. In the future, if users are able to withdraw their investment and burn their shares and due to some rounding errors or other causes _assetBalance() stays positive, then the next user to deposit and mint a share would receive zero shares.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LiquidCollective-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4.5,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LiquidCollective-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/LiquidCollective-Spearbit-Security-Review.pdf",
      "pdf_page_from": 11,
      "contest_id": "",
      "slug": "an-attacker-can-freeze-all-incoming-deposits-and-brick-the-oracle-members-reporting-system-with-spearbit-liquid-collective-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Liquid Collective",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Liquid Collective",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 67.10914421941607
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "totalSupply() = 0"
          }
        },
        {
          "tags_tag": {
            "title": "Revert By Sending Dust"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "3626",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 9,
      "protocol_id": "100",
      "title": "H-3: Early depositors to BufferBinaryPool can manipulate exchange rates to steal funds from later depositors",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/81 \n\n## Found by \ndipp, gandu, rvierdiiev, Ruhum, hansfriese, cccz, 0x52, ctf\\_sec, joestakey\n\n## Summary\n\nTo calculate the exchange rate for shares in BufferBinaryPool it divides the total supply of shares by the totalTokenXBalance of the vault. The first deposit can mint a very small number of shares then donate tokenX to the vault to grossly manipulate the share price. When later depositor deposit into the vault they will lose value due to precision loss and the adversary will profit.\n\n## Vulnerability Detail\n\n    function totalTokenXBalance()\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        return tokenX.balanceOf(address(this)) - lockedPremium;\n    }\n\nShare exchange rate is calculated using the total supply of shares and the totalTokenXBalance, which leaves it vulnerable to exchange rate manipulation. As an example, assume tokenX == USDC. An adversary can mint a single share, then donate 1e8 USDC. Minting the first share established a 1:1 ratio but then donating 1e8 changed the ratio to 1:1e8. Now any deposit lower than 1e8 (100 USDC) will suffer from precision loss and the attackers share will benefit from it.\n\n## Impact\n\nAdversary can effectively steal funds from later users through precision loss\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L405-L412\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRequire a small minimum deposit (i.e. 1e6) \n\n## Discussion\n\n**bufferfinance**\n\nWe'll add the initial liquidity and then burn those LP tokens.",
      "summary": "\nThis bug report is about an issue found in the BufferBinaryPool contract which allows early depositors to manipulate exchange rates to steal funds from later depositors. The exchange rate is calculated using the total supply of shares and the totalTokenXBalance, which leaves it vulnerable to manipulation. An adversary can mint a single share, then donate a large amount of tokenX to the vault to grossly manipulate the share price. When later depositors deposit into the vault they will lose value due to precision loss and the adversary will profit. The impact of this vulnerability is that the adversary can effectively steal funds from later users through precision loss. The bug was found manually and the recommendation is to require a small minimum deposit (e.g. 1e6). The issue has been discussed and a solution has been proposed.",
      "report_date": {},
      "contest_prize_txt": "21800 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/24",
      "sponsor_name": "Buffer Finance",
      "sponsor_link": "",
      "quality_score": 3.5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/81",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "24",
      "slug": "h-3-early-depositors-to-bufferbinarypool-can-manipulate-exchange-rates-to-steal-funds-from-later-depositors-sherlock-buffer-finance-buffer-finance-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Buffer Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Buffer Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Initial Deposit"
          }
        }
      ]
    },
    {
      "id": "3563",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "109",
      "title": "M-5: Math rounding in AutoRoller.sol is not ERC4626-complicant: previewWithdraw should round up.",
      "content": "Source: https://github.com/sherlock-audit/2022-11-sense-judging/issues/30 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nMath rounding in AutoRoller.sol is not ERC4626-complicant: previewWithdraw should round up.\n\n## Vulnerability Detail\n\nPer EIP 4626's Security Considerations (https://eips.ethereum.org/EIPS/eip-4626)\n\n> Finally, ERC-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users:\n\n> If (1) it’s calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) it’s determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round down.\nIf (1) it’s calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) it’s calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round up.\n\nThen previewWithdraw in AutoRoller.sol should round up.\n\nThe original implementation for previewWithdraw in Solmate ERC4626 is:\n\n```solidity\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n```\n\nIt is rounding up, however in the implementation of the AutoRoller.sol#previewWith is not round up.\n\n```solidity\nfor (uint256 i = 0; i < 20;) { // 20 chosen as a safe bound for convergence from practical trials.\n    if (guess > supply) {\n        guess = supply;\n    }\n\n    int256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n\n    if (answer >= 0 && answer <= assets.mulWadDown(0.001e18).safeCastToInt() || (prevAnswer == answer)) { // Err on the side of overestimating shares needed. Could reduce precision for gas efficiency.\n        break;\n    }\n\n    if (guess == supply && answer < 0) revert InsufficientLiquidity();\n\n    int256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n    prevGuess  = guess;\n    prevAnswer = answer;\n    guess      = nextGuess;\n\n    unchecked { ++i; }\n}\n\nreturn guess.safeCastToUint() + maxError; // Buffer for pow discrepancies.\n```\n\nnote the line:\n\n```solidity\n  int256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n```\n\npreviewRedeem is round down.\n\nand later we update guess and return guess\n\n```solidity\n    int256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n    prevGuess  = guess;\n    prevAnswer = answer;\n    guess      = nextGuess;\n```\n\nand\n\n```solidity\n return guess.safeCastToUint() + maxError; // Buffer for pow discrepancies.\n```\n\nwhen calculating the the nextGuess, the code does not round up.\n\n```solidity\nint256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n```\n\n## Impact\n\nOther protocols that integrate with Sense finance AutoRoller.sol might wrongly assume that the functions handle rounding as per ERC4626 expectation. Thus, it might cause some intergration problem in the future that can lead to wide range of issues for both parties.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/AutoRoller.sol#L528-L567\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRound up in previewWithdraw using mulDivUp and divWadUp\n\n## Discussion\n\n**jparklev**\n\nOur understanding is that `nextGuess` does not need to be rounded up since it's just a \"guess\" that is confirmed or denied in how close the \"answer\" is to what we're looking for. So the rounding needs to be in the answer assessment stage.\n\nIn addition, as our comment in the answer inequality says, we do overestimate the shares needed, which is equivalent to rounding up. Perhaps one could make the case that the inequality should be `> 0` rather than `>= 0` so that exact matches from the rounded down `previewRedeem` don't make it through\n\nGiven the above, we're ok accepting this issue, but disagree with the severity\n\n**jparklev**\n\nFix: https://github.com/sense-finance/auto-roller/pull/22\n\n**Evert0x**\n\n@jparklev What severity are you suggesting?\n\n**jparklev**\n\n> @jparklev What severity are you suggesting?\n\n`medium` would be our suggestion\n\n**aktech297**\n\nVerified the fix. As @jparklev mentioned, `rounding needs to be in the answer assessment stage`, the fix is not related to rounding up. It is related to inequality. so, the fix is to check for `> 0` rather than `>= 0` so that exact matches from the rounded down `previewRedeem` don't make it through.",
      "summary": "\nThis bug report is about an issue found in the AutoRoller.sol of the Sense Finance project. The issue is that the math rounding implemented in the previewWithdraw function is not compliant with ERC4626. According to the Ethereum Improvement Proposal (EIP) 4626, when calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide, or when determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round down. However, when calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens, or when calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round up.\n\nThe bug was found by ctf\\_sec and the code snippet can be found at https://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/AutoRoller.sol#L528-L567. The impact of this bug is that other protocols that integrate with Sense finance AutoRoller.sol might wrongly assume that the functions handle rounding as per ERC4626 expectation, which can lead to a wide range of issues for both parties.\n\nThe recommendation is to round up in previewWithdraw using mulDivUp and divWadUp. The fix was implemented and verified and can be found at https://github.com/sense-finance/auto-roller/pull/22. The severity of the issue was suggested to be medium.",
      "report_date": {},
      "contest_prize_txt": "25333 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/19",
      "sponsor_name": "Sense",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-sense-judging/issues/30",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "19",
      "slug": "m-5-math-rounding-in-autorollersol-is-not-erc4626-complicant-previewwithdraw-should-round-up-sherlock-sense-sense-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sense",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sense",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Rounding"
          }
        }
      ]
    },
    {
      "id": "3556",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "109",
      "title": "H-1: Public vault : Initial depositor can manipulate the price per share value and future depositors are forced to deposit huge value in vault.",
      "content": "Source: https://github.com/sherlock-audit/2022-11-sense-judging/issues/50 \n\n## Found by \nak1\n\n## Summary\nMost of the share based vault implementation will face this issue.\nThe vault is based on the ERC4626 where the shares are calculated based on the deposit value.\nBy depositing large amount as initial deposit, initial depositor can influence the future depositors value.\n\n## Vulnerability Detail\n\nShares are minted based on the deposit value.\nhttps://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/RollerPeriphery.sol#L59-L79\nPublic vault is based on the ERC4626 where the shares are calculated based on the deposit value.\n\nBy depositing large amount as initial deposit, first depositor can take advantage over other depositors.\n\nI am sharing reference for this type of issue that already reported and acknowledged. This explain how the share price could be manipulated to  large value.\n\nhttps://github.com/sherlock-audit/2022-08-sentiment-judging#issue-h-1-a-malicious-early-userattacker-can-manipulate-the-ltokens-pricepershare-to-take-an-unfair-share-of-future-users-deposits:~:text=Issue%20H%2D1%3A%20A%20malicious%20early%20user/attacker%20can%20manipulate%20the%20LToken%27s%20pricePerShare%20to%20take%20an%20unfair%20share%20of%20future%20users%27%20deposits\n\nERC4626 implementation\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n      function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n\n## Impact\nFuture depositors are forced for huge value of asset to deposit. It is not practically possible for all the users.\nThis could directly affect on the attrition of users towards this system.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/RollerPeriphery.sol#L59-L79\n\nERC4626 implementation\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n      function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider requiring a minimal amount of share tokens to be minted for the first minter, and send a portion of the initial mints as a reserve to the DAO/ burn so that the price per share can be more resistant to manipulation.\n\n## Discussion\n\n**Evert0x**\n\nDepositor can bypass this initial deposit https://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/AutoRoller.sol#L160",
      "summary": "\nThis bug report is about a vulnerability in the \"Public Vault\" of the ERC4626 implementation. The issue is that the initial depositor can manipulate the price per share value, and this will force future depositors to deposit huge values in the vault. This issue is found in most share-based vault implementations. The vulnerability is that the shares are minted based on the deposit value, so if the initial depositor deposits a large amount, they can take advantage of future depositors. This has been previously reported and acknowledged. The impact of this vulnerability is that future depositors are forced to deposit huge values, which not all users can do, and this can lead to a decrease in the number of users of the system. The code snippet and recommendation are included in the bug report. There is also a discussion about how the initial depositor can bypass the initial deposit.",
      "report_date": {},
      "contest_prize_txt": "25333 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/19",
      "sponsor_name": "Sense",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-sense-judging/issues/50",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "19",
      "slug": "h-1-public-vault-initial-depositor-can-manipulate-the-price-per-share-value-and-future-depositors-are-forced-to-deposit-huge-value-in-vault-sherlock-sense-sense-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sense",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sense",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "First Depositor Issue"
          }
        },
        {
          "tags_tag": {
            "title": "Initial Deposit"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "3337",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "137",
      "title": "M-12: Vault Share/Strategy Token Calculation Can Be Broken By First User/Attacker",
      "content": "Source: https://github.com/sherlock-audit/2022-09-notional-judging/issues/70 \n\n## Found by \nxiaoming90\n\n## Summary\n\nA well-known attack vector for almost all shares-based liquidity pool contracts, where an early user can manipulate the price per share and profit from late users' deposits because of the precision loss caused by the rather large value of price per share.\n\n## Vulnerability Detail\n\n> Note: This issue affects MetaStable2 and Boosted3 balancer leverage vaults\n\nFor simplicity's sake, we will simplify the strategy token minting formula as follows. Also, assume that the 1 vault share is equivalent to 1 strategy token for this particular strategy vault, therefore, we will use the term `vault share` and `strategy token` interchangeably here.\n\n```solidity\nstrategyToken = (totalBPTHeld == 0) ?  bptClaim : (bptClaim * totalStrategyToken) / totalBPTHeld\n```\n\nThe vault minting formula is taken from the following:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol#L27\n\n```solidity\nFile: StrategyUtils.sol\n26:     /// @notice Converts BPT to strategy tokens\n27:     function _convertBPTClaimToStrategyTokens(StrategyContext memory context, uint256 bptClaim)\n28:         internal pure returns (uint256 strategyTokenAmount) {\n29:         if (context.totalBPTHeld == 0) {\n30:             // Strategy tokens are in 8 decimal precision, BPT is in 18. Scale the minted amount down.\n31:             return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n32:                 BalancerConstants.BALANCER_PRECISION;\n33:         }\n34: \n35:         // BPT held in maturity is calculated before the new BPT tokens are minted, so this calculation\n36:         // is the tokens minted that will give the account a corresponding share of the new bpt balance held.\n37:         // The precision here will be the same as strategy token supply.\n38:         strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.totalBPTHeld;\n39:     }\n```\n\nIf the attacker who is the first depositor claims 1 BPT, he will receive 1 Strategy Token. So 1 BPT per Strategy Token. At this point in time, `totalBPTHeld = 1` and `totalStrategyToken = 1`.\n\nThe attacker obtains 9999 BPT can be obtained from the open market. He proceeds to deposit the 9999 BPT into the Aura reward pool on behalf of the vault. At this point in time, `totalBPTHeld = 10000` and `totalStrategyToken = 1`. So 10000 BPT per Strategy Token. Refer to the \"How to increase the total BPT held?\" section below for more details.\n\nTwo issues can occur from here.\n\n#### Issue 1 - If bptClaim >= totalBPTHeld\n\nThe following describes a scenario in which a user's assets are lost and stolen by an attacker. Assume that Alice deposits/borrow some assets and received 19999 BPT. Based on the formula, Alice will only receive 1 Strategy Token. She immediately loses 9999 BPT or half of her assets if she exits the vault or redeems the strategy tokens right after the deposit.\n\n```solidity\nstrategyToken = (bptClaim * totalStrategyToken) / totalBPTHeld\nstrategyToken = (19999 * 1) / 10000 = 1\n```\n\n If the attacker exits the vault right after Alice's deposit, the attacker will receive 14999 BPT. He profited 4999 BPT from this attack\n\n```solidity\nbptReceived = (strategyToken * totalBPTHeld) / totalStrategyToken\nbptReceived = (1 * 29999) / 2 = 14999\n```\n\n#### Issue 2 - If bptClaim < totalBPTHeld\n\nThe following describes a scenario in which a user's assets are lost entirely. Assume that Alice deposits/borrow some assets and received 9999 BPT\n\n```solidity\nstrategyToken = (bptClaim * totalStrategyToken) / totalBPTHeld\nstrategyToken = (9999  * 1) / 10000 = 0\n```\n\nAs such,  she deposited 9999 BPT but did not receive any strategy tokens in return.\n\n#### How to increase the total BPT held?\n\nUnlike the vault design seen in other protocols, Notional's leverage vault does not compute the total BPT held by the vault directly via `BTP.balanceOf(address(vault))`. The vault deposit its BPT to the Aura Reward Pool. Therefore, it is not possible to increase the total BPT held by the vault simply by performing a direct BPT token transfer to the vault or Aura Reward Pool in an attempt to increase it.\n\nHowever, there is a workaround to increase the total BPT held by the vault, and this can be executed by anyone.\n\nThe `totalBPTHeld` within the vault is obtained by calling the `PoolMixin._bptHeld` function.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol#L41\n\n```solidity\nFile: PoolMixin.sol\n41:     function _baseStrategyContext() internal view returns(StrategyContext memory) {\n42:         return StrategyContext({\n43:             totalBPTHeld: _bptHeld(),\n44:             settlementPeriodInSeconds: SETTLEMENT_PERIOD_IN_SECONDS,\n45:             tradingModule: TRADING_MODULE,\n46:             vaultSettings: BalancerVaultStorage.getStrategyVaultSettings(),\n47:             vaultState: BalancerVaultStorage.getStrategyVaultState(),\n48:             feeReceiver: FEE_RECEIVER\n49:         });\n50:     }\n```\n\nWithin the `PoolMixin._bptHeld` function, it will call the `AURA_REWARD_POOL.balanceOf(address(this))` to retrieve the number of BPT that the vault has deposited into the Aura Reward Pool.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol#L37\n\n```solidity\nFile: PoolMixin.sol\n36:     /// @dev Gets the total BPT held by the aura reward pool\n37:     function _bptHeld() internal view returns (uint256) {\n38:         return AURA_REWARD_POOL.balanceOf(address(this));\n39:     }\n```\n\nThe following is the contract of the AURA_REWARD_POOL taken from the Etherscan. Note that the `AURA_REWARD_POOL.balanceOf` will retrieve the number of BPT tokens held by an account. In this example, the account will be the vault's address.\n\nhttps://etherscan.io/address/0xdcee1c640cc270121faf145f231fd8ff1d8d5cd4#code\n\n```solidity\nFile: BaseRewardPool4626.sol\n/**\n * @dev Returns the amount of tokens owned by `account`.\n */\nfunction balanceOf(address account) public view override(BaseRewardPool, IERC20) returns (uint256) {\n    return BaseRewardPool.balanceOf(account);\n}\n```\n\n```solidity\nFile: BaseRewardPool.sol\nfunction balanceOf(address account) public view virtual returns (uint256) {\n\treturn _balances[account];\n}\n```\n\nTo increase the balance, the `deposit(uint256 _pid, uint256 _amount, bool _stake)` function of Aura's Booster contract can be called. However, the problem is that this function will deposit to the `msg.sender` and there is no way to spoof the vault's address. Thus, using this function will not work.\n\nHowever, there is a second method that can be used to perform a deposit. The `AURA_REWARD_POOL ` point to the `BaseRewardPool4626`, thus the reward pool is an ERC4626 vault. The Aura's ERC4626 vault supports an alternative deposit function called `BaseRewardPool4626.deposit` that allows anyone to deposit on behalf of another account. An attacker can leverage the `BaseRewardPool4626.deposit` function by specifying the `receiver` parameter to be the `vault.address` in an attempt to increase the total BPT tokens held by the vault.\n\nhttps://etherscan.io/address/0xdcee1c640cc270121faf145f231fd8ff1d8d5cd4#code\n\n```solidity\nFile: BaseRewardPool4626.sol\n/**\n * @notice Mints `shares` Vault shares to `receiver`.\n * @dev Because `asset` is not actually what is collected here, first wrap to required token in the booster.\n */\nfunction deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {\n    // Transfer \"asset\" (crvLP) from sender\n    IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n    // Convert crvLP to cvxLP through normal booster deposit process, but don't stake\n    uint256 balBefore = stakingToken.balanceOf(address(this));\n    IDeposit(operator).deposit(pid, assets, false);\n    uint256 balAfter = stakingToken.balanceOf(address(this));\n\n    require(balAfter.sub(balBefore) >= assets, \"!deposit\");\n\n    // Perform stake manually, now that the funds have been received\n    _processStake(assets, receiver);\n\n    emit Deposit(msg.sender, receiver, assets, assets);\n    emit Staked(receiver, assets);\n    return assets;\n}\n```\n\n```solidity\nFile: BaseRewardPool.sol \n/**\n* @dev Generic internal staking function that basically does 3 things: update rewards based\n*      on previous balance, trigger also on any child contracts, then update balances.\n* @param _amount    Units to add to the users balance\n* @param _receiver  Address of user who will receive the stake\n*/\nfunction _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {\n    require(_amount > 0, 'RewardPool : Cannot stake 0');\n\n    //also stake to linked rewards\n    for(uint i=0; i < extraRewards.length; i++){\n    IRewards(extraRewards[i]).stake(_receiver, _amount);\n    }\n\n    _totalSupply = _totalSupply.add(_amount);\n    _balances[_receiver] = _balances[_receiver].add(_amount);\n}\n```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol#L27\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol#L41\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol#L37\n\n## Tool used\n\nManual Review\n\n## Impact\n\nThe attacker can profit from future users' deposits while the late users will lose part of their funds to the attacker. Additionally, it is also possible for users to get no share in return for their deposited funds.\n\n## Recommendation\n\nConsider requiring a minimal amount of strategy tokens to be minted for the first minter, and send a portion of the initial mints as a reserve to the Notional Treasury so that the pricePerShare/pricePerStrategyToken can be more resistant to manipulation.\n\n#### Reference\n\nA similar issue was found in a past Sherlock audit\n\n- https://github.com/sherlock-audit/2022-08-sentiment-judging#issue-h-1-a-malicious-early-userattacker-can-manipulate-the-ltokens-pricepershare-to-take-an-unfair-share-of-future-users-deposits\n\n## Discussion\n\n**jeffywu**\n\n@T-Woodward / @weitianjie2000",
      "summary": "\nThis bug report is about an attack vector found in almost all shares-based liquidity pool contracts, where an early user can manipulate the price per share and profit from late users' deposits. Specifically, the issue affects MetaStable2 and Boosted3 balancer leverage vaults. In the simplified formula, if the first user claims 1 BPT, they will receive 1 Strategy Token (1 BPT per Strategy Token). If the attacker deposits 9999 BPT, they will receive 14999 BPT. This means the attacker profited 4999 BPT from this attack. \n\nIf Alice deposits/borrows some assets and received 19999 BPT, she will only receive 1 Strategy Token and lose 9999 BPT. If Alice deposits/borrows some assets and received 9999 BPT, she will receive 0 Strategy Token and lose all her assets. \n\nThe total BPT held by the vault is obtained by calling the `PoolMixin._bptHeld` function. It calls the `AURA_REWARD_POOL.balanceOf(address(this))` to retrieve the number of BPT that the vault has deposited into the Aura Reward Pool. To increase the balance, the `deposit(uint256 _pid, uint256 _amount, bool _stake)` function of Aura's Booster contract can be called. However, the problem is that this function will deposit to the `msg.sender` and there is no way to spoof the vault's address. An attacker can leverage the `BaseRewardPool4626.deposit` function by specifying the `receiver` parameter to be the `vault.address` in an attempt to increase the total BPT tokens held by the vault.\n\nThe impact of this attack is that the attacker can profit from future users' deposits while the late users will lose part of their funds to the attacker. Additionally, it is also possible for users to get no share in return for their deposited funds. The recommendation is to consider requiring a minimal amount of strategy tokens to be minted for the first minter, and send a portion of the initial mints as a reserve to the Notional Treasury so that the pricePerShare/pricePerStrategyToken can be more resistant to manipulation.",
      "report_date": {},
      "contest_prize_txt": "100000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/2",
      "sponsor_name": "Notional",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-notional-judging/issues/70",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "2",
      "slug": "m-12-vault-sharestrategy-token-calculation-can-be-broken-by-first-userattacker-sherlock-notional-notional-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Notional",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Notional",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "First Depositor Issue"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Initial Deposit"
          }
        }
      ]
    },
    {
      "id": "3400",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 21,
      "protocol_id": "138",
      "title": "H-1: Attacker can manipulate the pricePerShare to profit from future users' deposits",
      "content": "Source: https://github.com/sherlock-audit/2022-10-mycelium-judging/tree/main/001-H \n\n## Found by \nRuhum, ctf\\_sec, cccz, joestakey, ellahi, \\_\\_141345\\_\\_, 8olidity, hansfriese, minhquanym, 0x52, caventa, rvierdiiev, Sm4rty, rbserver, IllIllI, sorrynotsorry, JohnSmith, defsec, WATCHPUG, berndartmueller, ak1\n\n## Summary\n\nBy manipulating and inflating the pricePerShare to a super high value, the attacker can cause all future depositors to lose a significant portion of their deposits to the attacker due to precision loss.\n\n## Vulnerability Detail\n\nA malicious early user can `deposit()` with `1 wei` of `LINK` token as the first depositor of the Vault, and get `(1 * STARTING_SHARES_PER_LINK) wei` of shares.\n\nThen the attacker can send `STARTING_SHARES_PER_LINK - 1` of `LINK` tokens and inflate the price per share from `1 / STARTING_SHARES_PER_LINK` to 1.0000 .\n\nThen the attacker call `withdraw()` to withdraw `STARTING_SHARES_PER_LINK - 1` shares, and send `1e22` of `LINK` token and inflate the price per share from 1.000 to 1.000e22.\n\nAs a result, the future user who deposits `9999e18` will only receive `0` (from `9999e18 * 1 / 10000e18`) of shares token.\n\nThey will immediately lose all of their deposits.\n\n## Impact\n\nUsers may suffer a significant portion or even 100% of the funds they deposited to the Vault.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-mycelium/blob/main/mylink-contracts/src/Vault.sol#L131-142\n\n```solidity\n    function deposit(uint256 _amount) external {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(_amount <= availableForDeposit(), \"Amount exceeds available capacity\");\n\n        uint256 newShares = convertToShares(_amount);\n        _mintShares(msg.sender, newShares);\n\n        IERC20(LINK).transferFrom(msg.sender, address(this), _amount);\n        _distributeToPlugins();\n\n        emit Deposit(msg.sender, _amount);\n    }\n```\n\nhttps://github.com/sherlock-audit/2022-10-mycelium/blob/main/mylink-contracts/src/Vault.sol#L614-L620\n\n```solidity\n    function convertToShares(uint256 _tokens) public view returns (uint256) {\n        uint256 tokenSupply = totalSupply(); // saves one SLOAD\n        if (tokenSupply == 0) {\n            return _tokens * STARTING_SHARES_PER_LINK;\n        }\n        return _tokens.mulDivDown(totalShares, tokenSupply);\n    }\n```\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider requiring a minimal amount of share tokens to be minted for the first minter, and send part of the initial mints as a permanent reserve to the DAO/treasury/deployer so that the pricePerShare can be more resistant to manipulation.",
      "summary": "\nThis bug report is about an attacker being able to manipulate the pricePerShare in a smart contract to profit from future users' deposits. The vulnerability was found by a group of researchers, and it was discovered that the attacker can deposit a small amount of LINK token and inflate the pricePerShare to a super high value. This will cause all future depositors to lose a significant portion of their funds due to precision loss. The code snippet provided in the report shows how the attacker can exploit the vulnerability. The recommendation given in the report is to require a minimal amount of share tokens to be minted for the first minter, and send part of the initial mints as a permanent reserve to the DAO/treasury/deployer to make the pricePerShare more resistant to manipulation.",
      "report_date": {},
      "contest_prize_txt": "10000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/7",
      "sponsor_name": "Mycelium",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-mycelium-judging/tree/main/001-H",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "7",
      "slug": "h-1-attacker-can-manipulate-the-pricepershare-to-profit-from-future-users-deposits-sherlock-mycelium-mycelium-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Mycelium",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Mycelium",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Oracle"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Initial Deposit"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "First Depositor Issue"
          }
        }
      ]
    },
    {
      "id": "3371",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "150",
      "title": "M-15: LToken's implmentation is not fully up to EIP-4626's specification",
      "content": "Source: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/500-M \n## Found by \nWATCHPUG\n\n## Summary\n\nNote: This issue is a part of the extra scope added by Sentiment AFTER the audit contest. This scope was only reviewed by WatchPug and relates to these three PRs:\n\n1. [Lending deposit cap](https://github.com/sentimentxyz/protocol/pull/234)\n2. [Fee accrual modification](https://github.com/sentimentxyz/protocol/pull/233)\n3. [CRV staking](https://github.com/sentimentxyz/controller/pull/41)\n\nLToken's implmentation is not fully up to EIP-4626's specification. This issue is would actually be considered a Low issue if it were a part of a Sherlock contest. \n\n## Vulnerability Detail\n\nhttps://github.com/sentimentxyz/protocol/blob/ccfceb2805cf3595a95198c97b6846c8a0b91506/src/tokens/utils/ERC4626.sol#L185-L187\n\n```solidity\nfunction maxMint(address) public view virtual returns (uint256) {\n    return type(uint256).max;\n}\n```\n\nMUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.\n\nhttps://eips.ethereum.org/EIPS/eip-4626#:~:text=MUST%20return%20the%20maximum%20amount%20of%20shares,NOT%20rely%20on%20balanceOf%20of%20asset\n\nmaxMint() and maxDeposit() should reflect the limitation of maxSupply.\n\n## Impact\n\nCould cause unexpected behavior in the future due to non-compliance with EIP-4626 standard. \n\n## Code Snippet\nhttps://github.com/sentimentxyz/protocol/blob/ccfceb2805cf3595a95198c97b6846c8a0b91506/src/tokens/utils/ERC4626.sol#L185-L187\n\n```solidity\nfunction maxMint(address) public view virtual returns (uint256) {\n    return type(uint256).max;\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nmaxMint() and maxDeposit() should reflect the limitation of maxSupply.\n\nConsider changing maxMint() and maxDeposit() to:\n\n```solidity\nfunction maxMint(address) public view virtual returns (uint256) {\n    if (totalSupply >= maxSupply) {\n        return 0;\n    }\n    return maxSupply - totalSupply;\n}\n```\n\n```solidity\nfunction maxDeposit(address) public view virtual returns (uint256) {\n    return convertToAssets(maxMint(address(0)));\n}\n```\n\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/protocol/pull/235).\n\n## Lead Senior Watson\nConfirmed fix.",
      "summary": "\nThis bug report is about LToken's implementation not being fully up to EIP-4626's specification. It was found by the WATCHPUG team and would be considered a low issue if it was part of a Sherlock contest. The issue is related to three PRs, namely Lending deposit cap, Fee accrual modification, and CRV staking. The code snippet that was affected was maxMint() and maxDeposit() which should reflect the limitation of maxSupply. If left as is, it could lead to unexpected behavior in the future due to non-compliance with EIP-4626 standard. The recommendation was to change maxMint() and maxDeposit() to reflect the limitation of maxSupply. The Sentiment team fixed the issue as recommended and Lead Senior Watson confirmed the fix.",
      "report_date": {},
      "contest_prize_txt": "75000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/1",
      "sponsor_name": "Sentiment",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/500-M",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "1",
      "slug": "m-15-ltokens-implmentation-is-not-fully-up-to-eip-4626s-specification-sherlock-sentiment-sentiment-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sentiment",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sentiment",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "3366",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "150",
      "title": "M-10: ERC4626Oracle Vulnerable To Price Manipulation",
      "content": "Source: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/133-M \n## Found by \nxiaoming90, IllIllI\n\n## Summary\n\nERC4626 oracle is vulnerable to price manipulation. This allows an attacker to increase or decrease the price to carry out various attacks against the protocol.\n\n## Vulnerability Detail\n\nThe `getPrice` function within the `ERC4626Oracle` contract is vulnerable to price manipulation because the price can be increased or decreased within a single transaction/block.\n\nBased on the `getPrice` function, the price of the LP token of an ERC4626 vault is dependent on the `ERC4626.previewRedeem` and `oracleFacade.getPrice` functions. If the value returns by either `ERC4626.previewRedeem` or `oracleFacade.getPrice` can be manipulated within a single transaction/block, the price of the LP token of an ERC4626 vault is considered to be vulnerable to price manipulation.\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/oracle/src/erc4626/ERC4626Oracle.sol#L8\n\n```solidity\nFile: ERC4626Oracle.sol\n35:     function getPrice(address token) external view returns (uint) {\n36:         uint decimals = IERC4626(token).decimals();\n37:         return IERC4626(token).previewRedeem(\n38:             10 ** decimals\n39:         ).mulDivDown(\n40:             oracleFacade.getPrice(IERC4626(token).asset()),\n41:             10 ** decimals\n42:         );\n43:     }\n```\n\nIt was observed that the `ERC4626.previewRedeem` couldbe manipulated within a single transaction/block. As shown below, the `previewRedeem` function will call the `convertToAssets` function. Within the `convertToAssets`, the number of assets per share is calculated based on the current/spot total assets and current/spot supply that can be increased or decreased within a single block/transaction by calling the vault's deposit, mint, withdraw or redeem functions. This allows the attacker to artificially inflate or deflate the price within a single block/transaction.\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/tokens/utils/ERC4626.sol#L154\n\n```solidity\nFile: ERC4626.sol\n154:     function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n155:         return convertToAssets(shares);\n156:     }\n```\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/tokens/utils/ERC4626.sol#L132\n\n```solidity\nFile: ERC4626.sol\n132:     function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n133:         uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n134: \n135:         return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n136:     }\n```\n\n## Impact\n\nThe attacker could perform price manipulation to make the apparent value of an asset to be much higher or much lower than the true value of the asset. Following are some risks of price manipulation:\n\n- An attacker can increase the value of their collaterals to increase their borrowing power so that they can borrow more assets than they are allowed from Sentiment.\n- An attacker can decrease the value of some collaterals and attempt to liquidate another user account prematurely.\n\n## Recommendation\n\nAvoid using `previewRedeem` function to calculate the price of the LP token of an ERC4626 vault. Consider implementing TWAP so that the price cannot be inflated or deflated within a single block/transaction or within a short period of time.\n\n## Sentiment Team\nDepends on the integration itself, so there's no action that can be taken right now.\n\n## Lead Senior Watson\nAcknowledged.",
      "summary": "\nERC4626 oracle is vulnerable to price manipulation, which was discovered by xiaoming90 and IllIllI. This vulnerability allows an attacker to increase or decrease the price of the LP token of an ERC4626 vault within a single transaction/block. This is possible because the `getPrice` function is dependent on the `ERC4626.previewRedeem` and `oracleFacade.getPrice` functions, and the number of assets per share is calculated based on the current/spot total assets and current/spot supply that can be increased or decreased within a single block/transaction.\n\nThe attacker could use this vulnerability to make the apparent value of an asset to be much higher or much lower than the true value of the asset. This could be used to increase their borrowing power, or to liquidate another user account prematurely.\n\nTo avoid this vulnerability, the team should avoid using `previewRedeem` function to calculate the price of the LP token of an ERC4626 vault. Instead, they should consider implementing TWAP (Time Weighted Average Price) so that the price cannot be inflated or deflated within a single block/transaction or within a short period of time.",
      "report_date": {},
      "contest_prize_txt": "75000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/1",
      "sponsor_name": "Sentiment",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/133-M",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "1",
      "slug": "m-10-erc4626oracle-vulnerable-to-price-manipulation-sherlock-sentiment-sentiment-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sentiment",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sentiment",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Flash Loan"
          }
        },
        {
          "tags_tag": {
            "title": "Oracle"
          }
        }
      ]
    },
    {
      "id": "3352",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 6,
      "protocol_id": "150",
      "title": "H-4: `ERC4626Oracle` Price will be wrong when the ERC4626's `decimals` is different from the underlying token’s decimals",
      "content": "Source: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/025-H \n## Found by \nLambda, JohnSmith, WATCHPUG, 0x52, berndartmueller, Bahurum\n\n## Summary\n\nEIP-4626 does not require the decimals must be the same as the underlying tokens' decimals, and when it's not, `ERC4626Oracle` will malfunction.\n\n## Vulnerability Detail\n\nIn the current implementation, `IERC4626(token).decimals()` is used as the `IERC4626(token).asset()`'s decimals to calculate the ERC4626's price.\n\nHowever, while most ERC4626s are using the underlying token’s decimals as `decimals`, there are some ERC4626s use a different decimals from underlying token’s decimals since EIP-4626 does not require the decimals must be the same as the underlying token’s decimals:\n\n> Although the convertTo functions should eliminate the need for any use of an EIP-4626 Vault’s decimals variable, it is still strongly recommended to mirror the underlying token’s decimals if at all possible, to eliminate possible sources of confusion and simplify integration across front-ends and for other off-chain users.\n\nRef: https://eips.ethereum.org/EIPS/eip-4626\n\n## Impact\n\nThe price of ERC4626 will be significantly underestimated when the underlying token's decimals > ERC4626's decimals, and be significantly overestimated when the underlying token's decimals < ERC4626's decimals.\n\n## Code Snippet\n\nhttps://github.com/sentimentxyz/oracle/blob/59b26a3d8c295208437aad36c470386c9729a4bc/src/erc4626/ERC4626Oracle.sol#L35-L43\n\n```solidity\n    function getPrice(address token) external view returns (uint) {\n        uint decimals = IERC4626(token).decimals();\n        return IERC4626(token).previewRedeem(\n            10 ** decimals\n        ).mulDivDown(\n            oracleFacade.getPrice(IERC4626(token).asset()),\n            10 ** decimals\n        );\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`getPrice()` can be changed to:\n\n```solidity\n    function getPrice(address token) external view returns (uint) {\n        uint decimals = IERC4626(token).decimals();\n        address underlyingToken = IERC4626(token).asset();\n        return IERC4626(token).previewRedeem(\n            10 ** decimals\n        ).mulDivDown(\n            oracleFacade.getPrice(underlyingToken),\n            10 ** IERC20Metadata(underlyingToken).decimals()\n        );\n    }\n```\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/oracle/pull/34).\n\n## Lead Senior Watson\nConfirmed fix.",
      "summary": "\nThis bug report concerns a malfunction in the `ERC4626Oracle` when the decimals of the ERC4626 is different from the underlying token's decimals. This issue was found by Lambda, JohnSmith, WATCHPUG, 0x52, berndartmueller, and Bahurum. The current implementation uses `IERC4626(token).decimals()` as the `IERC4626(token).asset()`'s decimals to calculate the ERC4626's price, however, EIP-4626 does not require the decimals must be the same as the underlying token’s decimals. This causes the price of ERC4626 to be significantly underestimated when the underlying token's decimals > ERC4626's decimals, and be significantly overestimated when the underlying token's decimals < ERC4626's decimals. The Sentiment Team fixed the issue as recommended and Lead Senior Watson confirmed the fix.",
      "report_date": {},
      "contest_prize_txt": "75000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/1",
      "sponsor_name": "Sentiment",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/025-H",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "1",
      "slug": "h-4-erc4626oracle-price-will-be-wrong-when-the-erc4626s-decimals-is-different-from-the-underlying-tokens-decimals-sherlock-sentiment-sentiment-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sentiment",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sentiment",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Decimals"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "3349",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 9,
      "protocol_id": "150",
      "title": "H-1: A malicious early user/attacker can manipulate the LToken's pricePerShare to take an unfair share of future users' deposits",
      "content": "Source: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/004-H \n## Found by \nkankodu, JohnSmith, PwnPatrol, WATCHPUG, berndartmueller, hyh, \\_\\_141345\\_\\_, IllIllI, TomJ\n\n## Summary\n\nA well known attack vector for almost all shares based liquidity pool contracts, where an early user can manipulate the price per share and profit from late users' deposits because of the precision loss caused by the rather large value of price per share.\n\n## Vulnerability Detail\n\nA malicious early user can `deposit()` with `1 wei` of `asset` token as the first depositor of the LToken, and get `1 wei` of shares.\n\nThen the attacker can send `10000e18 - 1` of `asset` tokens and inflate the price per share from 1.0000 to an extreme value of 1.0000e22 ( from `(1 + 10000e18 - 1) / 1`) .\n\nAs a result, the future user who deposits `19999e18` will only receive `1 wei` (from `19999e18 * 1 / 10000e18`) of shares token.\n\nThey will immediately lose `9999e18` or half of their deposits if they `redeem()` right after the `deposit()`.\n\n## Impact\n\nThe attacker can profit from future users' deposits. While the late users will lose part of their funds to the attacker.\n\n## Code Snippet\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/utils/ERC4626.sol#L48-L60\n\n```solidity\nfunction deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n    beforeDeposit(assets, shares);\n\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/utils/ERC4626.sol#L138-L140\n\n```solidity\nfunction previewDeposit(uint256 assets) public view virtual returns (uint256) {\n    return convertToShares(assets);\n}\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/utils/ERC4626.sol#L126-L131\n\n```solidity\nfunction convertToShares(uint256 assets) public view virtual returns (uint256) {\n    uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n}\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/LToken.sol#L191-L193\n\n```solidity\nfunction totalAssets() public view override returns (uint) {\n    return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider requiring a minimal amount of share tokens to be minted for the first minter, and send a port of the initial mints as a reserve to the DAO so that the pricePerShare can be more resistant to manipulation.\n\n```solidity\nfunction deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n    beforeDeposit(assets, shares);\n\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    // for the first mint, we require the mint amount > (10 ** decimals) / 100\n    // and send (10 ** decimals) / 1_000_000 of the initial supply as a reserve to DAO\n    if (totalSupply == 0 && decimals >= 6) {\n        require(shares > 10 ** (decimals - 2));\n        uint256 reserveShares = 10 ** (decimals - 6);\n        _mint(DAO, reserveShares);\n        shares -= reserveShares;\n    }\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n\nfunction mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n    beforeDeposit(assets, shares);\n\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n    // for the first mint, we require the mint amount > (10 ** decimals) / 100\n    // and send (10 ** decimals) / 1_000_000 of the initial supply as a reserve to DAO\n    if (totalSupply == 0 && decimals >= 6) {\n        require(shares > 10 ** (decimals - 2));\n        uint256 reserveShares = 10 ** (decimals - 6);\n        _mint(DAO, reserveShares);\n        shares -= reserveShares;\n    }\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n```\n## Sentiment Team\nFixed as recommended but instead of sending these shares to the DAO, we burn them. PR [here](https://github.com/sentimentxyz/protocol/pull/232).\n\n## Lead Senior Watson\nConfirmed fix.",
      "summary": "\nThis bug report is about an attack vector found in liquidity pool contracts, which allows malicious early users to manipulate the price per share and profit from late users' deposits. The attack works by the malicious user depositing a small amount of asset token as the first depositor of the LToken, and then sending a large amount of asset tokens to inflate the price per share to an extreme value. This would result in future users who deposit a large amount of asset tokens only receiving a small amount of shares, and thus losing part of their funds to the attacker. \n\nThe code snippets provided in the report show the functions deposit, previewDeposit, convertToShares, and totalAssets which are related to the vulnerability. The recommendation was to require a minimal amount of share tokens to be minted for the first minter, and send a portion of the initial mints as a reserve to the DAO so that the pricePerShare can be more resistant to manipulation. The Sentiment Team fixed this issue by burning the shares instead of sending them to the DAO, and Lead Senior Watson confirmed the fix.",
      "report_date": {},
      "contest_prize_txt": "75000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/1",
      "sponsor_name": "Sentiment",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/004-H",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "1",
      "slug": "h-1-a-malicious-early-userattacker-can-manipulate-the-ltokens-pricepershare-to-take-an-unfair-share-of-future-users-deposits-sherlock-sentiment-sentiment-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sentiment",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sentiment",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Initial Deposit"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        }
      ]
    },
    {
      "id": "2491",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 12,
      "protocol_id": "216",
      "title": "[H-04] First depositor can break minting of shares",
      "content": "_Submitted by MiloTruck, also found by cccz, oyc_109, VAD37, PP1004, SmartSek, minhquanym, unforgiven, berndartmueller, WatchPug, CertoraInc, and sorrynotsorry_\n\nThe attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719\\_ToB_yearn_vaultsv2/ToB\\_-\\_Yearn_Vault_v\\_2\\_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.\n\n### Proof of Concept\n\nIn `BathToken.sol:569-571`, the allocation of shares is calculated as follows:\n\n```js\n(totalSupply == 0) ? shares = assets : shares = (\n    assets.mul(totalSupply)\n).div(_pool);\n```\n\nAn early attacker can exploit this by:\n\n*   Attacker calls `openBathTokenSpawnAndSignal()` with `initialLiquidityNew = 1`, creating a new bath token with `totalSupply = 1`\n*   Attacker transfers a large amount of underlying tokens to the bath token contract, such as `1000000`\n*   Using `deposit()`, a victim deposits an amount less than `1000000`, such as `1000`:\n    *   `assets = 1000`\n    *   `(assets * totalSupply) / _pool = (1000 * 1) / 1000000 = 0.001`, which would round down to `0`\n    *   Thus, the victim receives no shares in return for his deposit\n\nTo avoid minting 0 shares, subsequent depositors have to deposit equal to or more than the amount transferred by the attacker. Otherwise, their deposits accrue to the attacker who holds the only share.\n\n```js\nit(\"Victim receives 0 shares\", async () => {\n    // 1. Attacker deposits 1 testCoin first when creating the liquidity pool\n    const initialLiquidityNew = 1;\n    const initialLiquidityExistingBathToken = ethers.utils.parseUnits(\"100\", decimals);\n    \n    // Approve DAI and testCoin for bathHouseInstance\n    await testCoin.approve(bathHouseInstance.address, initialLiquidityNew, {\n        from: attacker,\n    });\n    await DAIInstance.approve(\n        bathHouseInstance.address,\n        initialLiquidityExistingBathToken,\n        { from: attacker }\n    );\n\n    // Call open creation function, attacker deposits only 1 testCoin\n    const desiredPairedAsset = await DAIInstance.address;\n    await bathHouseInstance.openBathTokenSpawnAndSignal(\n        await testCoin.address,\n        initialLiquidityNew,\n        desiredPairedAsset,\n        initialLiquidityExistingBathToken,\n        { from: attacker }\n    );\n    \n    // Retrieve resulting bathToken address\n    const newbathTokenAddress = await bathHouseInstance.getBathTokenfromAsset(testCoin.address);\n    const _newBathToken = await BathToken.at(newbathTokenAddress);\n\n    // 2. Attacker deposits large amount of testCoin into liquidity pool\n    let attackerAmt = ethers.utils.parseUnits(\"1000000\", decimals);\n    await testCoin.approve(newbathTokenAddress, attackerAmt, {from: attacker});\n    await testCoin.transfer(newbathTokenAddress, attackerAmt, {from: attacker});\n\n    // 3. Victim deposits a smaller amount of testCoin, receives 0 shares\n    // In this case, we use (1 million - 1) testCoin\n    let victimAmt = ethers.utils.parseUnits(\"999999\", decimals);\n    await testCoin.approve(newbathTokenAddress, victimAmt, {from: victim});\n    await _newBathToken.deposit(victimAmt, victim, {from: victim});\n    \n    assert.equal(await _newBathToken.balanceOf(victim), 0);\n});\n```\n\n### Recommended Mitigation Steps\n\n*   [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution.\n*   In `_deposit()`, ensure the number of shares to be minted is non-zero:\n\n`require(shares != 0, \"No shares minted\");`\n\n**[bghughes (Rubicon) confirmed and commented](https://github.com/code-423n4/2022-05-rubicon-findings/issues/397#issuecomment-1171626800):**\n > Great issue, what do y'all think of this code snippet as a solution:\n> \n> `\n>  /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n>     function _deposit(uint256 assets, address receiver)\n>         internal\n>         returns (uint256 shares)\n>     {\n>         uint256 _pool = underlyingBalance();\n>         uint256 _before = underlyingToken.balanceOf(address(this));\n> \n>         // **Assume caller is depositor**\n>         underlyingToken.safeTransferFrom(msg.sender, address(this), assets);\n>         uint256 _after = underlyingToken.balanceOf(address(this));\n>         assets = _after.sub(_before); // Additional check for deflationary tokens\n> \n>         if (totalSupply == 0) {\n>             uint minLiquidityShare = 10**3;\n>             shares = assets.sub(minLiquidityShare);\n>             // Handle protecting from an initial supply spoof attack\n>             _mint(address(0), (minLiquidityShare));\n>         } else {\n>             shares = (assets.mul(totalSupply)).div(_pool);\n>         }\n> \n>         // Send shares to designated target\n>         _mint(receiver, shares);\n> \n>         require(shares != 0, \"No shares minted\");\n>         emit LogDeposit(\n>             assets,\n>             underlyingToken,\n>             shares,\n>             msg.sender,\n>             underlyingBalance(),\n>             outstandingAmount,\n>             totalSupply\n>         );\n>         emit Deposit(msg.sender, msg.sender, assets, shares);\n>     }\n> `\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-05-rubicon-findings/issues/397#issuecomment-1171813747):**\n > LGTM :P\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that affects Rubicon Protocol's BathToken.sol smart contract. The vulnerability allows an attacker to manipulate the total asset amount and prevent users from receiving shares in exchange for their deposits. The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf).\n\nThe bug is located in lines 569-571 of the BathToken.sol smart contract, which calculates the allocation of shares. An early attacker can exploit this by calling the `openBathTokenSpawnAndSignal()` function with an initial liquidity of `1` and then transferring a large amount of underlying tokens to the bath token contract. If a victim then deposits an amount less than the amount transferred by the attacker, they will receive no shares in return for their deposit.\n\nTo avoid this issue, Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address. The same can be done in this case. Additionally, the `_deposit()` function should ensure that the number of shares to be minted is non-zero.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-05-rubicon-contest",
      "sponsor_name": "Rubicon",
      "sponsor_link": "https://twitter.com/rubicondefi",
      "quality_score": 3,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-05-rubicon",
      "github_link": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/397",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "129",
      "slug": "h-04-first-depositor-can-break-minting-of-shares-code4rena-rubicon-rubicon-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Rubicon",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Rubicon",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "First Depositor Issue"
          }
        }
      ]
    },
    {
      "id": "1544",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 5,
      "protocol_id": "239",
      "title": "[H-01] ERC4626 mint uses wrong `amount`",
      "content": "_Submitted by cmichel, also found by 0xliumin, CertoraInc, Picodes, and Ruhum_\n\n> The docs/video say `ERC4626.sol` is in scope as its part of `TurboSafe`\n\nThe `ERC4626.mint` function mints `amount` instead of `shares`.\nThis will lead to issues when the `asset <> shares` are not 1-to-1 as will be the case for most vaults over time.\nUsually, the asset amount is larger than the share amount as vaults receive asset yield.\nTherefore, when minting, `shares` should be less than `amount`.\nUsers receive a larger share amount here which can be exploited to drain the vault assets.\n\n```solidity\nfunction mint(uint256 shares, address to) public virtual returns (uint256 amount) {\n    amount = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n    _mint(to, amount);\n\n    emit Deposit(msg.sender, to, amount, shares);\n\n    afterDeposit(amount, shares);\n}\n```\n\n### Proof of Concept\n\nAssume `vault.totalSupply() = 1000`, `totalAssets = 1500`\n\n*   call `mint(shares=1000)`. Only need to pay `1000` asset amount but receive `1000` shares => `vault.totalSupply() = 2000`, `totalAssets = 2500`.\n*   call `redeem(shares=1000)`. Receive `(1000 / 2000) * 2500 = 1250` amounts. Make a profit of `250` asset tokens.\n*   repeat until `shares <> assets` are 1-to-1\n\n### Recommended Mitigation Steps\n\nIn `deposit`:\n\n```diff\nfunction mint(uint256 shares, address to) public virtual returns (uint256 amount) {\n-    _mint(to, amount);\n+    _mint(to, shares);\n}\n```\n\n**[Alex the Entreprenerd (judge)](https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/27#issuecomment-1065919880):**\n > The warden has identified what is most likely a small oversight, which would have drastic consequences in the internal accounting of the Vault.\n> Because of impact, I agree with high severity.\n> \n> The sponsor has mitigated.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the `ERC4626.sol` code used in the `TurboSafe` project. The code has an issue where it mints `amount` instead of `shares` which can lead to issues when the `asset <> shares` are not 1-to-1. This means that users can exploit this bug to drain the vault assets. \n\nA proof-of-concept (POC) was provided to demonstrate the bug. For example, if `vault.totalSupply() = 1000` and `totalAssets = 1500`, by calling `mint(shares=1000)`, users can receive `1000` shares but only need to pay `1000` asset amount. This means that `vault.totalSupply() = 2000` and `totalAssets = 2500`. When calling `redeem(shares=1000)`, users can receive `(1000 / 2000) * 2500 = 1250` amounts, resulting in a profit of `250` asset tokens.\n\nThe recommended mitigation step to fix this issue is to change the code in `deposit` by replacing `_mint(to, amount);` with `_mint(to, shares);`.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-02-tribe-turbo-contest",
      "sponsor_name": "Tribe",
      "sponsor_link": "https://twitter.com/feiprotocol",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-02-tribe-turbo",
      "github_link": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/27",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "92",
      "slug": "h-01-erc4626-mint-uses-wrong-amount-code4rena-tribe-tribe-turbo-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Tribe",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Tribe",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "Share Inflation"
          }
        }
      ]
    }
  ]
}