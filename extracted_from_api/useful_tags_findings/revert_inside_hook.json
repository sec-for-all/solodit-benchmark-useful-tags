{
  "tag": "Revert Inside Hook",
  "count": 4,
  "metadata": {
    "totalResults": 4,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 9,
    "reset": 1771761120
  },
  "findings": [
    {
      "id": "5894",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 6,
      "protocol_id": "106",
      "title": "[H-07] GiantLP with a transferHookProcessor cant be burned, users’ funds will be stuck in the Giant Pool",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantLP.sol#L39-L47\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L73-L78\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L57\n\n\n## Vulnerability details\n\n## Impact\nThe GiantLP with a transferHookProcessor will call `transferHookProcessor.beforeTokenTransfer(_from, _to, _amount)` when it's transferred / minted / burned. \n\nBut the `to` address is address(0x00) in the erc20 `_burn` function. The GiantMevAndFeesPool.beforeTokenTransfer will call the function `SyndicateRewardsProcessor._distributeETHRewardsToUserForToken` will a zero address check in the first line:\n```\nfunction _distributeETHRewardsToUserForToken(...) internal {\n    require(_recipient != address(0), \"Zero address\");\n```\n\nSo any withdraw function with a operation of burning the GiantLP token with a transferHookProcessor will revert because of the zero address check. The users' funds will be stuck in the Giant Pool contracts.\n\n## Proof of Concept\nI wrote a test about `GiantMevAndFeesPool.withdrawETH` function which is used to withdraw eth from the Giant Pool. It will be reverted.\n\ntest/foundry/LpBurn.t.sol\n```\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\nimport {GiantPoolTests} from \"./GiantPools.t.sol\";\n\ncontract LpBurnTests is GiantPoolTests {\n    function testburn() public{\n        address feesAndMevUserOne = accountOne; vm.deal(feesAndMevUserOne, 4 ether);\n        vm.startPrank(feesAndMevUserOne);\n        giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);\n        giantFeesAndMevPool.withdrawETH(4 ether);\n        vm.stopPrank();\n    }\n}\n```\n\nrun test\n```\nforge test --match-test testburn -vvv\n```\n\ntest log:\n```\n...\n...\n    ├─ [115584] GiantMevAndFeesPool::withdrawETH(4000000000000000000) \n    │   ├─ [585] GiantLP::balanceOf(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) [staticcall]\n    │   │   └─ ← 4000000000000000000\n    │   ├─ [128081] GiantLP::burn(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 4000000000000000000) \n    │   │   ├─ [126775] GiantMevAndFeesPool::beforeTokenTransfer(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 0x0000000000000000000000000000000000000000, 4000000000000000000) \n    │   │   │   ├─ [371] GiantLP::totalSupply() [staticcall]\n    │   │   │   │   └─ ← 4000000000000000000\n    │   │   │   ├─ emit ETHReceived(amount: 4000000000000000000)\n    │   │   │   ├─ [585] GiantLP::balanceOf(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) [staticcall]\n    │   │   │   │   └─ ← 4000000000000000000\n    │   │   │   ├─ [0] 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266::fallback{value: 4000000000000000000}() \n    │   │   │   │   └─ ← ()\n    │   │   │   ├─ emit ETHDistributed(user: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, recipient: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, amount: 4000000000000000000)\n    │   │   │   ├─ [2585] GiantLP::balanceOf(0x0000000000000000000000000000000000000000) [staticcall]\n    │   │   │   │   └─ ← 0\n    │   │   │   └─ ← \"Zero address\"\n    │   │   └─ ← \"Zero address\"\n    │   └─ ← \"Zero address\"\n    └─ ← \"Zero address\"\n```\n\n## Tools Used\nfoundry\n\n## Recommended Mitigation Steps\nskip update rewards for zero address.",
      "summary": "\nThis bug report is about a vulnerability found in the GiantLP, GiantMevAndFeesPool and SyndicateRewardsProcessor contracts. The vulnerability occurs when the GiantLP token is burned and the `to` address is address(0x00). The GiantMevAndFeesPool.beforeTokenTransfer will call the function `SyndicateRewardsProcessor._distributeETHRewardsToUserForToken` which has a zero address check in the first line. This will cause any withdraw function with a burning operation of the GiantLP token to revert, leaving the user's funds stuck in the Giant Pool contracts. \n\nTo prove this vulnerability, the tester wrote a test about `GiantMevAndFeesPool.withdrawETH` function which was used to withdraw eth from the Giant Pool and it was reverted. The test was run with the Foundry tool and the test log was included in the report.\n\nThe recommended mitigation step is to skip the update rewards for the zero address.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/116",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "h-07-giantlp-with-a-transferhookprocessor-cant-be-burned-users-funds-will-be-stuck-in-the-giant-pool-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Revert Inside Hook"
          }
        }
      ]
    },
    {
      "id": "5889",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "106",
      "title": "[H-02] Rewards of GiantMevAndFeesPool can be locked for all users",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L172\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L8\n\n\n## Vulnerability details\n\n## Impact\nAny malicious user could make the rewards in GiantMevAndFeesPool inaccessible to all other users...\n\n## Proof of Concept\n\nhttps://gist.github.com/clems4ever/9b05391cc2192c1b6e8178faa38dfe41\n\nCopy the file in the test suite and run the test.\n\n## Tools Used\n\nforge test\n\n## Recommended Mitigation Steps\n\nProtect the inherited functions of the ERC20 tokens (GiantLP and LPToken) because `transfer` is not protected and can trigger the `before` and `after` hooks. There is the same issue with LPToken and StakingFundsVault.",
      "summary": "\nThis bug report describes a vulnerability that affects the GiantMevAndFeesPool contract. If exploited, it would make the rewards inaccessible to all other users. The proof of concept can be found in a Gist, and testing can be done with the forge test. The recommended mitigation step is to protect the inherited functions of the ERC20 tokens (GiantLP and LPToken) because the `transfer` function is not protected and can trigger the `before` and `after` hooks. The same issue exists with LPToken and StakingFundsVault.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 2.0005842350026874,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/33",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "h-02-rewards-of-giantmevandfeespool-can-be-locked-for-all-users-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Revert Inside Hook"
          }
        }
      ]
    },
    {
      "id": "6251",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 6,
      "protocol_id": "119",
      "title": "[M-11] Lender can reject closing a position",
      "content": "\nA credit line can be closed by using the `LineOfCredit.depositAndClose()` or `LineOfCredit.close`. The remaining funds deposited by the lender (`credit.deposit`) and the accumulated and paid interest are transferred to the lender.\n\nHowever, if the used credit token `credit.token` is native ETH (or an ERC-777 token with receiver hooks, and under the assumption that the oracle supports this asset in the first place), the lender can reject the closing of the credit by reverting the token transfer.\n\n### Impact\n\nThe lender can prevent the borrower from closing the credit line. This leads to the following consequences:\n\n*   Migrating (rollover) to a new line is not possible (it requires all credits to be closed, see [SecuredLine.sol#L55](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L55))\n*   Releasing a spigot and transferring ownership to the borrower is not possible (see [SpigotedLineLib.sol#L195](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L195))\n*   Sweeping remaining tokens (e.g. revenue tokens) in the Spigot to the borrower is not possible (see [SpigotedLineLib.sol#L220](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L220>))\n\n### Proof of Concept\n\n[modules/credit/LineOfCredit.sol#L489-L493](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L489-L493)\n\n```solidity\nfunction _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n    if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n    // return the Lender's funds that are being repaid\n    if (credit.deposit + credit.interestRepaid > 0) {\n        LineLib.sendOutTokenOrETH(\n            credit.token,\n            credit.lender,\n            credit.deposit + credit.interestRepaid\n        );\n    }\n\n    delete credits[id]; // gas refunds\n\n    // remove from active list\n    ids.removePosition(id);\n    unchecked { --count; }\n\n    // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n    if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n    emit CloseCreditPosition(id);\n\n    return true;\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider using a pull-based pattern to allow the lender to withdraw the funds instead of sending them back directly.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/467#issuecomment-1405078929)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the LineOfCredit.sol contract, which is part of the Line-of-Credit project on Github. The vulnerability is related to the closing of a credit line, which can be done using the `LineOfCredit.depositAndClose()` or `LineOfCredit.close` functions. The remaining funds deposited by the lender (`credit.deposit`) and the accumulated and paid interest are transferred to the lender. However, if the used credit token is native ETH (or an ERC-777 token with receiver hooks, and under the assumption that the oracle supports this asset in the first place), the lender can reject the closing of the credit by reverting the token transfer. \n\nThe impact of this vulnerability is that the lender can prevent the borrower from closing the credit line. This leads to the borrower not being able to migrate (rollover) to a new line, releasing a spigot and transferring ownership to the borrower, and sweeping remaining tokens (e.g. revenue tokens) in the Spigot to the borrower. \n\nThe proof of concept for this vulnerability can be found in the LineOfCredit.sol contract, specifically in lines 489-493. The recommended mitigation steps are to consider using a pull-based pattern to allow the lender to withdraw the funds instead of sending them back directly.",
      "report_date": {},
      "contest_prize_txt": "$115,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-debt-dao-contest",
      "sponsor_name": "Debt DAO",
      "sponsor_link": "https://twitter.com/debtdao",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/467",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "174",
      "slug": "m-11-lender-can-reject-closing-a-position-code4rena-debt-dao-debt-dao-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Debt DAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Debt DAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA Lending"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Revert Inside Hook"
          }
        }
      ]
    },
    {
      "id": "3304",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "153",
      "title": "[H-03] A majority attack can easily bypass Zora auction stage in OpenseaProposal and steal the NFT from the party.",
      "content": "_Submitted by Trust_\n\nThe PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. One of the main protections is that before listing the NFT on Opensea for a proposal-supplied price, it must first try to be auctioned off on Zora. To move from Zora stage to Opensea stage, `\\_settleZoraAuction()` is called when executing ListedOnZora step in ListOnOpenseaProposal.sol. If the function returns false, the next step is executed which lists the item on Opensea. It is assumed that if majority attack proposal reaches this stage, it can steal the NFT for free, because it can list the item for negligible price and immediately purchase it from a contract that executes the Opensea proposal.\n\nIndeed, attacker can always make `settleZoraAuction()` return false. Looking at  the code:\n\n    try ZORA.endAuction(auctionId) {\n                // Check whether auction cancelled due to a failed transfer during\n                // settlement by seeing if we now possess the NFT.\n                if (token.safeOwnerOf(tokenId) == address(this)) {\n                    emit ZoraAuctionFailed(auctionId);\n                    return false;\n                }\n            } catch (bytes memory errData) {\n\nAs the comment already hints, an auction can be cancelled if the NFT transfer to the bidder fails. This is the relevant AuctionHouse code (endAuction):\n\n    {\n                // transfer the token to the winner and pay out the participants below\n                try IERC721(auctions[auctionId].tokenContract).safeTransferFrom(address(this), auctions[auctionId].bidder, auctions[auctionId].tokenId) {} catch {\n                    _handleOutgoingBid(auctions[auctionId].bidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);\n                    _cancelAuction(auctionId);\n                    return;\n     }\n\nAs most NFTs inherit from OpenZeppelin's ERC721.sol code, safeTransferFrom will run:\n\n        function _safeTransfer(\n            address from,\n            address to,\n            uint256 tokenId,\n            bytes memory data\n        ) internal virtual {\n            _transfer(from, to, tokenId);\n            require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n        }\n\nSo, attacker can bid a very high amount on the NFT to ensure it is the winning bid. When AuctionHouse tries to send the NFT to attacker, the safeTransferFrom will fail because attack will not implement an ERC721Receiver. This will force the AuctionHouse to return the bid amount to the bidder and cancel the auction. Importantly, it will lead to a graceful return from `endAuction()`, which will make `settleZoraAuction()` return false and progress to the OpenSea stage.\n\n### Impact\n\nA majority attack can easily bypass Zora auction stage and steal the NFT from the party.\n\n### Proof of Concept\n\n1.  Pass a ListOnOpenseaProposal with a tiny list price and execute it\n2.  Create an attacker contract which bids on the NFT an overpriced amount, but does not implement ERC721Receiver. Call its bid() function\n3.  Wait for the auction to end ( timeout after the bid() call)\n4.  Create a contract with a function which calls execute() on the proposal and immediately buys the item on Seaport. Call the attack function.\n\n### Recommended Mitigation Steps\n\n`\\_settleZoraAuction` is called from both ListOnZoraProposal and ListOnOpenseaProposal. If the auction was cancelled due to a failed transfer, as is described in the comment, we would like to handle it differently for each proposal type. For ListOnZoraProposal, it should indeed return false, in order to finish executing the proposal and not to hang the engine. For ListOnOpenseaProposal, the desired behavior is to *revert* in the case of a failed transfer. This is because the next stage is risky and defense against the mentioned attack is required. Therefore, pass a revertOnFail flag to `\\_settleZoraAuction`, which will be used like so:\n\n    // Check whether auction cancelled due to a failed transfer during\n    // settlement by seeing if we now possess the NFT.\n    if (token.safeOwnerOf(tokenId) == address(this)) {\n    \tif (revertOnFail) {\n    \t\trevert(\"Zora auction failed because of transfer to bidder\")\n    \t}\n               emit ZoraAuctionFailed(auctionId);\n               return false;\n    }\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/264#issuecomment-1255311135):**\n > Great find. We will modify `_settleZoraAuction()` to return some auction status to be communicated up to the Opensea proposal.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/264#issuecomment-1262795619):**\n > TIL. While digging into this I noticed that Zora changed this logic in their V3 implementation, avoiding this scenario - but there may be reasons to prefer the auction house contract.\n> \n> Agree with High risk - the auction safeguard can be bypassed, allowing a majority owner to steal from the rest of the party.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/264#issuecomment-1264680120):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/137\n\n\n\n***\n\n",
      "summary": "\nThe PartyGovernance system is a system that protects against a majority holder stealing a Non-Fungible Token (NFT). To move from the Zora stage to the Opensea stage, _settleZoraAuction() is called when executing the ListedOnZora step in ListOnOpenseaProposal.sol. An attacker can make settleZoraAuction() return false, which allows them to list the item on Opensea for a negligible price and immediately purchase it from a contract that executes the Opensea proposal. This would allow the attacker to steal the NFT for free. \n\nTo do this, the attacker passes a ListOnOpenseaProposal with a tiny list price and executes it. Then, they create an attacker contract which bids on the NFT an overpriced amount, but does not implement ERC721Receiver. When the auction ends, they create a contract with a function which calls execute() on the proposal and immediately buys the item on Seaport. \n\nThe recommended mitigation step for this vulnerability is to pass a revertOnFail flag to _settleZoraAuction. This flag will be used to revert in the case of a failed transfer for ListOnOpenseaProposal, as the next stage is risky and defense against the mentioned attack is required.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-09-partydao-contest",
      "sponsor_name": "PartyDAO",
      "sponsor_link": "https://twitter.com/prtyDAO",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/264",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "160",
      "slug": "h-03-a-majority-attack-can-easily-bypass-zora-auction-stage-in-openseaproposal-and-steal-the-nft-from-the-party-code4rena-partydao-partydao-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "PartyDAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "PartyDAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Revert Inside Hook"
          }
        },
        {
          "tags_tag": {
            "title": "NFT"
          }
        }
      ]
    }
  ]
}