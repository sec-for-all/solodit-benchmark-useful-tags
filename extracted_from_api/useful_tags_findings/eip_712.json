{
  "tag": "EIP-712",
  "count": 6,
  "metadata": {
    "totalResults": 6,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 6,
    "reset": 1771761060
  },
  "findings": [
    {
      "id": "33126",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 6,
      "protocol_id": "1366",
      "title": "M-1: Incorrect encoding of bytes for EIP712 digest in `TitleGraph` causes signatures generated by common EIP712 tools to be unusable",
      "content": "Source: https://github.com/sherlock-audit/2024-04-titles-judging/issues/74 \n\n## Found by \n0x73696d616f, T1MOH, ZanyBonzy, ast3ros, fugazzi, mt030d\n## Summary\n\nThe signature in `﻿TitleGraph.acknowledgeEdge()` and ﻿`TitleGraph.unacknowledgeEdge()` is generated based on a digest computed from ﻿`edgeId` and ﻿`data`. However, the ﻿`data` bytes argument is not correctly encoded according to the EIP712 specification. Consequently, a signature generated using common EIP712 tools would not pass validation in ﻿`TitleGraph.checkSignature()`.\n\n## Vulnerability Detail\nAccording to [EIP712](https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata):\n> The dynamic values bytes and string are encoded as a keccak256 hash of their contents.\n\n```solidity\n    modifier checkSignature(bytes32 edgeId, bytes calldata data, bytes calldata signature) {\n        bytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n        ...\n    }\n```\nHowever, the `checkSignature()` modifier in the `TitlesGraph` contract reconstructs the digest by encoding the ﻿data bytes argument without first applying keccak256 hashing.\nAs a result, a signature generated using common EIP712 tools (e.g. using the `signTypedData` function from `ethers.js`) would not pass validation in ﻿`TitleGraph.checkSignature()`.\n\n### POC\n1. EIP712 signature computed by using ethers.js\n```js\n// main.js\nconst { ethers } = require(\"ethers\");\n\nasync function main() {\n    const pk = \"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\";\n    const signer = new ethers.Wallet(pk);\n    const domain = {\n      name: \"TitlesGraph\",\n      version: '1',\n      chainId: 31337,\n      verifyingContract: \"0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\" // should match the address in foundry test\n    };\n    const types = {\n      Ack: [\n        { name: \"edgeId\", type: \"bytes32\" },\n        { name: \"data\", type: \"bytes\" },\n      ],\n    };\n    const value = {\n        edgeId: ethers.id(\"test edgeId\"),\n        data: \"0xabcd\"\n    };\n    const signature = await signer.signTypedData(domain, types, value);\n    console.log(signature);\n    \n}\n\nmain();\n```\nhere we run \n```bash\nnpm install ethers\nnode main.js\n```\nThe output is `0xab4623a7bacf25ed3d6779684f195ed63a5ed1ed46c278c107390086e74b739b35f1db213c6075dedc041d68ced3d11798d49afaf3c47743d4696c49f03037b51b`\n\n2. EIP712 signature computed using foundry\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Test, console} from \"forge-std/Test.sol\";\nimport {EIP712} from \"lib/solady/src/utils/EIP712.sol\";\n\ncontract EIP712Test is Test, EIP712 {\n    bytes32 public constant ACK_TYPEHASH = keccak256(\"Ack(bytes32 edgeId,bytes data)\");\n\n    // test data\n    bytes32 testEdgeId = keccak256(\"test edgeId\");\n    bytes testData = hex\"abcd\";\n\n\n    function test_sig() public {\n        uint256 pk = 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80;\n        bytes32 digest = _computeDigest(testEdgeId, testData);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, digest);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        console.logBytes(signature);\n    }\n\n    function test_sigShouldBe() public {\n        uint256 pk = 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80;\n        bytes32 digest = _computeDigestShouldBe(testEdgeId, testData);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, digest);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        console.logBytes(signature);\n    }\n\n    function _computeDigest(bytes32 edgeId, bytes memory data) internal returns (bytes32 digest) {\n        digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n    }\n\n    function _computeDigestShouldBe(bytes32 edgeId, bytes memory data) internal returns (bytes32 digest) {\n        digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, keccak256(data))));\n    }\n\n    function _domainNameAndVersion()\n        internal\n        pure\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"TitlesGraph\";\n        version = \"1\";\n    }\n}\n```\nhere we run\n```bash\nforge test --mc EIP712Test -vv\n```\nThe output is\n```txt\n[PASS] test_sig() (gas: 12176)\nLogs:\n  0x7bd09aece710ef3845f26c4a695d357b1b170f75d0702f18ec09409f571260237a38e0fed802f8a9d598d9aed0d7898562c51e09bfa7cf254e5a8a5bc74106561c\n\n[PASS] test_sigShouldBe() (gas: 11958)\nLogs:\n  0xab4623a7bacf25ed3d6779684f195ed63a5ed1ed46c278c107390086e74b739b35f1db213c6075dedc041d68ced3d11798d49afaf3c47743d4696c49f03037b51b\n```\n\n`test_sig()` simulates the way the digest is reconstructed in `TitleGraph.checkSignature()`, while `test_sigShouldBe()` shows how  the digest should be reconstructed.\nFrom the above output, we can see the signature generated by ethers.js matches the signature generated in `test_sigShouldBe()`  and does not match the signature generated in `test_sig()`.\nThis PoC shows the way `TitleGraph.checkSignature()` reconstruct the digest is not compatible with the way data is encoded in EIP712.\n\n## Impact\nA signature generated by the signer using common EIP712 tools (e.g. signTypedData in `ethers.js`) would not pass validation in ﻿`TitleGraph.checkSignature()`.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L41\n\n## Tool used\n\nManual Review, ethers.js, foundry\n\n## Recommendation\nEncoding the `data` bytes as a keccak256 hash of its contents before computing the digest from it:\n```diff\n- digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n+ digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, keccak256(data))));\n```",
      "summary": "\nThe bug report discusses an issue with the encoding of bytes in a specific contract called `TitleGraph`. This causes signatures generated by common tools to be unusable. The report explains that the encoding of the `data` bytes argument in the contract is not in line with the EIP712 specification, which leads to signatures generated by tools like `ethers.js` to fail validation in the contract. The report provides a proof of concept and suggests a solution to fix the issue. The impact of this bug is that signatures generated by the signer using common EIP712 tools will not work in the contract. The report also mentions the tools used for the review and provides a recommendation to fix the bug.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/326",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-04-titles-judging/issues/74",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "326",
      "slug": "m-1-incorrect-encoding-of-bytes-for-eip712-digest-in-titlegraph-causes-signatures-generated-by-common-eip712-tools-to-be-unusable-sherlock-titles-publishing-protocol-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "TITLES Publishing Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "TITLES Publishing Protocol",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-712"
          }
        }
      ]
    },
    {
      "id": "30538",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 45,
      "protocol_id": "1238",
      "title": "[M-11] Protocol does not implement EIP712 correctly on multiple occasions",
      "content": "\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L151-L151> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L373-L375> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L384-L386> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L232-L238> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L636>\n\nBeing not EIP712 compliant can lead to issues with integrators and possibly DOS.\n\n### Problem 1\n\nThe implementation of the hook hash ([here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L151C56-L151C56)) is done incorrectly. `hook.extraData` is of type `bytes` which according to EIP712 it is referred to as a `dynamic type`. Dynamic types must be first hashed with `keccak256` to become one 32-byte word before being encoded and hashed together with the typeHash and the other values.\n\n### Mitigation to Problem 1:\n\n```diff\nfunction _deriveHookHash(Hook memory hook) internal view returns (bytes32) {\n  // Derive and return the hook as specified by EIP-712.\n    return\n        keccak256(\n-           abi.encode(_HOOK_TYPEHASH, hook.target, hook.itemIndex, hook.extraData)\n+           abi.encode(_HOOK_TYPEHASH, hook.target, hook.itemIndex, keccak256(hook.extraData))\n        );\n}\n```\n\n### Problem 2\n\nSome TypeHashes are computed by using `abi.encode` instead of `abi.encodePacked` ([here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L373C1-L375)) which makes the typeHash value and the whole final hash different from the hash that correctly implementing EIP712 entities would get.\n\n```solidity\n// Construct the Item type string.\nbytes memory itemTypeString = abi.encodePacked(\n    \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n);\n\n// Construct the Hook type string.\nbytes memory hookTypeString = abi.encodePacked(\n    \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n);\n\n// Construct the RentalOrder type string.\nbytes memory rentalOrderTypeString = abi.encodePacked(\n    \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n);\n\n...\n\nrentalOrderTypeHash = keccak256(\n    abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n);\n```\n\nThe problem with this is that abi.encode-ing strings results in bytes with arbitrary length. In such cases (like the one here) there is a high chance that the bytes will not represent an exact N words in length (X &ast; 32 bytes length) and the data is padded to conform uniformly to 32-byte words. This padding results in an incorrect hash of the typeHash and it will make the digest hash invalid when compared with properly implemented hashes from widely used libraries such as ethers.\n\n### Proof of Concept\n\nPlace the following code in any of the tests and run `forge test -—mt test_EIP712_encoding`\n\n```solidity\nfunction test_EIP712_encoding() public {\n\t\t// Copied from the reNFT codebase\n    bytes memory itemTypeString = abi.encodePacked(\n        \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n    );\n    bytes memory hookTypeString = abi.encodePacked(\n        \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n    );\n    bytes memory rentalOrderTypeString = abi.encodePacked(\n        \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n    );\n\t\t// protocol implementation\n    bytes32 rentalOrderTypeHash = keccak256(\n        abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString) // <-----\n    );\n\n    // correct implementation\n    bytes32 rentalOrderTypeHashCorrect = keccak256(\n        abi.encodePacked(rentalOrderTypeString, hookTypeString, itemTypeString) // <-----\n    );\n\n    // the correct typehash\n    bytes32 correctTypeHash = keccak256(\n        \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)Hook(address target,uint256 itemIndex,bytes extraData)Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n    );\n\n    assertNotEq(rentalOrderTypeHash, rentalOrderTypeHashCorrect);\n    assertNotEq(rentalOrderTypeHash, correctTypeHash);\n    assertEq(rentalOrderTypeHashCorrect, correctTypeHash);\n}\n```\n\nThis test shows that the `rentalOrderTypeHashCorrect` is the correct typeHash.\n\n### Mitigation to Problem 2\n\n```diff\nrentalOrderTypeHash = keccak256(\n-    abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n+    abi.encodePacked(rentalOrderTypeString, hookTypeString, itemTypeString)\n);\n```\n\n### Problem 3\n\n`_deriveOrderMetadataHash`  constructs the hash incorrectly because \\_ORDER_METADATA_TYPEHASH includes `uint8 orderType` and `bytes emittedExtraData` (it can be seen [here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L384-L386C15)) but these values are not provided below the typeHash (it can be seen [here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L232-L238)).\n\n```solidity\nfunction _deriveOrderMetadataHash(\n    OrderMetadata memory metadata\n) internal view returns (bytes32) {\n    bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n\n    for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n        hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n    }\n\n    return\n        keccak256(\n            abi.encode(\n                _ORDER_METADATA_TYPEHASH,// OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\n\t\t\t\t\t\t\t\t// <---- misses uint8 orderType\n                metadata.rentDuration,\n                keccak256(abi.encodePacked(hookHashes))\n\t\t\t\t\t\t\t\t// <---- misses bytes emittedExtraData\n            )\n        );\n}\n```\n\nThis hash is important because it is compared to the zoneHash inside `Create.sol:validateOrder → _rentFromZone → _isValidOrderMetadata` ([link](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L636)): So if the provided zoneHash from Seaport was generated correctly and it is not the same as the one generated by reNFT, the protocol will not be able to create any rentalOrders resulting in **DOS**.\n\nIn any case, this implementation is not according to EIP712 and either the fields must be included or the `_ORDER_METADATA_TYPEHASH` must remove `uint8 orderType` and `bytes emittedExtraData`\n\n### Tools Used\n\nFoundry\n\n### Recommendations\n\nApply the described fixes for each example.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/239#issuecomment-1908739770)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/2) - Properly implements EIP-712.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/17), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/62) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/58).\n\n***\n\n",
      "summary": "\nThis bug report discusses issues found in the code of the reNFT smart contracts. The first problem is that the implementation of the hook hash is incorrect, which can cause problems with integrators and potentially lead to denial of service attacks. The second issue is that some type hashes are computed using `abi.encode` instead of `abi.encodePacked`, resulting in an incorrect hash value. This can also cause problems with integrators and lead to incorrect hashes being compared with other libraries. The third problem is that the `_deriveOrderMetadataHash` function constructs the hash incorrectly, which can result in denial of service attacks. The report recommends applying the fixes described for each issue. The reNFT team has confirmed and mitigated the issues. ",
      "report_date": {},
      "contest_prize_txt": "83600",
      "contest_link": "https://code4rena.com/reports/2024-01-renft",
      "sponsor_name": "reNFT",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/239",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "317",
      "slug": "m-11-protocol-does-not-implement-eip712-correctly-on-multiple-occasions-code4rena-renft-renft-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "reNFT",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "reNFT",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-712"
          }
        }
      ]
    },
    {
      "id": "27422",
      "kind": "GIT",
      "auditfirm_id": "20",
      "impact": "MEDIUM",
      "finders_count": 10,
      "protocol_id": "1109",
      "title": "The `digest` calculation in `deployProxyAndDistributeBySignature` does not follow EIP-712 specification",
      "content": "### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159\">https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159</a>\n\n\n## Summary\n\nThe calculation of the `digest` done in [`ProxyFactory.deployProxyAndDistributeBySignature()`](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159) does not follow the [EIP-712 specification](https://eips.ethereum.org/EIPS/eip-712). It is missing the function's corresponding `typeHash`, as well as the `hashStruct` calculation of the `data` signature parameter, which are both defined in the EIP.\n\nNot following the EIP specification will end up in unexpected integration failures with EIP712-compliant wallets or tooling that perform the encoding in the appropriate way.  \n\n## Vulnerability Details\n\nIn [`ProxyFactory.deployProxyAndDistributeBySignature()`](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159), the `digest` is calculated as follows:\n\n```solidity\nbytes32 digest = _hashTypedDataV4(\n    keccak256(\n        abi.encode(contestId, data)\n    )\n);\n```\nThe [EIP-712 specification](https://eips.ethereum.org/EIPS/eip-712#specification) defines the encoding of a message as:\n\n```\n\"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n```\nIn the current implementation, `\"\\x19\\x01\"` and `domainSeparator` are correctly calculated and appended as per OpenZeppelin's `_hashTypedDataV4()` function, but `hashStruct(message)` is not respected. \n\nThe EIP defines that the `hashStruct` of a message is calculated from the hashing of the **typeHash** and the encoding of the data; and the former is currently missing in the `digest` calculation.\n\nAdditionally, the `data` parameter which is being included as part of the signature, is a `bytes` type, which the EIP defines as **Dynamic**. Dynamic types [are encoded as the hash of the contents](https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata); and currently the `data` parameter is being encoded as-is.\n\n## Impact\n\nThe data being signed is not being encoded as per the EIP-712 specification, which will result in unexpected integration failures with EIP712-compliant wallets or tooling that perform the encoding in the appropriate way.\n\nAfter looking at the tests, I would say this error was not caught since the tests themselves follow the same exact implementation for creating the data being signed. Usage of external libraries such as Ethers.js would have likely revealed this issue earlier.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\n### Define and use the `typeHash` of the function.\n- Define the `typeHash`\n```solidity\nbytes32 internal constant DEPLOY_AND_DISTRIBUTE_TYPEHASH = keccak256(\n    \"DeployAndDistribute(bytes32 contestId,bytes data)\"\n);\n```\n- Include it in the `digest` calculation\n```solidity\nbytes32 digest = _hashTypedDataV4(\n    keccak256(\n        abi.encode(\n            DEPLOY_AND_DISTRIBUTE_TYPEHASH,\n            contestId,\n            ...\n        )\n    )\n);\n```\n\n### Encode the dynamic `data` parameter as per the EIP-712 specification.\n```solidity\nbytes32 digest = _hashTypedDataV4(\n    keccak256(\n        abi.encode(\n            DEPLOY_AND_DISTRIBUTE_TYPEHASH,\n            contestId,\n            keccak256(data)\n        )\n    )\n);\n```",
      "summary": "\nThis bug report is related to the calculation of the `digest` done in the `deployProxyAndDistributeBySignature()` function of the ProxyFactory.sol smart contract. The calculation of the `digest` does not follow the EIP-712 specification, which is a standard for Ethereum message encoding. \n\nThe EIP-712 specification defines the encoding of a message as `\"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)`. In the current implementation, `\"\\x19\\x01\"` and `domainSeparator` are correctly calculated and appended as per OpenZeppelin's `_hashTypedDataV4()` function, but `hashStruct(message)` is not respected. The EIP-712 defines that the `hashStruct` of a message is calculated from the hashing of the **typeHash** and the encoding of the data; and the former is currently missing in the `digest` calculation. Additionally, the `data` parameter which is being included as part of the signature, is a `bytes` type, which the EIP defines as **Dynamic**. Dynamic types [are encoded as the hash of the contents](https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata); and currently the `data` parameter is being encoded as-is.\n\nNot following the EIP specification will end up in unexpected integration failures with EIP712-compliant wallets or tooling that perform the encoding in the appropriate way. The impact of this bug is that the data being signed is not being encoded as per the EIP-712 specification, which will result in unexpected integration failures with EIP712-compliant wallets or tooling that perform the encoding in the appropriate way.\n\nThe bug was discovered through manual review and the tests did not catch it since the tests themselves follow the same exact implementation for creating the data being signed. Usage of external libraries such as Ethers.js would have likely revealed this issue earlier.\n\nThe recommended fixes are to define and use the `typeHash` of the function and encode the dynamic `data` parameter as per the EIP-712 specification.",
      "report_date": {},
      "contest_prize_txt": "15000 USDC",
      "contest_link": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
      "sponsor_name": "CodeFox Inc.",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "",
      "github_link": "https://github.com/Cyfrin/2023-08-sparkn",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "cllcnja1h0001lc08z7w0orxx",
      "slug": "the-digest-calculation-in-deployproxyanddistributebysignature-does-not-follow-eip-712-specification-codehawks-sparkn-git",
      "firm_name": "Codehawks",
      "firm_logo_square": "codehawks_square.png",
      "protocol_name": "Sparkn",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Codehawks",
        "logo_square": "codehawks_square.png"
      },
      "protocols_protocol": {
        "name": "Sparkn",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-712"
          }
        }
      ]
    },
    {
      "id": "28986",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "940",
      "title": "[M-07] EIP-712 typehash is incorrect for several functions in `MetaTxLib`",
      "content": "\nIn `LensHub.sol`, the second parameter of `setProfileMetadataURIWithSig()` is declared as `metadataURI`:\n\n[LensHub.sol#L119-L123](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L119-L123)\n\n```solidity\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n```\n\nHowever, its [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typehash stores the parameter as `metadata` instead:\n\n[Typehash.sol#L33](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Typehash.sol#L33)\n\n```solidity\nbytes32 constant SET_PROFILE_METADATA_URI = keccak256('SetProfileMetadataURI(uint256 profileId,string metadata,uint256 nonce,uint256 deadline)');\n```\n\nThe `PostParams` struct (which is used for [`postWithSig()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L235-L244)) has `address[] actionModules` and `bytes[] actionModulesInitDatas` as its third and fourth fields:\n\n[Types.sol#L178-L185](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Types.sol#L178-L185)\n\n```solidity\n    struct PostParams {\n        uint256 profileId;\n        string contentURI;\n        address[] actionModules;\n        bytes[] actionModulesInitDatas;\n        address referenceModule;\n        bytes referenceModuleInitData;\n    }\n```\n\nHowever, the third and fourth fields in its typehash are declared as `address collectModule` and `bytes collectModuleInitData` instead:\n\n[Typehash.sol#L23](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Typehash.sol#L23)\n\n```solidity\nbytes32 constant POST = keccak256('Post(uint256 profileId,string contentURI,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n```\n\nThis occurs for the [`commentWithSig()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L258-L267) and [`quoteWithSig()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L303-L313) functions as well:\n\n[Typehash.sol#L25](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Typehash.sol#L25)\n\n```solidity\nbytes32 constant QUOTE = keccak256('Quote(uint256 profileId,string contentURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n```\n\n[Typehash.sol#L15](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Typehash.sol#L15)\n\n```solidity\nbytes32 constant COMMENT = keccak256('Comment(uint256 profileId,string contentURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n```\n\nThe fourth and fifth fields in the `MirrorParams` struct (which is used for [`mirrorWithSig()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L281-L290)) are declared as `referrerProfileIds` and `referrerPubIds`:\n\n[Types.sol#L282-L289](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Types.sol#L282-L289)\n\n```solidity\n    struct MirrorParams {\n        uint256 profileId;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        bytes referenceModuleData;\n    }\n```\n\nHowever, its EIP-712 typehash declares these fields as `referrerProfileId` and `referrerPubId` instead:\n\n[Typehash.sol#L21](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Typehash.sol#L21)\n\n```solidity\nbytes32 constant MIRROR = keccak256('Mirror(uint256 profileId,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileId,uint256[] referrerPubId,bytes referenceModuleData,uint256 nonce,uint256 deadline)');\n```\n\n### Impact\n\nDue to the use of incorrect typehashes, the signature verification in the functions listed above is not [EIP-712](https://eips.ethereum.org/EIPS/eip-712) compliant.\n\nContracts or dapps/backends that use \"correct\" typehashes that match the parameters of these functions will end up generating different signatures, causing them to revert when called.\n\n### Recommended Mitigation\n\nAmend the typehashes shown above to have matching parameters with their respective functions.\n\n### Assessed type\n\nError\n\n**[donosonaumczuk (Lens) disagreed with severity and commented](https://github.com/code-423n4/2023-07-lens-findings/issues/141#issuecomment-1669811529):**\n > We accept it, but we consider it Low severity instead. \"Assets are not at risk, function incorrect as to spec\".\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-07-lens-findings/issues/141#issuecomment-1695727736):**\n > Keeping this under Medium severity as this breaks the EIP712 compliance, so can be seen as an instance of \"function of the protocol or its availability could be impacted\"\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about incorrect typehashes in the `LensHub.sol` contract, which is part of the Lens project. In the `setProfileMetadataURIWithSig()` function, the second parameter is declared as `metadataURI` but its EIP-712 typehash stores the parameter as `metadata` instead. Similarly, the third and fourth fields in the `PostParams` struct are declared as `actionModules` and `actionModulesInitDatas` but its typehash declares them as `collectModule` and `collectModuleInitData`. This occurs for the `commentWithSig()` and `quoteWithSig()` functions as well. For the `MirrorParams` struct, the fourth and fifth fields are declared as `referrerProfileIds` and `referrerPubIds` but its typehash declares them as `referrerProfileId` and `referrerPubId`.\n\nDue to the use of incorrect typehashes, the signature verification in the functions listed above is not EIP-712 compliant. This means that contracts or dapps/backends that use \"correct\" typehashes that match the parameters of these functions will end up generating different signatures, causing them to revert when called.\n\nTo mitigate this issue, the typehashes should be amended to have matching parameters with their respective functions. The severity of this bug has been assessed as Medium, as it breaks the EIP-712 compliance and could impact the function of the protocol or its availability.",
      "report_date": {},
      "contest_prize_txt": "85500",
      "contest_link": "https://code4rena.com/reports/2023-07-lens",
      "sponsor_name": "Lens Protocol",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-07-lens",
      "github_link": "https://github.com/code-423n4/2023-07-lens-findings/issues/141",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "263",
      "slug": "m-07-eip-712-typehash-is-incorrect-for-several-functions-in-metatxlib-code4rena-lens-protocol-lens-protocol-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Lens Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Lens Protocol",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-712"
          }
        }
      ]
    },
    {
      "id": "6840",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "113",
      "title": "The digest inSeaDrop.mintSigned is not calculated correctly according to EIP-712",
      "content": "## Severity: Medium Risk\n\n## Context\nSeaDrop.sol#L308\n\n## Description\nThe `mintParams` in the calculation of the digest in `mintSigned` is of struct type, so we would need to calculate and use its `hashStruct`, not the actual variable on its own.\n\n## Recommendation\nAccording to EIP-712, the correct digest would be:\n\n```solidity\n// Include this typehash at the top of the contract\nbytes32 internal constant _MINT_PARAMS_TYPEHASH = keccak256(\n    \"MintParams(\"\n    \"uint256 mintPrice,\"\n    \"uint256 maxTotalMintableByWallet,\"\n    \"uint256 startTime,\"\n    \"uint256 endTime,\"\n    \"uint256 dropStageIndex,\"\n    \"uint256 maxTokenSupplyForStage,\"\n    \"uint256 feeBps,\"\n    \"bool restrictFeeRecipients\"\n    \")\"\n);\n```\n\n...\n\n```solidity\n// hashStruct for mintParams\nbytes32 mintParamsHashStruct = keccak256(\n    abi.encode(\n        _MINT_PARAMS_TYPEHASH,\n        mintParams.mintPrice,\n        mintParams.maxTotalMintableByWallet,\n        mintParams.startTime,\n        mintParams.endTime,\n        mintParams.dropStageIndex,\n        mintParams.maxTokenSupplyForStage,\n        mintParams.feeBps,\n        mintParams.restrictFeeRecipients\n    )\n);\n```\n\n```solidity\nbytes32 digest = keccak256(\n    abi.encodePacked(\n        // EIP-191: `0x19 ` as set prefix, `0x01 ` as version byte\n        bytes2(0x1901),\n        _domainSeparator(),\n        keccak256(\n            abi.encode(\n                _SIGNED_MINT_TYPEHASH,\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParamsHashStruct // <--- correction\n            )\n        )\n    )\n);\n```\n\nThis wasn't caught in the test because the test re-uses the same digest calculation. It would be nice to also test it against an external EIP-712 signature calculation.\n\n## OpenSea\nThanks, the digest was fixed, and ethers EIP-712 `signTypedData` has been used to verify in added unit tests here and here.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the SeaDrop.sol#L308 code, which is used in the calculation of the digest inmintSigned. The bug is that the mintParams in the calculation of the digest is of struct type, so the hashStruct should be used instead of the actual variable. The recommendation is to include a typehash at the top of the contract and use the hashStruct for mintParams in the calculation of the digest. To verify this, Ethers EIP-712 signTypedData is used in added unit tests. The bug was fixed and the tests were successful.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Seadrop-Spearbit-Security-Review.pdf",
      "pdf_page_from": 11,
      "contest_id": "",
      "slug": "the-digest-inseadropmintsigned-is-not-calculated-correctly-according-to-eip-712-spearbit-seadrop-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "SeaDrop",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "SeaDrop",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-712"
          }
        }
      ]
    },
    {
      "id": "3099",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 6,
      "protocol_id": "176",
      "title": "[H-01] Untyped data signing",
      "content": "_Submitted by Lambda, also found by 0x1f8b, 0x52, horsefacts, vlad&#95;bochok, and wastewa_\n\n[Community.sol#L175](https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L175)<br>\n[Community.sol#L213](https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L213)<br>\n[Community.sol#L530](https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L530)<br>\n[Disputes.sol#L91](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Disputes.sol#L91)<br>\n[Project.sol#L142](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L142)<br>\n[Project.sol#L167](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L167)<br>\n[Project.sol#L235](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L235)<br>\n[Project.sol#L286](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L286)<br>\n[Project.sol#L346](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L346)<br>\n[Project.sol#L402](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L402)<br>\n[Project.sol#L499](https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L499)<br>\n\nIn many places of the project (see affected code), untyped application data is directly hashed and signed. This is strongly disencouraged, as it enables different attacks (that each could be considered their own issue / vulnerability, but I submitted it as one, as they have all the same root cause):\n\n1.) Signature reuse across different Rigor projects:<br>\nWhile some signature contain the project address, not all do. For instance, `updateProjectHash` only contains a `_hash` and a `_nonce`. Therefore, we can have the following scenario: Bob is the owner of project A and signs / submit `updateProjectHash` with nonce 0 and some hash. Then, a project B that also has Bob as the owner is created. Attacker Charlie can simply take the `_data` and `_signature` that Bob previously submitted to project A and send it to project B. As this project will have a nonce of 0 (fresh created), it will accept it. `updateTaskHash` is also affected by this.<br>\n2.) Signature reuse across different chains:<br>\nBecause the chain ID is not included in the data, all signatures are also valid when the project is launched on a chain with another chain ID. For instance, let's say it is also launched on Polygon. An attacker can now use all of the Ethereum signatures there. Because the Polygon addresses of user's (and potentially contracts, when the nonces for creating are the same) are often identical, there can be situations where the payload is meaningful on both chains.<br>\n3.) Signature reuse across Rigor functions:<br>\nSome functions accept and decode data / signatures that were intended for other functions. For instance, see this example of providing the data & signature that was intended for `inviteContractor` to `setComplete`:\n\n```diff\ndiff --git a/test/utils/projectTests.ts b/test/utils/projectTests.ts\nindex ae9e202..752e01f 100644\n--- a/test/utils/projectTests.ts\n+++ b/test/utils/projectTests.ts\n@@ -441,7 +441,7 @@ export const projectTests = async ({\n     }\n   });\n\n-  it('should be able to invite contractor', async () => {\n+  it.only('should be able to invite contractor', async () => {\n     expect(await project.contractor()).to.equal(ethers.constants.AddressZero);\n     const data = {\n       types: ['address', 'address'],\n@@ -452,6 +452,7 @@ export const projectTests = async ({\n       signers[1],\n     ]);\n     const tx = await project.inviteContractor(encodedData, signature);\n+    const tx2 = await project.setComplete(encodedData, signature);\n     await expect(tx)\n       .to.emit(project, 'ContractorInvited')\n       .withArgs(signers[1].address);\n```\n\nWhile this reverts because there is no task that corresponds to the address that is signed there, this is not always the case.<br>\n4.) Signature reuse from different Ethereum projects & phishing<br>\nBecause the payload of these signatures is very generic (two addresses, a byte and two uints), there might be situations where a user has already signed data with the same format for a completely different Ethereum application. Furthermore, an attacker could set up a DApp that uses the same format and trick someone into signing the data. Even a very security-conscious owner that has audited the contract of this DApp (that does not have any vulnerabilities and is not malicious, it simply consumes signatures that happen to have the same format) might be willing to sign data for this DApp, as he does not anticipate that this puts his Rigor project in danger.\n\n### Recommended Mitigation Steps\n\nI strongly recommend to follow [EIP-712](https://eips.ethereum.org/EIPS/eip-712) and not implement your own standard / solution. While this also improves the user experience, this topic is very complex and not easy to get right, so it is recommended to use a battle-tested approach that people have thought in detail about. All of the mentioned attacks are not possible with EIP-712:<br>\n1.) There is always a domain separator that includes the contract address.<br>\n2.) The chain ID is included in the domain separator<br>\n3.) There is a type hash (of the function name / parameters)<br>\n4.) The domain separator does not allow reuse across different projects, phishing with an innocent DApp is no longer possible (it would be shown to the user that he is signing data for Rigor, which he would off course not do on a different site)\n\n**[parv3213 (Rigor) confirmed](https://github.com/code-423n4/2022-08-rigor-findings/issues/75)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a project code that could enable different attacks. The code is located in several places, indicated by the provided links. The impacts of these attacks are that signature reuse across different Rigor projects, chains, and functions could be possible. This could lead to malicious users taking advantage of this vulnerability and potentially stealing user data. \n\nTo mitigate these attacks, it is recommended to follow the EIP-712 standard. This is a battle-tested approach that is designed to prevent these types of attacks. It includes a domain separator that includes the contract address, the chain ID, and a type hash. By following this standard, the attacks mentioned in the report would not be possible.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-08-rigor-protocol-contest",
      "sponsor_name": "Rigor Protocol",
      "sponsor_link": "https://twitter.com/Rigor_HQ",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/75",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "151",
      "slug": "h-01-untyped-data-signing-code4rena-rigor-protocol-rigor-protocol-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Rigor Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Rigor Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-712"
          }
        }
      ]
    }
  ]
}