{
  "tag": "Transfer Result Check",
  "count": 3,
  "metadata": {
    "totalResults": 3,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 3,
    "reset": 1771761120
  },
  "findings": [
    {
      "id": "51129",
      "kind": "MARKDOWN",
      "auditfirm_id": "4",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "2651",
      "title": "NON-STANDARD ERC20 TOKENS WILL REVERT",
      "content": "##### Description\n\nThe library `TokenTransfersLibrary.sol` contains the function to perform ERC20 tokens transfers in the protocol. However, this library uses the interface of `IERC20` from OpenZeppelin which enforces the return value on transfer.\n\nThis pattern is not followed by all ERC20 tokens, as for example USDT. If attempting to transfer these tokens, the contract will revert, preventing the transaction to be executed.\n\nCode Location\n-------------\n\n[TokenTransfersLibrary.sol#L12-L19](https://github.com/primex-finance/primex_contracts/blob/f809cc0471935013699407dcd9eab63b60cd2e22/src/contracts/libraries/TokenTransfersLibrary.sol#L12-L19)\n\n#### TokenTransfersLibrary.sol\n\n```\nfunction doTransferFromTo(address token, address from, address to, uint256 amount) public returns (uint256) {\n    uint256 balanceBefore = IERC20(token).balanceOf(to);\n    // The returned value is checked in the assembly code below.\n    // Arbitrary `from` should be checked at a higher level. The library function cannot be called by the user.\n    // slither-disable-next-line unchecked-transfer arbitrary-send-erc20\n    IERC20(token).transferFrom(from, to, amount);\n\n    bool success;\n\n```\n\n[TokenTransfersLibrary.sol#L46-L51](https://github.com/primex-finance/primex_contracts/blob/f809cc0471935013699407dcd9eab63b60cd2e22/src/contracts/libraries/TokenTransfersLibrary.sol#L46-L51)\n\n#### TokenTransfersLibrary.sol\n\n```\nfunction doTransferOut(address token, address to, uint256 amount) public {\n    // The returned value is checked in the assembly code below.\n    // slither-disable-next-line unchecked-transfer\n    IERC20(token).transfer(to, amount);\n\n    bool success;\n\n```\n\n##### BVSS\n\n[AO:A/AC:L/AX:L/C:N/I:N/A:N/D:M/Y:L/R:N/S:U (5.6)](/bvss?q=AO:A/AC:L/AX:L/C:N/I:N/A:N/D:M/Y:L/R:N/S:U)\n\n##### Recommendation\n\nConsider using a non-strict interface, as compound does, to transfer ERC20 tokens.\n\n##### Remediation\n\n**SOLVED**: The **Primex team** solved the issue by using a non-strict interface.\n\n`Commit ID:` [88d33deeebf9c169d21e333ef871c518b10e0b33](https://github.com/primex-finance/primex_contracts/pull/956/commits/88d33deeebf9c169d21e333ef871c518b10e0b33)",
      "summary": "\nThe bug report concerns a function in the `TokenTransfersLibrary.sol` library that is used for transferring ERC20 tokens in the protocol. The library uses the interface of `IERC20` from OpenZeppelin, which enforces a return value on transfer. However, this pattern is not followed by all ERC20 tokens, such as USDT, which causes the contract to revert and prevent the transaction from being executed. The code location of the issue is specified in the report. The BVSS score for this bug is 5.6, and the recommendation is to consider using a non-strict interface, as Compound does, for transferring ERC20 tokens. The Primex team has solved the issue by using a non-strict interface, and the commit ID for the solution is provided.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://www.halborn.com/audits/primex/primex-contracts",
      "sponsor_name": "Primex",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://www.halborn.com/audits/primex/primex-contracts",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "non-standard-erc20-tokens-will-revert-halborn-primex-primex-contracts-markdown",
      "firm_name": "Halborn",
      "firm_logo_square": "halborn_square.png",
      "protocol_name": "Primex Contracts",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Halborn",
        "logo_square": "halborn_square.png"
      },
      "protocols_protocol": {
        "name": "Primex Contracts",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "ERC20"
          }
        },
        {
          "tags_tag": {
            "title": "Change Validation"
          }
        },
        {
          "tags_tag": {
            "title": "Check Return Value"
          }
        },
        {
          "tags_tag": {
            "title": "Transfer Result Check"
          }
        }
      ]
    },
    {
      "id": "30672",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "471",
      "title": "[M-06] Funds locked due to missing transfer check",
      "content": "\nAll of the user's funds are unretrievably locked in the `PrizeVault` contract.\n\nA combination of issues allows for the following scenario:\n\n1. Alice invokes [`_withdraw(receiver, assets)`](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L925-L941) (via `burn()` or `withdraw()`).\n2. The contract [computes the number of shares to redeem](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L933-L934), via `previewWithdraw(assets)`.\n3. The contract [redeems as many shares](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L935-L936), but the ERC 4626-compliant vault returns fewer shares than expected. At this point, the contract holds fewer than `assets` tokens.\n4. The contract [attempts to `transfer` assets to the receiver](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L939). This fails due to insufficient funds, but the ERC 20-compliant token does not revert (only returns `false`).\n5. At this point, Alice's assets are locked in the `PrizeVault` contract. They cannot be withdrawn at a later point, because the corresponding prize vault and yield vault shares have been burned.\n\nThe exploit relies on insufficient handling of two corner cases of [ERC-20](https://eips.ethereum.org/EIPS/eip-20) and [ERC-4246](https://eips.ethereum.org/EIPS/eip-4626):\n\n- [ERC-20](https://eips.ethereum.org/EIPS/eip-20) does not stipulate that `transfer` must throw if the message sender holds insufficient balance. Instead, returning `false` is compliant with ERC-20 and implemented by many tokens, including [BAT](https://etherscan.io/token/0x0d8775f648430679a709e98d2b0cb6250d2887ef), [cUSDC](https://etherscan.io/token/0x39aa39c021dfbae8fac545936693ac917d5e7563), [EURS](https://etherscan.io/token/0xdb25f211ab05b1c97d595516f45794528a807ad8), [HuobiToken](https://etherscan.io/token/0x6f259637dcd74c767781e37bc6133cd6a68aa161), [ZRX](https://etherscan.io/token/0xe41d2489571d322189246dafa5ebde1f4699f498) and many more.\n- [ERC-4626](https://eips.ethereum.org/EIPS/eip-4626) does not stipulate that `redeem(previewWithdraw(assets))` transfers at least `assets`. In particular, [`redeem(shares, ...)`](https://eips.ethereum.org/EIPS/eip-4626#redeem) only guarantees that exactly `shares` are burned. The only guaranteed way to gain a certain amount of assets is by calling [`withdraw(assets, ...)`](https://eips.ethereum.org/EIPS/eip-4626#withdraw).\\\n\nWhile this is the most standards-compliant scenario, a malicious vault could simply not transfer the required tokens on purpose, and still trigger the same effect as described above.\n\n### Proof of Concept\n\nWe provide a proof of concept that results in all of Alice's assets locked in the `PrizeVault` contract and all her shares burned.\n\nPlace the file below in `test/unit/PrizeVault/PoCLockedFunds.t.sol` and run the test with:\n\n```\n    $ forge test --mt test_poc_lockedFundsOnLossyWithdrawal\n```\n\n<details>\n\n```solidity\n// Place in test/unit/PrizeVault/PoCLockedFunds.t.sol\npragma solidity ^0.8.24;\n\nimport { UnitBaseSetup } from \"./UnitBaseSetup.t.sol\";\n\nimport { IERC20, IERC4626 } from \"openzeppelin/token/ERC20/extensions/ERC4626.sol\";\nimport { ERC20PermitMock } from \"../../contracts/mock/ERC20PermitMock.sol\";\nimport { ERC4626Mock } from \"openzeppelin/mocks/ERC4626Mock.sol\";\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\n\n// An ERC20-compliant token that does not throw on insufficient balance.\ncontract NoRevertToken is IERC20 {\n    uint8   public decimals = 18;\n    uint256 public totalSupply;\n\n    mapping (address => uint)                      public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n\n    constructor(uint _totalSupply) {\n        totalSupply = _totalSupply;\n        balanceOf[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function transfer(address dst, uint wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n    function transferFrom(address src, address dst, uint wad) virtual public returns (bool) {\n        if (balanceOf[src] < wad) return false;                        // insufficient src bal\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n            if (allowance[src][msg.sender] < wad) return false;        // insufficient allowance\n            allowance[src][msg.sender] = allowance[src][msg.sender] - wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n    function approve(address usr, uint wad) virtual external returns (bool) {\n        allowance[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n}\n\n\n// An ERC4626-compliant (yield) vault.\n// `withdraw(assets)` burns `assets * totalSupply / (totalAssets + 1)` shares.\n// `redeem(shares)` transfers `shares * (totalAssets + 1) / (totalSupply + 1)` assets.\ncontract YieldVault is ERC4626Mock {\n    using Math for uint256;\n    constructor(address _asset) ERC4626Mock(_asset) {}\n\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets.mulDiv(totalSupply(), totalAssets() + 1);\n    }\n}\n\n// Demonstrate that all of Alice's funds are locked in the PrizeVault,\n// with all corresponding shares burned.\ncontract PoCLockedFunds is UnitBaseSetup {\n    NoRevertToken asset;\n\n    function setUpUnderlyingAsset() public view override returns (ERC20PermitMock) {\n        return ERC20PermitMock(address(asset));\n    }\n\n    function setUpYieldVault() public override returns (IERC4626) {\n        return new YieldVault(address(underlyingAsset));\n    }\n\n    function setUp() public override {\n        return;\n    }\n\n    function test_poc_lockedFundsOnLossyWithdrawal() public {\n        uint256 deposited = 1e18;\n\n        // Mint 10^18 tokens and transfer them to Alice.\n        asset = new NoRevertToken(deposited);\n        super.setUp();\n        asset.transfer(alice, deposited);\n\n        // Alice holds all tokens, the yield vault and the price vaults are empty.\n        assertEq(underlyingAsset.balanceOf(alice), deposited);\n        assertEq(underlyingAsset.balanceOf(address(vault)), 0);\n        assertEq(underlyingAsset.balanceOf(address(yieldVault)), 0);\n        assertEq(yieldVault.totalSupply(), 0);\n        assertEq(yieldVault.balanceOf(address(vault)), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n\n        // Alice enters the vault.\n        vm.startPrank(alice);\n        underlyingAsset.approve(address(vault), deposited);\n        vault.deposit(deposited, alice);\n\n        // All assets were transferred into the yield vault,\n        // as many yield vault shares were minted to the prize vault, and\n        // as many prize vault shares were minted to Alice.\n        assertEq(underlyingAsset.balanceOf(alice), 0);\n        assertEq(underlyingAsset.balanceOf(address(vault)), 0);\n        assertEq(underlyingAsset.balanceOf(address(yieldVault)), deposited);\n        assertEq(yieldVault.totalSupply(), deposited);\n        assertEq(yieldVault.balanceOf(address(vault)), deposited);\n        assertEq(vault.totalSupply(), deposited);\n        assertEq(vault.balanceOf(alice), deposited);\n\n        // Perform the lossy withdraw.\n        vault.withdraw(deposited, alice, alice);\n\n        // At this point Alice should've received all her assets back,\n        // and all prize/yield vault shares should've been burned.\n        // In contrast, no assets were transferred to Alice,\n        // but (almost) all shares have been burned.\n        assertEq(underlyingAsset.balanceOf(alice), 0);\n        assertEq(underlyingAsset.balanceOf(address(vault)), 999999999999999999);\n        assertEq(underlyingAsset.balanceOf(address(yieldVault)), 1);\n        assertEq(yieldVault.totalSupply(), 1);\n        assertEq(yieldVault.balanceOf(address(vault)), 1);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n\n        // As a result, Alice's funds are locked in the vault;\n        // she cannot even withdraw a single asset.\n        vm.expectRevert();\n        vault.withdraw(1, alice, alice);\n        vm.expectRevert();\n        vault.redeem(1, alice, alice);\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nWe recommend to fix both the ERC-20 transfer and ERC-4626 withdrawal.\n\nFor the first, it is easiest to rely on OpenZeppelin's [SafeERC20 `safeTransfer`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8cc7f2dcbf368f2a7ea491389dae41f01c16e352/contracts/token/ERC20/utils/SafeERC20.sol#L32-L38) function:\n\n```diff\ndiff --git a/pt-v5-vault/src/PrizeVault.sol b/pt-v5-vault/src/PrizeVault.sol\nindex fafcff3..de69915 100644\n--- a/pt-v5-vault/src/PrizeVault.sol\n+++ b/pt-v5-vault/src/PrizeVault.sol\n@@ -936,7 +936,7 @@ contract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownab\n             yieldVault.redeem(_yieldVaultShares, address(this), address(this));\n         }\n         if (_receiver != address(this)) {\n-            _asset.transfer(_receiver, _assets);\n+            _asset.safeTransfer(_receiver, _assets);\n         }\n     }\n```\n\nThis already mitigates the erroneous locking of assets.\n\nIn addition, we recommend to ensure that at least the necessary amount of shares is withdrawn from the yield vault.\nIn the simplest form, this can be ensured by invoking `withdraw` directly:\n\n```diff\ndiff --git a/pt-v5-vault/src/PrizeVault.sol b/pt-v5-vault/src/PrizeVault.sol\nindex fafcff3..9bb0653 100644\n--- a/pt-v5-vault/src/PrizeVault.sol\n+++ b/pt-v5-vault/src/PrizeVault.sol\n@@ -930,10 +930,7 @@ contract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownab\n         // latent balance, we don't need to redeem any yield vault shares.\n         uint256 _latentAssets = _asset.balanceOf(address(this));\n         if (_assets > _latentAssets) {\n-            // The latent balance is subtracted from the withdrawal so we don't withdraw more than we need.\n-            uint256 _yieldVaultShares = yieldVault.previewWithdraw(_assets - _latentAssets);\n-            // Assets are sent to this contract so any leftover dust can be redeposited later.\n-            yieldVault.redeem(_yieldVaultShares, address(this), address(this));\n+            yieldVault.withdraw(_assets - _latentAssets, address(this), address(this));\n         }\n         if (_receiver != address(this)) {\n             _asset.transfer(_receiver, _assets);\n```\n\nIf a tighter bound on redeemed shares is desired, the call to `previewWithdraw`/`redeem` should be followed by a `withdraw` of the outstanding assets:\n\n```diff\ndiff --git a/pt-v5-vault/src/PrizeVault.sol b/pt-v5-vault/src/PrizeVault.sol\nindex fafcff3..622a7a6 100644\n--- a/pt-v5-vault/src/PrizeVault.sol\n+++ b/pt-v5-vault/src/PrizeVault.sol\n@@ -934,6 +934,13 @@ contract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownab\n             uint256 _yieldVaultShares = yieldVault.previewWithdraw(_assets - _latentAssets);\n             // Assets are sent to this contract so any leftover dust can be redeposited later.\n             yieldVault.redeem(_yieldVaultShares, address(this), address(this));\n+            \n+            // Redeeming `_yieldVaultShares` may have transferred fewer than the required assets.\n+            // Ask for the outstanding assets directly.\n+            _latentAssets = _asset.balanceOf(address(this));\n+            if (_assets > _latentAssets) {\n+                yieldVault.withdraw(_assets - _latentAssets);\n+            }\n         }\n         if (_receiver != address(this)) {\n             _asset.transfer(_receiver, _assets);\n```\n\n### Assessed type\n\nERC20\n\n**[trmid (PoolTogether) confirmed and commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/235#issuecomment-1996001801):**\n > I would like to add that if a \"compatible ERC4626 yield vault returns less assets than expected\", then it is not actually ERC4626 compatible as these behaviors are required in the spec. That being said, there are likely to be some yield vaults that have errors like this and it is a good thing if we can protect against it without inhibiting the default experience!\n> \n> The `safeTransfer` addition seems sufficient, while the other recommended mitigations are unnecessary and would break the \"dust collector\" strategy that the prize vault employs.\n>\n> Mitigation [here](https://github.com/GenerationSoftware/pt-v5-vault/pull/86).\n\n**[hansfriese (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/235#issuecomment-2002771823):**\n > The impact is critical if `_asset.transfer()` fails silently and it will be mitigated from [this known issue](https://github.com/code-423n4/2024-03-pooltogether/blob/main/bot-report.md#m-02-erc-20-transfertransferfrom-return-values-should-be-checked).\n> So according to [this criteria](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-similar-exploits-under-a-single-issue), this issue might be OOS if it's fully mitigated by adding `safeTransfer`.\n> \n> But another impact is `withdraw()` might revert when `yieldVault.redeem()` returns fewer assets than requested and Medium is appropriate.\n\n***\n\n",
      "summary": "\nThe bug report describes a scenario where a user's funds are locked in a contract called `PrizeVault`. This happens due to a combination of issues where the contract does not handle certain cases properly. The bug can be triggered when a user tries to withdraw their funds using a function called `_withdraw()`, which calculates the number of shares to redeem and then tries to transfer the assets to the user. However, due to errors in the contract's code and the way some tokens work, the transfer fails but does not revert, leaving the user's funds locked in the contract. This exploit relies on the fact that some tokens do not throw an error when the user does not have enough funds, and that the contract does not always transfer the correct amount of shares. A proof of concept is provided to demonstrate the bug, and mitigation steps are recommended to fix the issue. The bug is assessed as Medium severity, as it can cause the user's funds to be locked and the contract to revert in certain situations. ",
      "report_date": {},
      "contest_prize_txt": "37700",
      "contest_link": "https://code4rena.com/reports/2024-03-pooltogether",
      "sponsor_name": "PoolTogether",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2024-03-pooltogether",
      "github_link": "https://github.com/code-423n4/2024-03-pooltogether-findings/issues/235",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "332",
      "slug": "m-06-funds-locked-due-to-missing-transfer-check-code4rena-pooltogether-pooltogether-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "PoolTogether",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "PoolTogether",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Transfer Result Check"
          }
        },
        {
          "tags_tag": {
            "title": "ERC4626"
          }
        },
        {
          "tags_tag": {
            "title": "ERC20"
          }
        }
      ]
    },
    {
      "id": "2333",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 32,
      "protocol_id": "219",
      "title": "[H-02] The check for value transfer success is made after the return statement in `_withdrawFromYieldPool` of `LidoVault`",
      "content": "\nUsers can lose their funds\n\n### Proof of Concept\n\n[LidoVault.sol#L142](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142)<br>\n\nThe code checks transaction success after returning the transfer value and finishing execution. If the call fails the transaction won't revert since  require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID); won't execute.\n\nUsers will have withdrawn without getting their funds back.\n\n### Recommended Mitigation Steps\n\nReturn the function after the success check\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/157)**\n\n**[iris112 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/157):**\n > [Fix the issue of return before require sturdyfi/code4rena-may-2022#9](https://github.com/sturdyfi/code4rena-may-2022/pull/9)\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/157#issuecomment-1145546283):**\n > Issue is rather clear-cut.\n\n\n\n***\n \n",
      "summary": "\nThis bug report is about a vulnerability in a smart contract code on the Ethereum blockchain. The code is located at https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142. The impact of this vulnerability is that users can lose their funds. The proof of concept is that the code checks the success of a transaction after returning the transfer value and finishing execution. If the call fails, the transaction won't revert, leaving users with no funds. The recommended mitigation step is to return the function after the success check.",
      "report_date": {},
      "contest_prize_txt": "$30,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-05-sturdy-contest",
      "sponsor_name": "Sturdy",
      "sponsor_link": "https://twitter.com/SturdyFinance",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-05-sturdy",
      "github_link": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/157",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "125",
      "slug": "h-02-the-check-for-value-transfer-success-is-made-after-the-return-statement-in-_withdrawfromyieldpool-of-lidovault-code4rena-sturdy-sturdy-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Sturdy",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Sturdy",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Transfer Result Check"
          }
        },
        {
          "tags_tag": {
            "title": "Weird ERC20"
          }
        }
      ]
    }
  ]
}