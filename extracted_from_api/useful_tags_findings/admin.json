{
  "tag": "Admin",
  "count": 36,
  "metadata": {
    "totalResults": 36,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 14,
    "reset": 1771760940
  },
  "findings": [
    {
      "id": "30589",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "1263",
      "title": "M-11: FRAX admin can adjust fee rate to harm Napier and its users",
      "content": "Source: https://github.com/sherlock-audit/2024-01-napier-judging/issues/108 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nxiaoming90\n## Summary\n\nFRAX admin can adjust fee rates to harm Napier and its users, preventing Napier users from withdrawing.\n\n## Vulnerability Detail\n\nPer the contest page, the admins of the protocols that Napier integrates with are considered \"RESTRICTED\". This means that any issue related to FRAX's admin action that could negatively affect Napier protocol/users will be considered valid in this audit contest.\n\n> Q: Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\n> RESTRICTED\n\nFollowing is one of the ways that FRAX admin can harm Napier and its users.\n\nFRAX admin can set the fee to 100%.\n\nhttps://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd#code#L3413\n\n```solidity\nFile: FraxEtherRedemptionQueue.sol\n217:     /// @notice Sets the fee for redeeming\n218:     /// @param _newFee New redemption fee given in percentage terms, using 1e6 precision\n219:     function setRedemptionFee(uint64 _newFee) external {\n220:         _requireSenderIsTimelock();\n221:         if (_newFee > FEE_PRECISION) revert ExceedsMaxRedemptionFee(_newFee, FEE_PRECISION);\n222: \n223:         emit SetRedemptionFee({ oldRedemptionFee: redemptionQueueState.redemptionFee, newRedemptionFee: _newFee });\n224: \n225:         redemptionQueueState.redemptionFee = _newFee;\n226:     }\n```\n\nWhen the adaptor attempts to redeem the staked ETH from FRAX via the `enterRedemptionQueue` function, the 100% fee will consume the entire amount of the staked fee, leaving nothing for Napier's adaptor.\n\nhttps://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd#code#L3645\n\n```solidity\nFile: FraxEtherRedemptionQueue.sol\n343:     function enterRedemptionQueue(address _recipient, uint120 _amountToRedeem) public nonReentrant {\n344:         // Get queue information\n345:         RedemptionQueueState memory _redemptionQueueState = redemptionQueueState;\n346:         RedemptionQueueAccounting memory _redemptionQueueAccounting = redemptionQueueAccounting;\n347: \n348:         // Calculations: redemption fee\n349:         uint120 _redemptionFeeAmount = ((uint256(_amountToRedeem) * _redemptionQueueState.redemptionFee) /\n350:             FEE_PRECISION).toUint120();\n351: \n352:         // Calculations: amount of ETH owed to the user\n353:         uint120 _amountEtherOwedToUser = _amountToRedeem - _redemptionFeeAmount;\n354: \n355:         // Calculations: increment ether liabilities by the amount of ether owed to the user\n356:         _redemptionQueueAccounting.etherLiabilities += uint128(_amountEtherOwedToUser);\n357: \n358:         // Calculations: increment unclaimed fees by the redemption fee taken\n359:         _redemptionQueueAccounting.unclaimedFees += _redemptionFeeAmount;\n360: \n361:         // Calculations: maturity timestamp\n362:         uint64 _maturityTimestamp = uint64(block.timestamp) + _redemptionQueueState.queueLengthSecs;\n363: \n364:         // Effects: Initialize the redemption ticket NFT information\n365:         nftInformation[_redemptionQueueState.nextNftId] = RedemptionQueueItem({\n366:             amount: _amountEtherOwedToUser,\n367:             maturity: _maturityTimestamp,\n368:             hasBeenRedeemed: false,\n369:             earlyExitFee: _redemptionQueueState.earlyExitFee\n370:         });\n```\n\n## Impact\n\nUsers unable to withdraw their assets. Loss of assets for the victim.\n\n## Code Snippet\n\nhttps://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd#code#L3413\n\nhttps://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd#code#L3645\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the protocol team and its users are aware of the risks of such an event and develop a contingency plan to manage it.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: medium(11)",
      "summary": "\nThe bug report is about an issue with the FRAX protocol, where the admin can adjust the fee rates to harm Napier and its users. This can prevent users from being able to withdraw their assets. The vulnerability was found by a user named xiaoming90 and has been acknowledged by the protocol. The bug can be exploited by setting the fee to 100%, which will consume the entire amount of staked fee, leaving nothing for Napier's adaptor. This can result in users losing their assets. The code snippet and tool used for this bug report was manual review. The recommendation is for the protocol team to be aware of this risk and have a contingency plan in place to manage it. ",
      "report_date": {},
      "contest_prize_txt": "29500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/171",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-01-napier-judging/issues/108",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "171",
      "slug": "m-11-frax-admin-can-adjust-fee-rate-to-harm-napier-and-its-users-sherlock-napier-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Napier",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Napier",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1954.351532908873
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "30586",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "1263",
      "title": "M-8: Permissioned rebalancing functions leading to loss of assets",
      "content": "Source: https://github.com/sherlock-audit/2024-01-napier-judging/issues/99 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nArabadzhiev, ZanyBonzy, cawfree, thisvishalsingh, xiaoming90\n## Summary\n\nPermissioned rebalancing functions that could only be accessed by admin could lead to a loss of assets.\n\n## Vulnerability Detail\n\nPer the contest's README page, it stated that the admin/owner is \"RESTRICTED\". Thus, any finding showing that the owner/admin can steal a user's funds, cause loss of funds or harm to the users, or cause the user's fund to be struck is valid in this audit contest.\n\n> Q: Is the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n>\n> RESTRICTED\n\nThe following describes a way where the admin can block users from withdrawing their assets from the protocol\n\n1. The admin calls the `setRebalancer` function to set the rebalance to a wallet address owned by them.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L245\n\n```solidity\nFile: BaseLSTAdapter.sol\n245:     function setRebalancer(address _rebalancer) external onlyOwner {\n246:         rebalancer = _rebalancer;\n247:     }\n```\n\n2. The admin calls the `setTargetBufferPercentage` the set the `targetBufferPercentage` to the smallest possible value of 1%. This will cause only 1% of the total ETH deposited by all the users to reside on the adaptor contract. This will cause the ETH buffer to deplete quickly and cause all the redemption and withdrawal to revert.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L251\n\n```solidity\nFile: BaseLSTAdapter.sol\n251:     function setTargetBufferPercentage(uint256 _targetBufferPercentage) external onlyRebalancer {\n252:         if (_targetBufferPercentage < MIN_BUFFER_PERCENTAGE || _targetBufferPercentage > BUFFER_PERCENTAGE_PRECISION) {\n253:             revert InvalidBufferPercentage();\n254:         }\n255:         targetBufferPercentage = _targetBufferPercentage;\n256:     }\n```\n\n3. The owner calls the `setRebalancer` function again and sets the rebalancer address to `address(0)`. As such, no one has the ability to call functions that are only accessible by rebalancer. The `requestWithdrawal` and `requestWithdrawalAll` functions are only accessible by rebalancer. Thus, no one can call these two functions to replenish the ETH buffer in the adaptor contract.\n4. When this state is reached, users can no longer withdraw their assets from the protocol, and their assets are stuck in the contract. This effectively causes them to lose their assets.\n\n## Impact\n\nLoss of assets for the victim.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L245\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L251\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo prevent the above scenario, the minimum `targetBufferPercentage` should be set to a higher percentage such as 5 or 10%, and the `requestWithdrawal` function should be made permissionless, so that even if the rebalancer does not do its job, anyone else can still initiate the rebalancing process to replenish the adaptor's ETH buffer for user's withdrawal.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**massun-onibakuchi**\n\nWe are aware of such issues. The owner account is set to governance or multisig. To prevent the target buffer from becoming too low, it is set to 10% by default. This value can be changed even after deployment. Additionally, executing rebalancing functions may reduce the scale of the adapter. Making such functions callable by anyone would, conversely, become a vulnerability. Considering this trade-off, we chose to make it a permissioned function.\n\n**nevillehuang**\n\nEscalate\n\nUnsure why this issue was excluded. The issue is highlighting how a potentially malicious protocol admin can cause a permanent DoS on users for core functionalities such as redemptions and withdrawals. Given protocol admins are explicitly mentioned as restricted in the contest details, I believe this issue should be valid medium severity.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Unsure why this issue was excluded. The issue is highlighting how a potentially malicious protocol admin can cause a permanent DoS on users for core functionalities such as redemptions and withdrawals. Given protocol admins are explicitly mentioned as restricted in the contest details, I believe this issue should be valid medium severity.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\nAgree with Nevi. This report and its duplicates highlighted that it is possible for a malicious admin to negatively impact the users. Thus, it should be valid as per Sherlock's contest rules as admin is \"restricted\" in the contest's README.\n\n**ABDuullahi**\n\nThis should stay invalid i believe, the README says `Rebalancer: An account can manage adapter and request withdrawal for liquid staking tokens. It can't steal funds.` and this issue does not describe a situation where the role can steal funds.\n\n**xiaoming9090**\n\n> 4\\. users can no longer withdraw their assets from the protocol, and their assets are stuck in the contract\n\nThe ability for the malicious admin (with rebalancer role) to cause users to be unable to withdraw their assets from the protocol, and in turn lead to their assets being stuck, is sufficient for this issue to be valid.\n\n**cvetanovv**\n\nI disagree with the escalation. \nThe reason the report is not valid is the first comment from the sponsor. As we can see this is a design decision. \nOther than that, one of the recommendations is that `targetBufferPercentage` should be higher. But this is a configuration value that can be changed. So I think the report should remain Low/Invalid.\n\n**xiaoming9090**\n\n> I disagree with the escalation. The reason the report is not valid is the first comment from the sponsor. As we can see this is a design decision. Other than that, one of the recommendations is that `targetBufferPercentage` should be higher. But this is a configuration value that can be changed. So I think the report should remain Low/Invalid.\n\nA malicious admin can set the `targetBufferPercentage` is configured to the lowest possible value, and then calls the `setRebalancer` function again and sets the rebalancer address to address(0). As such, no one has the ability to call functions that are only accessible by rebalancer. The `requestWithdrawal` and `requestWithdrawalAll` functions are only accessible by rebalancer. Thus, no one can call these two functions to replenish the ETH buffer in the adaptor contract.\n\nWhen the ETH buffer is not replenished, no one can withdraw from the protocol. This is sufficient to show that it is possible for malicious admins to harm users by preventing them from withdrawing. Note that the admin is restricted in this contest.\n\n**ABDuullahi**\n\nI think sherlock rules stated that the restriction must be explicitly mentioned, and for this role, its that `it cant steal funds`, not to disrupt the claiming/withdrawal process\n\n**nevillehuang**\n\n@ABDuullahi This issue is initiated by the admin (owner of contracts), not the rebalancer.\n\n**Czar102**\n\n> This issue is initiated by the admin (owner of contracts), not the rebalancer.\n\n@nevillehuang is the rebalancer relevant to this issue at all?\n\nIf not, I am planning to consider this a Medium severity issue and accept the escalation, with similar reasons to the ones listed here: https://github.com/sherlock-audit/2024-01-napier-judging/issues/97#issuecomment-1997410230.\n\n**nevillehuang**\n\n@Czar102 Not relevant, the admin can set the rebalancer to an address they control and/or themselves and execute the DoS\n\n**Czar102**\n\n@nevillehuang @cvetanovv is this a correct and full list of duplicates?\n#11, #21, #26, #119\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2024-01-napier-judging/issues/99/#issuecomment-1984813068): accepted",
      "summary": "\nThe report discusses a bug in the protocol that allows the admin to block users from withdrawing their assets, resulting in a loss of assets for the victim. The bug is caused by permissioned rebalancing functions that can only be accessed by the admin. The issue was found by multiple individuals and has been acknowledged by the protocol. The bug can be exploited by the admin setting the rebalancer address to zero and depleting the ETH buffer, preventing users from withdrawing their assets. The impact is a loss of assets for the victim. The bug was discovered through manual review and the recommendation is to make the `targetBufferPercentage` higher and to make the `requestWithdrawal` function permissionless. There was some discussion about the severity of the bug, but it was ultimately determined to be a medium severity issue with multiple duplicates. ",
      "report_date": {},
      "contest_prize_txt": "29500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/171",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-01-napier-judging/issues/99",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "171",
      "slug": "m-8-permissioned-rebalancing-functions-leading-to-loss-of-assets-sherlock-napier-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Napier",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Napier",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1954.351532908873
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "30585",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "1263",
      "title": "M-7: Users are unable to collect their yield if tranche is paused",
      "content": "Source: https://github.com/sherlock-audit/2024-01-napier-judging/issues/97 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nxiaoming90\n## Summary\n\nUsers are unable to collect their yield if Tranche is paused, resulting in a loss of assets for the victims.\n\n## Vulnerability Detail\n\nPer the contest's README page, it stated that the admin/owner is \"RESTRICTED\". Thus, any finding showing that the owner/admin can steal a user's funds, cause loss of funds or harm to the users, or cause the user's fund to be struck is valid in this audit contest.\n\n> Q: Is the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n>\n> RESTRICTED\n\nThe admin of the protocol has the ability to pause the Tranche contract, and no one except for the admin can unpause it. If a malicious admin paused the Tranche contract, the users will not be able to collect their yield earned, leading to a loss of assets for them.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/Tranche.sol#L605\n\n```solidity\nFile: Tranche.sol\n603:     /// @notice Pause issue, collect and updateUnclaimedYield\n604:     /// @dev only callable by management\n605:     function pause() external onlyManagement {\n606:         _pause();\n607:     }\n608: \n609:     /// @notice Unpause issue, collect and updateUnclaimedYield\n610:     /// @dev only callable by management\n611:     function unpause() external onlyManagement {\n612:         _unpause();\n613:     }\n```\n\nThe following shows that the `collect` function can only be executed when the system is not paused.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/Tranche.sol#L399\n\n```solidity\nFile: Tranche.sol\n399:     function collect() public nonReentrant whenNotPaused returns (uint256) {\n400:         uint256 _lscale = lscales[msg.sender];\n401:         uint256 accruedInTarget = unclaimedYields[msg.sender];\n```\n\n## Impact\n\nUsers are unable to collect their yield if Tranche is paused, resulting in a loss of assets for the victims.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/Tranche.sol#L605\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider allowing the users to collect yield even when the system is paused.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nEscalate\n\nAs mentioned by the watson, any issue that can causes a possible DoS/loss of funds by protocols admin not arising from external contract pauses/emergency withdrawals should be a valid medium severity issues due to centralization risks. In this case, protocol admins can block collection of yield permanently. In fact, it also blocks reinvestment of yield via `issue()`\n\n**sherlock-admin2**\n\n> Escalate\n> \n> As mentioned by the watson, any issue that can causes a possible DoS/loss of funds by protocols admin not arising from external contract pauses/emergency withdrawals should be a valid medium severity issues due to centralization risks. In this case, protocol admins can block collection of yield permanently. In fact, it also blocks reinvestment of yield via `issue()`\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\nAgree with the escalation by Nevi. The report highlighted a way for the admin to pause the contract, resulting in the users not being able to collect their yield earned, leading to a loss of assets for them. Per the contest rules, such an issue is considered valid.\n\n> Q: Is the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n>\n> RESTRICTED\n\n\n\n**cvetanovv**\n\nThe reason I left it invalid is that I consider the pausing mechanism a design decision. \n\nAlso, they have written in the readme that it is acceptable to have contracts pausing. Yes, I know this applies to External integrations, but I think it may be valid for them as well. \n\nApart from that pausing only stops users from collecting their rewards, doesn't mean the protocol will steal them. We have a sentence in the rules that gives the judge in this situation some flexibility to decide: \"Please note that these restrictions must be explicitly described by the protocol and will be considered case by case.\"\n\n**xiaoming9090**\n\n> The reason I left it invalid is that I consider the pausing mechanism a design decision.\n> \n> Also, they have written in the readme that it is acceptable to have contracts pausing. Yes, I know this applies to External integrations, but I think it may be valid for them as well.\n> \n> Apart from that pausing only stops users from collecting their rewards, doesn't mean the protocol will steal them. We have a sentence in the rules that gives the judge in this situation some flexibility to decide: \"Please note that these restrictions must be explicitly described by the protocol and will be considered case by case.\"\n\nI agree that having a pausing mechanism is a design choice by the protocol team. However, that does not mean the malicious admin will not use this pausing mechanism to block users from collecting their yields, causing harm to them.\n\nThe contest's README stated that pausing by external protocols is fine, but that does not mean that internal pausing is out-of-scope during the contest.\n\nWhen users cannot collect their earned yield due to malicious admin activities, it is basically the same as a loss of assets for them. Loss of assets for either users or protocols is considered a valid issue here.\n\nNote: Admin is restricted in this contest.\n\n\n\n**Czar102**\n\nI agree that this is a Medium severity issue, planning to accept the escalation. It is clear that when the protocol team considers the admins \"RESTRICTED\" and doesn't post the restrictions, the owners should not be able to cause losses to users.\n\n@cvetanovv\nThe pausing mechanism is a design decision, but when it starts to allow to cause loss of funds by an untrusted actor, then it becomes a vulnerability, too.\nThey are fine with external integration pausing, meaning that they trust the protocols to do it with the good of users in mind. This has an odd relation with the fact that external admins are restricted, but luckily we are not considering external admins here.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2024-01-napier-judging/issues/97/#issuecomment-1984824534): accepted",
      "summary": "\nThis bug report is about an issue with a protocol where users are unable to collect their yield if a certain part of the system is paused. This can result in a loss of assets for the users. The admin of the protocol has the ability to pause this part of the system, and no one except for the admin can undo this pause. This means that if a malicious admin pauses the system, users will not be able to collect their yield, leading to a loss of assets for them. The report recommends that the protocol consider allowing users to collect their yield even when the system is paused. There was some discussion about whether this issue should be considered valid, but it was ultimately resolved and classified as a medium severity issue.",
      "report_date": {},
      "contest_prize_txt": "29500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/171",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-01-napier-judging/issues/97",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "171",
      "slug": "m-7-users-are-unable-to-collect-their-yield-if-tranche-is-paused-sherlock-napier-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Napier",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Napier",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1954.351532908873
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        },
        {
          "tags_tag": {
            "title": "Denial-Of-Service"
          }
        }
      ]
    },
    {
      "id": "30583",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "1263",
      "title": "M-5: Users unable to withdraw their funds due to FRAX admin action",
      "content": "Source: https://github.com/sherlock-audit/2024-01-napier-judging/issues/95 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nxiaoming90\n## Summary\n\nFRAX admin action can lead to the fund of Naiper protocol and its users being stuck, resulting in users being unable to withdraw their assets.\n\n## Vulnerability Detail\n\nPer the contest page, the admins of the protocols that Napier integrates with are considered \"RESTRICTED\". This means that any issue related to FRAX's admin action that could negatively affect Napier protocol/users will be considered valid in this audit contest.\n\n> Q: Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\n> RESTRICTED\n\nWhen the Adaptor needs to unstake its staked ETH to replenish its ETH buffer so that users can redeem/withdraw their funds, it will first join the FRAX's redemption queue, and the queue will issue a redemption NFT afterward. After a certain period, the adaptor can claim their ETH by burning the redemption NFT at Line 65 via the `burnRedemptionTicketNft` function.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/frax/SFrxETHAdapter.sol#L65\n\n```solidity\nFile: SFrxETHAdapter.sol\n53:     function claimWithdrawal() external override {\n54:         uint256 _requestId = requestId;\n55:         uint256 _withdrawalQueueEth = withdrawalQueueEth;\n56:         if (_requestId == 0) revert NoPendingWithdrawal();\n57: \n58:         /// WRITE ///\n59:         delete withdrawalQueueEth;\n60:         delete requestId;\n61:         bufferEth += _withdrawalQueueEth.toUint128();\n62: \n63:         /// INTERACT ///\n64:         uint256 balanceBefore = address(this).balance;\n65:         REDEMPTION_QUEUE.burnRedemptionTicketNft(_requestId, payable(this));\n66:         if (address(this).balance < balanceBefore + _withdrawalQueueEth) revert InvariantViolation();\n67: \n68:         IWETH9(Constants.WETH).deposit{value: _withdrawalQueueEth}();\n69:     }\n```\n\nHowever, it is possible for FRAX's admin to disrupt the redemption process of the adaptor, resulting in Napier users being unable to withdraw their funds. When the `burnRedemptionTicketNft` function is executed, the redemption NFT will be burned, and native ETH residing in the `FraxEtherRedemptionQueue` contract will be sent to the adaptor at Line 498 below\n\nhttps://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd#code#L3761\n\n```solidity\nFile: FraxEtherRedemptionQueue.sol\n473:     function burnRedemptionTicketNft(uint256 _nftId, address payable _recipient) external nonReentrant {\n..SNIP..\n494:         // Effects: Burn frxEth to match the amount of ether sent to user 1:1\n495:         FRX_ETH.burn(_redemptionQueueItem.amount);\n496: \n497:         // Interactions: Transfer ETH to recipient, minus the fee\n498:         (bool _success, ) = _recipient.call{ value: _redemptionQueueItem.amount }(\"\");\n499:         if (!_success) revert InvalidEthTransfer();\n```\n\nFRAX admin could execute the `recoverEther` function to transfer out all the Native ETH residing in the `FraxEtherRedemptionQueue` contract, resulting in the NFT redemption failing due to lack of ETH. \n\nhttps://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd#code#L3381\n\n```solidity\nFile: FraxEtherRedemptionQueue.sol\n185:     /// @notice Recover ETH from exits where people early exited their NFT for frxETH, or when someone mistakenly directly sends ETH here\n186:     /// @param _amount Amount of ETH to recover\n187:     function recoverEther(uint256 _amount) external {\n188:         _requireSenderIsTimelock();\n189: \n190:         (bool _success, ) = address(msg.sender).call{ value: _amount }(\"\");\n191:         if (!_success) revert InvalidEthTransfer();\n192: \n193:         emit RecoverEther({ recipient: msg.sender, amount: _amount });\n194:     }\n```\n\nAs a result, Napier users will not be able to withdraw their funds.\n\n## Impact\n\nThe fund of Naiper protocol and its users will be stuck, resulting in users being unable to withdraw their assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/frax/SFrxETHAdapter.sol#L65\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the protocol team and its users are aware of the risks of such an event and develop a contingency plan to manage it.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: per contest ReadMe; this should be valid; medium(11)",
      "summary": "\nThe issue reported is that users of the Napier protocol are unable to withdraw their funds due to actions taken by the FRAX admin. This is a valid issue according to the contest rules, as the Napier protocol integrates with protocols that are considered \"RESTRICTED\" in terms of admin actions. The problem arises when the Adaptor of the Napier protocol needs to unstake its staked ETH in order to replenish its ETH buffer and allow users to withdraw their funds. This process involves joining a redemption queue and receiving a redemption NFT. However, if the FRAX admin disrupts this process by executing the \"recoverEther\" function, all the native ETH in the redemption queue will be transferred out, resulting in the NFT redemption failing and users being unable to withdraw their funds. This can have a significant impact on the funds of the Napier protocol and its users. The issue was found through manual review and the recommendation is for the protocol team to be aware of this risk and have a contingency plan in place to manage it.",
      "report_date": {},
      "contest_prize_txt": "29500 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/171",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2024-01-napier-judging/issues/95",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "171",
      "slug": "m-5-users-unable-to-withdraw-their-funds-due-to-frax-admin-action-sherlock-napier-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Napier",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Napier",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1954.351532908873
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "26174",
      "kind": "MARKDOWN",
      "auditfirm_id": "11",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "1082",
      "title": "Centralization risk",
      "content": "**Severity:** Medium\n\n**Description:** The protocol has an owner with privileged rights to perform admin tasks that can affect users.\nEspecially, the owner can change the fee settings and reward handler address.\n\n1. Validation is missing for admin fee setter functions.\n\n```solidity\nFeeData.sol\n31:     function setFeeValue(uint256 feeValue) external onlyOwner {\n32:         require(feeValue < _feeDenominator, \"Fee percentage must be less than 1\");\n33:         _feeValue = feeValue;\n34:     }\n\n43:\n44:     function setFixedFee(uint256 fixedFee) external onlyOwner {//@audit-issue validate min/max\n45:         _fixedFee = fixedFee;\n46:     }\n```\n\n2. Important changes initiated by admin should be logged via events.\n\n```solidity\nFile: helpers/FeeData.sol\n\n31:     function setFeeValue(uint256 feeValue) external onlyOwner {\n\n36:     function setMaxHops(uint256 maxHops) external onlyOwner {\n\n40:     function setMaxSwaps(uint256 maxSwaps) external onlyOwner {\n\n44:     function setFixedFee(uint256 fixedFee) external onlyOwner {\n\n48:     function setFeeToken(address feeTokenAddress) public onlyOwner {\n\n53:     function setFeeTokens(address[] memory feeTokenAddresses) public onlyOwner {\n\n60:     function clearFeeTokens() public onlyOwner {\n\n```\n\n```solidity\nFile: helpers/TransferHelper.sol\n\n86:     function setRewardHandler(address rewardAddress) external onlyOwner {\n\n92:     function setRewardsActive(bool _rewardsActive) external onlyOwner {\n\n```\n\n**Impact:** While the protocol owner is regarded as a trusted party, the owner can change the fee settings and reward handler address without any validation or logging. This can lead to unexpected results and users can be affected.\n\n**Recommended Mitigation:**\n- Specify the owner's privileges and responsibilities in the documentation.\n- Add constant state variables that can be used as the minimum and maximum values for the fee settings.\n- Add proper validation for the admin functions.\n- Log the changes in the important state variables via events.\n\n**Protocol:**\n\n- setFeeNumerator changes fixed in commit [f8f07c5](https://github.com/SwapExchangeio/Contracts/commit/f8f07c5e72c052d11c1b4c4dfd8b849a99694e03)\n- setFeeNumerator maximum reduced in commit [7874a8f](https://github.com/SwapExchangeio/Contracts/commit/7874a8f677b1e06e9b3e0289a91ab33e46806ff2)\n- setFixedFee changes fixed in commit [af760b4](https://github.com/SwapExchangeio/Contracts/commit/af760b484ff6da0ad9a8492a96a5e7ef19056df1)\n- events for setFeeToken/clearFeeToken/setFeeTokens as well as separating initialization setter to save emitting a heap of events when deploying, fixed in commit [927c102](https://github.com/SwapExchangeio/Contracts/commit/[927c1020a71c017d3a17e653be84996ba86ff8ed])\n- changing array arg type to calldata rather than memory, fixed in commit [e615cb2](https://github.com/SwapExchangeio/Contracts/commit/e615cb21ac67d8a31656c622d3b2e3ddc1dc8891)\n- events for RewardHandler and RewardsActive, fixed in commit [3068a2e](https://github.com/SwapExchangeio/Contracts/commit/3068a2e88621f991a54be80ef16d868e4fb10d25)\n- events for MaxHops and MaxSwaps, fixed in commit [077577b](https://github.com/SwapExchangeio/Contracts/commit/077577ba26b66cbb4b977b3738b59eb727c5d87d).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report is about the protocol of an owner with privileged rights to perform admin tasks that can affect users. The protocol lacks validation for admin fee setter functions and important changes initiated by admin should be logged via events. This can lead to unexpected results and users can be affected.\n\nThe recommended mitigation for this bug is to specify the owner's privileges and responsibilities in the documentation, add constant state variables that can be used as the minimum and maximum values for the fee settings, add proper validation for the admin functions, and log the changes in the important state variables via events.\n\nThe bug has been fixed in the following commits:\n\n- setFeeNumerator changes fixed in commit [f8f07c5](https://github.com/SwapExchangeio/Contracts/commit/f8f07c5e72c052d11c1b4c4dfd8b849a99694e03)\n- setFeeNumerator maximum reduced in commit [7874a8f](https://github.com/SwapExchangeio/Contracts/commit/7874a8f677b1e06e9b3e0289a91ab33e46806ff2)\n- setFixedFee changes fixed in commit [af760b4](https://github.com/SwapExchangeio/Contracts/commit/af760b484ff6da0ad9a8492a96a5e7ef19056df1)\n- events for setFeeToken/clearFeeToken/setFeeTokens as well as separating initialization setter to save emitting a heap of events when deploying, fixed in commit [927c102](https://github.com/SwapExchangeio/Contracts/commit/[927c1020a71c017d3a17e653be84996ba86ff8ed])\n- changing array arg type to calldata rather than memory, fixed in commit [e615cb2](https://github.com/SwapExchangeio/Contracts/commit/e615cb21ac67d8a31656c622d3b2e3ddc1dc8891)\n- events for RewardHandler and RewardsActive, fixed in commit [3068a2e](https://github.com/Swap",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-swapexchange.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "centralization-risk-cyfrin-none-cyfrin-swapexchange-markdown",
      "firm_name": "Cyfrin",
      "firm_logo_square": "Cyfrin_square.jpg",
      "protocol_name": "Swapexchange",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
      },
      "protocols_protocol": {
        "name": "Swapexchange",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Ownership"
          }
        },
        {
          "tags_tag": {
            "title": "Event"
          }
        },
        {
          "tags_tag": {
            "title": "Auditing and Logging"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "27424",
      "kind": "GIT",
      "auditfirm_id": "20",
      "impact": "MEDIUM",
      "finders_count": 43,
      "protocol_id": "1109",
      "title": "Malicious/Compromised organiser can reclaw all funds, stealing work from supporters",
      "content": "### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/main/src/Distributor.sol#L116\">https://github.com/Cyfrin/2023-08-sparkn/blob/main/src/Distributor.sol#L116</a>\n\n\n## Summary\n\nThe contest details state that 'If a contest is created and funded, there is no way to refund. All the funds belong to the persons who wants to help solve the problem, we call them \"supporters\".' (see More Context section). This is untrue, as the organizer is able to refund all of the contest funds.\n\n## Vulnerability Details\n\nIn `Distributor#_distribute`, there is no input validation on the `winners` array. A malicious or compromised organizer can, with little effort, simply pass an array of length one containing a wallet address that they control as the `winners` parameter, and `[10000]` as the `percentages` parameter in order to receive 100% of the funds initially deposited to the contract. Due to the design of the protocol, they would have 7 days after the contest ends (the value of the `EXPIRATION_TIME` constant in the `ProxyFactory` contract) to perform this action without the owner being able to prevent it.\n\n## Impact\n\nMalicious/Compromised organizer can refund 100% of the contest funds, stealing work from sponsors.\n\n## Tools Used\n\nManual review\n\n## Recommendations\n\nUse a two step procedure for distributing funds:\n1. The organizer submits an array of winners and percentages to the `Proxy` contract and they are cached using storage variables\n2. The owner of `ProxyFactor` (a trusted admin) checks the arrays to ensure the organizer is not distributing all of the money to themselves, and if satisfied, triggers the distribution of funds\n\nThis removes the risk of having to trust the organizer, and although it requires the trust of the admin, they were already a required trusted party and so the mitigation is beneficial overall. Also, this new system adds more truth to the statement from the contest details mentioned in the summary section of this report.",
      "summary": "\nThis bug report is about a vulnerability in the \"Distributor\" contract which allows malicious or compromised organizers to reclaim all of the funds from a contest, stealing work from supporters. The vulnerability lies in the fact that there is no input validation on the `winners` array in the `Distributor#_distribute` function, allowing the organizer to pass an array of length one containing a wallet address that they control as the `winners` parameter, and `[10000]` as the `percentages` parameter in order to receive 100% of the funds initially deposited to the contract.\n\nThe impact of this vulnerability is that malicious/compromised organizers can refund 100% of the contest funds, stealing work from sponsors. The tools used to identify this vulnerability were manual review.\n\nThe recommendation to mitigate this vulnerability is to use a two step procedure for distributing funds. The organizer submits an array of winners and percentages to the `Proxy` contract and they are cached using storage variables. The owner of `ProxyFactor` (a trusted admin) checks the arrays to ensure the organizer is not distributing all of the money to themselves, and if satisfied, triggers the distribution of funds. This removes the risk of having to trust the organizer, and although it requires the trust of the admin, they were already a required trusted party and so the mitigation is beneficial overall.",
      "report_date": {},
      "contest_prize_txt": "15000 USDC",
      "contest_link": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
      "sponsor_name": "CodeFox Inc.",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/Cyfrin/2023-08-sparkn",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "cllcnja1h0001lc08z7w0orxx",
      "slug": "maliciouscompromised-organiser-can-reclaw-all-funds-stealing-work-from-supporters-codehawks-sparkn-git",
      "firm_name": "Codehawks",
      "firm_logo_square": "codehawks_square.png",
      "protocol_name": "Sparkn",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Codehawks",
        "logo_square": "codehawks_square.png"
      },
      "protocols_protocol": {
        "name": "Sparkn",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "21188",
      "kind": "MARKDOWN",
      "auditfirm_id": "11",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "994",
      "title": "The off-chain mechanism must be ensured to work in a correct order strictly",
      "content": "**Severity:** Medium\n\n**Description:** The `PriorityPool` contract relies on the distribution oracle for accounting and the accounting calculation is done off-chain.\n\nAccording to the communication with the protocol team, the correct workflow for queued deposits can be described as below:\n- Whenever there is a new room for deposit in the staking pool, the function `depositQueuedTokens` is called.\n- The `PriorityPool` contract is paused by calling `pauseForUpdate()`.\n- Accounting calculations happen off-chain using the function `getAccountData()` and `getDepositsSinceLastUpdate()`(`depositsSinceLastUpdate`) variable to compose the latest Merkle tree.\n- The distribution oracle calls the function `updateDistribution()` and this will resume the `PriorityPool`.\n\nThe only purpose of pausing the queue contract is to prevent unqueue until the accounting status are updated.\nThrough an analysis we found that the off-chain mechanism MUST follow the order very strictly or else user funds can be stolen.\nWhile we acknowledge that the protocol team will ensure it, we decided to keep this finding as a medium risk because we can not verify the off-chain mechanism.\n\n**Impact:** If the off-chain mechanism occurs in a wrong order by any chance, user funds can be stolen.\nGiven the likelihood is low, we evaluate the impact to be Medium.\n\n**Proof of Concept:** The below test case shows the attack scenario.\n```javascript\n  it('Cyfrin: off-chain mechanism in an incorrect order can lead to user funds being stolen', async () => {\n    // try deposit 1500 while the capacity is 1000\n    await strategy.setMaxDeposits(toEther(1000))\n    await sq.connect(signers[1]).deposit(toEther(1500), true)\n\n    // 500 ether is queued for accounts[1]\n    assert.equal(fromEther(await stakingPool.balanceOf(accounts[1])), 1000)\n    assert.equal(fromEther(await sq.getQueuedTokens(accounts[1], 0)), 500)\n    assert.equal(fromEther(await token.balanceOf(accounts[1])), 8500)\n\n    // unqueue 500 ether should work while no updateDistribution was called\n    await sq.connect(signers[1]).unqueueTokens(0, 0, [], toEther(500))\n    assert.equal(fromEther(await sq.getQueuedTokens(accounts[1], 0)), 0)\n    assert.equal(fromEther(await token.balanceOf(accounts[1])), 9000)\n\n    // deposit again\n    await sq.connect(signers[1]).deposit(toEther(500), true)\n    assert.equal(fromEther(await token.balanceOf(accounts[1])), 8500)\n\n    // victim deposits 500 ether and it will be queued\n    await sq.connect(signers[2]).deposit(toEther(500), true)\n    assert.equal(fromEther(await sq.totalQueued()), 1000)\n\n    // max deposit has increased to 1500\n    await strategy.setMaxDeposits(toEther(1500))\n\n    // user sees that his queued tokens 500 can be deposited and call depositQueuedTokens\n    // this will deposit the 500 ether in the queue\n    await sq.connect(signers[1]).depositQueuedTokens()\n\n    // Correct off-chain mechanism: pauseForUpdate -> getAccountData -> updateDistribution\n    // Let us see what happens if getAccountData is called before pauseForUpdate\n\n    // await sq.pauseForUpdate()\n\n    // check account data\n    var a_data = await sq.getAccountData()\n    assert.equal(ethers.utils.formatEther(a_data[2][1]), \"500.0\")\n    assert.equal(ethers.utils.formatEther(a_data[2][2]), \"500.0\")\n\n    // user calls unqueueTokens to get his 500 ether back\n    // this is possible because the queue contract is not paused\n    await sq.connect(signers[1]).unqueueTokens(0, 0, [], toEther(500))\n\n    // pauseForUpdate is called at a wrong order\n    await sq.pauseForUpdate()\n\n    // at this point user has 1000 ether staked and 9000 ether in his wallet\n    assert.equal(fromEther(await token.balanceOf(accounts[1])), 9000)\n    assert.equal(fromEther(await stakingPool.balanceOf(accounts[1])), 1000)\n\n    // now updateDistribution is called with the wrong data\n    let data = [\n      [ethers.constants.AddressZero, toEther(0), toEther(0)],\n      [accounts[1], toEther(500), toEther(500)],\n    ]\n    let tree = StandardMerkleTree.of(data, ['address', 'uint256', 'uint256'])\n\n    await sq.updateDistribution(\n      tree.root,\n      ethers.utils.formatBytes32String('ipfs'),\n      toEther(500),\n      toEther(500)\n    )\n\n    // at this point user claims his LSD tokens\n    await sq.connect(signers[1]).claimLSDTokens(toEther(500), toEther(500), tree.getProof(1))\n\n    // at this point user has 1500 ether staked and 9000 ether in his wallet\n    assert.equal(fromEther(await token.balanceOf(accounts[1])), 9000)\n    assert.equal(fromEther(await stakingPool.balanceOf(accounts[1])), 1500)\n  })\n```\n**Recommended Mitigation:** Consider to force pause the contract at the end of the function `_depositQueuedTokens`.\n\n**Client:**\nAcknowledged. The protocol team will ensure the correct order of the off-chain mechanism.\n\n**Cyfrin:** Acknowledged.",
      "summary": "\nThe `PriorityPool` contract is used for accounting and the calculations are done off-chain. The protocol team has identified the correct workflow for queued deposits, which includes calling the `depositQueuedTokens` function, pausing the `PriorityPool` contract, and then using the functions `getAccountData()` and `getDepositsSinceLastUpdate()` to compose the latest Merkle tree. The purpose of pausing the queue contract is to prevent unqueuing until the accounting status is updated.\n\nAn analysis revealed that if the off-chain mechanism is not followed in the correct order, user funds can be stolen. This risk is considered to be medium, as the likelihood of this happening is low. A proof of concept was provided to show the attack scenario.\n\nThe recommended mitigation is to consider forcing the contract to pause at the end of the `_depositQueuedTokens` function. The protocol team has acknowledged this and will ensure the correct order of the off-chain mechanism.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-08-25-cyfrin-stake-link.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "the-off-chain-mechanism-must-be-ensured-to-work-in-a-correct-order-strictly-cyfrin-none-cyfrin-stake-link-markdown",
      "firm_name": "Cyfrin",
      "firm_logo_square": "Cyfrin_square.jpg",
      "protocol_name": "Stake Link",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
      },
      "protocols_protocol": {
        "name": "Stake Link",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Timing"
          }
        },
        {
          "tags_tag": {
            "title": "Pause"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "19118",
      "kind": "MARKDOWN",
      "auditfirm_id": "15",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "851",
      "title": "Admin level vulnerabilities",
      "content": "**Severity:** Medium\n\n**Context:** [`IDO.sol#L66-69`](https://github.com/getmetafinance/meta/blob/00bbac1613fa69e4c180ff53515451df4df9f69e/contracts/ido/IDO.sol#L66-69)\n\n**Description:**\nNumerous admin functions do not check the validity of the input parameters.\n\n- Many setter functions that set token addresses do not validate zero address (e.g. `MetaManager::setTokens`)\n- `IDO::setClaimTime` - time validation\n- `MetaManager::setMaxExitCycle` - use strict inequality to prevent DOS unstaking\n\nAlso some functions are not necessary and can lead to unintentional situations.\n\n- `IDO::setPrice` - According to the documentation, the floor price is kept as constant but the current implementation allow the owner to change the price to any value.\n\nAlthough we assume the admin is trusted, these issues can lead to unexpected loss by a mistake of an admin.\n\n**Impact**\nThe admin can change the protocols behavior in unexpected ways.\n\n**Recommendation:**\nAdd necessary validations to the admin functions and remove unnecessary functions.\n\n**Meta Team:**\n\nFixed. In the commit :007c1b9183cdb65a500928173608ebff0a5197ef.\nActions include require statments and also to remove unnecessary functions.\n\n**Hans:**\nVerified.",
      "summary": "\nThis bug report is about a medium severity issue found in the IDO.sol file on line 66-69. The problem is that many admin functions do not check the validity of the input parameters, and some of the functions are not necessary and can lead to unintentional situations. This can lead to unexpected loss by mistake of an admin.\n\nThe recommended action is to add necessary validations to the admin functions and remove unnecessary functions. The Meta Team has fixed this issue in the commit :007c1b9183cdb65a500928173608ebff0a5197ef. This included adding require statements and removing unnecessary functions. The bug has been verified by Hans.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hans/2023-07-13-Meta.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "admin-level-vulnerabilities-hans-none-meta-markdown_",
      "firm_name": "Hans",
      "firm_logo_square": "hans_square.jpg",
      "protocol_name": "Meta",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Hans",
        "logo_square": "hans_square.jpg"
      },
      "protocols_protocol": {
        "name": "Meta",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        },
        {
          "tags_tag": {
            "title": "Validation"
          }
        },
        {
          "tags_tag": {
            "title": "Missing Check"
          }
        },
        {
          "tags_tag": {
            "title": "Change Validation"
          }
        }
      ]
    },
    {
      "id": "6969",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "6",
      "title": "The Protocol owner can drain users' currency tokens",
      "content": "## Severity: Critical Risk\n\n## Context:\n- LooksRareProtocol.sol#L138\n- LooksRareProtocol.sol#L391-L398\n- ITransferSelectorNFT.sol#L14-L17\n- TransferSelectorNFT.sol#L41\n- TransferSelectorNFT.sol#L89-L98\n\n## Description:\nThe Protocol owner can drain users' currency tokens that have been approved to the protocol. Makers who want to bid on NFTs would need to approve their currency token to be spent by the protocol. The owner should not be able to access these funds for free.\n\nThe owner can drain the funds as follows:\n\n1. Calls `addTransferManagerForAssetType` and assigns the currency token as the `transferManagerForAssetType` and `IERC20.transferFrom.selector` as the `selectorForAssetType` for a new `assetType`.\n2. Signs an almost empty `MakerAsk` order and sets its collection as the address of the targeted user and the `assetType` to the newly created `assetType`. The owner also creates the corresponding `TakerBid` by setting the `recipient` field to the amount of currency they would like to transfer.\n3. Calls the `executeTakerBid` endpoint with the above data without a `merkleTree` or `affiliate`.\n\n```solidity\n// file: test/foundry/Attack.t.sol\npragma solidity 0.8.17;\n\nimport {IStrategyManager} from \"../../contracts/interfaces/IStrategyManager.sol\";\nimport {IBaseStrategy} from \"../../contracts/interfaces/IBaseStrategy.sol\";\nimport {OrderStructs} from \"../../contracts/libraries/OrderStructs.sol\";\nimport {ProtocolBase} from \"./ProtocolBase.t.sol\";\nimport {MockERC20} from \"../mock/MockERC20.sol\";\n\ncontract NullStrategy is IBaseStrategy {\n    function isLooksRareV2Strategy() external pure override returns (bool) {\n        return true;\n    }\n\n    function executeNull(\n        OrderStructs.TakerBid calldata /* takerBid */,\n        OrderStructs.MakerAsk calldata /* makerAsk */\n    )\n        external\n        pure\n        returns (\n            uint256 price,\n            uint256[] memory itemIds,\n            uint256[] memory amounts,\n            bool isNonceInvalidated\n        )\n    {}\n}\n\ncontract AttackTest is ProtocolBase {\n    NullStrategy private nullStrategy;\n    MockERC20 private mockERC20;\n    uint256 private signingOwnerPK = 42;\n    address private signingOwner = vm.addr(signingOwnerPK);\n    address private victimUser = address(505);\n\n    function setUp() public override {\n        super.setUp();\n        vm.startPrank(_owner);\n        looksRareProtocol.initiateOwnershipTransfer(signingOwner);\n        // This particular strategy is not a requirement of the exploit.\n        nullStrategy = new NullStrategy();\n        looksRareProtocol.addStrategy(\n            0,\n            0,\n            0,\n            NullStrategy.executeNull.selector,\n            false,\n            address(nullStrategy)\n        );\n        mockERC20 = new MockERC20();\n        looksRareProtocol.updateCurrencyWhitelistStatus(address(mockERC20), true);\n        looksRareProtocol.updateCreatorFeeManager(address(0));\n        mockERC20.mint(victimUser, 1000);\n        vm.stopPrank();\n        vm.prank(signingOwner);\n        looksRareProtocol.confirmOwnershipTransfer();\n    }\n\n    function testDrain() public {\n        vm.prank(victimUser);\n        mockERC20.approve(address(looksRareProtocol), 1000);\n        vm.startPrank(signingOwner);\n        looksRareProtocol.addTransferManagerForAssetType(\n            2,\n            address(mockERC20),\n            mockERC20.transferFrom.selector\n        );\n        OrderStructs.MakerAsk memory makerAsk =\n            _createSingleItemMakerAskOrder({\n                askNonce: 0,\n                subsetNonce: 0,\n                strategyId: 1, // null strategy\n                assetType: 2, // ERC20 asset!\n                orderNonce: 0,\n                collection: victimUser, // <--- will be used as the `from`\n                currency: address(0),\n                signer: signingOwner,\n                minPrice: 0,\n                itemId: 1\n            });\n        bytes memory signature = _signMakerAsk(makerAsk, signingOwnerPK);\n        OrderStructs.TakerBid memory takerBid = OrderStructs.TakerBid(\n            address(1000), // `amount` field for the `transferFrom`\n            0,\n            makerAsk.itemIds,\n            makerAsk.amounts,\n            bytes(\"\")\n        );\n        looksRareProtocol.executeTakerBid(\n            takerBid,\n            makerAsk,\n            signature,\n            _EMPTY_MERKLE_TREE,\n            _EMPTY_AFFILIATE\n        );\n        vm.stopPrank();\n        assertEq(mockERC20.balanceOf(signingOwner), 1000);\n        assertEq(mockERC20.balanceOf(victimUser), 0);\n    }\n}\n```\n\n## Recommendation:\nIt would be best to fix the selector instead of the protocol owner being able to assign arbitrary selectors for `managerSelectorOfAssetType[assetType]`. This can be done by requiring all selected transfer managers to adhere to the same interface which defines the following endpoint:\n\n```solidity\ninterface ITransferManager {\n    ...\n    function executeTransfer(\n        address collection,\n        address from,\n        address to,\n        uint256[] calldata itemIds,\n        uint256[] calldata amounts\n    )\n}\n```\n\nThe endpoint name `executeTransfer` above should be chosen to avoid selector collision with potential currencies that will be allowed for the protocol (IERC20 tokens or even all the endpoint selectors involved in the protocol).\n\nThe call in `transferNFT` can be changed to:\n\n```solidity\n(bool status, ) = ITransferManager(transferManager).executeTransfer(\n    collection,\n    sender,\n    recipient,\n    itemIds,\n    amounts\n);\n```\n\nAnd `managerSelectorOfAssetType`'s type can be changed to:\n\n```solidity\nmapping(uint256 => address) public managerSelectorOfAssetType;\n```\n\nThe above change also has the benefit of reducing gas costs.\n\n## LooksRare:\nThe ability to add new transfer managers and selectors for new asset types has been removed. Also, the transfer manager for ERC721 and ERC1155 assets gets assigned to an immutable variable upon deployment. Fixed in PR 308 and PR 363.\n\n## Spearbit:\nVerified",
      "summary": "\nThis bug report is about a critical risk in the LooksRareProtocol.sol, ITransferSelectorNFT.sol, and TransferSelectorNFT.sol. The Protocol owner can drain users' currency tokens that have been approved to the protocol. The owner can do this by calling addTransferManagerForAssetType and assigning the currency token as the transferManagerForAssetType and IERC20.transferFrom.selector as the selectorForAssetType for a new assetType. Then the owner creates an almost empty MakerAsk order and sets its collection as the address of the targeted user and the assetType to the newly created assetType. Finally, the owner calls the executeTakerBid endpoint with the above data without a merkleTree or affiliate.\n\nThe recommendation is to fix the selector instead of the protocol owner being able to assign arbitrary selectors for managerSelectorOfAssetType[assetType]. This can be done by requiring all selected transfer managers to adhere to the same interface which defines the executeTransfer endpoint. The call in_transferNFT can be changed to use the executeTransfer endpoint and the managerSelectorOfAssetType's type can be changed to mapping(uint256 => address). This change also has the benefit of reducing gas costs.\n\nThe bug has been fixed in PR 308 and PR 363 and has been verified by Spearbit.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/LooksRare-Spearbit-Security-Review.pdf",
      "pdf_page_from": 6,
      "contest_id": "",
      "slug": "the-protocol-owner-can-drain-users-currency-tokens-spearbit-looksrare-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "LOOKSRARE",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "LOOKSRARE",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "7025",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 5,
      "protocol_id": "53",
      "title": "LibOwnable._setAdmin allows setting address(0) as the admin of the contract",
      "content": "## Severity: Medium Risk\n\n## Context\nLibOwnable.sol#L8-L10\n\n## Description\nWhile other contracts like RiverAddress (for example) do not allow `address(0)` to be used as a set input parameter, there is no similar check inside `LibOwnable._setAdmin`. Because of this, contracts that call `LibOwnable._setAdmin` with `address(0)` will not revert, and functions that should be callable by an admin cannot be called anymore.\n\n### This is the list of contracts that import and use the LibOwnable library:\n- AllowlistV1\n- OperatorsRegistryV1\n- OracleV1\n- RiverV1\n\n## Recommendation\nConsider adding a check inside `LibOwnable._setAdmin` to prevent setting `address(0)` as the admin, or move that specific check into each contract that imports and uses `LibOwnable`.\n\n### Alluvial\nRecommendation implemented in SPEARBIT/11.\n\n### Spearbit\n**Note 1:** Still missing (client said it will be implemented in other PRs)\n- Administrable misses all Natspec comments\n- Event for `_setAdmin` is still missing but will be added to Initializable event in another PR\n\n**Note 2:** Client has acknowledged that all the contracts that inherit from Administrable have the ability to transfer ownership, even contracts like AllowlistV1 that didn't have the ability before this PR.\n\n### Alluvial \nIssues in Note 1 addressed in SPEARBIT/33.\n\n### Spearbit \nAcknowledged.",
      "summary": "\nThis bug report details an issue with the LibOwnable library, where contracts that call LibOwnable._setAdmin with address(0) will not revert and functions that should be callable by an admin cannot be called anymore. This affects four contracts that import and use the LibOwnable library: AllowlistV1, OperatorsRegistryV1, OracleV1, and RiverV1. The recommendation is to add a check inside LibOwnable._setAdmin to prevent setting address(0) as the admin, or move that specific check in each contract that import and use LibOwnable. The recommendation has been implemented in SPEARBIT/11, but there are still some issues that need to be addressed, such as missing natspec comments and events for _setAdmin. These issues have been addressed in SPEARBIT/33.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LiquidCollective-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LiquidCollective-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/LiquidCollective-Spearbit-Security-Review.pdf",
      "pdf_page_from": 28,
      "contest_id": "",
      "slug": "libownable_setadmin-allows-setting-address0-as-the-admin-of-the-contract-spearbit-liquid-collective-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Liquid Collective",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Liquid Collective",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 67.10914421941607
          },
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Validation"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "7136",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 5,
      "protocol_id": "72",
      "title": "Renouncing ownership or admin role could affect the normal operation of Connext",
      "content": "## Security Assessment Report\n\n## Severity: High Risk\n\n### Context\n- Affected Contracts: `WatcherClient.sol`, `WatchManager.sol`, `Merkle.sol`, `RootManager.sol`, `ConnextPriceOracle.sol`, `Upgrade-BeaconController.sol`, `ProposedOwnableFacet.sol#L276-L285`\n\n### Description\nConsider the following scenarios:\n\n#### Instance 1 - Renouncing Ownership\nAll the contracts that extend from `ProposedOwnable` or `ProposedOwnableUpgradeable` inherit a method called `renounceOwnership`. The owner of the contract can use this method to give up their ownership, thereby leaving the contract without an owner. If that were to happen, it would not be possible to perform any owner-specific functionality on that contract anymore.\n\nThe following is a summary of the affected contracts and their impact if the ownership has been renounced. One of the most significant impacts is that Connext's message system cannot recover after a fraud has been resolved since there is no way to unpause and add the connector back to the system.\n\n#### Instance 2 - Renouncing Admin Role\nAll the contracts that extend from `ProposedOwnableFacet` inherit a method called `revokeRole`. \n\n1. Assume that the Owner has renounced its power and the only Admin remaining used `revokeRole` to renounce its Admin role.\n2. Now the contract is left with Zero Owner & Admin.\n3. All swap operations collect admin fees via the `SwapUtils.sol` contract. In the absence of any Admin & Owner, these fees will get stuck in the contract with no way to retrieve them. Normally it would have been withdrawn using `withdrawSwapAdminFees|SwapAdminFacet.sol`.\n4. This is simply one example; there are multiple other critical functionalities impacted once both Admin and Owner revoke their roles.\n\n### Recommendation\n1. Review if the `renounceOwnership` function is required for each of the affected contracts and remove them if they are not needed. Ensure that renouncing ownership in any of the affected contracts will not affect the normal operation of Connext.\n2. Revise the `revokeRole` function to ensure that at least one Admin always remains in the system who will be responsible for managing all critical operations in case the owner renounces the role.\n\n### Conclusion\n- **Connext:** Solved in PR 2412.\n- **Spearbit:** Verified.",
      "summary": "\nThis bug report is about a high risk issue in the Connext system related to the contracts WatcherClient.sol, WatchManager.sol, Merkle.sol, RootManager.sol, ConnextPriceOracle.sol, Upgrade-BeaconController.sol, and ProposedOwnableFacet.sol. It describes two scenarios in which the owner and/or admin of the contract can renounce their roles, leaving the contract without an owner or admin.\n\nIn the first instance, if the owner renounces their power, the message system cannot recover after a fraud has been resolved, as there is no way to unpause and add the connector back to the system. In the second instance, if both the owner and admin renounce their roles, the admin fees collected via the SwapUtils.sol contract will get stuck in the contract with no way to retrieve them. Additionally, there are multiple other critical functionalities that would be impacted.\n\nThe recommendation is to review if the renounceOwnership function is needed for each of the affected contracts and remove them if they are not needed. It is also suggested to revise the revokeRole function to ensure that at least one Admin always remains in the system who will be responsible for managing all critical operations in case the owner renounces the role. Connext has solved this issue in PR 2412 and Spearbit has verified it.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/ConnextNxtp-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/ConnextNxtp-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/ConnextNxtp-Spearbit-Security-Review.pdf",
      "pdf_page_from": 13,
      "contest_id": "",
      "slug": "renouncing-ownership-or-admin-role-could-affect-the-normal-operation-of-connext-spearbit-connext-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Connext",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Connext",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "DOS"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        },
        {
          "tags_tag": {
            "title": "Ownership"
          }
        }
      ]
    },
    {
      "id": "7132",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 5,
      "protocol_id": "72",
      "title": "A malicious owner or user with a Role.Router role can drain a router 's liquidity",
      "content": "## Security Report\n\n## Severity: High Risk\n\n### Context\n- `RoutersFacet.sol#L263-L267`\n- `RoutersFacet.sol#L297`\n- `RoutersFacet.sol#L498`\n- `BridgeFacet.sol#L622`\n\n### Description\nA malicious owner or user with the `Role.Router` role (denominated as A in this example) can drain a router's liquidity for a current router (a router that has already been added to the system and might potentially have significant liquidity in some assets).\n\nHere is how A can do it (this can also be done atomically):\n1. Remove the router by calling `removeRouter`.\n2. Add the router back by calling `setupRouter` and set the owner and recipient parameters to accounts A has access to/control over.\n3. Loop over all tokens that the router has liquidity in and call `removeRouterLiquidityFor` to drain/redirect the funds into accounts A has control over.\n\nThis means that all routers would need to put their trust in the owner (of this Connext instance) and any user who has a `Role.Router` with their liquidity. Thus, the current setup is not trustless.\n\n### Recommendation\nTo remove this trust assumption, a redesign is required for how routers get integrated into this system. It would be best to have the function in a form like:\n\n```solidity\nfunction addRouter(IRouter router)\n```\n\n(renamed `setupRouter` to `addRouter`). Here, `IRouter` is an interface that establishes the requirements that the router would need to meet.\n\nA router:\n1. Needs to be able to set its own owner or recipient if required. This might not always be necessary.\n2. Needs to be able to sign transfers and bid for those transfers to a sequencer.\n3. If approved for using Aave Portal, it might need to be able to call `repayAavePortal`. However, this is not necessary since anyone can call `repayAavePortalFor` to repay the fees/debts for this router.\n4. Can implement calling `addRouterLiquidity` to add liquidity. However, this is not necessary since anyone can call `addRouterLiquidityFor` for this router.\n5. If the router does not register an account as its owner (this also needs to be implemented in this contract for the new redesign), it needs to implement a call to `removeRouterLiquidity` to remove its liquidity. If it does register an owner, implementing calls to `removeRouterLiquidity` is not necessary since the router's owner can call `removeRouterLiquidityFor`.\n\n**Connext:** Solved in PR 2413.\n\n**Spearbit:** Verified.",
      "summary": "\nThis bug report is about a malicious owner or user with Role.Router Role, denominated as A, who can drain a router's liquidity for a current router, which has already been added to the system and might potentially have added big liquidities to some assets. To fix this issue, a redesign of how routers get integrated into the system is recommended. This redesign should include a function called addRouter(IRouter router) which would shape the requirements that the router would need to have. These include the ability to set its own owner or recipient, to sign transfers and bid for those transfers to a sequencer, and to call repayAavePortal if approved for using Aave Portal. The bug was solved in PR 2413 and verified by Spearbit.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/ConnextNxtp-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 3,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/ConnextNxtp-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/ConnextNxtp-Spearbit-Security-Review.pdf",
      "pdf_page_from": 11,
      "contest_id": "",
      "slug": "a-malicious-owner-or-user-with-a-rolerouter-role-can-drain-a-router-s-liquidity-spearbit-connext-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Connext",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Connext",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "6342",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 35,
      "protocol_id": "78",
      "title": "[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L222-L230> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L78-L83> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L38-L46> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L48>\n\nThe project heavily relies on nodes/oracles, which are EOAs that sign the current price.\n\nSince all functions (including withdrawing) require a recently-signed price, the owner(s) of those EOA can freeze all activity by not providing signed prices.\n\nI got from the sponsor that the owner of the contract is going to be a timelock contract.\nHowever, once the owner holds the power to pause withdrawals - that nullifies the timelock. The whole point of the timelock is to allow users to withdraw their funds when they see a pending malicious tx before it's executed. If the owner has the power to freeze users' funds in the contract, they wouldn't be able to do anything while the owner executes his malicious activity.\n\nBesides that, there are also LP funds, which are locked to a certain period, and also can't withdraw their funds when they see a pending malicious timelock tx.\n\n### Impact\n\nThe owner (or attacker who steals the owner's wallet) can steal all user's funds.\n\n### Proof of Concept\n\n*   The fact that the protocol relies on EOA signatures is pretty clear from the code and docs\n*   The whole project relies on the 'StableVault' and 'StableToken'\n    *   The value of the 'StableToken' comes from the real stablecoin that's locked in 'StableVault', if someone manages to empty the 'StableVault' from the deposited stablecoins the 'StableToken' would become worthless\n*   The owner has a few ways to drain all funds:\n    *   Replace the minter via `StableToken.setMinter()`, mint more tokens, and redeem them via `StableVault.withdraw()`\n    *   List a fake token at `StableVault`, deposit it and withdraw real stablecoin\n    *   List a new fake asset for trading with a fake chainlink oracle, fake profit with trading with fake prices, and then withdraw\n        *   They can prevent other users from doing the same by setting `maxOi` and opening position in the same tx\n    *   Replace the MetaTx forwarder and execute tx on behalf of users (e.g. transferring bonds, positions and StableToken from their account)\n\n### Recommended Mitigation Steps\n\n*   Rely on a contract (chainlink/Uniswap) solely as an oracle\n*   Alternately, add functionality to withdraw funds at the last given price in case no signed data is given for a certain period\n    *   You can do it by creating a challenge in which a user requests to close his position at a recent price, if no bot executes it for a while it can be executed at the last recorded price.\n*   As for LPs' funds, I don't see an easy way around it (besides doing significant changes to the architecture of the protocol), this a risk LPs should be aware of and decide if they're willing to accept.\n\n**[TriHaz (Tigris Trade) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/377#issuecomment-1377601222):**\n > We are aware of the centralization risks. Owner of contracts will be a timelock and owner will be a multi sig to reduce the centralization for now until it's fully controlled by DAO.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/377#issuecomment-1383157493):**\n > Missing setFees, but am grouping generic reports under this one as well.\n>\n > Also missing changes to Trading Extension and Referral Fees.\n>\n > This report, in conjunction with [#648](https://github.com/code-423n4/2022-12-tigris-findings/issues/648) effectively covers all \"basic\" admin privilege findings. More nuanced issues are judged separately.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a project that heavily relies on nodes/oracles, which are EOAs that sign the current price. The vulnerability is that the owner of the contract can freeze all activity by not providing signed prices, which would allow them to steal all user's funds. The proof of concept is that the owner has a few ways to drain all funds, such as replacing the minter via `StableToken.setMinter()`, listing a fake token at `StableVault`, listing a new fake asset for trading with a fake chainlink oracle, and replacing the MetaTx forwarder and executing transactions on behalf of users.\n\nThe recommended mitigation steps are to rely on a contract (chainlink/Uniswap) solely as an oracle and to add functionality to withdraw funds at the last given price in case no signed data is given for a certain period. As for LPs' funds, there is no easy way around it, but this a risk LPs should be aware of and decide if they're willing to accept.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
      "sponsor_name": "Tigris Trade",
      "sponsor_link": "https://twitter.com/TigrisTrades",
      "quality_score": 5,
      "general_score": 5,
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/377",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "192",
      "slug": "m-12-centralization-risks-owner-can-freeze-withdraws-and-use-timelock-to-steal-all-funds-code4rena-tigris-trade-tigris-trade-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Tigris Trade",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Tigris Trade",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Derivatives"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Algo-Stables"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "5938",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "106",
      "title": "[M-30] Giant pools are prone to user griefing, preventing their holdings from being staked",
      "content": "\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L105>\n\nbatchRotateLPTokens in GiantMevAndFeesPool allows any user to rotate LP tokens of stakingFundsVaults around.\n\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\nThere is a check that sender has over 0.5 ether of lpTokenETH, to prevent griefing. However, this check is unsatisfactory as user can at any stage deposit ETH to receive lpTokenETH and burn it to receive back ETH. Their lpTokenETH holdings do not correlate with their interest in the vault funds.\n\nTherefore, malicious users can keep bouncing LP tokens around and prevent them from being available for actual staking by liquid staking manager.\n\n### Impact\n\nGiant pools are prone to user griefing, preventing their holdings from being staked.\n\n### Recommended Mitigation Steps\n\nThree options:\n\n1.  batchRotateLPTokens should have logic to enforce that this specific rotation is logical\n2.  Only DAO or some priviledged user can perform Giant pool operations\n3.  Make the caller have something to lose from behaving maliciously, unlike the current status.\n\n**[vince0656 (Stakehouse) disputed and commented](https://github.com/code-423n4/2022-11-stakehouse-findings/issues/415#issuecomment-1336214451):**\n > This doesn't factor in that when ETH is supplied to a liquid staking network, it has 30 minutes to be utilized for staking with the BLS public key - giant pool users can manage this inventory and move the liquidity between BLS keys but that's by design and as mentioned above cannot move for 30 minutes at a time. If it never gets used, it can always go back to the giant pool\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the batchRotateLPTokens function in the GiantMevAndFeesPool contract which allows any user to rotate LP tokens of stakingFundsVaults around. The function includes a check that the sender has over 0.5 ether of lpTokenETH, to prevent griefing. However, this check is unsatisfactory as users can deposit ETH to receive lpTokenETH and burn it to receive back ETH, making their lpTokenETH holdings not correlated with their interest in the vault funds. This would allow malicious users to keep bouncing LP tokens around and prevent them from being available for actual staking by liquid staking manager.\n\nThe impact of this vulnerability is that Giant pools are prone to user griefing, preventing their holdings from being staked. The bug was discovered through manual audit.\n\nTo mitigate this vulnerability, the developers have three options: (1) batchRotateLPTokens should have logic to enforce that this specific rotation is logical; (2) only DAO or some priviledged user can perform Giant pool operations; or (3) make the caller have something to lose from behaving maliciously, unlike the current status.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/415",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "m-30-giant-pools-are-prone-to-user-griefing-preventing-their-holdings-from-being-staked-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "5934",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "106",
      "title": "[M-26] Compromised or malicious DAO can restrict actions of node runners who are not malicious",
      "content": "\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LSDNFactory.sol#L73-L102><br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L239-L246><br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L308-L321><br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377><br>\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L326-L350>\n\n### Impact\n\nWhen calling the `deployNewLiquidStakingDerivativeNetwork` function, `_dao` is not required to be an address that corresponds to a governance contract. This is also confirmed by the code walkthrough at <https://www.youtube.com/watch?v=7UHDUA9l6Ek&t=650s>, which mentions that `_dao` can correspond to an address of a single user. Especially when the DAO is set to be an EOA address, it is possible that its private key becomes compromised. Moreover, because the `updateDAOAddress` function lacks a two step procedure for transferring the DAO's role, it is possible that the DAO is set to an uncontrolled address, which can be malicious. When the DAO becomes compromised or malicious, the actions of the node runners, who are not malicious, can be restricted at the DAO's will, such as by calling functions like `rotateEOARepresentativeOfNodeRunner` and `rotateNodeRunnerOfSmartWallet`. For example, a compromised DAO can call the `rotateNodeRunnerOfSmartWallet` function to transfer a smart wallet from a node runner, who is not malicious at all, to a colluded party. Afterwards, the affected node runner is banned from many interactions with the protocol and can no longer call, for instance, the `withdrawETHForKnot` function for withdrawing ETH from the corresponding smart wallet. Hence, a compromised or malicious DAO can cause severe consequences, including ETH losses.\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LSDNFactory.sol#L73-L102>\n\n```solidity\n    function deployNewLiquidStakingDerivativeNetwork(\n        address _dao,\n        uint256 _optionalCommission,\n        bool _deployOptionalHouseGatekeeper,\n        string calldata _stakehouseTicker\n    ) public returns (address) {\n\n        // Clone a new liquid staking manager instance\n        address newInstance = Clones.clone(liquidStakingManagerImplementation);\n        ILiquidStakingManager(newInstance).init(\n            _dao,\n            ...\n        );\n\n        ...\n    }\n```\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L239-L246>\n\n```solidity\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n```\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L308-L321>\n\n```solidity\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n```\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377>\n\n```solidity\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n```\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L326-L350>\n\n```solidity\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        ...\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        ...\n    }\n```\n\n### Proof of Concept\n\nPlease add the following test in `test\\foundry\\LSDNFactory.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n    function testCompromisedDaoCanRestrictActionsOfNodeRunnersWhoAreNotMalicious() public {\n        vm.prank(address(factory));\n        manager.updateDAOAddress(admin);\n\n        uint256 nodeStakeAmount = 4 ether;\n        address nodeRunner = accountOne;\n        vm.deal(nodeRunner, nodeStakeAmount);\n\n        address eoaRepresentative = accountTwo;\n\n        vm.prank(nodeRunner);\n        manager.registerBLSPublicKeys{value: nodeStakeAmount}(\n            getBytesArrayFromBytes(blsPubKeyOne),\n            getBytesArrayFromBytes(blsPubKeyOne),\n            eoaRepresentative\n        );\n\n        // Simulate a situation where admin, who is the dao at this moment, is compromised.\n        // Although nodeRunner is not malicious,\n        //   the compromised admin can call the rotateNodeRunnerOfSmartWallet function to assign nodeRunner's smart wallet to a colluded party.\n        vm.prank(admin);\n        manager.rotateNodeRunnerOfSmartWallet(nodeRunner, accountThree, true);\n\n        // nodeRunner is blocked from other interactions with the protocol since it is now banned unfairly\n        assertEq(manager.bannedNodeRunners(accountOne), true);\n\n        // for example, nodeRunner is no longer able to call the withdrawETHForKnot function\n        vm.prank(nodeRunner);\n        vm.expectRevert(\"Not the node runner for the smart wallet \");\n        manager.withdrawETHForKnot(nodeRunner, blsPubKeyOne);\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen calling the `deployNewLiquidStakingDerivativeNetwork` function, instead of explicitly setting the DAO's address, a configurable governance contract, which can have features like voting and timelock, can be deployed and used as the DAO.\n\n**[vince0656 (Stakehouse) disputed](https://github.com/code-423n4/2022-11-stakehouse-findings/issues/383)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Liquid Staking Derivative Network protocol, which is a part of a project called Stakehouse. The vulnerability exists when calling the deployNewLiquidStakingDerivativeNetwork function, where the DAO (Decentralized Autonomous Organization) is not required to be an address that corresponds to a governance contract. This means that the DAO can be set to an address of a single user, which can be compromised. Furthermore, the updateDAOAddress function lacks a two step procedure for transferring the DAO's role, which can lead to the DAO being set to a malicious address. \n\nWhen the DAO becomes compromised or malicious, the actions of the node runners, who are not malicious, can be restricted at the DAO's will. For example, the DAO can call the rotateNodeRunnerOfSmartWallet function to transfer a smart wallet from a node runner to a colluded party. Afterwards, the affected node runner is banned from many interactions with the protocol, such as calling the withdrawETHForKnot function for withdrawing ETH from the corresponding smart wallet. This can cause severe consequences, including ETH losses.\n\nThe recommended mitigation step is to deploy a configurable governance contract instead of explicitly setting the DAO's address when calling the deployNewLiquidStakingDerivativeNetwork function. This governance contract can have features like voting and timelock, which can help to secure the DAO's address.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/383",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "m-26-compromised-or-malicious-dao-can-restrict-actions-of-node-runners-who-are-not-malicious-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "5917",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "106",
      "title": "[M-09] DAO or lsdn owner can steal funds from node runner",
      "content": "\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L356-L377>\n\nDAO or LSD network owner can swap node runner of the smart contract to their own eoa, allowing them to withdrawETH or claim rewards from node runner.\n\n### Proof of Concept\n\nThere are no checks done when swapping the node runner whether there are funds in the smart contract that belongs to the node runner. Therefore, a malicious dao or lsd network owner can simply swap them out just right after the node runner has deposited 4 ether in the smart wallet.\n\nPlace poc in LiquidStakingManager.sol\n\n```solidity\n    function testDaoCanTakeNodeRunner4ETH() public {\n        address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);\n        address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n        address attacker = accountFour;\n\n\n        registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);\n\n        vm.startPrank(admin);\n        manager.rotateNodeRunnerOfSmartWallet(nodeRunner, attacker, true);\n\n        vm.stopPrank();\n\n        vm.startPrank(attacker);\n        emit log_uint(attacker.balance);\n        manager.withdrawETHForKnot(attacker,blsPubKeyOne);\n        emit log_uint(attacker.balance);\n        vm.stopPrank();\n    }\n\n```\n\n### Tools Used\n\nforge\n\n### Recommended Mitigation Steps\n\nSend back outstanding ETH and rewards that belongs to node runner if swapping is needed.\n\n**[vince0656 (Stakehouse) confirmed](https://github.com/code-423n4/2022-11-stakehouse-findings/issues/109#issuecomment-1329514501)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LiquidStakingManager.sol smart contract code. The vulnerability allows the DAO or LSD network owner to swap out the node runner of the smart contract to their own External Owned Account (EOA), which in turn allows them to withdraw ETH or claim rewards from the node runner. A malicious DAO or LSD network owner can take advantage of this vulnerability by swapping out the node runner just after they have deposited 4 Ether in the smart wallet. The recommended mitigation steps are to send back any outstanding ETH and rewards that belong to the node runner if swapping is needed. The bug report was tested using Forge.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/109",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "m-09-dao-or-lsdn-owner-can-steal-funds-from-node-runner-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "5916",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 4,
      "protocol_id": "106",
      "title": "[M-08] DAO admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund in the smart wallet via arbitrary execution.",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L202\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L210\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L426\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L460\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/smart-wallet/OwnableSmartWallet.sol#L63\n\n\n## Vulnerability details\n\n## Impact\n\nDao admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund via arbitrary execution.\n\n## Proof of Concept\n\nAfter the Liquid Staking Manager.so is deployed via LSDNFactory::deployNewLiquidStakingDerivativeNetwork,\n\n```solidity\n/// @notice Deploys a new LSDN and the liquid staking manger required to manage the network\n/// @param _dao Address of the entity that will govern the liquid staking network\n/// @param _stakehouseTicker Liquid staking derivative network ticker (between 3-5 chars)\nfunction deployNewLiquidStakingDerivativeNetwork(\n\taddress _dao,\n\tuint256 _optionalCommission,\n\tbool _deployOptionalHouseGatekeeper,\n\tstring calldata _stakehouseTicker\n) public returns (address) {\n```\n\nThe dao address governance address (contract) has very high privilege.\n\nThe dao address can perform arbitrary execution by calling LiquidStakingManager.sol::executeAsSmartWallet\n\n```solidity\n/// @notice Enable operations proxied through DAO contract to another contract\n/// @param _nodeRunner Address of the node runner that created the wallet\n/// @param _to Address of the target contract\n/// @param _data Encoded data of the function call\n/// @param _value Total value attached to the transaction\nfunction executeAsSmartWallet(\n\taddress _nodeRunner,\n\taddress _to,\n\tbytes calldata _data,\n\tuint256 _value\n) external payable onlyDAO {\n\taddress smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n\trequire(smartWallet != address(0), \"No wallet found\");\n\tIOwnableSmartWallet(smartWallet).execute(\n\t\t_to,\n\t\t_data,\n\t\t_value\n\t);\n}\n```\n\nWhen a register a new node operator with 4 ETH by calling registerBLSPublicKeys:\n\n```solidity\n/// @notice register a node runner to LSD by creating a new smart wallet\n/// @param _blsPublicKeys list of BLS public keys\n/// @param _blsSignatures list of BLS signatures\n/// @param _eoaRepresentative EOA representative of wallet\nfunction registerBLSPublicKeys(\n\tbytes[] calldata _blsPublicKeys,\n\tbytes[] calldata _blsSignatures,\n\taddress _eoaRepresentative\n) external payable nonReentrant {\n```\n\nthe smart wallet created in the smart contract custody the 4 ETH.\n\n```solidity\n// create new wallet owned by liquid staking manager\nsmartWallet = smartWalletFactory.createWallet(address(this));\nemit SmartWalletCreated(smartWallet, msg.sender);\n```\n\n```solidity\n{\n\t// transfer ETH to smart wallet\n\t(bool result,) = smartWallet.call{value: msg.value}(\"\");\n\trequire(result, \"Transfer failed\");\n\temit WalletCredited(smartWallet, msg.value);\n}\n```\n\nbut  Dao admin in LiquidStakingManager.sol can rug the registered node operator by stealing their fund in the smart wallet via arbitrary execution.\n\n**As shown in POC:**\n\nfirst we add this smart contract in LiquidStakingManager.t.sol\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12\n\n```solidity\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract RugContract {\n\n    function receiveFund() external payable {\n\n    }\n\n    receive() external payable {}\n}\n\ncontract MockToken is ERC20 {\n\n    constructor()ERC20(\"A\", \"B\") {\n        _mint(msg.sender, 10000 ether);\n    }\n\n}\n```\n\n**We add the two POC,** \n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35\n\nthe first POC shows the admin can steal the ETH from the smart contract via arbrary execution.\n\n```solidity\n    function testDaoRugFund_Pull_ETH_POC() public {\n        \n        address user = vm.addr(21312);\n\n        bytes[] memory publicKeys = new bytes[](1);\n        publicKeys[0] = \"publicKeys\";\n\n        bytes[] memory signature = new bytes[](1);\n        signature[0] = \"signature\";\n\n        RugContract rug = new RugContract();\n\n        // user spends 4 ehter and register the key to become the public operator\n        vm.prank(user);\n        vm.deal(user, 4 ether);\n        manager.registerBLSPublicKeys{value: 4 ether}(\n            publicKeys,\n            signature,\n            user\n        );\n        address wallet = manager.smartWalletOfNodeRunner(user);\n        console.log(\"wallet ETH balance for user after registering\");\n        console.log(wallet.balance);\n\n        // dao admin rug the user by withdraw the ETH via arbitrary execution.\n        vm.prank(admin);\n        bytes memory data = abi.encodeWithSelector(RugContract.receiveFund.selector, \"\");\n        manager.executeAsSmartWallet(\n            user,\n            address(rug),\n            data,\n            4 ether\n        );\n        console.log(\"wallet ETH balance for user after DAO admin rugging\");\n        console.log(wallet.balance);\n\n    }\n```\n\nWe run the test:\n\n```solidity\nforge test -vv --match testDaoRugFund_Pull_ETH_POC\n```\n\nthe result is\n\n```solidity\nRunning 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests\n[PASS] testDaoRugFund_Pull_ETH_POC() (gas: 353826)\nLogs:\n  wallet ETH balance for user after registering\n  4000000000000000000\n  wallet ETH balance for user after DAO admin rugging\n  0\n\nTest result: ok. 1 passed; 0 failed; finished in 13.63ms\n```\n\nthe second POC shows the admin can steal the ERC20 token from the smart contract via arbrary execution.\n\n```solidity\n    function testDaoRugFund_Pull_ERC20_Token_POC() public {\n\n        address user = vm.addr(21312);\n\n        bytes[] memory publicKeys = new bytes[](1);\n        publicKeys[0] = \"publicKeys\";\n\n        bytes[] memory signature = new bytes[](1);\n        signature[0] = \"signature\";\n\n        RugContract rug = new RugContract();\n\n        vm.prank(user);\n        vm.deal(user, 4 ether);\n        manager.registerBLSPublicKeys{value: 4 ether}(\n            publicKeys,\n            signature,\n            user\n        );\n\n        address wallet = manager.smartWalletOfNodeRunner(user);\n        ERC20 token = new MockToken();\n        token.transfer(wallet, 100 ether);\n\n        console.log(\"wallet ERC20 token balance for user after registering\");\n        console.log(token.balanceOf(wallet));\n\n        vm.prank(admin);\n        bytes memory data = abi.encodeWithSelector(IERC20.transfer.selector, address(rug), 100 ether);\n        manager.executeAsSmartWallet(\n            user,\n            address(token),\n            data,\n            0\n        );\n\n        console.log(\"wallet ERC20 token balance for dao rugging\");\n        console.log(token.balanceOf(wallet));\n\n    }\n```\n\nWe run the test:\n\n```solidity\nforge test -vv --match testDaoRugFund_Pull_ERC20_Token_POC\n```\n\nthe running result is\n\n```solidity\nRunning 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests\n[PASS] testDaoRugFund_Pull_ERC20_Token_POC() (gas: 940775)\nLogs:\n  wallet ERC20 token balance for user after registering\n  100000000000000000000\n  wallet ERC20 token balance for dao rugging\n  0\n\nTest result: ok. 1 passed; 0 failed; finished in 16.99ms\n```\n\n\n## Tools Used\n\nManual Review, Foundry\n\n## Recommended Mitigation Steps\n\nWe recommend not give the dao admin the priviledge to perform arbitrary execution to access user's fund.",
      "summary": "\nThis bug report is about a vulnerability that exists in the LiquidStakingManager.sol contract. The vulnerability allows the dao admin to rug the registered node operator by stealing their funds via arbitrary execution. The bug was discovered through manual review and Foundry, a tool for testing smart contracts. \n\nThe proof of concept shows that after the Liquid Staking Manager.so is deployed via LSDNFactory::deployNewLiquidStakingDerivativeNetwork, the dao address has very high privilege. This address can perform arbitrary execution by calling LiquidStakingManager.sol::executeAsSmartWallet. When a user registers a new node operator with 4 ETH by calling registerBLSPublicKeys, a smart wallet is created in the smart contract and the 4 ETH is transferred to it. However, the dao admin can rug the registered node operator by stealing their fund in the smart wallet via arbitrary execution. \n\nThe two proof of concept tests show that the dao admin can steal ETH from the smart contract via arbitrary execution, as well as ERC20 tokens. The tests show that the user's ETH and tokens are successfully transferred to the dao admin. \n\nThe recommended mitigation steps for this vulnerability is to not give the dao admin the privilege to perform arbitrary execution to access user's fund.",
      "report_date": {},
      "contest_prize_txt": "$90,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
      "sponsor_name": "Stakehouse Protocol",
      "sponsor_link": "https://twitter.com/blockswap_team",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-11-stakehouse",
      "github_link": "https://github.com/code-423n4/2022-11-stakehouse-findings/issues/106",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "182",
      "slug": "m-08-dao-admin-in-liquidstakingmanagersol-can-rug-the-registered-node-operator-by-stealing-their-fund-in-the-smart-wallet-via-arbitrary-execution-code4rena-stakehouse-protocol-lsd-network-stakehouse-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Stakehouse Protocol",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Stakehouse Protocol",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "6845",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "113",
      "title": "owner can reset feeBps set byadmin for token gated drops",
      "content": "## Medium Risk Report\n\n**Severity:** Medium Risk  \n**Context:** \n- ERC721SeaDrop.sol#L233-L245\n- SeaDrop.sol#L860\n- SeaDrop.sol#L889-L890  \n\n**Description:**  \nOnly the admin can call `updateTokenGatedDropFee` to update `feeBps`. However, the owner can call `updateTokenGatedDrop(address seaDropImpl, address allowedNftToken, TokenGatedDropStage calldata dropStage)` twice afterward to reset the `feeBps` to 0 for a drop.\n\n1. Once with `dropStage.maxTotalMintableByWallet` equal to 0 to wipe out the storage on the SeaDrop side.\n2. Then with the same `allowedNftToken` address and the other desired parameters, which would retrieve the previously wiped out drop stage data (with `feeBps` equal to 0).\n\n**NOTE:** This type of attack does not apply to `updatePublicDrop` and `updatePublicDropFee` pair, since `updatePublicDrop` cannot remove or update the `feeBps`. Once `updatePublicDropFee` is called with a specific `feeBps`, that value remains for this ERC721SeaDrop contract-related storage on SeaDrop (`_publicDrops[msg.sender] = publicDrop`). Any number of consecutive calls to `updatePublicDrop` with any parameters cannot change the already set `feeBps`.\n\n**Recommendation:**  \nThe admins could monitor all activities for `updateTokenGatedDrop` calls even when the same old `allowedNftToken` is used and make sure to set the fees after each call if it is not a removal kind.\n\n**OpenSea Proposal:**  \nWe can rework it so that `updateTokenGatedDropFee` \"initializes\" a TokenGatedDrop stage (setting all params to 0 besides `feeBps` and `restrictFeeRecipients`), allowing a partner to then edit other params and delete the stage, but not create a new one. This would be a workaround for the current issues.\n\n## Proposed Workaround:\n- Administrator/OpenSea is the only authorized user that can \"initialize\" a TokenGatedDrop. Initializing a token-gated drop sets all params to zero except `maxTotalMintableByWallet = 1` (the struct will not be stored if == 0), `feeBps`, and `restrictFeeRecipients = true`.\n- The parameter `startTime = 0` means the stage will not be active and cannot be made active by OpenSea.\n- The Owner/Partner can then update the initialized TokenGatedDrop stage (potentially including delete, if so desired, but it would need to be re-initialized with a fee by OpenSea).",
      "summary": "\nThis bug report is about the ERC721SeaDrop.sol and SeaDrop.sol contracts. There is a vulnerability in these contracts which allows the owner to call the updateTokenGatedDrop function twice in order to reset the feeBps to 0 for a drop. This vulnerability does not apply to the updatePublicDrop and updatePublicDropFee pair.\n\nThe severity of the issue is medium risk. The recommendation is that administrators should monitor all activities for updateTokenGatedDrop calls even when the same old allowedNftToken is used and make sure to set the fees after each call if it is not a removal kind.\n\nA proposed workaround is that the administrator/OpenSea is the only authorized user that can \"initialize\" a TokenGatedDrop. This sets the parameters to zero except maxTotalMintableByWallet = 1, feeBps, and restrictFeeRecipients = true. The Owner/Partner can then update the initialized TokenGatedDrop stage, which includes the possibility of deleting it. However, it would need to be re-initialized with a fee by OpenSea.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Seadrop-Spearbit-Security-Review.pdf",
      "pdf_page_from": 15,
      "contest_id": "",
      "slug": "owner-can-reset-feebps-set-byadmin-for-token-gated-drops-spearbit-seadrop-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "SeaDrop",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "SeaDrop",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "6843",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "113",
      "title": "ERC721SeaDrop owner can choose an address they control as the admin when the constructor is called.",
      "content": "## Severity: Medium Risk\n\n## Context\n`ERC721SeaDrop.sol#L83`\n\n## Description\nThe owner/creator can call the contract directly (skipping the use of the UI) and set the administrator as themselves or another address that they control. After creating a `PublicDrop` or `TokenGatedDrop`, they can call either `updatePublicDropFee` or `updateTokenGatedDropFee` and set the `feeBps` to:\n- zero\n- another number \n\nThey can also call `updateAllowedFeeRecipient` to add the same or another address they control as a `feeRecipient`. This way, they can circumvent the protocol fee.\n\n## Recommendation\nConsider implementing the following suggestions:\n- Do not list NFT contracts on the marketplace site that have an administrator who is not on an internal allowed list.\n- Allow each permitted SeaDrop implementation's admin/operator to set the admins for the `ERC721SeaDrop` contract. However, this could still potentially be rigged by a custom handcrafted contract that pretends to be an `ERC721SeaDrop` contract.\n- SeaDrop can have its own set of admins independent of the `IERC721SeaDrop` tokens. These admins should be able to set the `feeRecipients` and `feeBps` on SeaDrop without interacting with the original token.\n\n## OpenSea\nIn practice, this particular implementation will be deployed by OpenSea or a trusted partner. Generally, an administrator is not required for `ERC721SeaDrop` contracts; OpenSea will ingest events and data, then selectively decide which mints to surface and fulfill, depending on mint parameters. In other words, it's up to an individual marketplace to decide which mints they are willing to list and fulfill, with that decision making happening off-chain.\n\n## Spearbit\nI guess the listing and fulfillment on the OpenSea side is just about the OpenSea marketplace UI. For example, other aggregators that listen to events from OpenSea-deployed SeaDrops can/could list these `ERC721SeaDrop` on their marketplace. Obviously, users can still interact with the OpenSea-deployed SeaDrops directly.",
      "summary": "\nThis bug report is about an issue with the ERC721SeaDrop.sol contract on line 83. It states that the owner/creator can call the contract directly and set the administrator as themselves or another address they can control. This would allow them to circumvent the protocol fee by setting the feeBps to zero or another number and also call the updateAllowedFeeRecipient to add the same or another address they control as a feeRecipient. \n\nThe report offers some recommendations to address the issue. One is not to list NFT contracts on the marketplace site that have an administrator who is not in an internal allowed list. Another is to let each allowed SeaDrop implementation's admin/operator to set the admins for the ERC721SeaDrop contract. Additionally, SeaDrop can have its own set of admins independent of the IERC721SeaDrop tokens. Finally, it is up to the individual marketplace to decide which mints they are willing to list and fulfill, and that decision making happens off-chain. \n\nIn conclusion, this bug report is about an issue with the ERC721SeaDrop.sol contract on line 83 that allows the owner/creator to circumvent the protocol fee. The report offers some recommendations to address the issue.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Seadrop-Spearbit-Security-Review.pdf",
      "pdf_page_from": 14,
      "contest_id": "",
      "slug": "erc721seadrop-owner-can-choose-an-address-they-control-as-the-admin-when-the-constructor-is-spearbit-seadrop-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "SeaDrop",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "SeaDrop",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Validation"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "6836",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "113",
      "title": "ERC721SeaDrop 's modifier onlyOwnerOrAdministrator would allow either the owner or theadmin to override the other person's config parameters.",
      "content": "## Severity: High Risk\n\n## Context\n- ERC721SeaDrop.sol#L106\n- ERC721SeaDrop.sol#L212\n- ERC721SeaDrop.sol#L289\n- ERC721SeaDrop.sol#L345\n\n## Description\nThe following 4 external functions in `ERC721SeaDrop` have the `onlyOwnerOrAdministrator` modifier which allows either one to override the other person's work:\n- `updateAllowedSeaDrop`\n- `updateAllowList`\n- `updateDropURI`\n- `updateSigner`\n\nThis means there should be some sort of off-chain trust established between these two entities. Otherwise, there are possible vectors of attack.\n\nHere is an example of how the owner can override `AllowListData.merkleRoot` and the other fields within `AllowListData` to generate proofs for any allowed SeaDrop `smintAllowList` endpoint that would have `MintParams.feeBps` equal to 0:\n\n1. The administrator calls `updateAllowList` to set the Merkle root for an allowed SeaDrop implementation for this contract and emit the other parameters as logs. The SeaDrop endpoint being called by `ERC721SeaDrop.updateAllowList`: `SeaDrop.sol#L827`\n   \n2. The owner calls `updateAllowList` but this time with new parameters, specifically a new Merkle root that is computed from leaves that have `MintParams.feeBps == 0`.\n\n3. Users/minters use the generated proof corresponding to the latest allow list update and pass their `mintParams.feeBps` as 0, thus avoiding the protocol fee deduction for the `creatorPaymentAddress` (`SeaDrop.sol#L187-L194`).\n\n## Recommendation\nOnly use this implementation of `IERC721SeaDrop` if there is already a legal off-chain contract and a level of trust between the different parties. Otherwise, a different implementation with a stricter separation of roles is recommended.\n\n## OpenSea\nThis is related to specific legal/BD requirements - we need to be able to administer the contract for partners (some may choose to administer it themselves), but for legal clarity, they also need to unambiguously be the \"owner\" of the contract, in that they have the power to administer it as well.\n\nIn practice, in this implementation of the contract, both parties should be considered trusted, but ideally shouldn't have privileges that overstep their bounds (in particular, fee and creator payouts). This contract is intended to be used as the basis for our first few partnered primary mints. As such, there are some assumptions and particular tailored logic to meet our and our partners' needs. (In hindsight, it might have made more sense to split out into a more-generic `ERC721SeaDrop`, and more-specific `ERC721PartnerSeaDrop`).\n\n## Assumptions\n- OpenSea will be collecting a fee\n- There is a good deal of trust (i.e., legal contracts) established between the two parties\n- Some partners will prefer (or require) us to configure drop mechanics and metadata  \n   This is why some functions are `onlyOwnerOrAdministrator`.\n\n## Requirements (passed down from legal)\n- OpenSea is the \"Administrator\"\n- The Partner is the \"Owner\"\n- The Partner is the only entity in control of the pricing of the general drop and the creator payout address\n- OpenSea is the only entity that can update fees and fee recipients\n\nYou are correct that this requires trust between the two parties. As mentioned elsewhere, in general, an administrator will not be necessary for all token contracts.\n\nIn practice, a marketplace (OpenSea) will have to decide whether or not to provide a proof for a mint transaction depending on the allowed fee recipients and specified `feeBps` off-chain.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a vulnerability in the ERC721SeaDrop.sol contract which allows either the owner or the administrator to override the other person's config parameters. This could lead to potential attack vectors, such as the owner overriding the AllowListData.merkleRoot and other fields within AllowListData to generate proofs for any allowed SeaDrop 'smintAllowList endpoint that would have MintParams.feeBps equal to 0. \n\nOpenSea is the administrator and the partner is the owner, and the partner is the only entity in control of the pricing of the general drop and the creator payout address, while OpenSea is the only entity that can update fees and fee recipients. This requires trust between the two parties, and in general, an administrator will not be necessary for all token contracts.\n\nThe recommendation is that only use this implementation of IERC721SeaDrop if there is already a legal off-chain contract and level of trust between the different parties. Otherwise, a different implementation with a stricter separation of roles is recommended.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seadrop-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Seadrop-Spearbit-Security-Review.pdf",
      "pdf_page_from": 7,
      "contest_id": "",
      "slug": "erc721seadrop-s-modifier-onlyowneroradministrator-would-allow-either-the-owner-or-theadmin-to-spearbit-seadrop-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "SeaDrop",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "SeaDrop",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        },
        {
          "tags_tag": {
            "title": "Access Control"
          }
        }
      ]
    },
    {
      "id": "5748",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "122",
      "title": "[M-01] `diamondCut` is not protected in case of governor's key leakage",
      "content": "\nWhen the governor proposes a diamondCut, governor must wait for `upgradeNoticePeriod` to be passed, or security council members have to approve the proposal to bypass the notice period, so that the governor can execute the proposal.\n\n       require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire\n       require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");\n\nIf the governor's key is leaked and noticed by zkSync, the attacker must wait for the notice period to execute the already proposed diamondCut with the malicious `_calldata` based on the note below from zkSync, or to propose a new malicious diamondCut. For, both cases, the attacker loses time.\n\n> NOTE: proposeDiamondCut - commits data associated with an upgrade but does not execute it. While the upgrade is associated with facetCuts and (address \\_initAddress, bytes \\_calldata) the upgrade will be committed to the facetCuts and \\_initAddress. This is done on purpose, to leave some freedom to the governor to change calldata for the upgrade between proposing and executing it.\n\nSince, there is a notice period (as zkSync noticed the key leakage, security council member will not approve the proposal, so bypassing the notice period is not possible), there is enough time for zkSync to apply security measures (pausing any deposit/withdraw, reporting in media to not execute any transaction in zkSync, and so on).\n\nBut, the attacker can be smarter, just before the proposal be executed by the governor (i.e. the notice period is passed or security council members approved it), the attacker executes the proposal earlier than governor with the malicious `_calldata`. In other words, the attacker front runs the governor.\n\nTherefore, if zkSync notices the governor's key leakage beforehand, there is enough time to protect the project. But, if zkSync does not notice the governor's key leakage, the attacker can change the `_calldata` into a malicious one in the last moment so that it is not possible to protect the project.\n\n### Proof of Concept\n\n[Diamond.sol#L277](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Diamond.sol#L277)<br>\n[DiamondCut.sol#L46](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L46)\n\n### Recommended Mitigation Steps\n\n`_calldata` should be included in the proposed diamondCut:[DiamondCut.sol#L27](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L27).\n\nOr, at least one of the security council members should approve the `_calldata` during execution of the proposal.\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/46#issuecomment-1324267775):**\n > It is a valid issue, and the fix is going to be implemented, so we confirm the issue as medium! Thanks.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/46#issuecomment-1335849634):**\n > In contrast to other reports, this shows how a malicious proposal could be injected, bypassing the timelock protection, for this reason (after consulting with a second Judge), I agree with marking it as a distinct finding and agree with Medium Severity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the zkSync project. It is related to the governor's key being leaked, and the possibility of an attacker using this key to propose malicious diamondCuts. The attacker could then potentially front-run the governor and execute the malicious diamondCut earlier than the governor can.\n\nThe code that is affected by this vulnerability is in the DiamondCut.sol and Diamond.sol files. The vulnerable code is found at lines 46 and 277 of these files.\n\nThe impact of this vulnerability is that if the governor's key is leaked and noticed by zkSync, the attacker must wait for the notice period to execute the already proposed diamondCut with the malicious `_calldata`. However, the attacker could be smarter and execute the proposal earlier than the governor with the malicious `_calldata`. This would mean that zkSync would not have enough time to protect the project.\n\nThe proof of concept for this vulnerability is also included in the report. It is found at lines 27 and 46 of the DiamondCut.sol and Diamond.sol files.\n\nThe recommended mitigation steps for this vulnerability are that the `_calldata` should be included in the proposed diamondCut, or at least one of the security council members should approve the `_calldata` during execution of the proposal.\n\nOverall, this bug report is about a vulnerability in the zkSync project related to the governor's key being leaked and the possibility of an attacker using this key to propose malicious diamondCuts. The code that is affected by this vulnerability is in the DiamondCut.sol and Diamond.sol files, and the recommended mitigation steps are that the `_calldata` should be included in the proposed diamondCut, or at least one of the security council members should approve the `_calldata` during execution of the proposal.",
      "report_date": {},
      "contest_prize_txt": "$165,500 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-zksync-v2-contest",
      "sponsor_name": "zkSync",
      "sponsor_link": "https://twitter.com/zksync",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "https://github.com/code-423n4/2022-10-zksync-findings/issues/46",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "177",
      "slug": "m-01-diamondcut-is-not-protected-in-case-of-governors-key-leakage-code4rena-zksync-zksync-v2-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "zkSync",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "zkSync",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "25674",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 27,
      "protocol_id": "228",
      "title": "[M-02] Owner can transfer all ERC20 reward token out using function recoverERC20",
      "content": "\nThe function recoverERC20 is very privileged. It means to recover any token that is accidently sent to the contract.\n\n```solidity\nfunction recoverERC20(address token) external onlyOwner returns(bool) {\n\tif(minAmountRewardToken[token] != 0) revert Errors.CannotRecoverToken();\n\n\tuint256 amount = IERC20(token).balanceOf(address(this));\n\tif(amount == 0) revert Errors.NullValue();\n\tIERC20(token).safeTransfer(owner(), amount);\n\n\treturn true;\n}\n```\n\nHowever, admin / owner can use this function to transfer all the reserved reward tokens, which result in fund loss of the pledge creator and the loss of reward for users that want to delegate the veToken.\n\nAlso, the recovered token is sent to owner directly instead of sending to a recipient address.\n\nThe safeguard\n\n```solidity\nif(minAmountRewardToken[token] != 0)\n```\n\ncannot stop owner transferring funds because if the owner is compromised or misbehaves, he can adjust the whitelist easily.\n\n### Proof of Concept\n\nThe admin can set minAmountRewardToken\\[token] to 0 first by calling updateRewardToken:\n\n```solidity\nfunction updateRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n```\n\nBy doing this the admin removes the token from the whitelist, then the token can call recoverERC20 to transfer all the token into the owner wallet.\n\n```solidity\nfunction recoverERC20(address token) external onlyOwner returns(bool) {\n```\n\n### Recommended Mitigation Steps\n\nWe recommend that the project uses a multisig wallet to safeguard the owner's wallet.\n\nWe can also keep track of the reserved amount for rewarding token and only transfer the remaining amount of token out.\n\n```solidity\n pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n reservedReward[token] += totalRewardAmount;\n```\n\nThen we can change the implementation to:\n\n```solidity\nfunction recoverERC20(address token, address recipient) external onlyOwner returns(bool) {\n\n\tuint256 amount = IERC20(token).balanceOf(address(this));\n\tif(amount == 0) revert Errors.NullValue();\n\n\tif(minAmountRewardToken[token] == 0) {\n\t // if it is not whitelisted, we assume it is mistakenly sent, \n\t   // we transfer the token to recipient\n\t IERC20(token).safeTransfer(recipient, amount);\n\t} else {\n\t// revert if the owner over transfer\n\tif(amount >  reservedReward[token]) revert rewardReserved();\n\t  IERC20(token).safeTransfer(recipient, amount - reservedReward[token]);\n\t}\n\n\treturn true;\n\n}\n```\n\n**[Kogaroshi (Paladin) confirmed](https://github.com/code-423n4/2022-10-paladin-findings/issues/17)**\n\n**[Kogaroshi (Paladin) commented](https://github.com/code-423n4/2022-10-paladin-findings/issues/68#issuecomment-1296375338):**\n > Interesting proposed Mitigation to be noted. \n***\n\n",
      "summary": "\nThis bug report is about a function called recoverERC20 which is used to recover any token that is accidently sent to the contract. However, the admin or owner of the contract can use this function to transfer all the reserved reward tokens, which can result in the loss of funds for the pledge creator and the loss of rewards for users that want to delegate the veToken. This is because the safeguard cannot stop the owner from transferring funds as they can easily adjust the whitelist.\n\nThe admin can set minAmountRewardToken\\[token] to 0 first by calling updateRewardToken, which removes the token from the whitelist and then allows them to call recoverERC20 to transfer all the token into the owner wallet.\n\nTo mitigate this bug, it is recommended to use a multisig wallet to safeguard the owner's wallet. Additionally, the project can keep track of the reserved amount for rewarding token and only transfer the remaining amount of token out. The implementation of the function can also be changed to ensure that if the token is not whitelisted, it is transferred to a recipient address, and if the owner over transfers, the transaction is reverted.",
      "report_date": {},
      "contest_prize_txt": "$33,500 USDC",
      "contest_link": "https://code4rena.com/reports/2022-10-paladin",
      "sponsor_name": "Paladin",
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-10-paladin",
      "github_link": "https://github.com/code-423n4/2022-10-paladin-findings/issues/68",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "176",
      "slug": "m-02-owner-can-transfer-all-erc20-reward-token-out-using-function-recovererc20-code4rena-paladin-paladin-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Paladin",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Paladin",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 1.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "5737",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 16,
      "protocol_id": "126",
      "title": "[M-08] Protocol withdrawals of collateral can be unexpectedly locked if governance sets the collateralFactorBps to 0",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L359\nhttps://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L376\n\n\n## Vulnerability details\n\n#### Description\n\nThe FiRM `Marketplace` contract contains multiple governance functions for setting important values for a given debt market. Many of these are numeric values that affect ratios/levels for debt positions, fees, incentives, etc.\n\nIn particular, `Market.setCollateralFactorBps()` sets the ratio for how much collateral is required for loans vs the debt taken on by the user. The lower the value, the less debt a user can take on. See `Market.getCreditLimitInternal()` for that implementation.\n\nThe function `Market.getWithdrawalLimitInternal()` calculates how much collateral a user can withdraw from the protocol, factoring in their current level of debt. It contains the following check:\n\n`if(collateralFactorBps == 0) return 0;`\n\nThis would cause the user to not be able to withdraw any tokens, so long as they had any non-0 amount of debt and the `collateralFactorBps` was 0.\n\n#### Severity Rationalization\n\nIt is the warden's estimation that all semantics for locking functionality of the protocol should be explicit rather than implicit. While it is very unlikely that governance would intentionally set this value to 0, if it were to do so it would disproportionately affect users whose debt values were low compared to their deposited collateral.\n\nIt is also obvious that the same function that set the value to 0 could be used to revert the change. However, this would take time. Inverse Finance has mandatory minimums for the time required to process governance items in its workflow (https://docs.inverse.finance/inverse-finance/governance/creating-a-proposal)\n\n> The community has a social agreement to post all proposals on the forum and as a draft in GovMills at least 24 hours before the proposal is put up for an on-chain vote, and also to host a community call focusing on the proposal before the voting period.\n\n> Once a proposal has passed, it must be queued on-chain. This action can be triggered by anyone who is willing to pay the gas fee (usually done by a DAO member). The proposal then enters a holding period of 40 hours to allow users time to prepare for the consequences of the execution of the proposal.\n\nAs such, were the situation to occur it would cause at least 64 hours of lock.\n\nSince the contract itself only overtly contains locking for new borrowing, this implicit lock on withdraws seems like an unnecessary risk.\n\n#### Mitigation\n\nConsider a minimum for this value, to go along with the maximum value check already present in the setter function. While this will still reduce the quantity of collateral that can be withdrawn by users, it would allow for some withdraws to occur.\n\nAn explicit withdrawal lock could be implemented, making the semantic clear. This function could have modified access controls to enable faster reactions vs governance alone.\n\nAlternatively, if there was an intention for this value to accept `0`, consider an 'escape hatch' function that could be enacted by users when a 'defaulted' state is set on the Market.\n\n\n#### Tooling\nManual review",
      "summary": "\nThis bug report is about the FiRM `Marketplace` contract which contains multiple governance functions for setting important values for a given debt market. In particular, `Market.setCollateralFactorBps()` sets the ratio for how much collateral is required for loans vs the debt taken on by the user. The function `Market.getWithdrawalLimitInternal()` calculates how much collateral a user can withdraw from the protocol, but it contains a check that would cause the user to not be able to withdraw any tokens, so long as they had any non-0 amount of debt and the `collateralFactorBps` was 0.\n\nThe severity of this vulnerability is high as it would disproportionately affect users whose debt values were low compared to their deposited collateral. It could also cause at least 64 hours of lock as the time required to process governance items in its workflow is 24 hours before the proposal is put up for an on-chain vote and then a 40 hour holding period.\n\nThe bug can be mitigated by considering a minimum value for the collateral factor, to go along with the maximum value check already present in the setter function. This will still reduce the quantity of collateral that can be withdrawn by users, but it would allow for some withdraws to occur. Alternatively, an explicit withdrawal lock could be implemented, making the semantic clear. Manual review is the recommended tooling for this bug.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
      "sponsor_name": "Inverse Finance",
      "sponsor_link": "https://twitter.com/InverseFinance",
      "quality_score": 4,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-10-inverse",
      "github_link": "https://github.com/code-423n4/2022-10-inverse-findings/issues/301",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "175",
      "slug": "m-08-protocol-withdrawals-of-collateral-can-be-unexpectedly-locked-if-governance-sets-the-collateralfactorbps-to-0-code4rena-inverse-finance-inverse-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Inverse Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Inverse Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Validation"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "7095",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 3,
      "protocol_id": "133",
      "title": "Owner can circumvent allowance() viaenableTradingWithWeights()",
      "content": "## Security Assessment Report\n\n## Severity\n**Medium Risk**\n\n## Context\nAeraVaultV1.sol#L564-L593\n\n## Description\nThe vault Owner can set arbitrary weights via `disableTrading()` and then call `enableTradingWithWeights()` to set the spot price and create arbitrage opportunities for himself. This way, `allowance()` in `withdraw()` checks, which limit the amount of funds an owner can withdraw, can be circumvented. Something similar can be done with `enableTradingRiskingArbitrage()` in combination with sufficient time.\n\nAlso see the following issues:\n- `allowance()` doesnt limit `withdraw()`\n- `enableTradingWithWeights` allows the Treasury to change the pools weights even if the swap is not disabled\n- Separation of concerns between Owner and Manager\n\n### Functions\n```solidity\nfunction disableTrading() ... onlyOwnerOrManager ... {\n    setSwapEnabled(false);\n}\n\nfunction enableTradingWithWeights(uint256[] calldata weights) ... onlyOwner ... {\n    ...\n    pool.updateWeightsGradually(timestamp, timestamp, weights);\n    setSwapEnabled(true);\n}\n\nfunction enableTradingRiskingArbitrage() ... onlyOwner ... {\n    setSwapEnabled(true);\n}\n```\n\n## Recommendation\nConsider allowing only the manager to execute the `disableTrading()` function, although this also has disadvantages. Additionally, use an oracle to determine the spot price (as is already envisioned for the next versions of the protocol).\n\n## Gauntlet\nFor safety reasons, we want the treasury to have full control over trading. Given our current trust model, this wont be an issue for V1, so no action will be taken at this time.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about an issue in AeraVaultV1.sol. It is a medium risk bug that allows the vault owner to set arbitrary weights and then call enableTradingWithWeights() to set the spot price and create arbitrage opportunities for himself, thus bypassing the allowance() checks. This issue can also be done with enableTradingRiskingArbitrage() in combination with sufficient time. The recommendation is to consider allowing only the manager to execute the disableTrading() function and to use an oracle to determine the spot price. However, given the current trust model, this won't be an issue for V1 so no action will be taken at this time.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Gauntlet-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Gauntlet-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Gauntlet-Spearbit-Security-Review.pdf",
      "pdf_page_from": 14,
      "contest_id": "",
      "slug": "owner-can-circumvent-allowance-viaenabletradingwithweights-spearbit-gauntlet-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Gauntlet",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Gauntlet",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "7093",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "133",
      "title": "The vault manager has unchecked power to create arbitrage using setSwapFees",
      "content": "## High Risk Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n- AeraVaultV1.sol: Lines 663-679\n- BasePool.sol: Lines 58-59\n\n## Description\nA previously known issue was that a malicious vault manager could arbitrage the vault like in the below scenario:\n\n1. Set the swap fees to a high value by calling `setSwapFee` (10% is the maximum).\n2. Wait for the market price to move against the spot price.\n3. In the same transaction, reduce the swap fees to ~0 (0.0001% is the minimum) and arbitrage the vault.\n\nThe proposed fix was to limit the percentage change of the swap fee to a maximum of `MAXIMUM_SWAP_FEE_PERCENT_CHANGE` each time. However, because there is no restriction on how many times the `setSwapFee` function can be called in a block or transaction, a malicious manager can still call it multiple times in the same transaction and eventually set the swap fee to the value they want.\n\n## Recommendation\nEnforce a cooldown period of reasonable length between two consecutive `setSwapFee` function calls.",
      "summary": "\nThis bug report is about a security vulnerability in the AeraVaultV1.sol and BasePool.sol contracts. A malicious vault manager could take advantage of the vulnerability by setting the swap fees to a high value and then reducing them to a very low value in the same transaction. This would allow the manager to arbitrage the vault. \n\nThe proposed fix was to limit the percentage change of the swap fee to a maximum of MAXIMUM_SWAP_FEE_PERCENT_CHANGE each time. However, because there is no restriction on how many times the setSwapFee function can be called in a block or transaction, a malicious manager can still call it multiple times in the same transaction and eventually set the swap fee to the value they want.\n\nThe recommendation to fix this issue is to enforce a cooldown period of reasonable length between two consecutive setSwapFee function calls. This would prevent the malicious manager from calling the function multiple times in the same transaction.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Gauntlet-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Gauntlet-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Gauntlet-Spearbit-Security-Review.pdf",
      "pdf_page_from": 13,
      "contest_id": "",
      "slug": "the-vault-manager-has-unchecked-power-to-create-arbitrage-using-setswapfees-spearbit-gauntlet-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Gauntlet",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Gauntlet",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Cooldown"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "7091",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "133",
      "title": "Malicious manager could cause Vault funds to be inaccessible",
      "content": "## Severity: High Risk\n\n## Context\nAeraVaultV1.sol#L794-L822\n\n## Description\nThe `calculateAndDistributeManagerFees()` function pushes tokens to the manager, and if for unknown reasons this action fails, the entire Vault would be blocked, and funds become inaccessible. This occurs because the following functions depend on the execution of `calculateAndDistributeManagerFees()`: \n\n- `deposit()`\n- `withdraw()`\n- `setManager()`\n- `claimManagerFees()`\n- `initiateFinalization()`\n- `finalize()`\n\nWithin `calculateAndDistributeManagerFees()`, the function `safeTransfer()` is the riskiest and could fail under the following situations:\n\n- A token with a callback is used, for example, an ERC777 token, and the callback is not implemented correctly.\n- A token with a blacklist option is used and the manager is blacklisted. For example, USDC has such blacklist functionality. Because the manager can be an unknown party, a small risk exists that he is malicious and his address could be blacklisted in USDC.\n\n**Note:** Set as high risk because although probability is very small, impact results in Vault funds becoming inaccessible.\n\n```solidity\nfunction calculateAndDistributeManagerFees() internal {\n    ...\n    for (uint256 i = 0; i < amounts.length; i++) {\n        tokens[i].safeTransfer(manager, amounts[i]);\n    }\n}\n```\n\n## Recommendation\nBeware of including tokens with callbacks such as ERC777 tokens into the Vault. Additionally, use a pull over push pattern to let the manager retrieve fees. This way, the Vault can never get blocked. This recommendation can be implemented as follows:\n\n- Rename `calculateAndDistributeManagerFees()` to `calculateManagerFees()`.\n- In `calculateManagerFees()`, add up all management fees (for each manager address separately, e.g., in a mapping), to prevent having to push the fees in `setManager()` and keep track of the total of the fees (`managersFeeTotal`) to make sure fees are not withdrawn.\n- In `withdraw()` and `returnFunds()`, make sure unclaimed fees cannot be withdrawn.\n- Let the manager retrieve fees via `claimManagerFees()`, using `msg.sender` as the index to the mapping with the fees. This function should retrieve Balancer funds, e.g., use the code of the second half of `calculateAndDistributeManagerFees()`. It should also lower `managersFeeTotal` and the fee for `msg.sender`.\n\nThis also alleviates rounding issues with fees and reduces gas used by `deposit()`, which could be relevant when pools are deployed with a large number of tokens.\n\nAn alternative could be to use `try/catch` around the call to `safeTransfer()`, but this way the fees arent distributed properly.\n\n## Gauntlet\nWe will be incorporating the suggestions.",
      "summary": "\nThis bug report is about the function calculateAndDistributeManagerFees() in the AeraVaultV1.sol smart contract. This function pushes tokens to the manager and if for any reason this action fails, the entire Vault would be blocked and funds become inaccessible. This is because several other functions depend on the execution of calculateAndDistributeManagerFees(). The riskiest action within this function is the call to safeTransfer(), which could fail if the token used has a callback that is not implemented correctly, or if the manager is blacklisted.\n\nThe recommendation is to use a pull over push pattern to let the manager retrieve fees. This way the Vault can never get blocked. This can be implemented by renaming calculateAndDistributeManagerFees() to calculateManagerFees(), adding up the management fees in a mapping, making sure unclaimed fees cannot be withdrawn, and letting the manager retrieve fees via claimManagerFees(). An alternative could be to use try/catch around the call to safeTransfer(), but this way the fees arent distributed properly. Gauntlet will be incorporating the suggestions.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Gauntlet-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Gauntlet-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Gauntlet-Spearbit-Security-Review.pdf",
      "pdf_page_from": 12,
      "contest_id": "",
      "slug": "malicious-manager-could-cause-vault-funds-to-be-inaccessible-spearbit-gauntlet-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Gauntlet",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Gauntlet",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Reentrancy"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "7087",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "HIGH",
      "finders_count": 3,
      "protocol_id": "133",
      "title": "Manager can cause an immediate weight change",
      "content": "## High Risk Security Issue in ManagedPool.sol\n\n## Severity\n**High Risk**\n\n## Context\n- `ManagedPool.sol#L254-L272`\n- `ManagedPool.sol#L620-L654`\n- `ManagedPool.sol#L680-L698`\n\n## Description\nBalancers `ManagedPool` uses 32-bit values for `startTime` and `endTime` but does not verify if those values exist within that range. When `endTime` is set to \\(2^{32}\\), it becomes larger than `startTime`, so the `_require(startTime <= endTime, ...)` statement will not revert. When `endTime` is converted to 32 bits, it will get a value of 0, causing the check in `_calculateWeightChangeProgress()` with `if (currentTime >= endTime)` to be true, thus leading to an immediate weight change.\n\nThis allows the Manager to trigger an immediate weight change via the `updateWeightsGradually()` function and open arbitrage opportunities.\n\n**Note:** \n- `startTime` is also subject to this overflow problem.\n- The same issue occurs in the latest version of `ManagedPool`.\n- This issue has been reported to Balancer by the Spearbit team.\n\nAlso see the following issues:\n- Managed Pools are still undergoing development and may contain bugs and/or change significantly\n- Important fields of Balancer can be overwritten by `endTime`\n\n## Code Example\n```solidity\ncontract ManagedPool is BaseWeightedPool, ReentrancyGuard {\n    function updateWeightsGradually(uint256 startTime, uint256 endTime, ... ) {\n        ...\n        uint256 currentTime = block.timestamp;\n        startTime = Math.max(currentTime, startTime);\n        _require(startTime <= endTime, Errors.GRADUAL_UPDATE_TIME_TRAVEL); // will not revert if endTime == 2**32\n        ...\n        _startGradualWeightChange(startTime, endTime, _getNormalizedWeights(), endWeights, tokens);\n    }\n    \n    function _startGradualWeightChange(uint256 startTime, uint256 endTime, ... ) {\n        ...\n        _setMiscData(\n            _getMiscData().insertUint32(startTime, _START_TIME_OFFSET).insertUint32(endTime, _END_TIME_OFFSET) // this converts the values to 32 bits\n        );\n        ...\n    }\n    \n    function _calculateWeightChangeProgress() private view returns (uint256) {\n        uint256 currentTime = block.timestamp;\n        bytes32 poolState = _getMiscData();\n        uint256 startTime = poolState.decodeUint32(_START_TIME_OFFSET);\n        uint256 endTime = poolState.decodeUint32(_END_TIME_OFFSET);\n        if (currentTime >= endTime) { // will be true if endTime == (2**32) capped to 32 bits == 0\n            return FixedPoint.ONE;\n        } else ...\n        ...\n    }\n}\n```\n\n## Recommendation\nUse a `ManagedPool.sol` version that solves this issue. In the meantime, verify before `pool.updateWeightsGradually()` is called that:\n- `startTime <= type(uint32).max`\n- `endTime <= type(uint32).max`\n\n## Gauntlet\nRecommendation implemented in PR #145\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThe bug report is about a vulnerability found in the ManagedPool contract of Balancer. The vulnerability is that 32-bit values are used for startTime and endTime, but they are not verified if they exist within the range. This can result in endTime becoming larger than startTime, allowing a Manager to cause an immediate weight change via the updateWeightsGradually() function and open arbitrage opportunities. This issue is present in the latest version of the ManagedPool contract.\n\nThe recommendation is to use a ManagedPool version which solves this issue. In the meantime, users should verify that startTime and endTime are both less than the maximum value of a 32-bit integer before calling the updateWeightsGradually() function.\n\nGauntlet has implemented the recommendation in PR #145, and this has been acknowledged by Spearbit.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Gauntlet-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Gauntlet-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Gauntlet-Spearbit-Security-Review.pdf",
      "pdf_page_from": 8,
      "contest_id": "",
      "slug": "manager-can-cause-an-immediate-weight-change-spearbit-gauntlet-pdf",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Gauntlet",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Gauntlet",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Update State After Admin Action"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "5714",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 23,
      "protocol_id": "304",
      "title": "[M-04] Very critical Owner privileges can cause complete destruction of the project in a possible privateKey exploit",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/PendingOwnable.sol#L42\n\n\n## Vulnerability details\n\n### Vulnerability details\nTypically, the contracts owner is the account that deploys the contract. As a result, the owner is able to perform certain privileged activities.\n\nHowever, Owner privileges are numerous and there is no timelock structure in the process of using these privileges.\nThe Owner is assumed to be an EOA, since the documents do not provide information on whether the Owner will be a multisign structure.\n\nIn parallel with the private key thefts of the project owners, which have increased recently, this vulnerability has been stated as medium.\n\nSimilar vulnerability;\nPrivate keys stolen:\n\nHackers have stolen cryptocurrency worth around 552 million from a blockchain project linked to the popular online game Axie Infinity, in one of the largest cryptocurrency heists on record. Security issue : PrivateKey of the project officer was stolen:\nhttps://www.euronews.com/next/2022/03/30/blockchain-network-ronin-hit-by-552-million-crypto-heist\n\n\n### Proof of Concept\n\n`onlyOwner` powers;\n```js\n14 results - 2 files\n\nsrc/LBFactory.sol:\n  220:     function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner {\n  322:     function setLBPairIgnored() external override onlyOwner {\n  355:     function setPreset() external override onlyOwner {\n  401:     function removePreset(uint16 _binStep) external override onlyOwner {\n  439:     function setFeesParametersOnPair) external override onlyOwner {\n  473:     function setFeeRecipient(address _feeRecipient) external override onlyOwner {\n  479:     function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner {\n  490:     function setFactoryLockedState(bool _locked) external override onlyOwner {\n  498:     function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {\n  507:     function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {\n  525:     function forceDecay(ILBPair _LBPair) external override onlyOwner {\n\nsrc/libraries/PendingOwnable.sol:\n  59:     function setPendingOwner(address pendingOwner_) public override onlyOwner {\n  68:     function revokePendingOwner() public override onlyOwner {\n  84:     function renounceOwnership() public override onlyOwner {\n\n\n\n```\n\n### Recommendation;\n\n1- A timelock contract should be added to use `onlyOwner` privileges. In this way, users can be warned in case of a possible security weakness.\n2- `onlyOwner` can be a Multisign wallet and this part is specified in the documentation",
      "summary": "\nThis bug report concerns a vulnerability in the PendingOwnable contract, which is part of the 2022-10-traderjoe project. This vulnerability is related to the `onlyOwner` privileges, which can be used by the owner of the contract to perform certain privileged activities. The vulnerability is considered medium due to the recent increase in private key thefts. \n\nThe proof of concept provided in the report shows that the `onlyOwner` powers are used in various functions in two files, LBFactory.sol and PendingOwnable.sol. \n\nThe report recommends adding a timelock contract to use the `onlyOwner` privileges, as this would provide users with a warning in case of a possible security weakness. Additionally, it is suggested that the `onlyOwner` should be a Multisign wallet, and this should be specified in the project's documentation.",
      "report_date": {},
      "contest_prize_txt": "$100,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-trader-joe-v2-contest",
      "sponsor_name": "Trader Joe",
      "sponsor_link": "https://twitter.com/traderjoe_xyz",
      "quality_score": 3,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-10-traderjoe",
      "github_link": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/139",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "171",
      "slug": "m-04-very-critical-owner-privileges-can-cause-complete-destruction-of-the-project-in-a-possible-privatekey-exploit-code4rena-trader-joe-trader-joe-v2-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Trader Joe",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Trader Joe",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "6180",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 4,
      "protocol_id": "139",
      "title": "[M-03] Governor can rug pull the escrow",
      "content": "\n[BridgeEscrow.sol#L28-L30](https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/BridgeEscrow.sol#L28-L30)<br>\n\nGovernor can rug pull all GRT held by BridgeEscrow, which is a severe undermining of decentralization.\n\n### Proof of Concept\n\nThe governor can approve an arbitrary address to spend any amount from BridgeEscrow, so they can steal all escrowed tokens. Even if the governor is well intended, the contract can still be called out which would degrade the reputation of the protocol (e.g. see here: <https://twitter.com/RugDocIO/status/1411732108029181960>). This is especially an issue as the escrowed tokens are never burnt, so the users would need to trust the governor perpetually (not about stealing their L2 tokens, but about not taking a massive amount of L1 tokens for free for themselves).\n\nThis seems an unnecessary power granted to the governor and turns a decentralized bridge into a needless bottleneck of centralization.\n\n### Recommended Mitigation Steps\n\nRestrict access to `approveAll()` to the [\"bridge that manages the GRT funds held by the escrow\"](https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/BridgeEscrow.sol#L25). Or, similarly to how `finalizeInboundTransfer` in the gateways is restricted to its respective counterpart, only allow spending via other protocol functions.\n\n**0xean (judge) commented [via issue [#40](https://github.com/code-423n4/2022-10-thegraph-findings/issues/40#issuecomment-1279851479)]:**\n > This is the intended design to allow for multiple bridges in the future. Going to leave open for sponsor review, but may decide to close as invalid.\n\n**pcarranzav (The Graph) disputed and commented [via issue [#40](https://github.com/code-423n4/2022-10-thegraph-findings/issues/40#issuecomment-1282847604)]:**\n > Yes, this is intentional to allow multiple bridges but also to allow for recovery of the funds in case of a critical issue in Arbitrum.\n\n> Note that the Governor is not a regular EOA, but a Gnosis Safe managed by The Graph Council; this account is already able to control many protocol parameters, including adding minters to the GRT contract, so adding this control over the escrow does not change the trust assumption significantly imo.\n\n**0xean (judge) commented [via issue [#40](https://github.com/code-423n4/2022-10-thegraph-findings/issues/40#issuecomment-1287472176)]:**\n > @pcarranzav - totally understand that.  I personally would happily close this issue as invalid, but Code4rena seems to have a pattern of awarding these as Medium to ensure that users are aware of the risk, even as low as it may be.  \n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the BridgeEscrow contract of the Graph protocol. This vulnerability allows the Governor to approve an arbitrary address to spend any amount from the BridgeEscrow and thus steal all escrowed tokens. This is a severe undermining of decentralization and the reputation of the protocol. The bug was discovered by code inspection. \n\nThe recommended mitigation steps are to restrict access to the `approveAll()` function to the bridge that manages the GRT funds held by the escrow. Alternatively, spending should only be allowed via other protocol functions.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-the-graph-l2-bridge-contest",
      "sponsor_name": "The Graph",
      "sponsor_link": "https://twitter.com/graphprotocol",
      "quality_score": 4,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-10-thegraph",
      "github_link": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/300",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "169",
      "slug": "m-03-governor-can-rug-pull-the-escrow-code4rena-the-graph-the-graph-l2-bridge-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "The Graph",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "The Graph",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Staking Pool"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "3804",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 15,
      "protocol_id": "141",
      "title": "[M-01] Contract Owner Possesses Too Many Privileges",
      "content": "\n[ExecutionDelegate.sol#L119](https://github.com/code-423n4/2022-10-blur/blob/2fdaa6e13b544c8c11d1c022a575f16c3a72e3bf/contracts/ExecutionDelegate.sol#L119)<br>\n\nTo use the protocol (buy/sell NFTs), users must approve the `ExecutionDelegate` to handle transfers for their `ERC721`, `ERC1155`, or `ERC20` tokens.\n\nThe safety mechanisms mentioned by the protocol do not protect users at all if the project's owner decides to rugpull.\n\nFrom the contest page, Safety Features:\n\n*   The calling contract must be approved on the `ExecutionDelegate`\n*   Users have the ability to revoke approval from the `ExecutionDelegate` without having to individually calling every token contract.\n\n### Proof of Concept\n\n```sol\nfunction transferERC20(address token, address from, address to, uint256 amount)\n        approvedContract\n        external\n        returns (bool)\n    {\n        require(revokedApproval[from] == false, \"User has revoked approval\");\n        return IERC20(token).transferFrom(from, to, amount);\n    }\n```\n\nThe owner can set `approvedContract`  to any address at any time with `approveContract(address _contract)`, and `revokeApproval()` can be frontrun. As a result, all user funds approved to the `ExecutionDelegate` contract can be lost via rugpull.\n\n### Justification\n\nWhile rug-pulling may not be the project's intention, I find that this is still an inherently dangerous design.\n\nI am unsure about the validity of centralization risk findings on C4, but I argue this is a valid High risk issue as:\n\n*   It is too easy to steal all of user funds as a project owner. A single Bored Ape NFT traded on the exchange would mean roughly `$200,000` can be stolen based on current floor price (75.6 ETH as of writing, Source: <https://nftpricefloor.com/bored-ape-yacht-club>). `$200k` because 75.6ETH for NFT seller and at least 75.6ETH approved by buyer.\n*   web3 security should not be based on \"trust\".\n*   Assuming the project owner is not malicious and will never rug-pull:\n    *   1 successful phishing attack (private key compromise) against the project's owner is all it takes to wipe the protocol out.\n    *   The protocol is still affected as user's will not want to trade on a platfrom knowing such an attack is possible.\n\n### Recommended Mitigation Steps\n\nThis is due to an insecure design of the protocol. So as far as recommendations go, the team should reconsider the protocol's design.\n\nI do not think `ExecutionDelegate` should be used. It would be better if `BlurExchange.sol` is approved by users instead. The exchange should require that the buyer has received their NFT and the seller has received their ETH/WETH or revert.\n\n**[Alex the Entreprenerd (Judge) decreased severity and commented](https://github.com/code-423n4/2022-10-blur-findings/issues/235#issuecomment-1293732509):**\n > Refactoring.\n\n**[Alex the Entreprenerd (Judge) increased severity to Medium and commented](https://github.com/code-423n4/2022-10-blur-findings/issues/235#issuecomment-1316020261):**\n > Per discussion in https://github.com/code-423n4/org/issues, as well as discussion at End of Contest Triage.\n> \n> Am changing the judging on these issues, as these reports have shown a risk to end-users and have historically rated Admin Privilege as a Medium Severity.\n> \n> Am making this the primary as it clearly shows the risk for end users.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the protocol of the BlurExchange that allows the project owner to easily rug-pull users' funds. The protocol includes safety features such as the requirement of users to approve the ExecutionDelegate and the ability to revoke approval, however, these do not protect users if the owner decides to rugpull. The owner can set the approvedContract to any address at any time with the approveContract function and revokeApproval can be frontrun. As a result, all user funds approved to the ExecutionDelegate contract can be lost. \n\nThe bug report also argues that this is an inherently dangerous design as it is too easy to steal all of the user funds as a project owner. It is also argued that web3 security should not be based on trust and that a successful phishing attack against the project owner is all it takes to wipe out the protocol.\n\nThe bug report's recommendation is that the team should reconsider the protocol's design and not use the ExecutionDelegate. It is suggested that BlurExchange.sol should be approved by users instead and the exchange should require that the buyer has received their NFT and the seller has received their ETH/WETH or revert.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-10-blur-exchange-contest",
      "sponsor_name": "Blur Exchange",
      "sponsor_link": "https://twitter.com/blur_io",
      "quality_score": 3,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-10-blur",
      "github_link": "https://github.com/code-423n4/2022-10-blur-findings/issues/235",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "168",
      "slug": "m-01-contract-owner-possesses-too-many-privileges-code4rena-blur-exchange-blur-exchange-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Blur Exchange",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Blur Exchange",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Launchpad"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Synthetics"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "7235",
      "kind": "PDF",
      "auditfirm_id": "6",
      "impact": "MEDIUM",
      "finders_count": 2,
      "protocol_id": "72",
      "title": "diamondCut() allows re-execution of old updates",
      "content": "## Medium Risk Severity Report\n\n## Context\nLibDiamond.sol#L95-L119\n\n## Description\nThe function `diamondCut()` of `LibDiamond` verifies the signed version of the update parameters. It checks whether the signed version is available and if a sufficient amount of time has passed. However, it doesnt prevent multiple executions, and the signed version remains valid indefinitely.\n\nThis allows old updates to be executed again. Assume the following:\n\n- `facet_x` (or `function_y`) has value: `version_1`.\n- Then, replace `facet_x` (or `function_y`) with `version_2`.\n- A bug is found in `version_2`, and it is rolled back with: replace `facet_x` (or `function_y`) with `version_1`.\n- Then a (malicious) owner could immediately do: replace `facet_x` (or `function_y`) with `version_2` (because it is still valid).\n\n**Note:** The risk is limited because it can only be executed by the contract owner; however, this is probably not how the mechanism should work.\n\n```solidity\nlibrary LibDiamond {\n    function diamondCut(...) ... {\n        ...\n        uint256 time = ds.acceptanceTimes[keccak256(abi.encode(_diamondCut, _init, _calldata))];\n        require(time != 0 && time < block.timestamp, \"LibDiamond: delay not elapsed\");\n        ...\n    }\n}\n```\n\n## Recommendation\nConsider doing the following:\n\n- Add a validity period for updates.\n- Remember which updates have been executed and prevent re-execution.\n- Add a nonce (for cases where re-execution is wanted).\n\n## Connext\nSolved in PR 1576.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is about the function diamondCut() of the LibDiamond smart contract. It was found that the function verifies the signed version of the update parameters, and checks that a sufficient amount of time has passed. However, it does not prevent multiple executions, which allows old updates to be executed again. This poses a medium risk, as it could be exploited by the contract owner.\n\nThe recommendation is to add a validity period for updates, remember which updates have been executed, and add a nonce for cases where a re-execution is wanted. The bug has been solved in PR 1576, and verified by Spearbit.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Connext-Spearbit-Security-Review.pdf",
      "sponsor_name": "",
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Connext-Spearbit-Security-Review.pdf",
      "github_link": "",
      "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Connext-Spearbit-Security-Review.pdf",
      "pdf_page_from": 24,
      "contest_id": "",
      "slug": "diamondcut-allows-re-execution-of-old-updates-spearbit-connext-pdf_",
      "firm_name": "Spearbit",
      "firm_logo_square": "spearbit_square.png",
      "protocol_name": "Connext",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
      },
      "protocols_protocol": {
        "name": "Connext",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Business Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "2780",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 15,
      "protocol_id": "208",
      "title": "[M-03] Protocol fee rate can be arbitrarily modified by the owner and the new rate will apply to all existing orders",
      "content": "_Submitted by WatchPug, also found by berndartmueller, BowTiedWardens, cccz, csanuragjain, defsec, GreyArt, joestakey, m9800, peritoflores, reassor, Ruhum, shenwilly, throttle, and zer0dot_\n\n```solidity\nfunction matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n```\n\nPer [the comment](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1120-L1121):\n\n> Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is the one that actually 'pays' the fees\n\nAnd the code:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L725-L729>\n\n```solidity\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _transferMultipleNFTs(sell.signer, buy.signer, sell.nfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, sell.signer, remainingAmount);\n```\n\nIn the current design/implementation, the protocol fee is paid from the buyer's wallet, regardless of whether the buyer is the taker or the maker. And the protocol fee will be deducted from the `execPrice`, only the `remainingAmount` will be sent to the seller.\n\nThis is unconventional as if the buyer placed a limit order, say to sell 1 Punk for 100 ETH, it means that the seller is expected to receive 100 ETH. And now the seller must consider the fee rate and if they expect 100 ETH, the price must be set to 101 ETH.\n\nWhile this is unconventional and a little inconvenience, it's still acceptable IF the protocol fee rate is fixed, OR the seller is the taker so that they can do the math and agrees to the protocol fee when they choose to fulfill the counterparty's maker order.\n\nHowever, that's not always the case with the current implementation: the protocol can be changed, effective immediately, and applies to all existing orders.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1265-L1269>\n\n```solidity\n    /// @dev updates exchange fees\n  function setProtocolFee(uint16 _protocolFeeBps) external onlyOwner {\n    PROTOCOL_FEE_BPS = _protocolFeeBps;\n    emit NewProtocolFee(_protocolFeeBps);\n  }\n```\n\nPlus, when the protocol fee rate updated to a higher rate, say from `5%` to `50%`, an maker order placed before this fee rate update can be fulfilled by a buyer, while the buyer still pays the same amount, the seller (maker) will receive `45%` less than the initial sell order amount.\n\n### Recommendation\n\n1.  Consider making the protocol fee rate a constant, ie, can not be changed;\n2.  Or, consider changing to the protocol fee always be paid by the taker; while matching the maker buy and maker sell orders, the protocol fee must be paid from the price difference between the buy price and sell price;\n3.  Or, consider changing to the new protocol fee only applies to the orders created after the rate updated.\n\n**[nneverlander (Infinity) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/259#issuecomment-1160585250):**\n > This was a design decision. Initially we were fetching the protocol fee from the complication but decided not to make external contract calls for this to save on gas. The other option was to make the protocol fee a part of the maker order but that comes with its own attack surface.  So we implemented a compromise: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/793ee814d86030477470c81c4f6fda353967a42a\n> \n> As such the severity of the bug can be classified as low since this assumes malicious intent on part of the protocol admin.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/259#issuecomment-1179592297):**\n> Maker sell orders are charged the fee set at the time an order is filled and not when the order was created.\n> \n> I'm not sure that I agree this concern is limited to malicious intent. With the ability to change fee, it's safe to assume at some point the admin may choose to increase the fee. At that point, all outstanding maker sells are subject to a higher fee than expected. Some users may be more sensitive to this than others. The warden's recommendations seems to address that concern and the fix the sponsor posted mitigates it by setting a max fee that may apply.\n> \n> I think this is a Medium risk issue - an unexpected bump in fee impacting users who interacted with the system previous to that change is a form of value leak.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the code of the InfinityExchange smart contract. The code in question is from lines 132 to 146 and from lines 1120 to 1121. The issue is that the protocol fee is paid from the buyer's wallet regardless of whether the buyer is the taker or the maker. This means that if the buyer places a limit order, say to sell 1 Punk for 100 ETH, the seller will only receive the amount after the protocol fee is deducted from the execPrice. This is unconventional, as the seller is expected to receive the full amount. Additionally, the protocol fee rate can be changed, which could be detrimental to the seller. \n\nThe report recommends three potential solutions. The first is to make the protocol fee rate a constant, so it can not be changed. The second is to make the protocol fee always be paid by the taker. This means that when matching the maker buy and maker sell orders, the protocol fee must be paid from the price difference between the buy price and sell price. The third is to make the new protocol fee only applies to the orders created after the rate updated. \n\nOverall, this bug report is about an issue in the code of the InfinityExchange smart contract, where the protocol fee is paid from the buyer's wallet regardless of whether the buyer is the taker or the maker. The report recommends three potential solutions to address the issue.",
      "report_date": {},
      "contest_prize_txt": "$50,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
      "sponsor_name": "Infinity NFT Marketplace",
      "sponsor_link": "https://twitter.com/infinitydotxyz",
      "quality_score": 3,
      "general_score": 1,
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/259",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "136",
      "slug": "m-03-protocol-fee-rate-can-be-arbitrarily-modified-by-the-owner-and-the-new-rate-will-apply-to-all-existing-orders-code4rena-infinity-nft-marketplace-infinity-nft-marketplace-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Infinity NFT Marketplace",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Infinity NFT Marketplace",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Payments"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "NFT Marketplace"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Gaming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "1912",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "250",
      "title": "[H-06] Setting new controller can break YVaultLPFarming",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170\nhttps://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L108\n\n\n## Vulnerability details\n\n## Impact\nThe accruals in `yVaultLPFarming` will fail if [`currentBalance < previousBalance`](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170) in `_computeUpdate`.\n\n```solidity\ncurrentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\nuint256 newRewards = currentBalance - previousBalance;\n```\n\nNo funds can be withdrawn anymore as the `withdraw` functions first trigger an `_update`.\n\nThe `currentBalance < previousBalance` case can, for example, be triggerd by decreasing the `vault.balanceOfJPEG()` due to calling `yVault.setController`:\n\n```solidity\nfunction setController(address _controller) public onlyOwner {\n    // @audit can reduce balanceofJpeg which breaks other masterchef contract\n    require(_controller != address(0), \"INVALID_CONTROLLER\");\n    controller = IController(_controller);\n}\n\nfunction balanceOfJPEG() external view returns (uint256) {\n    // @audit new controller could return a smaller balance\n    return controller.balanceOfJPEG(address(token));\n}\n```\n\n## Recommended Mitigation Steps\nSetting a new controller on a vault must be done very carefully and requires a migration.",
      "summary": "\nThis bug report is about a vulnerability in the yVaultLPFarming contract, which is part of the code-423n4/2022-04-jpegd project. This vulnerability can cause the accruals in yVaultLPFarming to fail if the currentBalance is lower than the previousBalance in the _computeUpdate function. This can be triggered by decreasing the vault.balanceOfJPEG() when setting a new controller on a vault. This means that no funds can be withdrawn anymore.\n\nIn order to mitigate this vulnerability, it is recommended to set a new controller on a vault very carefully, and to do so with a migration.",
      "report_date": {},
      "contest_prize_txt": "$100,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-04-jpegd-contest",
      "sponsor_name": "JPEG'd",
      "sponsor_link": "https://twitter.com/jpegd_69",
      "quality_score": 3,
      "general_score": 3,
      "source_link": "https://code4rena.com/reports/2022-04-jpegd",
      "github_link": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/80",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "107",
      "slug": "h-06-setting-new-controller-can-break-yvaultlpfarming-code4rena-jpegd-jpegd-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "JPEG'd",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "JPEG'd",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Overflow/Underflow"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "1400",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "295",
      "title": "[H-01] Wrong reward token calculation in MasterChef contract",
      "content": "_Submitted by throttle, also found by cccz, cmichel, and leastwood_\n\n[MasterChef.sol#L86](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86)<br>\n\nWhen adding new token pool for staking in MasterChef contract\n\n```javascript\nfunction add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock)\n```\n\nAll other, already added, pools should be updated but currently they are not.<br>\nInstead, only totalPoints is updated. Therefore, old (and not updated) pools will lose it's share during the next update.<br>\nTherefore, user rewards are not computed correctly (will be always smaller).\n\n### Proof of Concept\n\nScenario 1:\n\n1.  Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100)<br>\n    and 1 block later Alice stakes 10 tokens in the first pool.\n2.  1 week passes\n3.  Alice withdraws her 10 tokens and claims X amount of reward tokens.<br>\n    and 1 block later Bob stakes 10 tokens in the first pool.\n4.  1 week passes\n5.  Owner adds new pool (second pool) for staking with points = 100 (totalPoints=200)<br>\n    and 1 block later Bob withdraws his 10 tokens and claims X/2 amount of reward tokens.<br>\n    But he should get X amount\n\nScenario 2:\n\n1.  Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100).\n2.  1 block later Alice, Bob and Charlie stake 10 tokens there (at the same time).\n3.  1 week passes\n4.  Owner adds new pool (second pool) for staking with points = 400 (totalPoints=500)\n5.  Right after that, when Alice, Bob or Charlie wants to withdraw tokens and claim rewards they will only be able to claim 20% of what they should be eligible for, because their pool is updated with 20% (100/500) rewards instead of 100% (100/100) rewards for the past week.\n\n### Recommended Mitigation Steps\n\nUpdate all existing pools before adding new pool. Use the massUdpate() function which is already present ... but unused.\n\n**[ryuheimat (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/219)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/219#issuecomment-1092858699):**\n > The warden has identified a fallacy in how `add`s logic work.\n> \n> Ultimately rewards in this contract have to be linearly vested over time, adding a new pool would change the rate at which vesting in all pools will go.\n> \n> For that reason, it is necessary to accrue the rewards that each pool generated up to that point, before changing the slope at which rewards will be distributed.\n> \n> In this case add should massUpdateFirst.\n> \n> Because this vulnerability ultimately breaks the accounting of the protocol, I believe High Severity to be appropriate.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the MasterChef contract, which is used to add new token pools for staking. When a new pool is added, the other existing pools should be updated, but currently they are not. This means that the rewards for users in the old pools are not computed correctly, and will always be smaller than they should be. \n\nTwo scenarios are given to illustrate the issue. In the first, Alice and Bob both stake 10 tokens in the first pool, and when Bob withdraws his tokens he only receives half the reward he should have. In the second, Alice, Bob and Charlie all stake 10 tokens in the first pool, and when they try to withdraw their tokens they only receive 20% of the rewards they should have.\n\nThe recommended mitigation steps are to update all existing pools before adding a new pool, using the massUpdate() function that is already present in the code.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDC",
      "contest_link": "https://code4rena.com/contests/2022-02-concur-finance-contest",
      "sponsor_name": "Concur Finance",
      "sponsor_link": "https://twitter.com/ConcurFinance",
      "quality_score": 3,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2022-02-concur",
      "github_link": "https://github.com/code-423n4/2022-02-concur-findings/issues/219",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "83",
      "slug": "h-01-wrong-reward-token-calculation-in-masterchef-contract-code4rena-concur-finance-concur-finance-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Concur Finance",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Concur Finance",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Liquid Staking"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Wrong Math"
          }
        },
        {
          "tags_tag": {
            "title": "Update State After Admin Action"
          }
        },
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "1302",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 1,
      "protocol_id": "313",
      "title": "[H-09] Vault#setController() owner of the Vault contracts can drain funds from the Vault",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L485-L496\n\n```solidity\nfunction setController(address _controller) public override onlyOwner {\n    require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n    if (address(controller) != address(0)) {\n        controller.migrate(address(_controller));\n        controller = IController(_controller);\n    } else {\n        controller = IController(_controller);\n    }\n\n    emit ControllerSet(_controller);\n}\n```\n\nThe owner of the Vault contract can set an arbitrary address as the `controller`.\n\nhttps://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352\n\n```solidity\nfunction utilize() external override returns (uint256 _amount) {\n    if (keeper != address(0)) {\n        require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n    }\n    _amount = available(); //balance\n    if (_amount > 0) {\n        IERC20(token).safeTransfer(address(controller), _amount);\n        balance -= _amount;\n        controller.earn(address(token), _amount);\n    }\n}\n```\n\nA malicious `controller` contract can transfer funds from the Vault to the attacker.\n\n## PoC\n\nA malicious/compromised can:\n\n1. Call `Vault#setController()` and set `controller` to a malicious contract;\n    -   L489 the old controller will transfer funds to the new, malicious controller.\n2. Call `Vault#utilize()` to deposit all the balance in the Vault contract into the malicious controller contract.\n3. Withdraw all the funds from the malicious controller contract.\n\n## Recommendation\n\nConsider disallowing `Vault#setController()` to set a new address if a controller is existing, which terminates the possibility of migrating funds to a specified address provided by the owner. Or, putting a timelock to this function at least.",
      "summary": "\nThis bug report is about a vulnerability in the Vault contract of the 2022-01-insure repository. The owner of the Vault contract can set an arbitrary address as the `controller`. This malicious `controller` contract can then transfer funds from the Vault to the attacker. A malicious/compromised user can call the `Vault#setController()` and set `controller` to a malicious contract, and then call `Vault#utilize()` to deposit all the balance in the Vault contract into the malicious controller contract. The attacker can then withdraw all the funds from the malicious controller contract. To fix this vulnerability, it is recommended to consider disallowing the `Vault#setController()` to set a new address if a controller is existing, or to put a timelock to this function at least.",
      "report_date": {},
      "contest_prize_txt": "$53,000 USDC (plus $27,000 in tokens)",
      "contest_link": "https://code4rena.com/contests/2022-01-insuredao-contest",
      "sponsor_name": "InsureDAO",
      "sponsor_link": "https://twitter.com/insuredao",
      "quality_score": 5,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/271",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "71",
      "slug": "h-09-vaultsetcontroller-owner-of-the-vault-contracts-can-drain-funds-from-the-vault-code4rena-insuredao-insuredao-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "InsureDAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "InsureDAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    },
    {
      "id": "1298",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 4,
      "protocol_id": "313",
      "title": "[H-05] backdoor in withdrawRedundant",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `Vault.withdrawRedundant` has wrong logic that allows the admins to steal the underlying vault token.\n\n```solidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token) &&\n          balance < IERC20(token).balanceOf(address(this))\n     ) {\n          uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n               balance;\n          IERC20(token).safeTransfer(_to, _redundant);\n     } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n          // @audit they can rug users. let's say balance == IERC20(token).balanceOf(address(this)) => first if false => transfers out everything\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n```\n\n#### POC\n- Vault deposits increase as `Vault.addValue` is called and the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. Note that `balance == IERC20(token).balanceOf(this)`\n- Admins call `vault.withdrawRedundant(vault.token(), attacker)` which goes into the `else if` branch due to the balance inequality condition being `false`. It will transfer out all `vault.token()` amounts to the attacker.\n\n## Impact\nThere's a backdoor in the `withdrawRedundant` that allows admins to steal all user deposits.\n\n## Recommended Mitigation Steps\nI think the devs wanted this logic from the code instead:\n\n```solidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token)\n     ) {\n          if (balance < IERC20(token).balanceOf(address(this))) {\n               uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                    balance;\n               IERC20(token).safeTransfer(_to, _redundant);\n          }\n     } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n```",
      "summary": "\nA bug report has been submitted by user cmichel for the `Vault.withdrawRedundant` function in a smart contract. This function has a wrong logic that allows the admins to steal the underlying vault token. When the `Vault.addValue` is called, the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. If the admins call `vault.withdrawRedundant(vault.token(), attacker)`, it will transfer out all `vault.token()` amounts to the attacker due to the balance inequality condition being `false`. This creates a backdoor in the `withdrawRedundant` function that allows admins to steal all user deposits.\n\nThe recommended mitigation step is to change the code to the following:\n\n```solidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token)\n     ) {\n          if (balance < IERC20(token).balanceOf(address(this))) {\n               uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                    balance;\n               IERC20(token).safeTransfer(_to, _redundant);\n          }\n     } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n```\n\nThis will ensure that the admins cannot steal the underlying vault token and the user deposits will remain secure.",
      "report_date": {},
      "contest_prize_txt": "$53,000 USDC (plus $27,000 in tokens)",
      "contest_link": "https://code4rena.com/contests/2022-01-insuredao-contest",
      "sponsor_name": "InsureDAO",
      "sponsor_link": "https://twitter.com/insuredao",
      "quality_score": 3,
      "general_score": 2,
      "source_link": "https://code4rena.com/reports/2022-01-insure",
      "github_link": "https://github.com/code-423n4/2022-01-insure-findings/issues/252",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "71",
      "slug": "h-05-backdoor-in-withdrawredundant-code4rena-insuredao-insuredao-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "InsureDAO",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "InsureDAO",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Cross Chain"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Indexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Insurance"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Admin"
          }
        }
      ]
    }
  ]
}