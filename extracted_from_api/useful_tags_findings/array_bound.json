{
  "tag": "Array Bound",
  "count": 2,
  "metadata": {
    "totalResults": 2,
    "totalPages": 1
  },
  "last_rateLimit": {
    "limit": 20,
    "remaining": 9,
    "reset": 1771760940
  },
  "findings": [
    {
      "id": "18487",
      "kind": "GIT",
      "auditfirm_id": "3",
      "impact": "HIGH",
      "finders_count": 2,
      "protocol_id": "617",
      "title": "H-7: WAuraPools will irreversibly break if reward tokens are added to pool after deposit",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/127 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nWAuraPools will irreversibly break if reward tokens are added to pool after deposit due to an OOB error on accExtPerShare.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L166-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L166-L189)\n\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength(); <- @audit-issue rewardTokenCount pulled fresh\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n\n            @audit-issue attempts to pull from array which will be too small if tokens are added\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n\naccExtPerShare stores the current rewardPerToken when the position is first created. It stores it as an array and only stores values for reward tokens that have been added prior to minting. This creates an issue if a reward token is added because now it will attempt to pull a value for an index that doesn't exist and throw an OOB error.\n\nThis is problematic because pendingRewards is called every single transaction via the isLiquidatable subcall in BlueBerryBank#execute.\n\n## Impact\n\nWAuraPools will irreversibly break if reward tokens are added to pool after\n\n## Code Snippet\n\n[WAuraPools.sol#L152-L190](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L152-L190)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a mapping rather than an array to store values",
      "summary": "\nThis bug report is about the WAuraPools smart contract. It was found by 0x52 and Ch_301 and is related to the issue of adding reward tokens to a pool after a deposit. This results in an Out of Bounds (OOB) error on the accExtPerShare variable, which is an array that stores the current reward per token when the position is first created. This OOB error occurs because the array only stores values for reward tokens that were added prior to minting, and so if a reward token is added after, it will attempt to pull a value for an index that doesn't exist. This is problematic because pendingRewards is called every single transaction via the isLiquidatable subcall in BlueBerryBank#execute. As a result, WAuraPools will irreversibly break if reward tokens are added to the pool after a deposit. The code snippet associated with this issue is found in the WAuraPools.sol file from line 152 to line 190. The tool used to find this bug was manual review. The recommendation to solve this issue is to use a mapping rather than an array to store values.",
      "report_date": {},
      "contest_prize_txt": "16000 USDC",
      "contest_link": "https://app.sherlock.xyz/audits/contests/69",
      "sponsor_name": null,
      "sponsor_link": "",
      "quality_score": 0,
      "general_score": 0,
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/127",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "69",
      "slug": "h-7-waurapools-will-irreversibly-break-if-reward-tokens-are-added-to-pool-after-deposit-sherlock-none-blueberry-update-git",
      "firm_name": "Sherlock",
      "firm_logo_square": "sherlock_square.png",
      "protocol_name": "Blueberry Update",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
      },
      "protocols_protocol": {
        "name": "Blueberry Update",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Lending"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Leveraged Farming"
            },
            "score": 1
          },
          {
            "protocols_protocolcategory": {
              "title": "Options Vault"
            },
            "score": 1
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Missing-Logic"
          }
        },
        {
          "tags_tag": {
            "title": "Mapping"
          }
        },
        {
          "tags_tag": {
            "title": "Coding-Bug"
          }
        },
        {
          "tags_tag": {
            "title": "Array Bound"
          }
        }
      ]
    },
    {
      "id": "1642",
      "kind": "GIT",
      "auditfirm_id": "2",
      "impact": "MEDIUM",
      "finders_count": 1,
      "protocol_id": "271",
      "title": "[M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze usersâ€™ funds in edge cases",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L270-L285\n\n\n## Vulnerability details\n\nIn the current implementation of `withdraw()`, it calls `_sendRewardsForNft()` at L243 which calls `updatePool()` at L129 which calls `getUpdatedAccTokenPerShare()` at L319.\n\n`getUpdatedAccTokenPerShare()` will loop over `rewardRateLog` to calculate an up to date value of accTokenPerShare.\n\nhttps://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L270-L285\n\n```solidity\nwhile (true) {\n    if (lastUpdatedTime >= counter) {\n        break;\n    }\n    unchecked {\n        accumulator +=\n            rewardRateLog[_baseToken][i].rewardsPerSecond *\n            (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));\n    }\n    counter = rewardRateLog[_baseToken][i].timestamp;\n    if (i == 0) {\n        break;\n    }\n    --i;\n}\n```\n\nThis won't be a problem in the usual cases, however, if there is a baseToken that:\n\n- the `rewardPerSecond` get updated quite frequently;\n- the liquidityProviders are inactive (no deposits / withdrawals for a period of time)\n\nThen by the time one of the `liquidityProviders` come to `withdraw()`, the tx may revert due to out-of-gas.\n\nAs the `rewardRateLog` is now accumulated to a large size that causes the loop costs more gas than the block gas limit.\n\nThere is a really easy fix for this, it will also make the code simpler:\n\n### Recommendation\n\nConsider removing `rewardRateLog` and change `setRewardPerSecond()` to:\n\n```solidity\nfunction setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {\n    updatePool(baseToken);\n    rewardRate[_baseToken] = RewardsPerSecondEntry(_rewardPerSecond, block.timestamp);\n    emit LogRewardPerSecond(_baseToken, _rewardPerSecond);\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the code of the LiquidityFarming.sol contract, which is part of the biconomy project. The vulnerability is caused by the implementation of the withdraw() function, which calls the _sendRewardsForNft() function at line 243, which in turn calls the updatePool() function at line 129, which calls the getUpdatedAccTokenPerShare() function at line 319. This function loops over the rewardRateLog to calculate an up-to-date value of accTokenPerShare. \n\nThe problem arises when the rewardPerSecond is updated frequently, and the liquidityProviders are inactive for a period of time. When one of the liquidityProviders comes to withdraw, the transaction may revert due to out-of-gas, as the rewardRateLog has accumulated to a large size, causing the loop to cost more gas than the block gas limit.\n\nThe recommended fix is to remove the rewardRateLog and change the setRewardPerSecond() function to the code provided in the report. This will make the code simpler and avoid the out-of-gas issue.",
      "report_date": {},
      "contest_prize_txt": "$75,000 USDT",
      "contest_link": "https://code4rena.com/contests/2022-03-biconomy-hyphen-20-contest",
      "sponsor_name": "Biconomy",
      "sponsor_link": "https://twitter.com/biconomy",
      "quality_score": 3,
      "general_score": 0,
      "source_link": "https://code4rena.com/reports/2022-03-biconomy",
      "github_link": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/136",
      "pdf_link": "",
      "pdf_page_from": 0,
      "contest_id": "97",
      "slug": "m-14-liquidityfarmingsol-unbounded-for-loops-can-potentially-freeze-users-funds-in-edge-cases-code4rena-biconomy-biconomy-hyphen-20-contest-git",
      "firm_name": "Code4rena",
      "firm_logo_square": "code4rena_square.png",
      "protocol_name": "Biconomy",
      "bookmarked": false,
      "read": false,
      "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
      },
      "protocols_protocol": {
        "name": "Biconomy",
        "protocols_protocolcategoryscore": [
          {
            "protocols_protocolcategory": {
              "title": "Dexes"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Bridge"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "CDP"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Services"
            },
            "score": 0.5
          },
          {
            "protocols_protocolcategory": {
              "title": "Yield Aggregator"
            },
            "score": 0.5
          }
        ]
      },
      "issues_issuetagscore": [
        {
          "tags_tag": {
            "title": "Array Bound"
          }
        }
      ]
    }
  ]
}