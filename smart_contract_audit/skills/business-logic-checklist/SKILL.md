---
name: business-logic-checklist
description: 检查智能合约业务逻辑的审计方法
---

# 多重状态更新中的“陈旧基准验证” (Stale Reference Validation)

## 核心原则

在任何允许对对象（如活动、订单、配置、提案）进行多次修改或覆盖（Override）的系统中，**验证逻辑（Validation Logic）** 必须始终基于对象的**当前生效状态（Effective State）**，而非对象的**初始创建状态（Genesis State）**。

如果系统保留了“原始数据”和“修改数据”两套存储（例如为了审计追踪或回滚），开发者极易在编写新的修改逻辑时，习惯性地读取“原始数据”作为验证基准。这会导致后续的修改请求被错误地基于“已过时”的约束条件进行拒绝，破坏连续修改的能力。

## 审计步骤与检查点

### 1. 识别“增量修改”或“覆盖”模式
   1. **检查修改功能：** 寻找允许用户调整已存在对象参数的函数。
   2. **关键信号词：** `override`, `update`, `modify`, `edit`, `adjust`, `amend`。
   3. **数据结构分析：** 检查合约如何存储修改：
      *   **直接覆写：** 修改直接覆盖原存储槽（通常风险较低，因为旧状态不存在了）。
      *   **分离存储（高风险）：** 修改被保存在一个新的映射或结构体中，而原始数据保留不变。或者系统使用“基础参数 + 增量（Delta）”的模式。

### 2. 定位验证逻辑的“基准源” (Source of Truth)
   1. 在修改函数中，找到所有的 `require` 检查或 `if (...) revert` 逻辑。
   2. 特别关注涉及**时间约束**（`startTimestamp`, `deadline`）、**状态流转**（`isActive`, `isSettled`）或**数值边界**（`minAmount`, `maxCap`）的检查。
   3. 追踪这些检查所读取的变量来源：它是直接读取资源，还是先判断资源是否存在？

### 3. 核心核对：验证基准的时效性
   这是最关键的一步。构建一个“连续修改”的心智模型进行演练：

   1. **检查“第二次修改”场景：**
      *   假设用户已经成功执行了第一次修改（状态 A -> 状态 B）。
      *   现在用户发起第二次修改（试图从 状态 B -> 状态 C）。
      *   **核对：** 代码中的验证逻辑是将“请求 C”与“当前状态 B”进行对比，还是错误地与“初始状态 A”进行对比？

   2. **检查“时间旅行”悖论：**
      *   如果涉及时间（如开始时间），假设初始开始时间 $T_0$ 已过，但第一次修改将时间推迟到 $T_1$（尚未到来）。
      *   **核对：** 当前时间介于 $T_0$ 和 $T_1$ 之间时，代码是否会因为 $Now > T_0$ 而错误地判定“活动已开始，不可修改”，忽略了实际生效时间 $T_1$ 还没到？

### 4. 典型错误模式 (Code Smells)
   *   **混合状态验证：** 验证逻辑中，一部分参数取自最新状态，但另一部分参数（通常是没打算修改的参数）却取自原始状态，导致逻辑不一致。

## 漏洞判定

如果验证逻辑在处理修改请求时，强制约束条件（Constraints）是基于**已经被之前的修改废弃的原始参数**，而非**当前实际生效的参数**，则该系统存在“陈旧基准验证”漏洞。这通常导致合法的后续操作被拒绝（DoS）或逻辑死锁。
